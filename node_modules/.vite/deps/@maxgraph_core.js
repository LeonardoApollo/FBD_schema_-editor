import {
  __export
} from "./chunk-HKJ2B2AA.js";

// node_modules/@maxgraph/core/lib/view/image/ImageBox.js
var ImageBox = class {
  constructor(src, width, height) {
    this.src = src;
    this.width = width;
    this.height = height;
  }
};
var ImageBox_default = ImageBox;

// node_modules/@maxgraph/core/lib/view/event/EventObject.js
var EventObject = class {
  constructor(name2 = "", ...args) {
    this.consumed = false;
    this.name = name2;
    this.properties = {};
    if (!!args[0] && args[0].constructor === Object) {
      for (const [key2, value2] of Object.entries(args[0])) {
        this.properties[key2] = value2;
      }
    } else {
      for (let i2 = 0; i2 < args.length; i2 += 2) {
        if (args[i2 + 1] !== null) {
          this.properties[args[i2]] = args[i2 + 1];
        }
      }
    }
  }
  /**
   * Returns <name>.
   */
  getName() {
    return this.name;
  }
  /**
   * Returns <properties>.
   */
  getProperties() {
    return this.properties;
  }
  /**
   * Returns the property for the given key.
   */
  getProperty(key2) {
    return this.properties[key2];
  }
  /**
   * Returns true if the event has been consumed.
   */
  isConsumed() {
    return this.consumed;
  }
  /**
   * Consumes the event.
   */
  consume() {
    this.consumed = true;
  }
};
var EventObject_default = EventObject;

// node_modules/@maxgraph/core/lib/view/event/EventSource.js
var EventSource = class {
  constructor(eventSource = null) {
    this.eventListeners = [];
    this.eventsEnabled = true;
    this.eventSource = null;
    this.eventSource = eventSource;
  }
  /**
   * Returns <eventsEnabled>.
   */
  isEventsEnabled() {
    return this.eventsEnabled;
  }
  /**
   * Sets <eventsEnabled>.
   */
  setEventsEnabled(value2) {
    this.eventsEnabled = value2;
  }
  /**
   * Returns <eventSource>.
   */
  getEventSource() {
    return this.eventSource;
  }
  /**
   * Sets <eventSource>.
   */
  setEventSource(value2) {
    this.eventSource = value2;
  }
  /**
   * Binds the specified function to the given event name. If no event name
   * is given, then the listener is registered for all events.
   *
   * The parameters of the listener are the sender and an {@link EventObject}.
   */
  addListener(name2, funct2) {
    this.eventListeners.push({ name: name2, funct: funct2 });
  }
  /**
   * Removes all occurrences of the given listener from <eventListeners>.
   */
  removeListener(funct2) {
    let i2 = 0;
    while (i2 < this.eventListeners.length) {
      if (this.eventListeners[i2].funct === funct2) {
        this.eventListeners.splice(i2, 1);
      } else {
        i2 += 1;
      }
    }
  }
  /**
   * Dispatches the given event to the listeners which are registered for
   * the event. The sender argument is optional. The current execution scope
   * ("this") is used for the listener invocation (see {@link Utils#bind}).
   *
   * Example:
   *
   * ```javascript
   * fireEvent(new mxEventObject("eventName", key1, val1, .., keyN, valN))
   * ```
   *
   * @param evt {@link EventObject} that represents the event.
   * @param sender Optional sender to be passed to the listener. Default value is
   * the return value of <getEventSource>.
   */
  fireEvent(evt2, sender = null) {
    if (this.isEventsEnabled()) {
      if (!evt2) {
        evt2 = new EventObject_default("");
      }
      if (!sender) {
        sender = this.getEventSource();
      }
      if (!sender) {
        sender = this;
      }
      for (const eventListener of this.eventListeners) {
        if (eventListener.name === null || eventListener.name === evt2.getName()) {
          eventListener.funct.apply(this, [sender, evt2]);
        }
      }
    }
  }
};
var EventSource_default = EventSource;

// node_modules/@maxgraph/core/lib/util/EventUtils.js
var EventUtils_exports = {};
__export(EventUtils_exports, {
  getClientX: () => getClientX,
  getClientY: () => getClientY,
  getMainEvent: () => getMainEvent,
  getSource: () => getSource,
  isAltDown: () => isAltDown,
  isConsumed: () => isConsumed,
  isControlDown: () => isControlDown,
  isLeftMouseButton: () => isLeftMouseButton,
  isMetaDown: () => isMetaDown,
  isMiddleMouseButton: () => isMiddleMouseButton,
  isMouseEvent: () => isMouseEvent,
  isMultiTouchEvent: () => isMultiTouchEvent,
  isPenEvent: () => isPenEvent,
  isPopupTrigger: () => isPopupTrigger,
  isRightMouseButton: () => isRightMouseButton,
  isShiftDown: () => isShiftDown,
  isTouchEvent: () => isTouchEvent
});

// node_modules/@maxgraph/core/lib/Client.js
var Client = class {
};
Client.VERSION = "0.13.1";
Client.basePath = ".";
Client.setBasePath = (value2) => {
  if (typeof value2 !== "undefined" && value2.length > 0) {
    if (value2.substring(value2.length - 1) === "/") {
      value2 = value2.substring(0, value2.length - 1);
    }
    Client.basePath = value2;
  } else {
    Client.basePath = ".";
  }
};
Client.imageBasePath = ".";
Client.setImageBasePath = (value2) => {
  if (typeof value2 !== "undefined" && value2.length > 0) {
    if (value2.substring(value2.length - 1) === "/") {
      value2 = value2.substring(0, value2.length - 1);
    }
    Client.imageBasePath = value2;
  } else {
    Client.imageBasePath = `${Client.basePath}/images`;
  }
};
Client.language = typeof window !== "undefined" ? navigator.language : "en";
Client.setLanguage = (value2) => {
  if (typeof value2 !== "undefined" && value2 != null) {
    Client.language = value2;
  } else {
    Client.language = navigator.language;
  }
};
Client.defaultLanguage = "en";
Client.setDefaultLanguage = (value2) => {
  if (typeof value2 !== "undefined" && value2 != null) {
    Client.defaultLanguage = value2;
  } else {
    Client.defaultLanguage = "en";
  }
};
Client.languages = null;
Client.setLanguages = (value2) => {
  if (typeof value2 !== "undefined" && value2 != null) {
    Client.languages = value2;
  }
};
Client.IS_EDGE = typeof window !== "undefined" && navigator.userAgent != null && !!navigator.userAgent.match(/Edge\//);
Client.IS_NS = typeof window !== "undefined" && navigator.userAgent != null && navigator.userAgent.indexOf("Mozilla/") >= 0 && navigator.userAgent.indexOf("MSIE") < 0 && navigator.userAgent.indexOf("Edge/") < 0;
Client.IS_SF = typeof window !== "undefined" && /Apple Computer, Inc/.test(navigator.vendor);
Client.IS_ANDROID = typeof window !== "undefined" && navigator.appVersion.indexOf("Android") >= 0;
Client.IS_IOS = typeof window !== "undefined" && /iP(hone|od|ad)/.test(navigator.platform);
Client.IS_GC = typeof window !== "undefined" && /Google Inc/.test(navigator.vendor);
Client.IS_CHROMEAPP = typeof window !== "undefined" && // @ts-ignore
window.chrome != null && // @ts-ignore
chrome.app != null && // @ts-ignore
chrome.app.runtime != null;
Client.IS_FF = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
Client.IS_MT = typeof window !== "undefined" && (navigator.userAgent.indexOf("Firefox/") >= 0 && navigator.userAgent.indexOf("Firefox/1.") < 0 && navigator.userAgent.indexOf("Firefox/2.") < 0 || navigator.userAgent.indexOf("Iceweasel/") >= 0 && navigator.userAgent.indexOf("Iceweasel/1.") < 0 && navigator.userAgent.indexOf("Iceweasel/2.") < 0 || navigator.userAgent.indexOf("SeaMonkey/") >= 0 && navigator.userAgent.indexOf("SeaMonkey/1.") < 0 || navigator.userAgent.indexOf("Iceape/") >= 0 && navigator.userAgent.indexOf("Iceape/1.") < 0);
Client.IS_SVG = typeof window !== "undefined" && navigator.appName.toUpperCase() !== "MICROSOFT INTERNET EXPLORER";
Client.NO_FO = typeof window !== "undefined" && (!document.createElementNS || document.createElementNS("http://www.w3.org/2000/svg", "foreignObject").toString() !== "[object SVGForeignObjectElement]" || navigator.userAgent.indexOf("Opera/") >= 0);
Client.IS_WIN = typeof window !== "undefined" && navigator.appVersion.indexOf("Win") > 0;
Client.IS_MAC = typeof window !== "undefined" && navigator.appVersion.indexOf("Mac") > 0;
Client.IS_CHROMEOS = typeof window !== "undefined" && /\bCrOS\b/.test(navigator.appVersion);
Client.IS_TOUCH = typeof window !== "undefined" && "ontouchstart" in document.documentElement;
Client.IS_POINTER = typeof window !== "undefined" && window.PointerEvent != null && !(navigator.appVersion.indexOf("Mac") > 0);
Client.IS_LOCAL = typeof window !== "undefined" && document.location.href.indexOf("http://") < 0 && document.location.href.indexOf("https://") < 0;
Client.isBrowserSupported = () => {
  return Client.IS_SVG;
};
var Client_default = Client;

// node_modules/@maxgraph/core/lib/util/EventUtils.js
var getMainEvent = (evt2) => {
  let t = evt2;
  if ((t.type === "touchstart" || t.type === "touchmove") && t.touches && t.touches[0]) {
    t = t.touches[0];
  } else if (t.type === "touchend" && t.changedTouches && t.changedTouches[0]) {
    t = t.changedTouches[0];
  }
  return t;
};
var getClientX = (evt2) => {
  return getMainEvent(evt2).clientX;
};
var getClientY = (evt2) => {
  return getMainEvent(evt2).clientY;
};
var getSource = (evt2) => {
  return evt2.target;
};
var isConsumed = (evt2) => {
  const t = evt2;
  return t.isConsumed !== void 0 && t.isConsumed;
};
var isTouchEvent = (evt2) => {
  const t = evt2;
  return t.pointerType ? t.pointerType === "touch" || t.pointerType === t.MSPOINTER_TYPE_TOUCH : t.mozInputSource !== void 0 ? t.mozInputSource === 5 : t.type.indexOf("touch") === 0;
};
var isPenEvent = (evt2) => {
  const t = evt2;
  return t.pointerType ? t.pointerType == "pen" || t.pointerType === t.MSPOINTER_TYPE_PEN : t.mozInputSource !== void 0 ? t.mozInputSource === 2 : t.type.indexOf("pen") === 0;
};
var isMultiTouchEvent = (evt2) => {
  const t = evt2;
  return t.type && t.type.indexOf("touch") == 0 && t.touches !== void 0 && t.touches.length > 1;
};
var isMouseEvent = (evt2) => {
  const t = evt2;
  return t.pointerType ? t.pointerType == "mouse" || t.pointerType === t.MSPOINTER_TYPE_MOUSE : t.mozInputSource !== void 0 ? t.mozInputSource === 1 : t.type.indexOf("mouse") === 0;
};
var isLeftMouseButton = (evt2) => {
  if ("buttons" in evt2 && (evt2.type === "mousedown" || evt2.type === "mousemove")) {
    return evt2.buttons === 1;
  }
  if (evt2.which !== void 0) {
    return evt2.which === 1;
  }
  return evt2.button === 1;
};
var isMiddleMouseButton = (evt2) => {
  return evt2.button === 4;
};
var isRightMouseButton = (evt2) => {
  return evt2.button === 2;
};
var isPopupTrigger = (evt2) => {
  return isRightMouseButton(evt2) || Client_default.IS_MAC && isControlDown(evt2) && !isShiftDown(evt2) && !isMetaDown(evt2) && !isAltDown(evt2);
};
var isShiftDown = (evt2) => {
  return evt2.shiftKey;
};
var isAltDown = (evt2) => {
  return evt2.altKey;
};
var isControlDown = (evt2) => {
  return evt2.ctrlKey;
};
var isMetaDown = (evt2) => {
  return evt2.metaKey;
};

// node_modules/@maxgraph/core/lib/util/domUtils.js
var domUtils_exports = {};
__export(domUtils_exports, {
  addLinkToHead: () => addLinkToHead,
  br: () => br,
  clearSelection: () => clearSelection,
  createImage: () => createImage,
  extractTextWithWhitespace: () => extractTextWithWhitespace,
  getChildNodes: () => getChildNodes,
  getInnerHtml: () => getInnerHtml,
  getOuterHtml: () => getOuterHtml,
  getTextContent: () => getTextContent,
  importNode: () => importNode,
  importNodeImplementation: () => importNodeImplementation,
  isAncestorNode: () => isAncestorNode,
  isNode: () => isNode,
  para: () => para,
  setTextContent: () => setTextContent,
  write: () => write,
  writeln: () => writeln
});

// node_modules/@maxgraph/core/lib/util/Constants.js
var Constants_exports = {};
__export(Constants_exports, {
  ABSOLUTE_LINE_HEIGHT: () => ABSOLUTE_LINE_HEIGHT,
  ALIGN: () => ALIGN,
  ARROW: () => ARROW,
  ARROW_SIZE: () => ARROW_SIZE,
  ARROW_SPACING: () => ARROW_SPACING,
  ARROW_WIDTH: () => ARROW_WIDTH,
  CONNECT_HANDLE_FILLCOLOR: () => CONNECT_HANDLE_FILLCOLOR,
  CONNECT_TARGET_COLOR: () => CONNECT_TARGET_COLOR,
  CURSOR: () => CURSOR,
  DEFAULT_FONTFAMILY: () => DEFAULT_FONTFAMILY,
  DEFAULT_FONTSIZE: () => DEFAULT_FONTSIZE,
  DEFAULT_FONTSTYLE: () => DEFAULT_FONTSTYLE,
  DEFAULT_HOTSPOT: () => DEFAULT_HOTSPOT,
  DEFAULT_IMAGESIZE: () => DEFAULT_IMAGESIZE,
  DEFAULT_INVALID_COLOR: () => DEFAULT_INVALID_COLOR,
  DEFAULT_MARKERSIZE: () => DEFAULT_MARKERSIZE,
  DEFAULT_STARTSIZE: () => DEFAULT_STARTSIZE,
  DEFAULT_TEXT_DIRECTION: () => DEFAULT_TEXT_DIRECTION,
  DEFAULT_VALID_COLOR: () => DEFAULT_VALID_COLOR,
  DIALECT: () => DIALECT,
  DIRECTION: () => DIRECTION,
  DIRECTION_MASK: () => DIRECTION_MASK,
  DROP_TARGET_COLOR: () => DROP_TARGET_COLOR,
  EDGESTYLE: () => EDGESTYLE,
  EDGE_SELECTION_COLOR: () => EDGE_SELECTION_COLOR,
  EDGE_SELECTION_DASHED: () => EDGE_SELECTION_DASHED,
  EDGE_SELECTION_STROKEWIDTH: () => EDGE_SELECTION_STROKEWIDTH,
  ELBOW: () => ELBOW,
  ENTITY_SEGMENT: () => ENTITY_SEGMENT,
  FONT: () => FONT,
  GUIDE_COLOR: () => GUIDE_COLOR,
  GUIDE_STROKEWIDTH: () => GUIDE_STROKEWIDTH,
  HANDLE_FILLCOLOR: () => HANDLE_FILLCOLOR,
  HANDLE_SIZE: () => HANDLE_SIZE,
  HANDLE_STROKECOLOR: () => HANDLE_STROKECOLOR,
  HIGHLIGHT_COLOR: () => HIGHLIGHT_COLOR,
  HIGHLIGHT_OPACITY: () => HIGHLIGHT_OPACITY,
  HIGHLIGHT_SIZE: () => HIGHLIGHT_SIZE,
  HIGHLIGHT_STROKEWIDTH: () => HIGHLIGHT_STROKEWIDTH,
  IDENTITY_FIELD_NAME: () => IDENTITY_FIELD_NAME,
  INVALID_COLOR: () => INVALID_COLOR,
  INVALID_CONNECT_TARGET_COLOR: () => INVALID_CONNECT_TARGET_COLOR,
  LABEL_HANDLE_FILLCOLOR: () => LABEL_HANDLE_FILLCOLOR,
  LABEL_HANDLE_SIZE: () => LABEL_HANDLE_SIZE,
  LINE_ARCSIZE: () => LINE_ARCSIZE,
  LINE_HEIGHT: () => LINE_HEIGHT,
  LOCKED_HANDLE_FILLCOLOR: () => LOCKED_HANDLE_FILLCOLOR,
  MAX_HOTSPOT_SIZE: () => MAX_HOTSPOT_SIZE,
  MIN_HOTSPOT_SIZE: () => MIN_HOTSPOT_SIZE,
  NODETYPE: () => NODETYPE,
  NONE: () => NONE,
  NS_SVG: () => NS_SVG,
  NS_XLINK: () => NS_XLINK,
  OUTLINE_COLOR: () => OUTLINE_COLOR,
  OUTLINE_HANDLE_FILLCOLOR: () => OUTLINE_HANDLE_FILLCOLOR,
  OUTLINE_HANDLE_STROKECOLOR: () => OUTLINE_HANDLE_STROKECOLOR,
  OUTLINE_HIGHLIGHT_COLOR: () => OUTLINE_HIGHLIGHT_COLOR,
  OUTLINE_HIGHLIGHT_STROKEWIDTH: () => OUTLINE_HIGHLIGHT_STROKEWIDTH,
  OUTLINE_STROKEWIDTH: () => OUTLINE_STROKEWIDTH,
  PAGE_FORMAT_A4_LANDSCAPE: () => PAGE_FORMAT_A4_LANDSCAPE,
  PAGE_FORMAT_A4_PORTRAIT: () => PAGE_FORMAT_A4_PORTRAIT,
  PAGE_FORMAT_LETTER_LANDSCAPE: () => PAGE_FORMAT_LETTER_LANDSCAPE,
  PAGE_FORMAT_LETTER_PORTRAIT: () => PAGE_FORMAT_LETTER_PORTRAIT,
  PERIMETER: () => PERIMETER,
  RECTANGLE_ROUNDING_FACTOR: () => RECTANGLE_ROUNDING_FACTOR,
  RENDERING_HINT: () => RENDERING_HINT,
  SHADOWCOLOR: () => SHADOWCOLOR,
  SHADOW_OFFSET_X: () => SHADOW_OFFSET_X,
  SHADOW_OFFSET_Y: () => SHADOW_OFFSET_Y,
  SHADOW_OPACITY: () => SHADOW_OPACITY,
  SHAPE: () => SHAPE,
  TEXT_DIRECTION: () => TEXT_DIRECTION,
  TOOLTIP_VERTICAL_OFFSET: () => TOOLTIP_VERTICAL_OFFSET,
  VALID_COLOR: () => VALID_COLOR,
  VERTEX_SELECTION_COLOR: () => VERTEX_SELECTION_COLOR,
  VERTEX_SELECTION_DASHED: () => VERTEX_SELECTION_DASHED,
  VERTEX_SELECTION_STROKEWIDTH: () => VERTEX_SELECTION_STROKEWIDTH,
  WORD_WRAP: () => WORD_WRAP
});
var DEFAULT_HOTSPOT = 0.3;
var MIN_HOTSPOT_SIZE = 8;
var MAX_HOTSPOT_SIZE = 0;
var RENDERING_HINT;
(function(RENDERING_HINT2) {
  RENDERING_HINT2["EXACT"] = "exact";
  RENDERING_HINT2["FASTER"] = "faster";
  RENDERING_HINT2["FASTEST"] = "fastest";
})(RENDERING_HINT || (RENDERING_HINT = {}));
var DIALECT;
(function(DIALECT2) {
  DIALECT2["SVG"] = "svg";
  DIALECT2["MIXEDHTML"] = "mixedHtml";
  DIALECT2["PREFERHTML"] = "preferHtml";
  DIALECT2["STRICTHTML"] = "strictHtml";
})(DIALECT || (DIALECT = {}));
var IDENTITY_FIELD_NAME = "mxObjectId";
var NS_SVG = "http://www.w3.org/2000/svg";
var NS_XLINK = "http://www.w3.org/1999/xlink";
var SHADOWCOLOR = "gray";
var SHADOW_OFFSET_X = 2;
var SHADOW_OFFSET_Y = 3;
var SHADOW_OPACITY = 1;
var NODETYPE;
(function(NODETYPE2) {
  NODETYPE2[NODETYPE2["ELEMENT"] = 1] = "ELEMENT";
  NODETYPE2[NODETYPE2["ATTRIBUTE"] = 2] = "ATTRIBUTE";
  NODETYPE2[NODETYPE2["TEXT"] = 3] = "TEXT";
  NODETYPE2[NODETYPE2["CDATA"] = 4] = "CDATA";
  NODETYPE2[NODETYPE2["ENTITY_REFERENCE"] = 5] = "ENTITY_REFERENCE";
  NODETYPE2[NODETYPE2["ENTITY"] = 6] = "ENTITY";
  NODETYPE2[NODETYPE2["PROCESSING_INSTRUCTION"] = 7] = "PROCESSING_INSTRUCTION";
  NODETYPE2[NODETYPE2["COMMENT"] = 8] = "COMMENT";
  NODETYPE2[NODETYPE2["DOCUMENT"] = 9] = "DOCUMENT";
  NODETYPE2[NODETYPE2["DOCUMENTTYPE"] = 10] = "DOCUMENTTYPE";
  NODETYPE2[NODETYPE2["DOCUMENT_FRAGMENT"] = 11] = "DOCUMENT_FRAGMENT";
  NODETYPE2[NODETYPE2["NOTATION"] = 12] = "NOTATION";
})(NODETYPE || (NODETYPE = {}));
var TOOLTIP_VERTICAL_OFFSET = 16;
var DEFAULT_VALID_COLOR = "#00FF00";
var DEFAULT_INVALID_COLOR = "#FF0000";
var OUTLINE_HIGHLIGHT_COLOR = "#00FF00";
var OUTLINE_HIGHLIGHT_STROKEWIDTH = 5;
var HIGHLIGHT_STROKEWIDTH = 3;
var HIGHLIGHT_SIZE = 2;
var HIGHLIGHT_OPACITY = 100;
var CURSOR;
(function(CURSOR2) {
  CURSOR2["MOVABLE_VERTEX"] = "move";
  CURSOR2["MOVABLE_EDGE"] = "move";
  CURSOR2["LABEL_HANDLE"] = "default";
  CURSOR2["TERMINAL_HANDLE"] = "pointer";
  CURSOR2["BEND_HANDLE"] = "crosshair";
  CURSOR2["VIRTUAL_BEND_HANDLE"] = "crosshair";
  CURSOR2["CONNECT"] = "pointer";
})(CURSOR || (CURSOR = {}));
var HIGHLIGHT_COLOR = "#00FF00";
var CONNECT_TARGET_COLOR = "#0000FF";
var INVALID_CONNECT_TARGET_COLOR = "#FF0000";
var DROP_TARGET_COLOR = "#0000FF";
var VALID_COLOR = "#00FF00";
var INVALID_COLOR = "#FF0000";
var EDGE_SELECTION_COLOR = "#00FF00";
var VERTEX_SELECTION_COLOR = "#00FF00";
var VERTEX_SELECTION_STROKEWIDTH = 1;
var EDGE_SELECTION_STROKEWIDTH = 1;
var VERTEX_SELECTION_DASHED = true;
var EDGE_SELECTION_DASHED = true;
var GUIDE_COLOR = "#FF0000";
var GUIDE_STROKEWIDTH = 1;
var OUTLINE_COLOR = "#0099FF";
var OUTLINE_STROKEWIDTH = 3;
var HANDLE_SIZE = 6;
var LABEL_HANDLE_SIZE = 4;
var HANDLE_FILLCOLOR = "#00FF00";
var HANDLE_STROKECOLOR = "black";
var LABEL_HANDLE_FILLCOLOR = "yellow";
var CONNECT_HANDLE_FILLCOLOR = "#0000FF";
var LOCKED_HANDLE_FILLCOLOR = "#FF0000";
var OUTLINE_HANDLE_FILLCOLOR = "#00FFFF";
var OUTLINE_HANDLE_STROKECOLOR = "#0033FF";
var DEFAULT_FONTFAMILY = "Arial,Helvetica";
var DEFAULT_FONTSIZE = 11;
var DEFAULT_TEXT_DIRECTION = "";
var LINE_HEIGHT = 1.2;
var WORD_WRAP = "normal";
var ABSOLUTE_LINE_HEIGHT = false;
var DEFAULT_FONTSTYLE = 0;
var DEFAULT_STARTSIZE = 40;
var DEFAULT_MARKERSIZE = 6;
var DEFAULT_IMAGESIZE = 24;
var ENTITY_SEGMENT = 30;
var RECTANGLE_ROUNDING_FACTOR = 0.15;
var LINE_ARCSIZE = 20;
var ARROW_SPACING = 0;
var ARROW_WIDTH = 30;
var ARROW_SIZE = 30;
var PAGE_FORMAT_A4_PORTRAIT = [0, 0, 827, 1169];
var PAGE_FORMAT_A4_LANDSCAPE = [0, 0, 1169, 827];
var PAGE_FORMAT_LETTER_PORTRAIT = [0, 0, 850, 1100];
var PAGE_FORMAT_LETTER_LANDSCAPE = [0, 0, 1100, 850];
var NONE = "none";
var FONT;
(function(FONT2) {
  FONT2[FONT2["BOLD"] = 1] = "BOLD";
  FONT2[FONT2["ITALIC"] = 2] = "ITALIC";
  FONT2[FONT2["UNDERLINE"] = 4] = "UNDERLINE";
  FONT2[FONT2["STRIKETHROUGH"] = 8] = "STRIKETHROUGH";
})(FONT || (FONT = {}));
var ARROW;
(function(ARROW2) {
  ARROW2["CLASSIC"] = "classic";
  ARROW2["CLASSIC_THIN"] = "classicThin";
  ARROW2["BLOCK"] = "block";
  ARROW2["BLOCK_THIN"] = "blockThin";
  ARROW2["OPEN"] = "open";
  ARROW2["OPEN_THIN"] = "openThin";
  ARROW2["OVAL"] = "oval";
  ARROW2["DIAMOND"] = "diamond";
  ARROW2["DIAMOND_THIN"] = "diamondThin";
})(ARROW || (ARROW = {}));
var ALIGN;
(function(ALIGN2) {
  ALIGN2["LEFT"] = "left";
  ALIGN2["CENTER"] = "center";
  ALIGN2["RIGHT"] = "right";
  ALIGN2["TOP"] = "top";
  ALIGN2["MIDDLE"] = "middle";
  ALIGN2["BOTTOM"] = "bottom";
})(ALIGN || (ALIGN = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["NORTH"] = "north";
  DIRECTION2["SOUTH"] = "south";
  DIRECTION2["EAST"] = "east";
  DIRECTION2["WEST"] = "west";
})(DIRECTION || (DIRECTION = {}));
var TEXT_DIRECTION;
(function(TEXT_DIRECTION2) {
  TEXT_DIRECTION2["DEFAULT"] = "";
  TEXT_DIRECTION2["AUTO"] = "auto";
  TEXT_DIRECTION2["LTR"] = "ltr";
  TEXT_DIRECTION2["RTL"] = "rtl";
})(TEXT_DIRECTION || (TEXT_DIRECTION = {}));
var DIRECTION_MASK = {
  NONE: 0,
  WEST: 1,
  NORTH: 2,
  SOUTH: 4,
  EAST: 8,
  ALL: 15
};
var ELBOW;
(function(ELBOW2) {
  ELBOW2["VERTICAL"] = "vertical";
  ELBOW2["HORIZONTAL"] = "horizontal";
})(ELBOW || (ELBOW = {}));
var EDGESTYLE;
(function(EDGESTYLE2) {
  EDGESTYLE2["ELBOW"] = "elbowEdgeStyle";
  EDGESTYLE2["ENTITY_RELATION"] = "entityRelationEdgeStyle";
  EDGESTYLE2["LOOP"] = "loopEdgeStyle";
  EDGESTYLE2["SIDETOSIDE"] = "sideToSideEdgeStyle";
  EDGESTYLE2["TOPTOBOTTOM"] = "topToBottomEdgeStyle";
  EDGESTYLE2["ORTHOGONAL"] = "orthogonalEdgeStyle";
  EDGESTYLE2["SEGMENT"] = "segmentEdgeStyle";
  EDGESTYLE2["MANHATTAN"] = "manhattanEdgeStyle";
})(EDGESTYLE || (EDGESTYLE = {}));
var PERIMETER;
(function(PERIMETER2) {
  PERIMETER2["ELLIPSE"] = "ellipsePerimeter";
  PERIMETER2["RECTANGLE"] = "rectanglePerimeter";
  PERIMETER2["RHOMBUS"] = "rhombusPerimeter";
  PERIMETER2["HEXAGON"] = "hexagonPerimeter";
  PERIMETER2["TRIANGLE"] = "trianglePerimeter";
})(PERIMETER || (PERIMETER = {}));
var SHAPE;
(function(SHAPE2) {
  SHAPE2["RECTANGLE"] = "rectangle";
  SHAPE2["ELLIPSE"] = "ellipse";
  SHAPE2["DOUBLE_ELLIPSE"] = "doubleEllipse";
  SHAPE2["RHOMBUS"] = "rhombus";
  SHAPE2["LINE"] = "line";
  SHAPE2["IMAGE"] = "image";
  SHAPE2["ARROW"] = "arrow";
  SHAPE2["ARROW_CONNECTOR"] = "arrowConnector";
  SHAPE2["LABEL"] = "label";
  SHAPE2["CYLINDER"] = "cylinder";
  SHAPE2["SWIMLANE"] = "swimlane";
  SHAPE2["CONNECTOR"] = "connector";
  SHAPE2["ACTOR"] = "actor";
  SHAPE2["CLOUD"] = "cloud";
  SHAPE2["TRIANGLE"] = "triangle";
  SHAPE2["HEXAGON"] = "hexagon";
})(SHAPE || (SHAPE = {}));

// node_modules/@maxgraph/core/lib/util/domUtils.js
var extractTextWithWhitespace = (elems) => {
  const blocks = [
    "BLOCKQUOTE",
    "DIV",
    "H1",
    "H2",
    "H3",
    "H4",
    "H5",
    "H6",
    "OL",
    "P",
    "PRE",
    "TABLE",
    "UL"
  ];
  const ret = [];
  function doExtract(elts) {
    if (elts.length == 1 && (elts[0].nodeName == "BR" || elts[0].innerHTML == "\n")) {
      return;
    }
    for (let i2 = 0; i2 < elts.length; i2 += 1) {
      const elem = elts[i2];
      if (elem.nodeName == "BR" || elem.innerHTML == "\n" || (elts.length == 1 || i2 == 0) && elem.nodeName == "DIV" && elem.innerHTML.toLowerCase() == "<br>") {
        ret.push("\n");
      } else {
        if (elem.nodeType === 3 || elem.nodeType === 4) {
          if (elem.nodeValue && elem.nodeValue.length > 0) {
            ret.push(elem.nodeValue);
          }
        } else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {
          doExtract(Array.from(elem.childNodes));
        }
        if (i2 < elts.length - 1 && blocks.indexOf(elts[i2 + 1].nodeName) >= 0) {
          ret.push("\n");
        }
      }
    }
  }
  doExtract(elems);
  return ret.join("");
};
var getTextContent = (node2) => {
  return node2 != null && node2.textContent ? node2.textContent : "";
};
var setTextContent = (node2, text2) => {
  if ("innerText" in node2) {
    node2.innerText = text2;
  } else {
    node2.textContent = text2;
  }
};
var getInnerHtml = (node2) => {
  if (node2 != null) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(node2);
  }
  return "";
};
var getOuterHtml = (node2) => {
  if (node2 != null) {
    const serializer = new XMLSerializer();
    return serializer.serializeToString(node2);
  }
  return "";
};
var write = (parent2, text2) => {
  const doc = parent2.ownerDocument;
  const node2 = doc.createTextNode(text2);
  if (parent2 != null) {
    parent2.appendChild(node2);
  }
  return node2;
};
var writeln = (parent2, text2) => {
  const doc = parent2.ownerDocument;
  const node2 = doc.createTextNode(text2);
  if (parent2 != null) {
    parent2.appendChild(node2);
    parent2.appendChild(document.createElement("br"));
  }
  return node2;
};
var br = (parent2, count = 1) => {
  let br2 = null;
  for (let i2 = 0; i2 < count; i2 += 1) {
    if (parent2 != null) {
      br2 = parent2.ownerDocument.createElement("br");
      parent2.appendChild(br2);
    }
  }
  return br2;
};
var para = (parent2, text2) => {
  const p = document.createElement("p");
  write(p, text2);
  if (parent2 != null) {
    parent2.appendChild(p);
  }
  return p;
};
var isNode = (value2, nodeName = null, attributeName, attributeValue) => {
  if (value2 != null && !isNaN(value2.nodeType) && (nodeName == null || value2.nodeName.toLowerCase() == nodeName.toLowerCase())) {
    return attributeName == null || value2.getAttribute(attributeName) == attributeValue;
  }
  return false;
};
var isAncestorNode = (ancestor, child2) => {
  let parent2 = child2;
  while (parent2 != null) {
    if (parent2 === ancestor) {
      return true;
    }
    parent2 = parent2.parentNode;
  }
  return false;
};
var getChildNodes = (node2, nodeType = NODETYPE.ELEMENT) => {
  nodeType = nodeType || NODETYPE.ELEMENT;
  const children = [];
  let tmp2 = node2.firstChild;
  while (tmp2 != null) {
    if (tmp2.nodeType === nodeType) {
      children.push(tmp2);
    }
    tmp2 = tmp2.nextSibling;
  }
  return children;
};
var importNode = (doc, node2, allChildren) => {
  return doc.importNode(node2, allChildren);
};
var importNodeImplementation = (doc, node2, allChildren) => {
  switch (node2.nodeType) {
    case 1: {
      const newNode = doc.createElement(node2.nodeName);
      if (node2.attributes && node2.attributes.length > 0) {
        for (let i2 = 0; i2 < node2.attributes.length; i2 += 1) {
          newNode.setAttribute(node2.attributes[i2].nodeName, node2.getAttribute(node2.attributes[i2].nodeName));
        }
      }
      if (allChildren && node2.childNodes && node2.childNodes.length > 0) {
        for (let i2 = 0; i2 < node2.childNodes.length; i2 += 1) {
          newNode.appendChild(importNodeImplementation(doc, node2.childNodes[i2], allChildren));
        }
      }
      return newNode;
      break;
    }
    case 3:
    case 4:
    case 8: {
      return doc.createTextNode(node2.nodeValue || "");
      break;
    }
  }
};
var clearSelection = () => {
  const sel = window.getSelection ? window.getSelection() : document.selection;
  if (sel) {
    if (sel.removeAllRanges) {
      sel.removeAllRanges();
    } else if (sel.empty) {
      sel.empty();
    }
  }
};
var createImage = (src) => {
  let imageNode = null;
  imageNode = document.createElement("img");
  imageNode.setAttribute("src", src);
  imageNode.setAttribute("border", "0");
  return imageNode;
};
var addLinkToHead = (rel, href, doc = null, id2 = null) => {
  doc = doc || document;
  const link2 = doc.createElement("link");
  link2.setAttribute("rel", rel);
  link2.setAttribute("href", href);
  link2.setAttribute("charset", "UTF-8");
  link2.setAttribute("type", "text/css");
  if (id2) {
    link2.setAttribute("id", id2);
  }
  const head = doc.getElementsByTagName("head")[0];
  head.appendChild(link2);
};

// node_modules/@maxgraph/core/lib/view/event/InternalMouseEvent.js
var InternalMouseEvent = class {
  constructor(evt2, state2 = null) {
    this.consumed = false;
    this.evt = evt2;
    this.state = state2;
    this.sourceState = state2;
    this.graphX = 0;
    this.graphY = 0;
  }
  /**
   * Returns <evt>.
   */
  getEvent() {
    return this.evt;
  }
  /**
   * Returns the target DOM element using {@link Event#getSource} for <evt>.
   */
  getSource() {
    return getSource(this.evt);
  }
  /**
   * Returns true if the given {@link Shape} is the source of <evt>.
   */
  isSource(shape2) {
    return shape2 ? isAncestorNode(shape2.node, this.getSource()) : false;
  }
  /**
   * Returns <evt.clientX>.
   */
  getX() {
    return getClientX(this.getEvent());
  }
  /**
   * Returns <evt.clientY>.
   */
  getY() {
    return getClientY(this.getEvent());
  }
  /**
   * Returns <graphX>.
   */
  getGraphX() {
    return this.graphX;
  }
  /**
   * Returns <graphY>.
   */
  getGraphY() {
    return this.graphY;
  }
  /**
   * Returns <state>.
   */
  getState() {
    return this.state;
  }
  /**
   * Returns the <Cell> in <state> is not null.
   */
  getCell() {
    const state2 = this.getState();
    return state2 ? state2.cell : null;
  }
  /**
   * Returns true if the event is a popup trigger.
   */
  isPopupTrigger() {
    return isPopupTrigger(this.getEvent());
  }
  /**
   * Returns <consumed>.
   */
  isConsumed() {
    return this.consumed;
  }
  /**
   * Sets <consumed> to true and invokes preventDefault on the native event
   * if such a method is defined. This is used mainly to avoid the cursor from
   * being changed to a text cursor in Webkit. You can use the preventDefault
   * flag to disable this functionality.
   *
   * @param preventDefault Specifies if the native event should be canceled. Default
   * is true.
   */
  consume(preventDefault) {
    preventDefault = preventDefault ? preventDefault : window.TouchEvent && this.evt instanceof TouchEvent || isMouseEvent(this.evt);
    if (preventDefault && this.evt.preventDefault) {
      this.evt.preventDefault();
    }
    this.consumed = true;
  }
};
var InternalMouseEvent_default = InternalMouseEvent;

// node_modules/@maxgraph/core/lib/view/event/InternalEvent.js
var supportsPassive = false;
try {
  document.addEventListener("test", () => {
    return;
  }, Object.defineProperty && Object.defineProperty({}, "passive", {
    get: () => {
      supportsPassive = true;
    }
  }));
} catch (e) {
}
var InternalEvent = class _InternalEvent {
  /**
   * Binds the function to the specified event on the given element. Use
   * {@link mxUtils.bind} in order to bind the "this" keyword inside the function
   * to a given execution scope.
   */
  static addListener(element, eventName, funct2) {
    element.addEventListener(eventName, funct2, supportsPassive ? { passive: false } : false);
    if (!element.mxListenerList) {
      element.mxListenerList = [];
    }
    const entry2 = { name: eventName, f: funct2 };
    element.mxListenerList.push(entry2);
  }
  /**
   * Removes the specified listener from the given element.
   */
  static removeListener(element, eventName, funct2) {
    element.removeEventListener(eventName, funct2, false);
    if (element.mxListenerList) {
      const listenerCount = element.mxListenerList.length;
      for (let i2 = 0; i2 < listenerCount; i2 += 1) {
        const entry2 = element.mxListenerList[i2];
        if (entry2.f === funct2) {
          element.mxListenerList.splice(i2, 1);
          break;
        }
      }
    }
  }
  /**
   * Removes all listeners from the given element.
   */
  static removeAllListeners(element) {
    const list = element.mxListenerList;
    if (list) {
      while (list.length > 0) {
        const entry2 = list[0];
        _InternalEvent.removeListener(element, entry2.name, entry2.f);
      }
    }
  }
  /**
   * Adds the given listeners for touch, mouse and/or pointer events. If
   * <Client.IS_POINTER> is true then pointer events will be registered,
   * else the respective mouse events will be registered. If <Client.IS_POINTER>
   * is false and <Client.IS_TOUCH> is true then the respective touch events
   * will be registered as well as the mouse events.
   */
  static addGestureListeners(node2, startListener = null, moveListener = null, endListener = null) {
    if (startListener) {
      _InternalEvent.addListener(node2, Client_default.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener) {
      _InternalEvent.addListener(node2, Client_default.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener) {
      _InternalEvent.addListener(node2, Client_default.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!Client_default.IS_POINTER && Client_default.IS_TOUCH) {
      if (startListener) {
        _InternalEvent.addListener(node2, "touchstart", startListener);
      }
      if (moveListener) {
        _InternalEvent.addListener(node2, "touchmove", moveListener);
      }
      if (endListener) {
        _InternalEvent.addListener(node2, "touchend", endListener);
      }
    }
  }
  /**
   * Removes the given listeners from mousedown, mousemove, mouseup and the
   * respective touch events if <Client.IS_TOUCH> is true.
   */
  static removeGestureListeners(node2, startListener, moveListener, endListener) {
    if (startListener) {
      _InternalEvent.removeListener(node2, Client_default.IS_POINTER ? "pointerdown" : "mousedown", startListener);
    }
    if (moveListener) {
      _InternalEvent.removeListener(node2, Client_default.IS_POINTER ? "pointermove" : "mousemove", moveListener);
    }
    if (endListener) {
      _InternalEvent.removeListener(node2, Client_default.IS_POINTER ? "pointerup" : "mouseup", endListener);
    }
    if (!Client_default.IS_POINTER && Client_default.IS_TOUCH) {
      if (startListener) {
        _InternalEvent.removeListener(node2, "touchstart", startListener);
      }
      if (moveListener) {
        _InternalEvent.removeListener(node2, "touchmove", moveListener);
      }
      if (endListener) {
        _InternalEvent.removeListener(node2, "touchend", endListener);
      }
    }
  }
  /**
   * Redirects the mouse events from the given DOM node to the graph dispatch
   * loop using the event and given state as event arguments. State can
   * either be an instance of <CellState> or a function that returns an
   * <CellState>. The down, move, up and dblClick arguments are optional
   * functions that take the trigger event as arguments and replace the
   * default behaviour.
   */
  static redirectMouseEvents(node2, graph, state2 = null, down = null, move = null, up = null, dblClick = null) {
    const getState = (evt2) => {
      return typeof state2 === "function" ? state2(evt2) : state2;
    };
    _InternalEvent.addGestureListeners(node2, (evt2) => {
      if (down) {
        down(evt2);
      } else if (!isConsumed(evt2)) {
        graph.fireMouseEvent(_InternalEvent.MOUSE_DOWN, new InternalMouseEvent_default(evt2, getState(evt2)));
      }
    }, (evt2) => {
      if (move) {
        move(evt2);
      } else if (!isConsumed(evt2)) {
        graph.fireMouseEvent(_InternalEvent.MOUSE_MOVE, new InternalMouseEvent_default(evt2, getState(evt2)));
      }
    }, (evt2) => {
      if (up) {
        up(evt2);
      } else if (!isConsumed(evt2)) {
        graph.fireMouseEvent(_InternalEvent.MOUSE_UP, new InternalMouseEvent_default(evt2, getState(evt2)));
      }
    });
    _InternalEvent.addListener(node2, "dblclick", (evt2) => {
      if (dblClick) {
        dblClick(evt2);
      } else if (!isConsumed(evt2)) {
        const tmp2 = getState(evt2);
        graph.dblClick(evt2, tmp2 == null ? void 0 : tmp2.cell);
      }
    });
  }
  /**
   * Removes the known listeners from the given DOM node and its descendants.
   *
   * @param element DOM node to remove the listeners from.
   */
  static release(element) {
    try {
      _InternalEvent.removeAllListeners(element);
      const children = element.childNodes;
      if (children !== void 0) {
        const childCount2 = children.length;
        for (let i2 = 0; i2 < childCount2; i2 += 1) {
          _InternalEvent.release(children[i2]);
        }
      }
    } catch (e) {
    }
  }
  /**
   * Installs the given function as a handler for mouse wheel events. The
   * function has two arguments: the mouse event and a boolean that specifies
   * if the wheel was moved up or down.
   *
   * This has been tested with IE 6 and 7, Firefox (all versions), Opera and
   * Safari. It does currently not work on Safari for Mac.
   *
   * ### Example
   *
   * @example
   * ```javascript
   * mxEvent.addMouseWheelListener(function (evt, up)
   * {
   *   GlobalConfig.logger.show();
   *   GlobalConfig.logger.debug('mouseWheel: up='+up);
   * });
   * ```
   *
   * @param funct Handler function that takes the event argument and a boolean up
   * argument for the mousewheel direction.
   * @param target Target for installing the listener in Google Chrome. See
   * https://www.chromestatus.com/features/6662647093133312.
   */
  static addMouseWheelListener(funct2, target2) {
    if (funct2 != null) {
      const wheelHandler = (evt2) => {
        if (evt2.ctrlKey) {
          evt2.preventDefault();
        }
        if (Math.abs(evt2.deltaX) > 0.5 || Math.abs(evt2.deltaY) > 0.5) {
          funct2(evt2, evt2.deltaY == 0 ? -evt2.deltaX > 0 : -evt2.deltaY > 0);
        }
      };
      target2 = target2 != null ? target2 : window;
      if (Client_default.IS_SF && !Client_default.IS_TOUCH) {
        let scale = 1;
        _InternalEvent.addListener(target2, "gesturestart", (evt2) => {
          _InternalEvent.consume(evt2);
          scale = 1;
        });
        _InternalEvent.addListener(target2, "gesturechange", (evt2) => {
          _InternalEvent.consume(evt2);
          if (typeof evt2.scale === "number") {
            const diff = scale - evt2.scale;
            if (Math.abs(diff) > 0.2) {
              funct2(evt2, diff < 0, true);
              scale = evt2.scale;
            }
          }
        });
        _InternalEvent.addListener(target2, "gestureend", (evt2) => {
          _InternalEvent.consume(evt2);
        });
      } else {
        let evtCache = [];
        let dx0 = 0;
        let dy0 = 0;
        _InternalEvent.addGestureListeners(target2, (evt2) => {
          if (!isMouseEvent(evt2) && evt2.pointerId != null) {
            evtCache.push(evt2);
          }
        }, (evt2) => {
          if (!isMouseEvent(evt2) && evtCache.length == 2) {
            for (let i2 = 0; i2 < evtCache.length; i2 += 1) {
              if (evt2.pointerId == evtCache[i2].pointerId) {
                evtCache[i2] = evt2;
                break;
              }
            }
            const dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);
            const dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);
            const tx = Math.abs(dx - dx0);
            const ty = Math.abs(dy - dy0);
            if (tx > _InternalEvent.PINCH_THRESHOLD || ty > _InternalEvent.PINCH_THRESHOLD) {
              const cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;
              const cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;
              funct2(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);
              dx0 = dx;
              dy0 = dy;
            }
          }
        }, (evt2) => {
          evtCache = [];
          dx0 = 0;
          dy0 = 0;
        });
      }
      _InternalEvent.addListener(target2, "wheel", wheelHandler);
    }
  }
  /**
   * Disables the context menu for the given element.
   */
  static disableContextMenu(element) {
    _InternalEvent.addListener(element, "contextmenu", (evt2) => {
      if (evt2.preventDefault) {
        evt2.preventDefault();
      }
      return false;
    });
  }
  /**
   * Consumes the given event.
   *
   * @param evt Native event to be consumed.
   * @param {boolean} [preventDefault=true] Optional boolean to prevent the default for the event.
   * Default is true.
   * @param {boolean} [stopPropagation=true] Option boolean to stop event propagation. Default is
   * true.
   */
  static consume(evt2, preventDefault = true, stopPropagation = true) {
    if (preventDefault) {
      if (evt2.preventDefault) {
        if (stopPropagation) {
          evt2.stopPropagation();
        }
        evt2.preventDefault();
      } else if (stopPropagation) {
        evt2.cancelBubble = true;
      }
    }
    evt2.isConsumed = true;
    if (!evt2.preventDefault) {
      evt2.returnValue = false;
    }
  }
};
InternalEvent.LABEL_HANDLE = -1;
InternalEvent.ROTATION_HANDLE = -2;
InternalEvent.CUSTOM_HANDLE = -100;
InternalEvent.VIRTUAL_HANDLE = -1e5;
InternalEvent.MOUSE_DOWN = "mouseDown";
InternalEvent.MOUSE_MOVE = "mouseMove";
InternalEvent.MOUSE_UP = "mouseUp";
InternalEvent.ACTIVATE = "activate";
InternalEvent.RESIZE_START = "resizeStart";
InternalEvent.RESIZE = "resize";
InternalEvent.RESIZE_END = "resizeEnd";
InternalEvent.MOVE_START = "moveStart";
InternalEvent.MOVE = "move";
InternalEvent.MOVE_END = "moveEnd";
InternalEvent.PAN_START = "panStart";
InternalEvent.PAN = "pan";
InternalEvent.PAN_END = "panEnd";
InternalEvent.MINIMIZE = "minimize";
InternalEvent.NORMALIZE = "normalize";
InternalEvent.MAXIMIZE = "maximize";
InternalEvent.HIDE = "hide";
InternalEvent.SHOW = "show";
InternalEvent.CLOSE = "close";
InternalEvent.DESTROY = "destroy";
InternalEvent.REFRESH = "refresh";
InternalEvent.SIZE = "size";
InternalEvent.SELECT = "select";
InternalEvent.FIRED = "fired";
InternalEvent.FIRE_MOUSE_EVENT = "fireMouseEvent";
InternalEvent.GESTURE = "gesture";
InternalEvent.TAP_AND_HOLD = "tapAndHold";
InternalEvent.GET = "get";
InternalEvent.RECEIVE = "receive";
InternalEvent.CONNECT = "connect";
InternalEvent.DISCONNECT = "disconnect";
InternalEvent.SUSPEND = "suspend";
InternalEvent.RESUME = "resume";
InternalEvent.MARK = "mark";
InternalEvent.ROOT = "root";
InternalEvent.POST = "post";
InternalEvent.OPEN = "open";
InternalEvent.SAVE = "save";
InternalEvent.BEFORE_ADD_VERTEX = "beforeAddVertex";
InternalEvent.ADD_VERTEX = "addVertex";
InternalEvent.AFTER_ADD_VERTEX = "afterAddVertex";
InternalEvent.DONE = "done";
InternalEvent.EXECUTE = "execute";
InternalEvent.EXECUTED = "executed";
InternalEvent.BEGIN_UPDATE = "beginUpdate";
InternalEvent.START_EDIT = "startEdit";
InternalEvent.END_UPDATE = "endUpdate";
InternalEvent.END_EDIT = "endEdit";
InternalEvent.BEFORE_UNDO = "beforeUndo";
InternalEvent.UNDO = "undo";
InternalEvent.REDO = "redo";
InternalEvent.CHANGE = "change";
InternalEvent.NOTIFY = "notify";
InternalEvent.LAYOUT_CELLS = "layoutCells";
InternalEvent.CLICK = "click";
InternalEvent.SCALE = "scale";
InternalEvent.TRANSLATE = "translate";
InternalEvent.SCALE_AND_TRANSLATE = "scaleAndTranslate";
InternalEvent.UP = "up";
InternalEvent.DOWN = "down";
InternalEvent.ADD = "add";
InternalEvent.REMOVE = "remove";
InternalEvent.CLEAR = "clear";
InternalEvent.ADD_CELLS = "addCells";
InternalEvent.CELLS_ADDED = "cellsAdded";
InternalEvent.MOVE_CELLS = "moveCells";
InternalEvent.CELLS_MOVED = "cellsMoved";
InternalEvent.RESIZE_CELLS = "resizeCells";
InternalEvent.CELLS_RESIZED = "cellsResized";
InternalEvent.TOGGLE_CELLS = "toggleCells";
InternalEvent.CELLS_TOGGLED = "cellsToggled";
InternalEvent.ORDER_CELLS = "orderCells";
InternalEvent.CELLS_ORDERED = "cellsOrdered";
InternalEvent.REMOVE_CELLS = "removeCells";
InternalEvent.CELLS_REMOVED = "cellsRemoved";
InternalEvent.GROUP_CELLS = "groupCells";
InternalEvent.UNGROUP_CELLS = "ungroupCells";
InternalEvent.REMOVE_CELLS_FROM_PARENT = "removeCellsFromParent";
InternalEvent.FOLD_CELLS = "foldCells";
InternalEvent.CELLS_FOLDED = "cellsFolded";
InternalEvent.ALIGN_CELLS = "alignCells";
InternalEvent.LABEL_CHANGED = "labelChanged";
InternalEvent.CONNECT_CELL = "connectCell";
InternalEvent.CELL_CONNECTED = "cellConnected";
InternalEvent.SPLIT_EDGE = "splitEdge";
InternalEvent.FLIP_EDGE = "flipEdge";
InternalEvent.START_EDITING = "startEditing";
InternalEvent.EDITING_STARTED = "editingStarted";
InternalEvent.EDITING_STOPPED = "editingStopped";
InternalEvent.ADD_OVERLAY = "addOverlay";
InternalEvent.REMOVE_OVERLAY = "removeOverlay";
InternalEvent.UPDATE_CELL_SIZE = "updateCellSize";
InternalEvent.ESCAPE = "escape";
InternalEvent.DOUBLE_CLICK = "doubleClick";
InternalEvent.START = "start";
InternalEvent.RESET = "reset";
InternalEvent.PINCH_THRESHOLD = 10;
var InternalEvent_default = InternalEvent;

// node_modules/@maxgraph/core/lib/view/geometry/Point.js
var Point = class _Point {
  constructor(x = 0, y = 0) {
    this._x = 0;
    this._y = 0;
    this.x = x;
    this.y = y;
  }
  get x() {
    return this._x;
  }
  set x(x) {
    if (Number.isNaN(x))
      throw new Error("Invalid x supplied.");
    this._x = x;
  }
  get y() {
    return this._y;
  }
  set y(y) {
    if (Number.isNaN(y))
      throw new Error("Invalid y supplied.");
    this._y = y;
  }
  /**
   * Returns true if the given object equals this point.
   */
  equals(p) {
    if (!p)
      return false;
    return p.x === this.x && p.y === this.y;
  }
  /**
   * Returns a clone of this {@link Point}.
   */
  clone() {
    return new _Point(this.x, this.y);
  }
};
var Point_default = Point;

// node_modules/@maxgraph/core/lib/view/geometry/Rectangle.js
var Rectangle = class _Rectangle extends Point_default {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    super(x, y);
    this._width = 0;
    this._height = 0;
    this.width = width;
    this.height = height;
  }
  get width() {
    return this._width;
  }
  set width(width) {
    if (Number.isNaN(width))
      throw new Error("Invalid width supplied.");
    this._width = width;
  }
  get height() {
    return this._height;
  }
  set height(height) {
    if (Number.isNaN(height))
      throw new Error("Invalid height supplied.");
    this._height = height;
  }
  /**
   * Sets this rectangle to the specified values
   */
  setRect(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  /**
   * Returns the x-coordinate of the center point.
   */
  getCenterX() {
    return this.x + this.width / 2;
  }
  /**
   * Returns the y-coordinate of the center point.
   */
  getCenterY() {
    return this.y + this.height / 2;
  }
  /**
   * Adds the given rectangle to this rectangle.
   */
  add(rect) {
    const minX = Math.min(this.x, rect.x);
    const minY = Math.min(this.y, rect.y);
    const maxX = Math.max(this.x + this.width, rect.x + rect.width);
    const maxY = Math.max(this.y + this.height, rect.y + rect.height);
    this.x = minX;
    this.y = minY;
    this.width = maxX - minX;
    this.height = maxY - minY;
  }
  /**
   * Changes this rectangle to where it overlaps with the given rectangle.
   */
  intersect(rect) {
    const r1 = this.x + this.width;
    const r2 = rect.x + rect.width;
    const b1 = this.y + this.height;
    const b2 = rect.y + rect.height;
    this.x = Math.max(this.x, rect.x);
    this.y = Math.max(this.y, rect.y);
    this.width = Math.min(r1, r2) - this.x;
    this.height = Math.min(b1, b2) - this.y;
  }
  /**
   * Grows the rectangle by the given amount, that is, this method subtracts
   * the given amount from the x- and y-coordinates and adds twice the amount
   * to the width and height.
   */
  grow(amount) {
    this.x -= amount;
    this.y -= amount;
    this.width += 2 * amount;
    this.height += 2 * amount;
  }
  /**
   * Returns the top, left corner as a new {@link Point}.
   */
  getPoint() {
    return new Point_default(this.x, this.y);
  }
  /**
   * Rotates this rectangle by 90 degree around its center point.
   */
  rotate90() {
    const t = (this.width - this.height) / 2;
    this.x += t;
    this.y -= t;
    const tmp2 = this.width;
    this.width = this.height;
    this.height = tmp2;
  }
  /**
   * Returns true if the given object equals this rectangle.
   */
  equals(rect) {
    if (!rect)
      return false;
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  }
  clone() {
    return new _Rectangle(this.x, this.y, this.width, this.height);
  }
};
Rectangle.fromRectangle = (rect) => {
  return new Rectangle(rect.x, rect.y, rect.width, rect.height);
};
var Rectangle_default = Rectangle;

// node_modules/@maxgraph/core/lib/util/StringUtils.js
var StringUtils_exports = {};
__export(StringUtils_exports, {
  getColor: () => getColor,
  getFunctionName: () => getFunctionName,
  getNumber: () => getNumber,
  getStringValue: () => getStringValue,
  htmlEntities: () => htmlEntities,
  ltrim: () => ltrim,
  removeWhitespace: () => removeWhitespace,
  replaceTrailingNewlines: () => replaceTrailingNewlines,
  rtrim: () => rtrim,
  toString: () => toString,
  trim: () => trim
});
var ltrim = (str, chars = "\\s") => str != null ? str.replace(new RegExp(`^[${chars}]+`, "g"), "") : null;
var rtrim = (str, chars = "\\s") => str != null ? str.replace(new RegExp(`[${chars}]+$`, "g"), "") : null;
var trim = (str, chars) => ltrim(rtrim(str, chars), chars);
var getFunctionName = (f) => {
  let str = null;
  if (f != null) {
    if (f.name != null) {
      str = f.name;
    } else {
      str = trim(f.toString());
      if (str !== null && /^function\s/.test(str)) {
        str = ltrim(str.substring(9));
        if (str !== null) {
          const idx2 = str.indexOf("(");
          if (idx2 > 0) {
            str = str.substring(0, idx2);
          }
        }
      }
    }
  }
  return str;
};
var replaceTrailingNewlines = (str, pattern) => {
  let postfix = "";
  while (str.length > 0 && str.charAt(str.length - 1) == "\n") {
    str = str.substring(0, str.length - 1);
    postfix += pattern;
  }
  return str + postfix;
};
var removeWhitespace = (node2, before) => {
  var _a2, _b;
  let tmp2 = before ? node2.previousSibling : node2.nextSibling;
  while (tmp2 != null && tmp2.nodeType === NODETYPE.TEXT) {
    const next = before ? tmp2.previousSibling : tmp2.nextSibling;
    const text2 = getTextContent(tmp2);
    if (((_a2 = trim(text2)) == null ? void 0 : _a2.length) === 0) {
      (_b = tmp2.parentNode) == null ? void 0 : _b.removeChild(tmp2);
    }
    tmp2 = next;
  }
};
var htmlEntities = (s, newline = true) => {
  s = String(s || "");
  s = s.replace(/&/g, "&amp;");
  s = s.replace(/"/g, "&quot;");
  s = s.replace(/'/g, "&#39;");
  s = s.replace(/</g, "&lt;");
  s = s.replace(/>/g, "&gt;");
  if (newline) {
    s = s.replace(/\n/g, "&#xa;");
  }
  return s;
};
var getStringValue = (array, key2, defaultValue) => {
  let value2 = array != null ? array[key2] : null;
  if (value2 == null) {
    value2 = defaultValue;
  }
  return value2 == null ? null : String(value2);
};
var getNumber = (array, key2, defaultValue) => {
  let value2 = array != null ? array[key2] : null;
  if (value2 == null) {
    value2 = defaultValue || 0;
  }
  return Number(value2);
};
var getColor = (array, key2, defaultValue) => {
  let value2 = array != null ? array[key2] : null;
  if (value2 == null) {
    value2 = defaultValue;
  } else if (value2 === NONE) {
    value2 = null;
  }
  return value2;
};
var toString = (obj2) => {
  let output = "";
  for (const i2 in obj2) {
    try {
      if (obj2[i2] == null) {
        output += `${i2} = [null]
`;
      } else if (typeof obj2[i2] === "function") {
        output += `${i2} => [Function]
`;
      } else if (typeof obj2[i2] === "object") {
        const ctor = getFunctionName(obj2[i2].constructor);
        output += `${i2} => [${ctor}]
`;
      } else {
        output += `${i2} = ${obj2[i2]}
`;
      }
    } catch (e) {
      output += `${i2}=${e.message}`;
    }
  }
  return output;
};

// node_modules/@maxgraph/core/lib/util/ObjectIdentity.js
var ObjectIdentity = class _ObjectIdentity {
  /**
   * Returns the ID for the given object or function.
   */
  static get(obj2) {
    if (obj2) {
      if (obj2[IDENTITY_FIELD_NAME] === null || obj2[IDENTITY_FIELD_NAME] === void 0) {
        if (typeof obj2 === "object") {
          const ctor = getFunctionName(obj2.constructor);
          obj2[IDENTITY_FIELD_NAME] = `${ctor}#${_ObjectIdentity.counter++}`;
        } else if (typeof obj2 === "function") {
          obj2[IDENTITY_FIELD_NAME] = `Function#${_ObjectIdentity.counter++}`;
        }
      }
      return obj2[IDENTITY_FIELD_NAME];
    }
    return null;
  }
  /**
   * Deletes the ID from the given object or function.
   */
  static clear(obj2) {
    delete obj2[IDENTITY_FIELD_NAME];
  }
};
ObjectIdentity.FIELD_NAME = IDENTITY_FIELD_NAME;
ObjectIdentity.counter = 0;
var ObjectIdentity_default = ObjectIdentity;

// node_modules/@maxgraph/core/lib/util/Dictionary.js
var Dictionary = class {
  constructor() {
    this.map = {};
    this.clear();
  }
  /**
   * Clears the dictionary.
   */
  clear() {
    this.map = {};
  }
  /**
   * Returns the value for the given key.
   */
  get(key2) {
    const id2 = ObjectIdentity_default.get(key2);
    return this.map[id2] ?? null;
  }
  /**
   * Stores the value under the given key and returns the previous
   * value for that key.
   */
  put(key2, value2) {
    const id2 = ObjectIdentity_default.get(key2);
    const previous = this.map[id2];
    this.map[id2] = value2;
    return previous ?? null;
  }
  /**
   * Removes the value for the given key and returns the value that
   * has been removed.
   */
  remove(key2) {
    const id2 = ObjectIdentity_default.get(key2);
    const previous = this.map[id2];
    delete this.map[id2];
    return previous ?? null;
  }
  /**
   * Returns all keys as an array.
   */
  getKeys() {
    const result2 = [];
    for (const key2 in this.map) {
      result2.push(key2);
    }
    return result2;
  }
  /**
   * Returns all values as an array.
   */
  getValues() {
    const result2 = [];
    for (const key2 in this.map) {
      result2.push(this.map[key2]);
    }
    return result2;
  }
  /**
   * Visits all entries in the dictionary using the given function with the
   * following signature: (key, value)=> where key is a string and
   * value is an object.
   *
   * @param visitor A function that takes the key and value as arguments.
   */
  visit(visitor) {
    for (const key2 in this.map) {
      visitor(key2, this.map[key2]);
    }
  }
};
var Dictionary_default = Dictionary;

// node_modules/@maxgraph/core/lib/util/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  copyTextToClipboard: () => copyTextToClipboard,
  getElapseMillisecondsMessage: () => getElapseMillisecondsMessage,
  getValue: () => getValue,
  isNotNullish: () => isNotNullish,
  isNullish: () => isNullish,
  mixInto: () => mixInto,
  utils: () => utils
});

// node_modules/@maxgraph/core/lib/util/logger.js
var NoOpLogger = class {
  debug(_message) {
  }
  enter(_message) {
    return void 0;
  }
  error(_message, ..._optionalParams) {
  }
  info(_message) {
  }
  leave(_message, _baseTimestamp) {
  }
  show() {
  }
  trace(_message) {
  }
  warn(_message) {
  }
};
var ConsoleLogger = class {
  constructor() {
    this.debugEnabled = false;
    this.infoEnabled = false;
    this.traceEnabled = false;
  }
  /* eslint-disable no-console -- we must use "console" to direct logs to the browser console */
  enter(message) {
    if (this.traceEnabled) {
      console.trace(`Entering ${message}`);
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  leave(message, baseTimestamp) {
    if (this.traceEnabled) {
      const dt = getElapseMillisecondsMessage(baseTimestamp);
      console.trace(`Leaving ${message}${dt}`);
    }
  }
  show() {
  }
  trace(message) {
    if (this.traceEnabled) {
      console.trace(message);
    }
  }
  debug(message) {
    if (this.debugEnabled) {
      console.debug(message);
    }
  }
  info(message) {
    if (this.infoEnabled) {
      console.info(message);
    }
  }
  warn(message) {
    console.warn(message);
  }
  error(message, ...optionalParams) {
    console.error(message, ...optionalParams);
  }
};

// node_modules/@maxgraph/core/lib/util/config.js
var GlobalConfig = {
  /**
   * Configure the logger to use for all log messages.
   *
   * Available implementations provided by maxGraph are:
   * * {@link ConsoleLogger} - Directs logs to the browser console.
   * * {@link NoOpLogger} - Default implementation that does nothing.
   * * {@link MaxLogAsLogger} - Directs logs to {@link MaxLog}.
   *
   * To change the logger, set this property to an instance of the desired logger:
   * ```js
   * // To direct logs to the browser console
   * GlobalConfig.logger = new ConsoleLogger();
   * // To direct logs to MaxLog
   * GlobalConfig.logger = new MaxLogAsLogger();
   * ```
   *
   * @default `NoOpLogger`
   */
  logger: new NoOpLogger()
};

// node_modules/@maxgraph/core/lib/util/Utils.js
var utils = {
  /*
   * Specifies the resource key for the title of the error window. If the
   * resource for this key does not exist then the value is used as
   * the title. Default is 'error'.
   */
  errorResource: "error",
  /**
   * Specifies the resource key for the label of the close button. If the
   * resource for this key does not exist then the value is used as
   * the label. Default is 'close'.
   */
  closeResource: "close",
  /**
   * Defines the image used for error dialogs.
   */
  errorImage: `${Client_default.imageBasePath}/error.gif`
};
var isNullish = (v) => v === null || v === void 0;
var isNotNullish = (v) => !isNullish(v);
var mixInto = (dest) => (mixin) => {
  const keys = Reflect.ownKeys(mixin);
  try {
    for (const key2 of keys) {
      Object.defineProperty(dest.prototype, key2, {
        value: mixin[key2],
        writable: true
      });
    }
  } catch (e) {
    GlobalConfig.logger.error("Error while mixing", e);
  }
};
var getValue = (array, key2, defaultValue) => {
  let value2 = array != null ? array[key2] : null;
  if (value2 == null) {
    value2 = defaultValue;
  }
  return value2;
};
var copyTextToClipboard = (text2) => {
  if (!navigator.clipboard) {
    fallbackCopyTextToClipboard(text2);
    return;
  }
  navigator.clipboard.writeText(text2).then(function() {
    GlobalConfig.logger.info("Async: Copying to clipboard was successful!");
  }, function(err) {
    GlobalConfig.logger.error("Async: Could not copy text: ", err);
  });
};
var fallbackCopyTextToClipboard = (text2) => {
  const textArea = document.createElement("textarea");
  textArea.value = text2;
  textArea.style.top = "0";
  textArea.style.left = "0";
  textArea.style.position = "fixed";
  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();
  try {
    const successful = document.execCommand("copy");
    const msg = successful ? "successful" : "unsuccessful";
    GlobalConfig.logger.info(`Fallback: Copying text command was ${msg}`);
  } catch (err) {
    GlobalConfig.logger.error("Fallback: Oops, unable to copy", err);
  }
  document.body.removeChild(textArea);
};
var getElapseMillisecondsMessage = (baseTimestamp) => baseTimestamp ? ` (${(/* @__PURE__ */ new Date()).getTime() - baseTimestamp} ms)` : "";

// node_modules/@maxgraph/core/lib/util/mathUtils.js
var mathUtils_exports = {};
__export(mathUtils_exports, {
  arcToCurves: () => arcToCurves,
  contains: () => contains,
  findNearestSegment: () => findNearestSegment,
  getBoundingBox: () => getBoundingBox,
  getDirectedBounds: () => getDirectedBounds,
  getPerimeterPoint: () => getPerimeterPoint,
  getPortConstraints: () => getPortConstraints,
  getRotatedPoint: () => getRotatedPoint,
  intersection: () => intersection,
  intersects: () => intersects2,
  intersectsHotspot: () => intersectsHotspot,
  isInteger: () => isInteger,
  isNumeric: () => isNumeric,
  mod: () => mod,
  ptLineDist: () => ptLineDist,
  ptSegDistSq: () => ptSegDistSq,
  rectangleIntersectsSegment: () => rectangleIntersectsSegment,
  relativeCcw: () => relativeCcw,
  reversePortConstraints: () => reversePortConstraints,
  toDegree: () => toDegree,
  toRadians: () => toRadians
});
var toRadians = (deg) => {
  return Math.PI * deg / 180;
};
var toDegree = (rad) => {
  return rad * 180 / Math.PI;
};
var arcToCurves = (x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) => {
  x -= x0;
  y -= y0;
  if (r1 === 0 || r2 === 0) {
    return [];
  }
  const fS = sweepFlag;
  const psai = angle;
  r1 = Math.abs(r1);
  r2 = Math.abs(r2);
  const ctx = -x / 2;
  const cty = -y / 2;
  const cpsi = Math.cos(psai * Math.PI / 180);
  const spsi = Math.sin(psai * Math.PI / 180);
  const rxd = cpsi * ctx + spsi * cty;
  const ryd = -1 * spsi * ctx + cpsi * cty;
  const rxdd = rxd * rxd;
  const rydd = ryd * ryd;
  const r1x = r1 * r1;
  const r2y = r2 * r2;
  const lamda = rxdd / r1x + rydd / r2y;
  let sds;
  if (lamda > 1) {
    r1 = Math.sqrt(lamda) * r1;
    r2 = Math.sqrt(lamda) * r2;
    sds = 0;
  } else {
    let seif = 1;
    if (largeArcFlag === fS) {
      seif = -1;
    }
    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  const txd = sds * r1 * ryd / r2;
  const tyd = -1 * sds * r2 * rxd / r1;
  const tx = cpsi * txd - spsi * tyd + x / 2;
  const ty = spsi * txd + cpsi * tyd + y / 2;
  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);
  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;
  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);
  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;
  if (!fS && dr > 0) {
    dr -= 2 * Math.PI;
  } else if (fS && dr < 0) {
    dr += 2 * Math.PI;
  }
  const sse = dr * 2 / Math.PI;
  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);
  const segr = dr / seg;
  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  const cpsir1 = cpsi * r1;
  const cpsir2 = cpsi * r2;
  const spsir1 = spsi * r1;
  const spsir2 = spsi * r2;
  let mc = Math.cos(s1);
  let ms = Math.sin(s1);
  let x2 = -t * (cpsir1 * ms + spsir2 * mc);
  let y2 = -t * (spsir1 * ms - cpsir2 * mc);
  let x3 = 0;
  let y3 = 0;
  const result2 = [];
  for (let n = 0; n < seg; ++n) {
    s1 += segr;
    mc = Math.cos(s1);
    ms = Math.sin(s1);
    x3 = cpsir1 * mc - spsir2 * ms + tx;
    y3 = spsir1 * mc + cpsir2 * ms + ty;
    const dx = -t * (cpsir1 * ms + spsir2 * mc);
    const dy = -t * (spsir1 * ms - cpsir2 * mc);
    const index = n * 6;
    result2[index] = Number(x2 + x0);
    result2[index + 1] = Number(y2 + y0);
    result2[index + 2] = Number(x3 - dx + x0);
    result2[index + 3] = Number(y3 - dy + y0);
    result2[index + 4] = Number(x3 + x0);
    result2[index + 5] = Number(y3 + y0);
    x2 = x3 + dx;
    y2 = y3 + dy;
  }
  return result2;
};
var getBoundingBox = (rect, rotation, cx = null) => {
  let result2 = null;
  if (rect && rotation !== 0) {
    const rad = toRadians(rotation);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    cx = cx != null ? cx : new Point_default(rect.x + rect.width / 2, rect.y + rect.height / 2);
    let p1 = new Point_default(rect.x, rect.y);
    let p2 = new Point_default(rect.x + rect.width, rect.y);
    let p3 = new Point_default(p2.x, rect.y + rect.height);
    let p4 = new Point_default(rect.x, p3.y);
    p1 = getRotatedPoint(p1, cos, sin, cx);
    p2 = getRotatedPoint(p2, cos, sin, cx);
    p3 = getRotatedPoint(p3, cos, sin, cx);
    p4 = getRotatedPoint(p4, cos, sin, cx);
    result2 = new Rectangle_default(p1.x, p1.y, 0, 0);
    result2.add(new Rectangle_default(p2.x, p2.y, 0, 0));
    result2.add(new Rectangle_default(p3.x, p3.y, 0, 0));
    result2.add(new Rectangle_default(p4.x, p4.y, 0, 0));
  }
  return result2;
};
var getRotatedPoint = (pt, cos, sin, c = new Point_default()) => {
  const x = pt.x - c.x;
  const y = pt.y - c.y;
  const x1 = x * cos - y * sin;
  const y1 = y * cos + x * sin;
  return new Point_default(x1 + c.x, y1 + c.y);
};
var getPortConstraints = (terminal, edge2, source2, defaultValue) => {
  const value2 = getValue(terminal.style, "portConstraint", getValue(edge2.style, source2 ? "sourcePortConstraint" : "targetPortConstraint", null));
  if (isNullish(value2)) {
    return defaultValue;
  }
  const directions = value2.toString();
  let returnValue = DIRECTION_MASK.NONE;
  const constraintRotationEnabled = terminal.style.portConstraintRotation ?? false;
  let rotation = 0;
  if (constraintRotationEnabled) {
    rotation = terminal.style.rotation ?? 0;
  }
  let quad = 0;
  if (rotation > 45) {
    quad = 1;
    if (rotation >= 135) {
      quad = 2;
    }
  } else if (rotation < -45) {
    quad = 3;
    if (rotation <= -135) {
      quad = 2;
    }
  }
  if (directions.indexOf(DIRECTION.NORTH) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.WEST;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.WEST) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.SOUTH) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.EAST;
        break;
    }
  }
  if (directions.indexOf(DIRECTION.EAST) >= 0) {
    switch (quad) {
      case 0:
        returnValue |= DIRECTION_MASK.EAST;
        break;
      case 1:
        returnValue |= DIRECTION_MASK.SOUTH;
        break;
      case 2:
        returnValue |= DIRECTION_MASK.WEST;
        break;
      case 3:
        returnValue |= DIRECTION_MASK.NORTH;
        break;
    }
  }
  return returnValue;
};
var reversePortConstraints = (constraint) => {
  let result2 = 0;
  result2 = (constraint & DIRECTION_MASK.WEST) << 3;
  result2 |= (constraint & DIRECTION_MASK.NORTH) << 1;
  result2 |= (constraint & DIRECTION_MASK.SOUTH) >> 1;
  result2 |= (constraint & DIRECTION_MASK.EAST) >> 3;
  return result2;
};
var findNearestSegment = (state2, x, y) => {
  let index = -1;
  if (state2.absolutePoints.length > 0) {
    let last = state2.absolutePoints[0];
    let min = null;
    for (let i2 = 1; i2 < state2.absolutePoints.length; i2 += 1) {
      const current = state2.absolutePoints[i2];
      if (!last || !current)
        continue;
      const dist = ptSegDistSq(last.x, last.y, current.x, current.y, x, y);
      if (min == null || dist < min) {
        min = dist;
        index = i2 - 1;
      }
      last = current;
    }
  }
  return index;
};
var getDirectedBounds = (rect, m, style2, flipH, flipV) => {
  const d = getValue(style2, "direction", DIRECTION.EAST);
  flipH = flipH != null ? flipH : getValue(style2, "flipH", false);
  flipV = flipV != null ? flipV : getValue(style2, "flipV", false);
  m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));
  m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));
  m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));
  m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));
  if (flipV && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipH && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {
    const tmp2 = m.x;
    m.x = m.width;
    m.width = tmp2;
  }
  if (flipH && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH) || flipV && (d === DIRECTION.EAST || d === DIRECTION.WEST)) {
    const tmp2 = m.y;
    m.y = m.height;
    m.height = tmp2;
  }
  const m2 = Rectangle_default.fromRectangle(m);
  if (d === DIRECTION.SOUTH) {
    m2.y = m.x;
    m2.x = m.height;
    m2.width = m.y;
    m2.height = m.width;
  } else if (d === DIRECTION.WEST) {
    m2.y = m.height;
    m2.x = m.width;
    m2.width = m.x;
    m2.height = m.y;
  } else if (d === DIRECTION.NORTH) {
    m2.y = m.width;
    m2.x = m.y;
    m2.width = m.height;
    m2.height = m.x;
  }
  return new Rectangle_default(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);
};
var getPerimeterPoint = (pts, center, point) => {
  let min = null;
  for (let i2 = 0; i2 < pts.length - 1; i2 += 1) {
    const pt = intersection(pts[i2].x, pts[i2].y, pts[i2 + 1].x, pts[i2 + 1].y, center.x, center.y, point.x, point.y);
    if (pt != null) {
      const dx = point.x - pt.x;
      const dy = point.y - pt.y;
      const ip = { p: pt, distSq: dy * dy + dx * dx };
      if (ip != null && (min == null || min.distSq > ip.distSq)) {
        min = ip;
      }
    }
  }
  return min != null ? min.p : null;
};
var rectangleIntersectsSegment = (bounds, p1, p2) => {
  const top = bounds.y;
  const left = bounds.x;
  const bottom = top + bounds.height;
  const right = left + bounds.width;
  let minX = p1.x;
  let maxX = p2.x;
  if (p1.x > p2.x) {
    minX = p2.x;
    maxX = p1.x;
  }
  if (maxX > right) {
    maxX = right;
  }
  if (minX < left) {
    minX = left;
  }
  if (minX > maxX) {
    return false;
  }
  let minY = p1.y;
  let maxY = p2.y;
  const dx = p2.x - p1.x;
  if (Math.abs(dx) > 1e-7) {
    const a = (p2.y - p1.y) / dx;
    const b = p1.y - a * p1.x;
    minY = a * minX + b;
    maxY = a * maxX + b;
  }
  if (minY > maxY) {
    const tmp2 = maxY;
    maxY = minY;
    minY = tmp2;
  }
  if (maxY > bottom) {
    maxY = bottom;
  }
  if (minY < top) {
    minY = top;
  }
  if (minY > maxY) {
    return false;
  }
  return true;
};
var contains = (bounds, x, y) => {
  return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;
};
var intersects2 = (a, b) => {
  let tw = a.width;
  let th = a.height;
  let rw = b.width;
  let rh = b.height;
  if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
    return false;
  }
  const tx = a.x;
  const ty = a.y;
  const rx = b.x;
  const ry = b.y;
  rw += rx;
  rh += ry;
  tw += tx;
  th += ty;
  return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);
};
var intersectsHotspot = (state2, x, y, hotspot, min, max) => {
  hotspot = hotspot != null ? hotspot : 1;
  min = min != null ? min : 0;
  max = max != null ? max : 0;
  if (hotspot > 0) {
    let cx = state2.getCenterX();
    let cy = state2.getCenterY();
    let w = state2.width;
    let h = state2.height;
    const start = getValue(state2.style, "startSize") * state2.view.scale;
    if (start > 0) {
      if (getValue(state2.style, "horizontal", true)) {
        cy = state2.y + start / 2;
        h = start;
      } else {
        cx = state2.x + start / 2;
        w = start;
      }
    }
    w = Math.max(min, w * hotspot);
    h = Math.max(min, h * hotspot);
    if (max > 0) {
      w = Math.min(w, max);
      h = Math.min(h, max);
    }
    const rect = new Rectangle_default(cx - w / 2, cy - h / 2, w, h);
    const alpha = toRadians(getValue(state2.style, "rotation") || 0);
    if (alpha != 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      const cx2 = new Point_default(state2.getCenterX(), state2.getCenterY());
      const pt = getRotatedPoint(new Point_default(x, y), cos, sin, cx2);
      x = pt.x;
      y = pt.y;
    }
    return contains(rect, x, y);
  }
  return true;
};
var isNumeric = (n) => {
  return !Number.isNaN(parseFloat(n)) && isFinite(+n) && (typeof n !== "string" || n.toLowerCase().indexOf("0x") < 0);
};
var isInteger = (n) => {
  return String(parseInt(n)) === String(n);
};
var mod = (n, m) => {
  return (n % m + m) % m;
};
var intersection = (x0, y0, x1, y1, x2, y2, x3, y3) => {
  const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);
  const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);
  const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);
  const ua = nume_a / denom;
  const ub = nume_b / denom;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    const x = x0 + ua * (x1 - x0);
    const y = y0 + ua * (y1 - y0);
    return new Point_default(x, y);
  }
  return null;
};
var ptSegDistSq = (x1, y1, x2, y2, px, py) => {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let dotprod = px * x2 + py * y2;
  let projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x2 - px;
    py = y2 - py;
    dotprod = px * x2 + py * y2;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
    }
  }
  let lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
var ptLineDist = (x1, y1, x2, y2, px, py) => {
  return Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
};
var relativeCcw = (x1, y1, x2, y2, px, py) => {
  x2 -= x1;
  y2 -= y1;
  px -= x1;
  py -= y1;
  let ccw = px * y2 - py * x2;
  if (ccw == 0) {
    ccw = px * x2 + py * y2;
    if (ccw > 0) {
      px -= x2;
      py -= y2;
      ccw = px * x2 + py * y2;
      if (ccw < 0) {
        ccw = 0;
      }
    }
  }
  return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
};

// node_modules/@maxgraph/core/lib/util/styleUtils.js
var styleUtils_exports = {};
__export(styleUtils_exports, {
  convertPoint: () => convertPoint,
  fit: () => fit,
  getAlignmentAsPoint: () => getAlignmentAsPoint,
  getCurrentStyle: () => getCurrentStyle,
  getDocumentScrollOrigin: () => getDocumentScrollOrigin,
  getDocumentSize: () => getDocumentSize,
  getOffset: () => getOffset,
  getScrollOrigin: () => getScrollOrigin,
  getSizeForString: () => getSizeForString,
  hasScrollbars: () => hasScrollbars,
  matchBinaryMask: () => matchBinaryMask,
  parseCssNumber: () => parseCssNumber,
  removeCursors: () => removeCursors,
  setCellStyleFlags: () => setCellStyleFlags,
  setCellStyles: () => setCellStyles,
  setOpacity: () => setOpacity,
  setPrefixedStyle: () => setPrefixedStyle,
  setStyleFlag: () => setStyleFlag,
  sortCells: () => sortCells
});

// node_modules/@maxgraph/core/lib/view/cell/CellPath.js
var CellPath = class _CellPath {
  constructor() {
    throw new Error("Static class can't be instantiated!");
  }
  /**
   * Creates the cell path for the given cell. The cell path is a
   * concatenation of the indices of all ancestors on the (finite) path to
   * the root, eg. "0.0.0.1".
   *
   * @param cell Cell whose path should be returned.
   */
  static create(cell2) {
    let result2 = "";
    let parent2 = cell2.getParent();
    while (parent2) {
      const index = parent2.getIndex(cell2);
      result2 = index + _CellPath.PATH_SEPARATOR + result2;
      cell2 = parent2;
      parent2 = cell2.getParent();
    }
    const n = result2.length;
    if (n > 1) {
      result2 = result2.substring(0, n - 1);
    }
    return result2;
  }
  /**
   * Returns the path for the parent of the cell represented by the given
   * path. Returns null if the given path has no parent.
   *
   * @param path Path whose parent path should be returned.
   */
  static getParentPath(path) {
    const index = path.lastIndexOf(_CellPath.PATH_SEPARATOR);
    if (index >= 0) {
      return path.substring(0, index);
    }
    if (path.length > 0) {
      return "";
    }
    return null;
  }
  /**
   * Returns the cell for the specified cell path using the given root as the
   * root of the path.
   *
   * @param root Root cell of the path to be resolved.
   * @param path String that defines the path.
   */
  static resolve(root, path) {
    let parent2 = root;
    const tokens = path.split(_CellPath.PATH_SEPARATOR);
    for (let i2 = 0; i2 < tokens.length; i2 += 1) {
      parent2 = parent2.getChildAt(parseInt(tokens[i2]));
    }
    return parent2;
  }
  /**
   * Compares the given cell paths and returns -1 if p1 is smaller, 0 if
   * p1 is equal and 1 if p1 is greater than p2.
   */
  static compare(p1, p2) {
    const min = Math.min(p1.length, p2.length);
    let comp = 0;
    for (let i2 = 0; i2 < min; i2 += 1) {
      if (p1[i2] !== p2[i2]) {
        if (p1[i2].length === 0 || p2[i2].length === 0) {
          comp = p1[i2] === p2[i2] ? 0 : p1[i2] > p2[i2] ? 1 : -1;
        } else {
          const t1 = parseInt(p1[i2]);
          const t2 = parseInt(p2[i2]);
          comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;
        }
        break;
      }
    }
    if (comp === 0) {
      const t1 = p1.length;
      const t2 = p2.length;
      if (t1 !== t2) {
        comp = t1 > t2 ? 1 : -1;
      }
    }
    return comp;
  }
};
CellPath.PATH_SEPARATOR = ".";
var CellPath_default = CellPath;

// node_modules/@maxgraph/core/lib/util/styleUtils.js
var removeCursors = (element) => {
  if (element.style) {
    element.style.cursor = "";
  }
  const children = element.children;
  if (children) {
    const childCount2 = children.length;
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      removeCursors(children[i2]);
    }
  }
};
var getCurrentStyle = (element) => {
  return !element || element.toString() === "[object ShadowRoot]" ? null : window.getComputedStyle(element, "");
};
var parseCssNumber = (value2) => {
  if (value2 === "thin") {
    value2 = "2";
  } else if (value2 === "medium") {
    value2 = "4";
  } else if (value2 === "thick") {
    value2 = "6";
  }
  let n = parseFloat(value2);
  if (Number.isNaN(n)) {
    n = 0;
  }
  return n;
};
var setPrefixedStyle = (style2, name2, value2) => {
  let prefix = null;
  if (Client_default.IS_SF || Client_default.IS_GC) {
    prefix = "Webkit";
  } else if (Client_default.IS_MT) {
    prefix = "Moz";
  }
  style2.setProperty(name2, value2);
  if (prefix !== null && name2.length > 0) {
    name2 = prefix + name2.substring(0, 1).toUpperCase() + name2.substring(1);
    style2.setProperty(name2, value2);
  }
};
var hasScrollbars = (node2) => {
  const style2 = getCurrentStyle(node2);
  return !!style2 && (style2.overflow === "scroll" || style2.overflow === "auto");
};
var getDocumentSize = () => {
  const b = document.body;
  const d = document.documentElement;
  try {
    return new Rectangle_default(0, 0, b.clientWidth ?? d.clientWidth, Math.max(b.clientHeight ?? 0, d.clientHeight));
  } catch (e) {
    return new Rectangle_default();
  }
};
var fit = (node2) => {
  const ds = getDocumentSize();
  const left = node2.offsetLeft;
  const width = node2.offsetWidth;
  const offset = getDocumentScrollOrigin(node2.ownerDocument);
  const sl = offset.x;
  const st = offset.y;
  const right = sl + ds.width;
  if (left + width > right) {
    node2.style.left = `${Math.max(sl, right - width)}px`;
  }
  const top = node2.offsetTop;
  const height = node2.offsetHeight;
  const bottom = st + ds.height;
  if (top + height > bottom) {
    node2.style.top = `${Math.max(st, bottom - height)}px`;
  }
};
var getOffset = (container, scrollOffset = false) => {
  let offsetLeft = 0;
  let offsetTop = 0;
  let fixed = false;
  let node2 = container;
  const b = document.body;
  const d = document.documentElement;
  while (node2 != null && node2 != b && node2 != d && !fixed) {
    const style2 = getCurrentStyle(node2);
    if (style2 != null) {
      fixed = fixed || style2.position == "fixed";
    }
    node2 = node2.parentNode;
  }
  if (!scrollOffset && !fixed) {
    const offset = getDocumentScrollOrigin(container.ownerDocument);
    offsetLeft += offset.x;
    offsetTop += offset.y;
  }
  const r = container.getBoundingClientRect();
  if (r != null) {
    offsetLeft += r.left;
    offsetTop += r.top;
  }
  return new Point_default(offsetLeft, offsetTop);
};
var getDocumentScrollOrigin = (doc) => {
  const wnd = doc.defaultView || doc.parentWindow;
  const x = wnd != null && window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;
  const y = wnd != null && window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
  return new Point_default(x, y);
};
var getScrollOrigin = (node2 = null, includeAncestors = false, includeDocument = true) => {
  const doc = node2 != null ? node2.ownerDocument : document;
  const b = doc.body;
  const d = doc.documentElement;
  const result2 = new Point_default();
  let fixed = false;
  while (node2 != null && node2 != b && node2 != d) {
    if (!Number.isNaN(node2.scrollLeft) && !Number.isNaN(node2.scrollTop)) {
      result2.x += node2.scrollLeft;
      result2.y += node2.scrollTop;
    }
    const style2 = getCurrentStyle(node2);
    if (style2 != null) {
      fixed = fixed || style2.position == "fixed";
    }
    node2 = includeAncestors ? node2.parentNode : null;
  }
  if (!fixed && includeDocument) {
    const origin = getDocumentScrollOrigin(doc);
    result2.x += origin.x;
    result2.y += origin.y;
  }
  return result2;
};
var convertPoint = (container, x, y) => {
  const origin = getScrollOrigin(container, false);
  const offset = getOffset(container);
  offset.x -= origin.x;
  offset.y -= origin.y;
  return new Point_default(x - offset.x, y - offset.y);
};
var setCellStyles = (model2, cells, key2, value2) => {
  if (cells.length > 0) {
    model2.batchUpdate(() => {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const cell2 = cells[i2];
        if (cell2) {
          const style2 = cell2.getClonedStyle();
          style2[key2] = value2;
          model2.setStyle(cell2, style2);
        }
      }
    });
  }
};
var setCellStyleFlags = (model2, cells, key2, flag, value2) => {
  if (cells.length > 0) {
    model2.batchUpdate(() => {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const cell2 = cells[i2];
        if (cell2) {
          const style2 = setStyleFlag(cell2.getClonedStyle(), key2, flag, value2);
          model2.setStyle(cell2, style2);
        }
      }
    });
  }
};
var setStyleFlag = (style2, key2, flag, value2) => {
  const v = style2[key2];
  if (v === void 0) {
    style2[key2] = value2 === void 0 || value2 ? flag : 0;
  } else {
    if (value2 === void 0) {
      style2[key2] = v ^ flag;
    } else if (value2) {
      style2[key2] = v | flag;
    } else {
      style2[key2] = v & ~flag;
    }
  }
  return style2;
};
var setOpacity = (node2, value2) => {
  node2.style.opacity = String(value2 / 100);
};
var matchBinaryMask = (value2, mask) => {
  return (value2 & mask) === mask;
};
var getSizeForString = (text2, fontSize = DEFAULT_FONTSIZE, fontFamily = DEFAULT_FONTFAMILY, textWidth = null, fontStyle = null) => {
  const div = document.createElement("div");
  div.style.fontFamily = fontFamily;
  div.style.fontSize = `${Math.round(fontSize)}px`;
  div.style.lineHeight = `${Math.round(fontSize * LINE_HEIGHT)}px`;
  if (fontStyle !== null) {
    matchBinaryMask(fontStyle, FONT.BOLD) && (div.style.fontWeight = "bold");
    matchBinaryMask(fontStyle, FONT.ITALIC) && (div.style.fontWeight = "italic");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (div.style.textDecoration = txtDecor.join(" "));
  }
  div.style.position = "absolute";
  div.style.visibility = "hidden";
  div.style.display = "inline-block";
  if (textWidth !== null) {
    div.style.width = `${textWidth}px`;
    div.style.whiteSpace = "normal";
  } else {
    div.style.whiteSpace = "nowrap";
  }
  div.innerHTML = text2;
  document.body.appendChild(div);
  const size = new Rectangle_default(0, 0, div.offsetWidth, div.offsetHeight);
  document.body.removeChild(div);
  return size;
};
var sortCells = (cells, ascending = true) => {
  const lookup = new Dictionary_default();
  cells.sort((o1, o2) => {
    let p1 = lookup.get(o1);
    if (p1 == null) {
      p1 = CellPath_default.create(o1).split(CellPath_default.PATH_SEPARATOR);
      lookup.put(o1, p1);
    }
    let p2 = lookup.get(o2);
    if (p2 == null) {
      p2 = CellPath_default.create(o2).split(CellPath_default.PATH_SEPARATOR);
      lookup.put(o2, p2);
    }
    const comp = CellPath_default.compare(p1, p2);
    return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;
  });
  return cells;
};
var getAlignmentAsPoint = (align, valign) => {
  let dx = -0.5;
  let dy = -0.5;
  if (align === ALIGN.LEFT) {
    dx = 0;
  } else if (align === ALIGN.RIGHT) {
    dx = -1;
  }
  if (valign === ALIGN.TOP) {
    dy = 0;
  } else if (valign === ALIGN.BOTTOM) {
    dy = -1;
  }
  return new Point_default(dx, dy);
};

// node_modules/@maxgraph/core/lib/util/UrlConverter.js
var UrlConverter = class {
  constructor() {
    this.enabled = true;
    this.baseUrl = null;
    this.baseDomain = null;
  }
  /**
   * Private helper function to update the base URL.
   */
  updateBaseUrl() {
    this.baseDomain = `${location.protocol}//${location.host}`;
    this.baseUrl = this.baseDomain + location.pathname;
    const tmp2 = this.baseUrl.lastIndexOf("/");
    if (tmp2 > 0) {
      this.baseUrl = this.baseUrl.substring(0, tmp2 + 1);
    }
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns <baseUrl>.
   */
  getBaseUrl() {
    return this.baseUrl;
  }
  /**
   * Sets <baseUrl>.
   */
  setBaseUrl(value2) {
    this.baseUrl = value2;
  }
  /**
   * Returns <baseDomain>.
   */
  getBaseDomain() {
    return this.baseDomain;
  }
  /**
   * Sets <baseDomain>.
   */
  setBaseDomain(value2) {
    this.baseDomain = value2;
  }
  /**
   * Returns true if the given URL is relative.
   */
  isRelativeUrl(url) {
    return url && url.substring(0, 2) !== "//" && url.substring(0, 7) !== "http://" && url.substring(0, 8) !== "https://" && url.substring(0, 10) !== "data:image" && url.substring(0, 7) !== "file://";
  }
  /**
   * Converts the given URL to an absolute URL with protol and domain.
   * Relative URLs are first converted to absolute URLs.
   */
  convert(url) {
    if (this.isEnabled() && this.isRelativeUrl(url)) {
      if (!this.getBaseUrl()) {
        this.updateBaseUrl();
      }
      if (url.charAt(0) === "/") {
        url = this.getBaseDomain() + url;
      } else {
        url = this.getBaseUrl() + url;
      }
    }
    return url;
  }
};
var UrlConverter_default = UrlConverter;

// node_modules/@maxgraph/core/lib/util/cloneUtils.js
var cloneUtils_exports = {};
__export(cloneUtils_exports, {
  clone: () => clone
});
var clone = function _clone(obj2, transients = null, shallow = false) {
  shallow = shallow != null ? shallow : false;
  let clone2 = null;
  if (obj2 != null && typeof obj2.constructor === "function") {
    clone2 = new obj2.constructor();
    for (const i2 in obj2) {
      if (i2 != ObjectIdentity_default.FIELD_NAME && (transients == null || transients.indexOf(i2) < 0)) {
        if (!shallow && typeof obj2[i2] === "object") {
          clone2[i2] = _clone(obj2[i2]);
        } else {
          clone2[i2] = obj2[i2];
        }
      }
    }
  }
  return clone2;
};

// node_modules/@maxgraph/core/lib/view/canvas/AbstractCanvas2D.js
var AbstractCanvas2D = class {
  constructor() {
    this.state = this.createState();
    this.states = [];
    this.path = [];
    this.rotateHtml = true;
    this.lastX = 0;
    this.lastY = 0;
    this.moveOp = "M";
    this.lineOp = "L";
    this.quadOp = "Q";
    this.curveOp = "C";
    this.closeOp = "Z";
    this.pointerEvents = false;
    this.pointerEventsValue = null;
    this.addOp = (op, ...args) => {
      this.path.push(op);
      if (args.length > 1) {
        const s = this.state;
        for (let i2 = 1; i2 < args.length; i2 += 2) {
          this.lastX = args[i2 - 1];
          this.lastY = args[i2];
          this.path.push(this.format((this.lastX + s.dx) * s.scale));
          this.path.push(this.format((this.lastY + s.dy) * s.scale));
        }
      }
    };
    this.converter = this.createUrlConverter();
    this.reset();
  }
  /**
   * Create a new <UrlConverter> and returns it.
   */
  createUrlConverter() {
    return new UrlConverter_default();
  }
  /**
   * Resets the state of this canvas.
   */
  reset() {
    this.state = this.createState();
    this.states = [];
  }
  /**
   * Creates the state of the this canvas.
   */
  createState() {
    return {
      dx: 0,
      dy: 0,
      scale: 1,
      alpha: 1,
      fillAlpha: 1,
      strokeAlpha: 1,
      fillColor: NONE,
      gradientFillAlpha: 1,
      gradientColor: NONE,
      gradientAlpha: 1,
      gradientDirection: DIRECTION.EAST,
      strokeColor: NONE,
      strokeWidth: 1,
      dashed: false,
      dashPattern: "3 3",
      fixDash: false,
      lineCap: "flat",
      lineJoin: "miter",
      miterLimit: 10,
      fontColor: "#000000",
      fontBackgroundColor: NONE,
      fontBorderColor: NONE,
      fontSize: DEFAULT_FONTSIZE,
      fontFamily: DEFAULT_FONTFAMILY,
      fontStyle: 0,
      shadow: false,
      shadowColor: SHADOWCOLOR,
      shadowAlpha: SHADOW_OPACITY,
      shadowDx: SHADOW_OFFSET_X,
      shadowDy: SHADOW_OFFSET_Y,
      rotation: 0,
      rotationCx: 0,
      rotationCy: 0
    };
  }
  /**
   * Rounds all numbers to integers.
   */
  format(value2) {
    return Math.round(value2);
  }
  /**
   * Rotates the given point and returns the result as an {@link Point}.
   */
  rotatePoint(x, y, theta, cx, cy) {
    const rad = theta * (Math.PI / 180);
    return getRotatedPoint(new Point_default(x, y), Math.cos(rad), Math.sin(rad), new Point_default(cx, cy));
  }
  /**
   * Saves the current state.
   */
  save() {
    this.states.push(this.state);
    this.state = clone(this.state);
  }
  /**
   * Restores the current state.
   */
  restore() {
    const state2 = this.states.pop();
    if (state2)
      this.state = state2;
  }
  /**
   * Sets the current link. Hook for subclassers.
   */
  setLink(link2) {
  }
  /**
   * Scales the current state.
   */
  scale(value2) {
    this.state.scale *= value2;
    if (this.state.strokeWidth !== null)
      this.state.strokeWidth *= value2;
  }
  /**
   * Translates the current state.
   */
  translate(dx, dy) {
    this.state.dx += dx;
    this.state.dy += dy;
  }
  /**
   * Rotates the current state.
   */
  rotate(theta, flipH, flipV, cx, cy) {
  }
  /**
   * Sets the current alpha.
   */
  setAlpha(value2) {
    this.state.alpha = value2;
  }
  /**
   * Sets the current solid fill alpha.
   */
  setFillAlpha(value2) {
    this.state.fillAlpha = value2;
  }
  /**
   * Sets the current stroke alpha.
   */
  setStrokeAlpha(value2) {
    this.state.strokeAlpha = value2;
  }
  /**
   * Sets the current fill color.
   */
  setFillColor(value2) {
    this.state.fillColor = value2 ?? NONE;
    this.state.gradientColor = NONE;
  }
  /**
   * Sets the current gradient.
   */
  setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {
    const s = this.state;
    s.fillColor = color1;
    s.gradientFillAlpha = alpha1;
    s.gradientColor = color2;
    s.gradientAlpha = alpha2;
    s.gradientDirection = direction;
  }
  /**
   * Sets the current stroke color.
   */
  setStrokeColor(value2) {
    this.state.strokeColor = value2 ?? NONE;
  }
  /**
   * Sets the current stroke width.
   */
  setStrokeWidth(value2) {
    this.state.strokeWidth = value2;
  }
  /**
   * Enables or disables dashed lines.
   */
  setDashed(value2, fixDash = false) {
    this.state.dashed = value2;
    this.state.fixDash = fixDash;
  }
  /**
   * Sets the current dash pattern.
   */
  setDashPattern(value2) {
    this.state.dashPattern = value2;
  }
  /**
   * Sets the current line cap.
   */
  setLineCap(value2) {
    this.state.lineCap = value2;
  }
  /**
   * Sets the current line join.
   */
  setLineJoin(value2) {
    this.state.lineJoin = value2;
  }
  /**
   * Sets the current miter limit.
   */
  setMiterLimit(value2) {
    this.state.miterLimit = value2;
  }
  /**
   * Sets the current font color.
   */
  setFontColor(value2) {
    this.state.fontColor = value2 ?? NONE;
  }
  /**
   * Sets the current font background color.
   */
  setFontBackgroundColor(value2) {
    this.state.fontBackgroundColor = value2 ?? NONE;
  }
  /**
   * Sets the current font border color.
   */
  setFontBorderColor(value2) {
    this.state.fontBorderColor = value2 ?? NONE;
  }
  /**
   * Sets the current font size.
   */
  setFontSize(value2) {
    this.state.fontSize = value2;
  }
  /**
   * Sets the current font family.
   */
  setFontFamily(value2) {
    this.state.fontFamily = value2;
  }
  /**
   * Sets the current font style.
   */
  setFontStyle(value2) {
    this.state.fontStyle = value2;
  }
  /**
   * Enables or disables and configures the current shadow.
   */
  setShadow(enabled2) {
    this.state.shadow = enabled2;
  }
  /**
   * Enables or disables and configures the current shadow.
   */
  setShadowColor(value2) {
    this.state.shadowColor = value2 ?? NONE;
  }
  /**
   * Enables or disables and configures the current shadow.
   */
  setShadowAlpha(value2) {
    this.state.shadowAlpha = value2;
  }
  /**
   * Enables or disables and configures the current shadow.
   */
  setShadowOffset(dx, dy) {
    this.state.shadowDx = dx;
    this.state.shadowDy = dy;
  }
  /**
   * Starts a new path.
   */
  begin() {
    this.lastX = 0;
    this.lastY = 0;
    this.path = [];
  }
  /**
   *  Moves the current path the given coordinates.
   */
  moveTo(x, y) {
    this.addOp(this.moveOp, x, y);
  }
  /**
   * Draws a line to the given coordinates. Uses moveTo with the op argument.
   */
  lineTo(x, y) {
    this.addOp(this.lineOp, x, y);
  }
  /**
   * Adds a quadratic curve to the current path.
   */
  quadTo(x1, y1, x2, y2) {
    this.addOp(this.quadOp, x1, y1, x2, y2);
  }
  /**
   * Adds a bezier curve to the current path.
   */
  curveTo(x1, y1, x2, y2, x3, y3) {
    this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);
  }
  /**
   * Adds the given arc to the current path. This is a synthetic operation that
   * is broken down into curves.
   * @param rx: The x distance between the current position
   *            and the center of the ellipse around which to arc
   * @param ry: The y distance between the current position
   *            and the center of the ellipse around which to arc
   * @param x: The x position of the end point of the arc
   * @param y: The y position of the end point of the arc
   */
  arcTo(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
    const curves = arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);
    if (curves != null) {
      for (let i2 = 0; i2 < curves.length; i2 += 6) {
        this.curveTo(curves[i2], curves[i2 + 1], curves[i2 + 2], curves[i2 + 3], curves[i2 + 4], curves[i2 + 5]);
      }
    }
  }
  /**
   * Closes the current path.
   */
  close(x1, y1, x2, y2, x3, y3) {
    this.addOp(this.closeOp);
  }
};
var AbstractCanvas2D_default = AbstractCanvas2D;

// node_modules/@maxgraph/core/lib/util/xmlUtils.js
var xmlUtils_exports = {};
__export(xmlUtils_exports, {
  createXmlDocument: () => createXmlDocument2,
  findNode: () => findNode,
  getPrettyXml: () => getPrettyXml,
  getViewXml: () => getViewXml,
  getXml: () => getXml,
  parseXml: () => parseXml
});

// node_modules/@maxgraph/core/lib/view/cell/TemporaryCellStates.js
var TemporaryCellStates = class {
  constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null) {
    this.view = view;
    this.oldValidateCellState = view.validateCellState;
    this.oldBounds = view.getGraphBounds();
    this.oldStates = view.getStates();
    this.oldScale = view.getScale();
    this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;
    if (getLinkForCellState != null) {
      view.graph.cellRenderer.doRedrawShape = (state2) => {
        const shape2 = state2 == null ? void 0 : state2.shape;
        const oldPaint = shape2.paint;
        shape2.paint = (c) => {
          const link2 = getLinkForCellState(state2);
          if (link2 != null) {
            c.setLink(link2);
          }
          oldPaint.apply(shape2, [c]);
          if (link2 != null) {
            c.setLink(null);
          }
        };
        this.oldDoRedrawShape.apply(view.graph.cellRenderer, [state2]);
        shape2.paint = oldPaint;
      };
    }
    view.validateCellState = (cell2, recurse) => {
      if (cell2 == null || isCellVisibleFn == null || isCellVisibleFn(cell2)) {
        return this.oldValidateCellState.apply(view, [cell2, recurse]);
      }
      return null;
    };
    view.setStates(new Dictionary_default());
    view.setScale(scale);
    view.resetValidationState();
    let bbox = null;
    for (const cell2 of cells) {
      const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell2)));
      if (bbox == null) {
        bbox = bounds;
      } else {
        bbox.add(bounds);
      }
    }
    view.setGraphBounds(bbox || new Rectangle_default());
  }
  destroy() {
    const view = this.view;
    view.setScale(this.oldScale);
    view.setStates(this.oldStates);
    view.setGraphBounds(this.oldBounds);
    view.validateCellState = this.oldValidateCellState;
    view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;
  }
};
var TemporaryCellStates_default = TemporaryCellStates;

// node_modules/@maxgraph/core/lib/util/arrayUtils.js
var remove = (obj2, array) => {
  let result2 = null;
  if (typeof array === "object") {
    let index = array.indexOf(obj2);
    while (index >= 0) {
      array.splice(index, 1);
      result2 = obj2;
      index = array.indexOf(obj2);
    }
  }
  for (const key2 in array) {
    if (array[key2] == obj2) {
      delete array[key2];
      result2 = obj2;
    }
  }
  return result2;
};
var equalPoints = (a, b) => {
  if (!a && b || a && !b || a && b && a.length != b.length) {
    return false;
  }
  if (a && b) {
    for (let i2 = 0; i2 < a.length; i2 += 1) {
      const p = a[i2];
      if (!p || p && !p.equals(b[i2]))
        return false;
    }
  }
  return true;
};
var equalEntries = (a, b) => {
  let count = 0;
  if (!a && b || a && !b || a && b && a.length != b.length) {
    return false;
  }
  if (a && b) {
    for (const key2 in b) {
      count++;
    }
    for (const key2 in a) {
      count--;
      if ((!Number.isNaN(a[key2]) || !Number.isNaN(b[key2])) && a[key2] !== b[key2]) {
        return false;
      }
    }
  }
  return count === 0;
};
var removeDuplicates = (arr) => {
  const dict = new Dictionary_default();
  const result2 = [];
  for (let i2 = 0; i2 < arr.length; i2 += 1) {
    if (!dict.get(arr[i2])) {
      result2.push(arr[i2]);
      dict.put(arr[i2], true);
    }
  }
  return result2;
};

// node_modules/@maxgraph/core/lib/view/geometry/Geometry.js
var Geometry = class extends Rectangle_default {
  constructor(x = 0, y = 0, width = 0, height = 0) {
    super(x, y, width, height);
    this.TRANSLATE_CONTROL_POINTS = true;
    this.alternateBounds = null;
    this.sourcePoint = null;
    this.targetPoint = null;
    this.points = null;
    this.offset = null;
    this.relative = false;
  }
  setRelative(isRelative) {
    this.relative = isRelative;
  }
  /**
   * Swaps the x, y, width and height with the values stored in
   * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as
   * a rectangle. This operation is carried-out in-place, that is, using the
   * existing geometry instance. If this operation is called during a graph
   * model transactional change, then the geometry should be cloned before
   * calling this method and setting the geometry of the cell using
   * {@link GraphDataModel.setGeometry}.
   */
  swap() {
    if (this.alternateBounds) {
      const old = new Rectangle_default(this.x, this.y, this.width, this.height);
      this.x = this.alternateBounds.x;
      this.y = this.alternateBounds.y;
      this.width = this.alternateBounds.width;
      this.height = this.alternateBounds.height;
      this.alternateBounds = old;
    }
  }
  /**
   * Returns the {@link Point} representing the source or target point of this
   * edge. This is only used if the edge has no source or target vertex.
   *
   * @param {Boolean} isSource that specifies if the source or target point should be returned.
   */
  getTerminalPoint(isSource) {
    return isSource ? this.sourcePoint : this.targetPoint;
  }
  /**
   * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and
   * returns the new point.
   *
   * @param {Point} point to be used as the new source or target point.
   * @param {Boolean} isSource that specifies if the source or target point should be set.
   */
  setTerminalPoint(point, isSource) {
    if (isSource) {
      this.sourcePoint = point;
    } else {
      this.targetPoint = point;
    }
    return point;
  }
  /**
   * Rotates the geometry by the given angle around the given center. That is,
   * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all
   * {@link points} are translated by the given amount. {@link x} and {@link y} are only
   * translated if {@link relative} is false.
   *
   * @param {Number} angle that specifies the rotation angle in degrees.
   * @param {Point} cx   that specifies the center of the rotation.
   */
  rotate(angle, cx) {
    const rad = toRadians(angle);
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    if (!this.relative) {
      const ct = new Point_default(this.getCenterX(), this.getCenterY());
      const pt = getRotatedPoint(ct, cos, sin, cx);
      this.x = Math.round(pt.x - this.width / 2);
      this.y = Math.round(pt.y - this.height / 2);
    }
    if (this.sourcePoint) {
      const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);
      this.sourcePoint.x = Math.round(pt.x);
      this.sourcePoint.y = Math.round(pt.y);
    }
    if (this.targetPoint) {
      const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);
      this.targetPoint.x = Math.round(pt.x);
      this.targetPoint.y = Math.round(pt.y);
    }
    if (this.points) {
      for (let i2 = 0; i2 < this.points.length; i2 += 1) {
        if (this.points[i2]) {
          const pt = getRotatedPoint(this.points[i2], cos, sin, cx);
          this.points[i2].x = Math.round(pt.x);
          this.points[i2].y = Math.round(pt.y);
        }
      }
    }
  }
  /**
   * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the
   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated
   * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.
   * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by
   * this function.
   *
   * @param {Number} dx that specifies the x-coordinate of the translation.
   * @param {Number} dy that specifies the y-coordinate of the translation.
   */
  translate(dx, dy) {
    if (!this.relative) {
      this.x += dx;
      this.y += dy;
    }
    if (this.sourcePoint) {
      this.sourcePoint.x = this.sourcePoint.x + dx;
      this.sourcePoint.y = this.sourcePoint.y + dy;
    }
    if (this.targetPoint) {
      this.targetPoint.x = this.targetPoint.x + dx;
      this.targetPoint.y = this.targetPoint.y + dy;
    }
    if (this.TRANSLATE_CONTROL_POINTS && this.points) {
      for (let i2 = 0; i2 < this.points.length; i2 += 1) {
        if (this.points[i2]) {
          this.points[i2].x = this.points[i2].x + dx;
          this.points[i2].y = this.points[i2].y + dy;
        }
      }
    }
  }
  /**
   * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the
   * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled
   * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if
   * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value
   * is used to scale the width and the height.
   *
   * @param {Number} sx that specifies the horizontal scale factor.
   * @param {Number} sy that specifies the vertical scale factor.
   * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.
   */
  scale(sx, sy, fixedAspect) {
    if (this.sourcePoint) {
      this.sourcePoint.x = this.sourcePoint.x * sx;
      this.sourcePoint.y = this.sourcePoint.y * sy;
    }
    if (this.targetPoint) {
      this.targetPoint.x = this.targetPoint.x * sx;
      this.targetPoint.y = this.targetPoint.y * sy;
    }
    if (this.points) {
      for (let i2 = 0; i2 < this.points.length; i2 += 1) {
        if (this.points[i2]) {
          this.points[i2].x = this.points[i2].x * sx;
          this.points[i2].y = this.points[i2].y * sy;
        }
      }
    }
    if (!this.relative) {
      this.x *= sx;
      this.y *= sy;
      if (fixedAspect) {
        sy = sx = Math.min(sx, sy);
      }
      this.width *= sx;
      this.height *= sy;
    }
  }
  /**
   * Returns true if the given object equals this geometry.
   */
  equals(geom) {
    var _a2, _b, _c, _d;
    if (!geom)
      return false;
    return super.equals(geom) && this.relative === geom.relative && (this.sourcePoint === null && geom.sourcePoint === null || !!((_a2 = this.sourcePoint) == null ? void 0 : _a2.equals(geom.sourcePoint))) && (this.targetPoint === null && geom.targetPoint === null || !!((_b = this.targetPoint) == null ? void 0 : _b.equals(geom.targetPoint))) && equalPoints(this.points, geom.points) && (this.alternateBounds === null && geom.alternateBounds === null || !!((_c = this.alternateBounds) == null ? void 0 : _c.equals(geom.alternateBounds))) && (this.offset === null && geom.offset === null || !!((_d = this.offset) == null ? void 0 : _d.equals(geom.offset)));
  }
  clone() {
    return clone(this);
  }
};
var Geometry_default = Geometry;

// node_modules/@maxgraph/core/lib/util/MaxXmlRequest.js
var MaxXmlRequest = class {
  constructor(url, params = null, method = "POST", async = true, username = null, password = null) {
    this.binary = false;
    this.withCredentials = false;
    this.request = null;
    this.decodeSimulateValues = false;
    this.url = url;
    this.params = params;
    this.method = method || "POST";
    this.async = async;
    this.username = username;
    this.password = password;
  }
  /**
   * Returns {@link binary}.
   */
  isBinary() {
    return this.binary;
  }
  /**
   * Sets {@link binary}.
   *
   * @param value
   */
  setBinary(value2) {
    this.binary = value2;
  }
  /**
   * Returns the response as a string.
   */
  getText() {
    return this.request.responseText;
  }
  /**
   * Returns true if the response is ready.
   */
  isReady() {
    return this.request.readyState === 4;
  }
  /**
   * Returns the document element of the response XML document.
   */
  getDocumentElement() {
    const doc = this.getXml();
    if (doc != null) {
      return doc.documentElement;
    }
    return null;
  }
  /**
   * Returns the response as an XML document. Use {@link getDocumentElement} to get
   * the document element of the XML document.
   */
  getXml() {
    let xml = this.request.responseXML;
    if (xml == null || xml.documentElement == null) {
      xml = new DOMParser().parseFromString(this.request.responseText, "text/xml");
    }
    return xml;
  }
  /**
   * Returns the status as a number, eg. 404 for "Not found" or 200 for "OK".
   * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.
   */
  getStatus() {
    return this.request != null ? this.request.status : null;
  }
  /**
   * Creates and returns the inner {@link request} object.
   */
  create() {
    const req = new XMLHttpRequest();
    if (this.isBinary() && req.overrideMimeType) {
      req.overrideMimeType("text/plain; charset=x-user-defined");
    }
    return req;
  }
  /**
   * Send the <request> to the target URL using the specified functions to
   * process the response asychronously.
   *
   * Note: Due to technical limitations, onerror is currently ignored.
   *
   * @param onload Function to be invoked if a successful response was received.
   * @param onerror Function to be called on any error. Unused in this implementation, intended for overriden function.
   * @param timeout Optional timeout in ms before calling ontimeout.
   * @param ontimeout Optional function to execute on timeout.
   */
  send(onload = null, onerror = null, timeout = null, ontimeout = null) {
    this.request = this.create();
    if (this.request != null) {
      if (onload != null) {
        this.request.onreadystatechange = () => {
          if (this.isReady()) {
            onload(this);
            this.request.onreadystatechange = null;
          }
        };
      }
      this.request.open(this.method, this.url, this.async, this.username, this.password);
      this.setRequestHeaders(this.request, this.params);
      if (window.XMLHttpRequest && this.withCredentials) {
        this.request.withCredentials = "true";
      }
      if (window.XMLHttpRequest && timeout != null && ontimeout != null) {
        this.request.timeout = timeout;
        this.request.ontimeout = ontimeout;
      }
      this.request.send(this.params);
    }
  }
  /**
   * Sets the headers for the given request and parameters. This sets the
   * content-type to application/x-www-form-urlencoded if any params exist.
   *
   * @example
   * ```JavaScript
   * request.setRequestHeaders = function(request, params)
   * {
   *   if (params != null)
   *   {
   *     request.setRequestHeader('Content-Type',
   *             'multipart/form-data');
   *     request.setRequestHeader('Content-Length',
   *             params.length);
   *   }
   * };
   * ```
   *
   * Use the code above before calling {@link send} if you require a
   * multipart/form-data request.
   *
   * @param request
   * @param params
   */
  setRequestHeaders(request, params) {
    if (params != null) {
      request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
  }
  /**
   * Creates and posts a request to the given target URL using a dynamically
   * created form inside the given document.
   *
   * @param doc Document that contains the form element.
   * @param target Target to send the form result to.
   */
  simulate(doc, target2 = null) {
    doc = doc || document;
    let old = null;
    if (doc === document) {
      old = window.onbeforeunload;
      window.onbeforeunload = null;
    }
    const form = doc.createElement("form");
    form.setAttribute("method", this.method);
    form.setAttribute("action", this.url);
    if (target2 != null) {
      form.setAttribute("target", target2);
    }
    form.style.display = "none";
    form.style.visibility = "hidden";
    const params = this.params;
    const pars = params.indexOf("&") > 0 ? params.split("&") : params.split(" ");
    for (let i2 = 0; i2 < pars.length; i2 += 1) {
      const pos = pars[i2].indexOf("=");
      if (pos > 0) {
        const name2 = pars[i2].substring(0, pos);
        let value2 = pars[i2].substring(pos + 1);
        if (this.decodeSimulateValues) {
          value2 = decodeURIComponent(value2);
        }
        const textarea = doc.createElement("textarea");
        textarea.setAttribute("wrap", "off");
        textarea.setAttribute("name", name2);
        write(textarea, value2);
        form.appendChild(textarea);
      }
    }
    doc.body.appendChild(form);
    form.submit();
    if (form.parentNode != null) {
      form.parentNode.removeChild(form);
    }
    if (old != null) {
      window.onbeforeunload = old;
    }
  }
};
var load = (url) => {
  const req = new MaxXmlRequest(url, null, "GET", false);
  req.send();
  return req;
};
var get = (url, onload = null, onerror = null, binary = false, timeout = null, ontimeout = null, headers = null) => {
  const req = new MaxXmlRequest(url, null, "GET");
  const { setRequestHeaders } = req;
  if (headers) {
    req.setRequestHeaders = (request, params) => {
      setRequestHeaders.apply(void 0, [request, params]);
      for (const key2 in headers) {
        request.setRequestHeader(key2, headers[key2]);
      }
    };
  }
  if (binary != null) {
    req.setBinary(binary);
  }
  req.send(onload, onerror, timeout, ontimeout);
  return req;
};
var getAll = (urls, onload, onerror) => {
  let remain = urls.length;
  const result2 = [];
  let errors = 0;
  const err = () => {
    if (errors == 0 && onerror != null) {
      onerror();
    }
    errors++;
  };
  for (let i2 = 0; i2 < urls.length; i2 += 1) {
    ((url, index) => {
      get(url, (req) => {
        const status = req.getStatus();
        if (status < 200 || status > 299) {
          err();
        } else {
          result2[index] = req;
          remain--;
          if (remain == 0) {
            onload(result2);
          }
        }
      }, err);
    })(urls[i2], i2);
  }
  if (remain == 0) {
    onload(result2);
  }
};
var post = (url, params = null, onload, onerror = null) => {
  return new MaxXmlRequest(url, params).send(onload, onerror);
};
var submit = (url, params, doc, target2) => {
  return new MaxXmlRequest(url, params).simulate(doc, target2);
};
var MaxXmlRequest_default = MaxXmlRequest;

// node_modules/@maxgraph/core/lib/serialization/ObjectCodec.js
var ObjectCodec = class _ObjectCodec {
  constructor(template2, exclude = [], idrefs = [], mapping = {}) {
    this.template = template2;
    this.exclude = exclude;
    this.idrefs = idrefs;
    this.mapping = mapping;
    this.reverse = {};
    for (const i2 in this.mapping) {
      this.reverse[this.mapping[i2]] = i2;
    }
  }
  /**
   * Returns the name used for the node names and lookup of the codec when
   * classes are encoded and nodes are decoded. For classes to work with
   * this the codec registry automatically adds an alias for the classname
   * if that is different from what this returns.
   *
   * The default implementation returns the classname of the template class if no name is set.
   */
  getName() {
    return this.name ?? this.template.constructor.name;
  }
  setName(name2) {
    this.name = name2;
  }
  /**
   * Returns a new instance of the template for this codec.
   */
  cloneTemplate() {
    return new this.template.constructor();
  }
  /**
   * Returns the field name for the given attribute name.
   * Looks up the value in the {@link reverse} mapping or returns
   * the input if there is no reverse mapping for the
   * given name.
   */
  getFieldName(attributename) {
    if (attributename != null) {
      const mapped = this.reverse[attributename];
      if (mapped != null) {
        attributename = mapped;
      }
    }
    return attributename;
  }
  /**
   * Returns the attribute name for the given field name.
   * Looks up the value in the {@link mapping} or returns
   * the input if there is no mapping for the
   * given name.
   */
  getAttributeName(fieldname2) {
    if (fieldname2 != null) {
      const mapped = this.mapping[fieldname2];
      if (mapped != null) {
        fieldname2 = mapped;
      }
    }
    return fieldname2;
  }
  /**
   * Returns true if the given attribute is to be ignored by the codec. This
   * implementation returns true if the given field name is in {@link exclude} or
   * if the field name equals {@link ObjectIdentity.FIELD_NAME}.
   *
   * @param obj Object instance that contains the field.
   * @param attr Fieldname of the field.
   * @param value Value of the field.
   * @param write Boolean indicating if the field is being encoded or decoded.
   * Write is true if the field is being encoded, else it is being decoded.
   */
  isExcluded(obj2, attr, value2, write2) {
    return attr == ObjectIdentity_default.FIELD_NAME || this.exclude.indexOf(attr) >= 0;
  }
  /**
   * Returns true if the given field name is to be treated
   * as a textual reference (ID). This implementation returns
   * true if the given field name is in {@link idrefs}.
   *
   * @param obj Object instance that contains the field.
   * @param attr Field name of the field.
   * @param value Value of the field.
   * @param write Boolean indicating if the field is being encoded or decoded.
   * Write is true if the field is being encoded, else it is being decoded.
   */
  isReference(obj2, attr, value2, write2) {
    return this.idrefs.indexOf(attr) >= 0;
  }
  /**
   * Encodes the specified object and returns a node
   * representing then given object. Calls {@link beforeEncode}
   * after creating the node and {@link afterEncode} with the
   * resulting node after processing.
   *
   * Enc is a reference to the calling encoder. It is used
   * to encode complex objects and create references.
   *
   * This implementation encodes all variables of an
   * object according to the following rules:
   *
   * - If the variable name is in {@link exclude} then it is ignored.
   * - If the variable name is in {@link idrefs} then {@link Codec.getId}
   * is used to replace the object with its ID.
   * - The variable name is mapped using {@link mapping}.
   * - If obj is an array and the variable name is numeric
   * (ie. an index) then it is not encoded.
   * - If the value is an object, then the codec is used to
   * create a child node with the variable name encoded into
   * the "as" attribute.
   * - Else, if {@link encodeDefaults} is true or the value differs
   * from the template value, then ...
   * - ... if obj is not an array, then the value is mapped to
   * an attribute.
   * - ... else if obj is an array, the value is mapped to an
   * add child with a value attribute or a text child node,
   * if the value is a function.
   *
   * If no ID exists for a variable in {@link idrefs} or if an object
   * cannot be encoded, a warning is issued using {@link GlobalConfig.logger}.
   *
   * Returns the resulting XML node that represents the given
   * object.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   */
  encode(enc, obj2) {
    const node2 = enc.document.createElement(this.getName());
    obj2 = this.beforeEncode(enc, obj2, node2);
    this.encodeObject(enc, obj2, node2);
    return this.afterEncode(enc, obj2, node2);
  }
  /**
   * Encodes the value of each member in then given obj into the given node using
   * {@link encodeValue}.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node that contains the encoded object.
   */
  encodeObject(enc, obj2, node2) {
    enc.setAttribute(node2, "id", enc.getId(obj2));
    for (const i2 in obj2) {
      let name2 = i2;
      const value2 = obj2[name2];
      if (value2 != null && !this.isExcluded(obj2, name2, value2, true)) {
        if (isInteger(name2)) {
          name2 = null;
        }
        this.encodeValue(enc, obj2, name2, value2, node2);
      }
    }
  }
  /**
   * Converts the given value according to the mappings
   * and id-refs in this codec and uses {@link writeAttribute}
   * to write the attribute into the given node.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object whose property is going to be encoded.
   * @param name XML node that contains the encoded object.
   * @param value Value of the property to be encoded.
   * @param node XML node that contains the encoded object.
   */
  encodeValue(enc, obj2, name2, value2, node2) {
    if (value2 != null) {
      if (name2 != null && this.isReference(obj2, name2, value2, true)) {
        const tmp2 = enc.getId(value2);
        if (tmp2 == null) {
          GlobalConfig.logger.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name2}=${value2}`);
          return;
        }
        value2 = tmp2;
      }
      if (name2 == null || enc.encodeDefaults || this.template[name2] != value2) {
        name2 = this.getAttributeName(name2);
        this.writeAttribute(enc, obj2, name2, value2, node2);
      }
    }
  }
  /**
   * Writes the given value into node using {@link writePrimitiveAttribute}
   * or {@link writeComplexAttribute} depending on the type of the value.
   */
  writeAttribute(enc, obj2, name2, value2, node2) {
    if (typeof value2 !== "object") {
      this.writePrimitiveAttribute(enc, obj2, name2, value2, node2);
    } else {
      this.writeComplexAttribute(enc, obj2, name2, value2, node2);
    }
  }
  /**
   * Writes the given value as an attribute of the given node.
   */
  writePrimitiveAttribute(enc, obj2, name2, value2, node2) {
    value2 = this.convertAttributeToXml(enc, obj2, name2, value2, node2);
    if (name2 == null) {
      const child2 = enc.document.createElement("add");
      if (typeof value2 === "function") {
        child2.appendChild(enc.document.createTextNode(value2));
      } else {
        enc.setAttribute(child2, "value", value2);
      }
      node2.appendChild(child2);
    } else if (typeof value2 !== "function") {
      enc.setAttribute(node2, name2, value2);
    }
  }
  /**
   * Writes the given value as a child node of the given node.
   */
  writeComplexAttribute(enc, obj2, name2, value2, node2) {
    const child2 = enc.encode(value2);
    if (child2 != null) {
      if (name2 != null) {
        child2.setAttribute("as", name2);
      }
      node2.appendChild(child2);
    } else {
      GlobalConfig.logger.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name2}: ${value2}`);
    }
  }
  /**
   * Converts true to "1" and false to "0" is {@link isBooleanAttribute} returns true.
   * All other values are not converted.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Objec to convert the attribute for.
   * @param name Name of the attribute to be converted.
   * @param value Value to be converted.
   */
  convertAttributeToXml(enc, obj2, name2, value2, node2) {
    if (this.isBooleanAttribute(enc, obj2, name2, value2)) {
      value2 = value2 == true ? "1" : "0";
    }
    return value2;
  }
  /**
   * Returns true if the given object attribute is a boolean value.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to convert the attribute for.
   * @param name Name of the attribute to be converted.
   * @param value Value of the attribute to be converted.
   */
  isBooleanAttribute(enc, obj2, name2, value2) {
    return typeof value2.length === "undefined" && (value2 == true || value2 == false);
  }
  /**
   * Converts booleans and numeric values to the respective types. Values are
   * numeric if {@link isNumericAttribute} returns true.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be converted.
   * @param obj Objec to convert the attribute for.
   */
  convertAttributeFromXml(dec2, attr, obj2) {
    let { value: value2 } = attr;
    if (this.isNumericAttribute(dec2, attr, obj2)) {
      value2 = parseFloat(value2);
      if (Number.isNaN(value2) || !Number.isFinite(value2)) {
        value2 = 0;
      }
    }
    return value2;
  }
  /**
   * Returns true if the given XML attribute is or should be a numeric value.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be converted.
   * @param obj Object to convert the attribute for.
   */
  isNumericAttribute(dec2, attr, obj2) {
    return obj2.constructor === Geometry_default && (attr.name === "x" || attr.name === "y" || attr.name === "width" || attr.name === "height") || obj2.constructor === Point_default && (attr.name === "x" || attr.name === "y") || isNumeric(attr.value);
  }
  /**
   * Hook for subclassers to pre-process the object before
   * encoding. This returns the input object. The return
   * value of this function is used in {@link encode} to perform
   * the default encoding into the given node.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node to encode the object into.
   */
  beforeEncode(enc, obj2, node2) {
    return obj2;
  }
  /**
   * Hook for subclassers to post-process the node
   * for the given object after encoding and return the
   * post-processed node. This implementation returns
   * the input node. The return value of this method
   * is returned to the encoder from {@link encode}.
   *
   * @param enc {@link Codec} that controls the encoding process.
   * @param obj Object to be encoded.
   * @param node XML node that represents the default encoding.
   */
  afterEncode(enc, obj2, node2) {
    return node2;
  }
  /**
   * Parses the given node into the object or returns a new object
   * representing the given node.
   *
   * Dec is a reference to the calling decoder. It is used to decode
   * complex objects and resolve references.
   *
   * If a node has an id attribute then the object cache is checked for the
   * object. If the object is not yet in the cache then it is constructed
   * using the constructor of {@link template} and cached in {@link Codec.objects}.
   *
   * This implementation decodes all attributes and childs of a node
   * according to the following rules:
   *
   * - If the variable name is in {@link exclude} or if the attribute name is "id"
   * or "as" then it is ignored.
   * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used
   * to replace the reference with an object.
   * - The variable name is mapped using a reverse {@link mapping}.
   * - If the value has a child node, then the codec is used to create a
   * child object with the variable name taken from the "as" attribute.
   * - If the object is an array and the variable name is empty then the
   * value or child object is appended to the array.
   * - If an add child has no value or the object is not an array then
   * the child text content is evaluated using {@link eval}.
   *
   * For add nodes where the object is not an array and the variable name
   * is defined, the default mechanism is used, allowing to override/add
   * methods as follows:
   *
   * ```javascript
   * <Object>
   *   <add as="hello"><![CDATA[
   *     function(arg1) {
   *       mxUtils.alert('Hello '+arg1);
   *     }
   *   ]]></add>
   * </Object>
   * ```
   *
   * If no object exists for an ID in {@link idrefs} a warning is issued
   * using {@link GlobalConfig.logger}.
   *
   * Returns the resulting object that represents the given XML node
   * or the object given to the method as the into parameter.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param into Optional object to encode the node into.
   */
  decode(dec2, node2, into2) {
    const id2 = node2.getAttribute("id");
    let obj2 = dec2.objects[id2];
    if (obj2 == null) {
      obj2 = into2 || this.cloneTemplate();
      if (id2 != null) {
        dec2.putObject(id2, obj2);
      }
    }
    const _node2 = this.beforeDecode(dec2, node2, obj2);
    this.decodeNode(dec2, _node2, obj2);
    return this.afterDecode(dec2, _node2, obj2);
  }
  /**
   * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeNode(dec2, node2, obj2) {
    if (node2 != null) {
      this.decodeAttributes(dec2, node2, obj2);
      this.decodeChildren(dec2, node2, obj2);
    }
  }
  /**
   * Decodes all attributes of the given node using {@link decodeAttribute}.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Object to encode the node into.
   */
  decodeAttributes(dec2, node2, obj2) {
    const attrs = node2.attributes;
    if (attrs != null) {
      for (let i2 = 0; i2 < attrs.length; i2 += 1) {
        this.decodeAttribute(dec2, attrs[i2], obj2);
      }
    }
  }
  /**
   * Returns true if the given attribute should be ignored. This implementation
   * returns true if the attribute name is "as" or "id".
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be decoded.
   * @param obj Objec to encode the attribute into.
   */
  isIgnoredAttribute(dec2, attr, obj2) {
    return attr.nodeName === "as" || attr.nodeName === "id";
  }
  /**
   * Reads the given attribute into the specified object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param attr XML attribute to be decoded.
   * @param obj Objec to encode the attribute into.
   */
  decodeAttribute(dec2, attr, obj2) {
    if (!this.isIgnoredAttribute(dec2, attr, obj2)) {
      const name2 = attr.nodeName;
      let value2 = this.convertAttributeFromXml(dec2, attr, obj2);
      const fieldname2 = this.getFieldName(name2);
      if (this.isReference(obj2, fieldname2, value2, false)) {
        const tmp2 = dec2.getObject(value2);
        if (tmp2 == null) {
          GlobalConfig.logger.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name2}=${value2}`);
          return;
        }
        value2 = tmp2;
      }
      if (!this.isExcluded(obj2, name2, value2, false)) {
        obj2[name2] = value2;
      }
    }
  }
  /**
   * Decodes all children of the given node using {@link decodeChild}.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeChildren(dec2, node2, obj2) {
    let child2 = node2.firstChild;
    while (child2 != null) {
      const tmp2 = child2.nextSibling;
      if (child2.nodeType === NODETYPE.ELEMENT && !this.processInclude(dec2, child2, obj2)) {
        this.decodeChild(dec2, child2, obj2);
      }
      child2 = tmp2;
    }
  }
  /**
   * Reads the specified child into the given object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param child XML child element to be decoded.
   * @param obj Objec to encode the node into.
   */
  decodeChild(dec, child, obj) {
    const fieldname = this.getFieldName(child.getAttribute("as"));
    if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {
      const template = this.getFieldTemplate(obj, fieldname, child);
      let value = null;
      if (child.nodeName === "add") {
        value = child.getAttribute("value");
        if (value == null && _ObjectCodec.allowEval) {
          value = eval(getTextContent(child));
        }
      } else {
        value = dec.decode(child, template);
      }
      try {
        this.addObjectValue(obj, fieldname, value, template);
      } catch (e) {
        throw new Error(`${e.message} for ${child.nodeName}`);
      }
    }
  }
  /**
   * Returns the template instance for the given field. This returns the
   * value of the field, null if the value is an array or an empty collection
   * if the value is a collection. The value is then used to populate the
   * field for a new instance. For strongly typed languages it may be
   * required to override this to return the correct collection instance
   * based on the encoded child.
   */
  getFieldTemplate(obj2, fieldname2, child2) {
    let template2 = obj2[fieldname2];
    if (template2 instanceof Array && template2.length > 0) {
      template2 = null;
    }
    return template2;
  }
  /**
   * Sets the decoded child node as a value of the given object. If the
   * object is a map, then the value is added with the given field name as a
   * key. If the field name is not empty, then setFieldValue is called or
   * else, if the object is a collection, the value is added to the
   * collection. For strongly typed languages it may be required to
   * override this with the correct code to add an entry to an object.
   */
  addObjectValue(obj2, fieldname2, value2, template2) {
    if (value2 != null && value2 !== template2) {
      if (fieldname2 != null && fieldname2.length > 0) {
        obj2[fieldname2] = value2;
      } else {
        obj2.push(value2);
      }
    }
  }
  /**
   * Returns true if the given node is an include directive and
   * executes the include by decoding the XML document. Returns
   * false if the given node is not an include directive.
   *
   * @param dec {@link Codec} that controls the encoding/decoding process.
   * @param node XML node to be checked.
   * @param into Optional object to pass-thru to the codec.
   */
  processInclude(dec2, node2, into2) {
    if (node2.nodeName === "include") {
      const name2 = node2.getAttribute("name");
      if (name2 != null) {
        try {
          const xml = load(name2).getDocumentElement();
          if (xml != null) {
            dec2.decode(xml, into2);
          }
        } catch (e) {
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Hook for subclassers to pre-process the node for
   * the specified object and return the node to be
   * used for further processing by {@link decode}.
   * The object is created based on the template in the
   * calling method and is never null. This implementation
   * returns the input node. The return value of this
   * function is used in {@link decode} to perform
   * the default decoding into the given object.
   *
   * @param dec {@link Codec} that controls the decoding process.
   * @param node XML node to be decoded.
   * @param obj Object to encode the node into.
   */
  beforeDecode(dec2, node2, obj2) {
    return node2;
  }
  /**
   * Hook for subclassers to post-process the object after
   * decoding. This implementation returns the given object
   * without any changes. The return value of this method
   * is returned to the decoder from {@link decode}.
   *
   * @param dec {@link Codec} that controls the encoding process.
   * @param node XML node to be decoded.
   * @param obj Object that represents the default decoding.
   */
  afterDecode(dec2, node2, obj2) {
    return obj2;
  }
};
ObjectCodec.allowEval = false;
var ObjectCodec_default = ObjectCodec;

// node_modules/@maxgraph/core/lib/serialization/CodecRegistry.js
var CodecRegistry = class _CodecRegistry {
  /**
   * Registers a new codec and associates the name of the codec via {@link ObjectCodec.getName} with the codec object.
   *
   * @param codec ObjectCodec to be registered.
   * @param registerAlias if `true`, register an alias if the codec name doesn't match the name of the constructor of {@link ObjectCodec.template}.
   */
  static register(codec, registerAlias = true) {
    if (codec != null) {
      const name2 = codec.getName();
      _CodecRegistry.codecs[name2] = codec;
      const classname = codec.template.constructor.name;
      if (registerAlias && classname !== name2) {
        _CodecRegistry.addAlias(classname, name2);
      }
    }
    return codec;
  }
  /**
   * Adds an alias for mapping a classname to a codec name.
   */
  static addAlias(classname, codecname) {
    _CodecRegistry.aliases[classname] = codecname;
  }
  /**
   * Returns a codec that handles objects that are constructed using the given constructor or a codec registered under the provided name.
   *
   * When passing a name, the method first check if an alias exists for the name, and if so, it uses it to retrieve the codec.
   *
   * If there is no registered Codec, the method tries to register a new Codec using the provided constructor.
   *
   * @param constructorOrName JavaScript constructor function of the Codec or Codec name.
   */
  static getCodec(constructorOrName) {
    if (constructorOrName == null) {
      return null;
    }
    let codec = null;
    let name2 = typeof constructorOrName === "string" ? constructorOrName : constructorOrName.name;
    const tmp2 = _CodecRegistry.aliases[name2];
    if (tmp2 != null) {
      name2 = tmp2;
    }
    codec = _CodecRegistry.codecs[name2] ?? null;
    if (codec == null) {
      try {
        codec = new ObjectCodec_default(new constructorOrName());
        _CodecRegistry.register(codec);
      } catch (e) {
      }
    }
    return codec;
  }
  /**
   * First try to get the codec by the name it is registered with. If it doesn't exist, use the alias eventually declared
   * to get the codec.
   * @param name the name of the codec that is willing to be retrieved.
   */
  static getCodecByName(name2) {
    let codec = _CodecRegistry.codecs[name2];
    if (!codec) {
      const alias = _CodecRegistry.aliases[name2];
      if (alias) {
        codec = _CodecRegistry.codecs[alias];
      }
    }
    return codec ?? null;
  }
};
CodecRegistry.codecs = {};
CodecRegistry.aliases = {};
var CodecRegistry_default = CodecRegistry;

// node_modules/@maxgraph/core/lib/view/cell/Cell.js
var Cell = class {
  constructor(value2 = null, geometry = null, style2 = {}) {
    this.invalidating = false;
    this.onInit = null;
    this.overlays = [];
    this.id = null;
    this.value = null;
    this.geometry = null;
    this.style = {};
    this.vertex = false;
    this.edge = false;
    this.connectable = true;
    this.visible = true;
    this.collapsed = false;
    this.parent = null;
    this.source = null;
    this.target = null;
    this.children = [];
    this.edges = [];
    this.mxTransient = [
      "id",
      "value",
      "parent",
      "source",
      "target",
      "children",
      "edges"
    ];
    this.value = value2;
    this.setGeometry(geometry);
    this.setStyle(style2);
    if (this.onInit) {
      this.onInit();
    }
  }
  // TODO: Document me!!!
  getChildren() {
    return this.children || [];
  }
  /**
   * Returns the Id of the cell as a string.
   */
  getId() {
    return this.id;
  }
  /**
   * Sets the Id of the cell to the given string.
   */
  setId(id2) {
    this.id = id2;
  }
  /**
   * Returns the user object of the cell. The user
   * object is stored in <value>.
   */
  getValue() {
    return this.value;
  }
  /**
   * Sets the user object of the cell. The user object
   * is stored in <value>.
   */
  setValue(value2) {
    this.value = value2;
  }
  /**
   * Changes the user object after an in-place edit
   * and returns the previous value. This implementation
   * replaces the user object with the given value and
   * returns the old user object.
   */
  valueChanged(newValue) {
    const previous = this.getValue();
    this.setValue(newValue);
    return previous;
  }
  /**
   * Returns the {@link Geometry} that describes the <geometry>.
   */
  getGeometry() {
    return this.geometry;
  }
  /**
   * Sets the {@link Geometry} to be used as the <geometry>.
   */
  setGeometry(geometry) {
    this.geometry = geometry;
  }
  /**
   * Returns a string that describes the {@link style}.
   *
   * **IMPORTANT**: if you want to get the style object to later update it and propagate changes to the view, use {@link getClonedStyle} instead.
   */
  getStyle() {
    return this.style;
  }
  /**
   * Use this method to get the style object to later update it and propagate changes to the view.
   *
   * See {@link GraphDataModel.setStyle} for more details.
   */
  getClonedStyle() {
    return clone(this.getStyle());
  }
  /**
   * Sets the string to be used as the {@link style}.
   */
  setStyle(style2) {
    this.style = style2;
  }
  /**
   * Returns true if the cell is a vertex.
   */
  isVertex() {
    return this.vertex;
  }
  /**
   * Specifies if the cell is a vertex. This should only be assigned at
   * construction of the cell and not be changed during its lifecycle.
   *
   * @param vertex Boolean that specifies if the cell is a vertex.
   */
  setVertex(vertex) {
    this.vertex = vertex;
  }
  /**
   * Returns true if the cell is an edge.
   */
  isEdge() {
    return this.edge;
  }
  /**
   * Specifies if the cell is an edge. This should only be assigned at
   * construction of the cell and not be changed during its lifecycle.
   *
   * @param edge Boolean that specifies if the cell is an edge.
   */
  setEdge(edge2) {
    this.edge = edge2;
  }
  /**
   * Returns true if the cell is connectable.
   */
  isConnectable() {
    return this.connectable;
  }
  /**
   * Sets the connectable state.
   *
   * @param connectable Boolean that specifies the new connectable state.
   */
  setConnectable(connectable) {
    this.connectable = connectable;
  }
  /**
   * Returns true if the cell is visibile.
   */
  isVisible() {
    return this.visible;
  }
  /**
   * Specifies if the cell is visible.
   *
   * @param visible Boolean that specifies the new visible state.
   */
  setVisible(visible) {
    this.visible = visible;
  }
  /**
   * Returns true if the cell is collapsed.
   */
  isCollapsed() {
    return this.collapsed;
  }
  /**
   * Sets the collapsed state.
   *
   * @param collapsed Boolean that specifies the new collapsed state.
   */
  setCollapsed(collapsed) {
    this.collapsed = collapsed;
  }
  /**
   * Returns the cell's parent.
   */
  getParent() {
    return this.parent;
  }
  /**
   * Sets the parent cell.
   *
   * @param parent<Cell> that represents the new parent.
   */
  setParent(parent2) {
    this.parent = parent2;
  }
  /**
   * Returns the source or target terminal.
   *
   * @param source Boolean that specifies if the source terminal should be
   * returned.
   */
  getTerminal(source2 = false) {
    return source2 ? this.source : this.target;
  }
  /**
   * Sets the source or target terminal and returns the new terminal.
   *
   * @param terminal  Cell that represents the new source or target terminal.
   * @param isSource  boolean that specifies if the source or target terminal should be set.
   */
  setTerminal(terminal, isSource) {
    if (isSource) {
      this.source = terminal;
    } else {
      this.target = terminal;
    }
    return terminal;
  }
  /**
   * Returns the number of child cells.
   */
  getChildCount() {
    return this.children.length;
  }
  /**
   * Returns the index of the specified child in the child array.
   *
   * @param child Child whose index should be returned.
   */
  getIndex(child2) {
    if (child2 === null)
      return -1;
    return this.children.indexOf(child2);
  }
  /**
   * Returns the child at the specified index.
   *
   * @param indexInteger that specifies the child to be returned.
   */
  getChildAt(index) {
    return this.children[index];
  }
  /**
   * Inserts the specified child into the child array at the specified index
   * and updates the parent reference of the child. If not childIndex is
   * specified then the child is appended to the child array. Returns the
   * inserted child.
   *
   * @param child<Cell> to be inserted or appended to the child array.
   * @param indexOptional integer that specifies the index at which the child
   * should be inserted into the child array.
   */
  insert(child2, index) {
    if (index === void 0) {
      index = this.getChildCount();
      if (child2.getParent() === this) {
        index--;
      }
    }
    child2.removeFromParent();
    child2.setParent(this);
    this.children.splice(index, 0, child2);
    return child2;
  }
  /**
   * Removes the child at the specified index from the child array and
   * returns the child that was removed. Will remove the parent reference of
   * the child.
   *
   * @param indexInteger that specifies the index of the child to be
   * removed.
   */
  remove(index) {
    let child2 = null;
    if (index >= 0) {
      child2 = this.getChildAt(index);
      if (child2) {
        this.children.splice(index, 1);
        child2.setParent(null);
      }
    }
    return child2;
  }
  /**
   * Removes the cell from its parent.
   */
  removeFromParent() {
    if (this.parent) {
      const index = this.parent.getIndex(this);
      this.parent.remove(index);
    }
  }
  /**
   * Returns the number of edges in the edge array.
   */
  getEdgeCount() {
    return this.edges.length;
  }
  /**
   * Returns the index of the specified edge in <edges>.
   *
   * @param edge<Cell> whose index in <edges> should be returned.
   */
  getEdgeIndex(edge2) {
    return this.edges.indexOf(edge2);
  }
  /**
   * Returns the edge at the specified index in <edges>.
   *
   * @param indexInteger that specifies the index of the edge to be returned.
   */
  getEdgeAt(index) {
    return this.edges[index];
  }
  /**
   * Inserts the specified edge into the edge array and returns the edge.
   * Will update the respective terminal reference of the edge.
   *
   * @param edge              <Cell> to be inserted into the edge array.
   * @param isOutgoing Boolean that specifies if the edge is outgoing.
   */
  insertEdge(edge2, isOutgoing = false) {
    edge2.removeFromTerminal(isOutgoing);
    edge2.setTerminal(this, isOutgoing);
    if (this.edges.length === 0 || edge2.getTerminal(!isOutgoing) !== this || this.edges.indexOf(edge2) < 0) {
      this.edges.push(edge2);
    }
    return edge2;
  }
  /**
   * Removes the specified edge from the edge array and returns the edge.
   * Will remove the respective terminal reference from the edge.
   *
   * @param edge<Cell> to be removed from the edge array.
   * @param isOutgoing Boolean that specifies if the edge is outgoing.
   */
  removeEdge(edge2, isOutgoing = false) {
    if (edge2 != null) {
      if (edge2.getTerminal(!isOutgoing) !== this && this.edges != null) {
        const index = this.getEdgeIndex(edge2);
        if (index >= 0) {
          this.edges.splice(index, 1);
        }
      }
      edge2.setTerminal(null, isOutgoing);
    }
    return edge2;
  }
  /**
   * Removes the edge from its source or target terminal.
   *
   * @param isSource Boolean that specifies if the edge should be removed from its source or target terminal.
   */
  removeFromTerminal(isSource) {
    const terminal = this.getTerminal(isSource);
    if (terminal) {
      terminal.removeEdge(this, isSource);
    }
  }
  /**
   * Returns true if the user object is an XML node that contains the given attribute.
   *
   * @param name Name nameName of the attribute.
   */
  hasAttribute(name2) {
    var _a2;
    const userObject = this.getValue();
    return isNotNullish(userObject) && (userObject.nodeType === NODETYPE.ELEMENT && userObject.hasAttribute ? userObject.hasAttribute(name2) : isNotNullish((_a2 = userObject.getAttribute) == null ? void 0 : _a2.call(userObject, name2)));
  }
  /**
   * Returns the specified attribute from the user object if it is an XML node.
   *
   * @param name Name of the attribute whose value should be returned.
   * @param defaultValue Optional default value to use if the attribute has no
   * value.
   */
  getAttribute(name2, defaultValue) {
    var _a2;
    const userObject = this.getValue();
    const val = isNotNullish(userObject) && userObject.nodeType === NODETYPE.ELEMENT ? (_a2 = userObject.getAttribute) == null ? void 0 : _a2.call(userObject, name2) : null;
    return val ?? defaultValue;
  }
  /**
   * Sets the specified attribute on the user object if it is an XML node.
   *
   * @param name Name of the attribute whose value should be set.
   * @param value New value of the attribute.
   */
  setAttribute(name2, value2) {
    var _a2;
    const userObject = this.getValue();
    if (isNotNullish(userObject) && userObject.nodeType === NODETYPE.ELEMENT) {
      (_a2 = userObject.setAttribute) == null ? void 0 : _a2.call(userObject, name2, value2);
    }
  }
  /**
   * Returns a clone of the cell.
   *
   * Uses {@link cloneValue} to clone the user object.
   *
   * All fields in {@link mxTransient} are ignored during the cloning.
   */
  clone() {
    const c = clone(this, this.mxTransient);
    c.setValue(this.cloneValue());
    return c;
  }
  /**
   * Returns a clone of the cell's user object.
   */
  cloneValue() {
    let value2 = this.getValue();
    if (isNotNullish(value2)) {
      if (typeof value2.clone === "function") {
        value2 = value2.clone();
      } else if (isNotNullish(value2.nodeType) && value2.cloneNode) {
        value2 = value2.cloneNode(true);
      }
    }
    return value2;
  }
  /**
   * Returns the nearest common ancestor for the specified cells to `this`.
   *
   * @param {Cell} cell2  that specifies the second cell in the tree.
   */
  getNearestCommonAncestor(cell2) {
    let path = CellPath_default.create(cell2);
    if (path.length > 0) {
      let cell3 = this;
      let current = CellPath_default.create(cell3);
      if (path.length < current.length) {
        cell3 = cell2;
        const tmp2 = current;
        current = path;
        path = tmp2;
      }
      while (cell3 && current) {
        const parent2 = cell3.getParent();
        if (path.indexOf(current + CellPath_default.PATH_SEPARATOR) === 0 && parent2) {
          return cell3;
        }
        current = CellPath_default.getParentPath(current);
        cell3 = parent2;
      }
    }
    return null;
  }
  /**
   * Returns true if the given parent is an ancestor of the given child. Note
   * returns true if child == parent.
   *
   * @param {Cell} child  that specifies the child.
   */
  isAncestor(child2) {
    while (child2 && child2 !== this) {
      child2 = child2.getParent();
    }
    return child2 === this;
  }
  /**
   * Returns the child vertices of the given parent.
   */
  getChildVertices() {
    return this.getChildCells(true, false);
  }
  /**
   * Returns the child edges of the given parent.
   */
  getChildEdges() {
    return this.getChildCells(false, true);
  }
  /**
   * Returns the children of the given cell that are vertices and/or edges
   * depending on the arguments.
   *
   * @param vertices  Boolean indicating if child vertices should be returned.
   * Default is false.
   * @param edges  Boolean indicating if child edges should be returned.
   * Default is false.
   */
  getChildCells(vertices = false, edges = false) {
    const childCount2 = this.getChildCount();
    const result2 = [];
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = this.getChildAt(i2);
      if (!edges && !vertices || edges && child2.isEdge() || vertices && child2.isVertex()) {
        result2.push(child2);
      }
    }
    return result2;
  }
  /**
   * Returns the number of incoming or outgoing edges, ignoring the given
   * edge.
   *
   * @param outgoing  Boolean that specifies if the number of outgoing or
   * incoming edges should be returned.
   * @param {Cell} ignoredEdge  that represents an edge to be ignored.
   */
  getDirectedEdgeCount(outgoing, ignoredEdge = null) {
    let count = 0;
    const edgeCount = this.getEdgeCount();
    for (let i2 = 0; i2 < edgeCount; i2 += 1) {
      const edge2 = this.getEdgeAt(i2);
      if (edge2 !== ignoredEdge && edge2 && edge2.getTerminal(outgoing) === this) {
        count += 1;
      }
    }
    return count;
  }
  /**
   * Returns all edges of the given cell without loops.
   */
  getConnections() {
    return this.getEdges(true, true, false);
  }
  /**
   * Returns the incoming edges of the given cell without loops.
   */
  getIncomingEdges() {
    return this.getEdges(true, false, false);
  }
  /**
   * Returns the outgoing edges of the given cell without loops.
   */
  getOutgoingEdges() {
    return this.getEdges(false, true, false);
  }
  /**
   * Returns all distinct edges connected to this cell as a new array of
   * {@link Cell}. If at least one of incoming or outgoing is true, then loops
   * are ignored, otherwise if both are false, then all edges connected to
   * the given cell are returned including loops.
   *
   * @param incoming  Optional boolean that specifies if incoming edges should be
   * returned. Default is true.
   * @param outgoing  Optional boolean that specifies if outgoing edges should be
   * returned. Default is true.
   * @param includeLoops  Optional boolean that specifies if loops should be returned.
   * Default is true.
   */
  getEdges(incoming = true, outgoing = true, includeLoops = true) {
    const edgeCount = this.getEdgeCount();
    const result2 = [];
    for (let i2 = 0; i2 < edgeCount; i2 += 1) {
      const edge2 = this.getEdgeAt(i2);
      const source2 = edge2.getTerminal(true);
      const target2 = edge2.getTerminal(false);
      if (includeLoops && source2 === target2 || source2 !== target2 && (incoming && target2 === this || outgoing && source2 === this)) {
        result2.push(edge2);
      }
    }
    return result2;
  }
  /**
   * Returns the absolute, accumulated origin for the children inside the
   * given parent as an {@link Point}.
   */
  getOrigin() {
    let result2 = new Point_default();
    const parent2 = this.getParent();
    if (parent2) {
      result2 = parent2.getOrigin();
      if (!this.isEdge()) {
        const geo = this.getGeometry();
        if (geo) {
          result2.x += geo.x;
          result2.y += geo.y;
        }
      }
    }
    return result2;
  }
  /**
   * Returns all descendants of the given cell and the cell itself in an array.
   */
  getDescendants() {
    return this.filterDescendants(null);
  }
  /**
   * Visits all cells recursively and applies the specified filter function
   * to each cell. If the function returns true then the cell is added
   * to the resulting array. The parent and result paramters are optional.
   * If parent is not specified then the recursion starts at {@link root}.
   *
   * Example:
   * The following example extracts all vertices from a given model:
   * ```javascript
   * var filter(cell)
   * {
   * 	return model.isVertex(cell);
   * }
   * var vertices = model.filterDescendants(filter);
   * ```
   *
   * @param filter  JavaScript function that takes an {@link Cell} as an argument
   * and returns a boolean.
   */
  filterDescendants(filter) {
    let result2 = [];
    if (filter === null || filter(this)) {
      result2.push(this);
    }
    const childCount2 = this.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = this.getChildAt(i2);
      result2 = result2.concat(child2.filterDescendants(filter));
    }
    return result2;
  }
  /**
   * Returns the root of the model or the topmost parent of the given cell.
   */
  getRoot() {
    let cell2 = this;
    let root = cell2;
    while (cell2) {
      root = cell2;
      cell2 = cell2.getParent();
    }
    return root;
  }
};
var Cell_default = Cell;

// node_modules/@maxgraph/core/lib/serialization/Codec.js
var createXmlDocument = () => {
  return document.implementation.createDocument("", "", null);
};
var Codec = class {
  constructor(document2 = createXmlDocument()) {
    this.elements = null;
    this.encodeDefaults = false;
    this.document = document2;
    this.objects = {};
  }
  /**
   * Associates the given object with the given ID and returns the given object.
   *
   * @param id ID for the object to be associated with.
   * @param obj Object to be associated with the ID.
   */
  putObject(id2, obj2) {
    this.objects[id2] = obj2;
    return obj2;
  }
  /**
   * Returns the decoded object for the element with the specified ID in
   * {@link document}. If the object is not known then {@link lookup} is used to find an
   * object. If no object is found, then the element with the respective ID
   * from the document is parsed using {@link decode}.
   */
  getObject(id2) {
    let obj2 = null;
    if (id2 != null) {
      obj2 = this.objects[id2];
      if (obj2 == null) {
        obj2 = this.lookup(id2);
        if (obj2 == null) {
          const node2 = this.getElementById(id2);
          if (node2 != null) {
            obj2 = this.decode(node2);
          }
        }
      }
    }
    return obj2;
  }
  /**
   * Hook for subclassers to implement a custom lookup mechanism for cell IDs.
   * This implementation always returns null.
   *
   * Example:
   *
   * ```javascript
   * const codec = new Codec();
   * codec.lookup(id)
   * {
   *   return model.getCell(id);
   * };
   * ```
   *
   * @param id ID of the object to be returned.
   */
  lookup(id2) {
    return null;
  }
  /**
   * Returns the element with the given ID from {@link document}.
   *
   * @param id String that contains the ID.
   */
  getElementById(id2) {
    this.updateElements();
    return this.elements[id2];
  }
  updateElements() {
    if (this.elements == null) {
      this.elements = {};
      if (this.document.documentElement != null) {
        this.addElement(this.document.documentElement);
      }
    }
  }
  /**
   * Adds the given element to {@link elements} if it has an ID.
   */
  addElement(node2) {
    if (node2.nodeType === NODETYPE.ELEMENT) {
      const id2 = node2.getAttribute("id");
      if (id2 != null) {
        if (this.elements[id2] == null) {
          this.elements[id2] = node2;
        } else if (this.elements[id2] !== node2) {
          throw new Error(`${id2}: Duplicate ID`);
        }
      }
    }
    let nodeChild = node2.firstChild;
    while (nodeChild != null) {
      this.addElement(nodeChild);
      nodeChild = nodeChild.nextSibling;
    }
  }
  /**
   * Returns the ID of the specified object. This implementation
   * calls {@link reference} first and if that returns null handles
   * the object as an {@link Cell} by returning their IDs using
   * {@link Cell.getId}. If no ID exists for the given cell, then
   * an on-the-fly ID is generated using {@link CellPath.create}.
   *
   * @param obj Object to return the ID for.
   */
  getId(obj2) {
    let id2 = null;
    if (obj2 != null) {
      id2 = this.reference(obj2);
      if (id2 == null && obj2 instanceof Cell_default) {
        id2 = obj2.getId();
        if (id2 == null) {
          id2 = CellPath_default.create(obj2);
          if (id2.length === 0) {
            id2 = "root";
          }
        }
      }
    }
    return id2;
  }
  /**
   * Hook for subclassers to implement a custom method
   * for retrieving IDs from objects. This implementation
   * always returns null.
   *
   * Example:
   *
   * ```javascript
   * const codec = new Codec();
   * codec.reference(obj)
   * {
   *   return obj.getCustomId();
   * };
   * ```
   *
   * @param obj Object whose ID should be returned.
   */
  reference(obj2) {
    return null;
  }
  /**
   * Encodes the specified object and returns the resulting XML node.
   *
   * @param obj Object to be encoded.
   */
  encode(obj2) {
    let node2 = null;
    if (obj2 != null && obj2.constructor != null) {
      const enc = CodecRegistry_default.getCodec(obj2.constructor);
      if (enc != null) {
        node2 = enc.encode(this, obj2);
      } else if (isNode(obj2)) {
        node2 = importNode(this.document, obj2, true);
      } else {
        GlobalConfig.logger.warn(`Codec.encode: No codec for ${getFunctionName(obj2.constructor)}`);
      }
    }
    return node2;
  }
  /**
   * Decodes the given XML node. The optional "into"
   * argument specifies an existing object to be
   * used. If no object is given, then a new instance
   * is created using the constructor from the codec.
   *
   * The function returns the passed in object or
   * the new instance if no object was given.
   *
   * @param node XML node to be decoded.
   * @param into Optional object to be decoded into.
   */
  decode(node2, into2) {
    this.updateElements();
    let obj2 = null;
    if (node2 != null && node2.nodeType === NODETYPE.ELEMENT) {
      const dec2 = CodecRegistry_default.getCodecByName(node2.nodeName);
      if (dec2 != null) {
        obj2 = dec2.decode(this, node2, into2);
      } else {
        obj2 = node2.cloneNode(true);
        obj2.removeAttribute("as");
      }
    }
    return obj2;
  }
  /**
   * Encoding of cell hierarchies is built-into the core, but
   * is a higher-level function that needs to be explicitely
   * used by the respective object encoders (eg. {@link ModelCodec},
   * {@link ChildChangeCodec} and {@link RootChangeCodec}). This
   * implementation writes the given cell and its children as a
   * (flat) sequence into the given node. The children are not
   * encoded if the optional includeChildren is false. The
   * function is in charge of adding the result into the
   * given node and has no return value.
   *
   * @param cell {@link mxCell} to be encoded.
   * @param node Parent XML node to add the encoded cell into.
   * @param includeChildren Optional boolean indicating if the
   * function should include all descendents. Default is true.
   */
  encodeCell(cell2, node2, includeChildren) {
    const appendMe = this.encode(cell2);
    if (appendMe) {
      node2.appendChild(appendMe);
    }
    if (includeChildren == null || includeChildren) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        this.encodeCell(cell2.getChildAt(i2), node2);
      }
    }
  }
  /**
   * Returns true if the given codec is a cell codec. This uses
   * {@link CellCodec.isCellCodec} to check if the codec is of the
   * given type.
   */
  isCellCodec(codec) {
    if (codec != null && "isCellCodec" in codec) {
      return codec.isCellCodec();
    }
    return false;
  }
  /**
   * Decodes cells that have been encoded using inversion, ie.
   * where the user object is the enclosing node in the XML,
   * and restores the group and graph structure in the cells.
   * Returns a new {@link Cell} instance that represents the
   * given node.
   *
   * @param node XML node that contains the cell data.
   * @param restoreStructures Optional boolean indicating whether
   * the graph structure should be restored by calling insert
   * and insertEdge on the parent and terminals, respectively.
   * Default is `true`.
   */
  decodeCell(node2, restoreStructures = true) {
    if ((node2 == null ? void 0 : node2.nodeType) !== NODETYPE.ELEMENT) {
      return null;
    }
    let decoder = CodecRegistry_default.getCodec(node2.nodeName);
    if (!this.isCellCodec(decoder)) {
      let child2 = node2.firstChild;
      while (child2 != null && !this.isCellCodec(decoder)) {
        decoder = CodecRegistry_default.getCodec(child2.nodeName);
        child2 = child2.nextSibling;
      }
    }
    if (!this.isCellCodec(decoder)) {
      decoder = CodecRegistry_default.getCodec(Cell_default);
    }
    const cell2 = decoder == null ? void 0 : decoder.decode(this, node2);
    if (restoreStructures) {
      this.insertIntoGraph(cell2);
    }
    return cell2;
  }
  /**
   * Inserts the given cell into its parent and terminal cells.
   */
  insertIntoGraph(cell2) {
    const { parent: parent2 } = cell2;
    const source2 = cell2.getTerminal(true);
    const target2 = cell2.getTerminal(false);
    cell2.setTerminal(null, false);
    cell2.setTerminal(null, true);
    cell2.parent = null;
    if (parent2 != null) {
      if (parent2 === cell2) {
        throw new Error(`${parent2.id}: Self Reference`);
      } else {
        parent2.insert(cell2);
      }
    }
    if (source2 != null) {
      source2.insertEdge(cell2, true);
    }
    if (target2 != null) {
      target2.insertEdge(cell2, false);
    }
  }
  /**
   * Sets the attribute on the specified node to value. This is a
   * helper method that makes sure the attribute and value arguments
   * are not null.
   *
   * @param node XML node to set the attribute for.
   * @param attribute The name of the attribute to be set.
   * @param value New value of the attribute.
   */
  setAttribute(node2, attribute2, value2) {
    if (attribute2 != null && value2 != null) {
      node2.setAttribute(attribute2, value2);
    }
  }
};
var Codec_default = Codec;

// node_modules/@maxgraph/core/lib/util/xmlUtils.js
var createXmlDocument2 = () => {
  return document.implementation.createDocument("", "", null);
};
var parseXml = (xmlString) => {
  return new DOMParser().parseFromString(xmlString, "text/xml");
};
var getViewXml = (graph, scale = 1, cells = null, x0 = 0, y0 = 0) => {
  if (cells == null) {
    const model2 = graph.getDataModel();
    cells = [model2.getRoot()];
  }
  const view = graph.getView();
  let result2 = null;
  const eventsEnabled = view.isEventsEnabled();
  view.setEventsEnabled(false);
  const { drawPane } = view;
  const { overlayPane } = view;
  if (graph.dialect === DIALECT.SVG) {
    view.drawPane = document.createElementNS(NS_SVG, "g");
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = document.createElementNS(NS_SVG, "g");
    view.canvas.appendChild(view.overlayPane);
  } else {
    view.drawPane = view.drawPane.cloneNode(false);
    view.canvas.appendChild(view.drawPane);
    view.overlayPane = view.overlayPane.cloneNode(false);
    view.canvas.appendChild(view.overlayPane);
  }
  const translate = view.getTranslate();
  view.translate = new Point_default(x0, y0);
  const temp = new TemporaryCellStates_default(graph.getView(), scale, cells);
  try {
    const enc = new Codec_default();
    result2 = enc.encode(graph.getView());
  } finally {
    temp.destroy();
    view.translate = translate;
    view.canvas.removeChild(view.drawPane);
    view.canvas.removeChild(view.overlayPane);
    view.drawPane = drawPane;
    view.overlayPane = overlayPane;
    view.setEventsEnabled(eventsEnabled);
  }
  return result2;
};
var getXml = (node2, linefeed = "&#xa;") => {
  const xmlSerializer = new XMLSerializer();
  let xml = xmlSerializer.serializeToString(node2);
  xml = xml.replace(/\n/g, linefeed);
  return xml;
};
var getPrettyXml = (node2, tab = "  ", indent = "", newline = "\n", ns = null) => {
  const result2 = [];
  if (node2 != null) {
    if (node2.namespaceURI != null && node2.namespaceURI !== ns) {
      ns = node2.namespaceURI;
      if (node2.getAttribute("xmlns") == null) {
        node2.setAttribute("xmlns", node2.namespaceURI);
      }
    }
    if (node2.nodeType === NODETYPE.DOCUMENT) {
      result2.push(getPrettyXml(node2.documentElement, tab, indent, newline, ns));
    } else if (node2.nodeType === NODETYPE.DOCUMENT_FRAGMENT) {
      let tmp2 = node2.firstChild;
      if (tmp2 != null) {
        while (tmp2 != null) {
          result2.push(getPrettyXml(tmp2, tab, indent, newline, ns));
          tmp2 = tmp2.nextSibling;
        }
      }
    } else if (node2.nodeType === NODETYPE.COMMENT) {
      const value2 = getTextContent(node2);
      if (value2.length > 0) {
        result2.push(`${indent}<!--${value2}-->${newline}`);
      }
    } else if (node2.nodeType === NODETYPE.TEXT) {
      const value2 = trim(getTextContent(node2));
      if (value2 && value2.length > 0) {
        result2.push(indent + htmlEntities(value2, false) + newline);
      }
    } else if (node2.nodeType === NODETYPE.CDATA) {
      const value2 = getTextContent(node2);
      if (value2.length > 0) {
        result2.push(`${indent}<![CDATA[${value2}]]${newline}`);
      }
    } else {
      result2.push(`${indent}<${node2.nodeName}`);
      const attrs = node2.attributes;
      if (attrs != null) {
        for (let i2 = 0; i2 < attrs.length; i2 += 1) {
          const val = htmlEntities(attrs[i2].value);
          result2.push(` ${attrs[i2].nodeName}="${val}"`);
        }
      }
      let tmp2 = node2.firstChild;
      if (tmp2 != null) {
        result2.push(`>${newline}`);
        while (tmp2 != null) {
          result2.push(getPrettyXml(tmp2, tab, indent + tab, newline, ns));
          tmp2 = tmp2.nextSibling;
        }
        result2.push(`${indent}</${node2.nodeName}>${newline}`);
      } else {
        result2.push(` />${newline}`);
      }
    }
  }
  return result2.join("");
};
var findNode = (node2, attr, value2) => {
  if (node2.nodeType === NODETYPE.ELEMENT) {
    const tmp2 = node2.getAttribute(attr);
    if (tmp2 && tmp2 === value2) {
      return node2;
    }
  }
  node2 = node2.firstChild;
  while (node2) {
    const result2 = findNode(node2, attr, value2);
    if (result2) {
      return result2;
    }
    node2 = node2.nextSibling;
  }
  return null;
};

// node_modules/@maxgraph/core/lib/view/canvas/SvgCanvas2D.js
var useAbsoluteIds = typeof DOMParser === "function" && !Client_default.IS_CHROMEAPP && !Client_default.IS_EDGE && document.getElementsByTagName("base").length > 0;
var SvgCanvas2D = class _SvgCanvas2D extends AbstractCanvas2D_default {
  constructor(root, styleEnabled) {
    super();
    this.defs = null;
    this.styleEnabled = true;
    this.node = null;
    this.matchHtmlAlignment = true;
    this.textEnabled = true;
    this.foEnabled = true;
    this.foAltText = "[Object]";
    this.foOffset = 0;
    this.textOffset = 0;
    this.imageOffset = 0;
    this.strokeTolerance = 0;
    this.minStrokeWidth = 1;
    this.refCount = 0;
    this.lineHeightCorrection = 1;
    this.pointerEventsValue = "all";
    this.fontMetricsPadding = 10;
    this.cacheOffsetSize = true;
    this.originalRoot = null;
    this.root = root;
    this.gradients = {};
    this.defs = null;
    this.styleEnabled = styleEnabled != null ? styleEnabled : false;
    let svg = null;
    if (root.ownerDocument !== document) {
      let node2 = root;
      while (node2 && node2.nodeName !== "svg") {
        node2 = node2.parentElement;
      }
      svg = node2;
    }
    if (svg) {
      const tmp2 = svg.getElementsByTagName("defs");
      if (tmp2.length > 0) {
        this.defs = svg.getElementsByTagName("defs")[0];
      }
      if (!this.defs) {
        this.defs = this.createElement("defs");
        if (svg.firstChild != null) {
          svg.insertBefore(this.defs, svg.firstChild);
        } else {
          svg.appendChild(this.defs);
        }
      }
      if (this.styleEnabled) {
        this.defs.appendChild(this.createStyle());
      }
    }
  }
  /**
   * Rounds all numbers to 2 decimal points.
   */
  format(value2) {
    return parseFloat(value2.toFixed(2));
  }
  /**
   * Returns the URL of the page without the hash part. This needs to use href to
   * include any search part with no params (ie question mark alone). This is a
   * workaround for the fact that window.location.search is empty if there is
   * no search string behind the question mark.
   */
  getBaseUrl() {
    let { href } = window.location;
    const hash = href.lastIndexOf("#");
    if (hash > 0) {
      href = href.substring(0, hash);
    }
    return href;
  }
  /**
   * Returns any offsets for rendering pixels.
   */
  reset() {
    super.reset();
    this.gradients = {};
  }
  end() {
    return;
  }
  /**
   * Creates the optional style section.
   */
  createStyle() {
    const style2 = this.createElement("style");
    style2.setAttribute("type", "text/css");
    write(style2, `svg{font-family:${DEFAULT_FONTFAMILY};font-size:${DEFAULT_FONTSIZE};fill:none;stroke-miterlimit:10}`);
    return style2;
  }
  /**
   * Private helper function to create SVG elements
   */
  createElement(tagName, namespace) {
    var _a2;
    return (_a2 = this.root) == null ? void 0 : _a2.ownerDocument.createElementNS(namespace || NS_SVG, tagName);
  }
  /**
   * Returns the alternate text string for the given foreignObject.
   */
  getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
    return isNotNullish(str) ? this.foAltText : null;
  }
  /**
   * Returns the alternate content for the given foreignObject.
   */
  createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {
    const text2 = this.getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
    const s = this.state;
    if (isNotNullish(text2) && s.fontSize > 0) {
      const dy = valign === ALIGN.TOP ? 1 : valign === ALIGN.BOTTOM ? 0 : 0.3;
      const anchor = align === ALIGN.RIGHT ? "end" : align === ALIGN.LEFT ? "start" : "middle";
      const alt = this.createElement("text");
      alt.setAttribute("x", String(Math.round(x + s.dx)));
      alt.setAttribute("y", String(Math.round(y + s.dy + dy * s.fontSize)));
      alt.setAttribute("fill", s.fontColor || "black");
      alt.setAttribute("font-family", s.fontFamily);
      alt.setAttribute("font-size", `${Math.round(s.fontSize)}px`);
      anchor !== "start" && alt.setAttribute("text-anchor", anchor);
      const fontStyle = s.fontStyle;
      matchBinaryMask(fontStyle, FONT.BOLD) && alt.setAttribute("font-weight", "bold");
      matchBinaryMask(fontStyle, FONT.ITALIC) && alt.setAttribute("font-style", "italic");
      const txtDecor = [];
      matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
      matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
      txtDecor.length > 0 && alt.setAttribute("text-decoration", txtDecor.join(" "));
      write(alt, text2);
      return alt;
    }
    return null;
  }
  /**
   * Private helper function to create SVG elements
   */
  createGradientId(start, end, alpha1, alpha2, direction) {
    if (start.charAt(0) === "#") {
      start = start.substring(1);
    }
    if (end.charAt(0) === "#") {
      end = end.substring(1);
    }
    start = `${start.toLowerCase()}-${alpha1}`;
    end = `${end.toLowerCase()}-${alpha2}`;
    let dir = null;
    if (direction == null || direction === DIRECTION.SOUTH) {
      dir = "s";
    } else if (direction === DIRECTION.EAST) {
      dir = "e";
    } else {
      const tmp2 = start;
      start = end;
      end = tmp2;
      if (direction === DIRECTION.NORTH) {
        dir = "s";
      } else if (direction === DIRECTION.WEST) {
        dir = "e";
      }
    }
    return `mx-gradient-${start}-${end}-${dir}`;
  }
  /**
   * Private helper function to create SVG elements
   */
  getSvgGradient(start, end, alpha1, alpha2, direction) {
    const id2 = this.createGradientId(start, end, alpha1, alpha2, direction);
    let gradient = this.gradients[id2];
    if (!gradient) {
      const svg = this.root.ownerSVGElement;
      let counter = 0;
      let tmpId = `${id2}-${counter}`;
      if (svg) {
        gradient = svg.ownerDocument.getElementById(tmpId);
        while (gradient && gradient.ownerSVGElement !== svg) {
          tmpId = `${id2}-${counter++}`;
          gradient = svg.ownerDocument.getElementById(tmpId);
        }
      } else {
        tmpId = `id${++this.refCount}`;
      }
      if (!gradient) {
        gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);
        gradient.setAttribute("id", tmpId);
        if (this.defs) {
          this.defs.appendChild(gradient);
        } else if (svg) {
          svg.appendChild(gradient);
        }
      }
      this.gradients[id2] = gradient;
    }
    return gradient.getAttribute("id");
  }
  /**
   * Creates the given SVG gradient.
   */
  createSvgGradient(start, end, alpha1, alpha2, direction) {
    const gradient = this.createElement("linearGradient");
    gradient.setAttribute("x1", "0%");
    gradient.setAttribute("y1", "0%");
    gradient.setAttribute("x2", "0%");
    gradient.setAttribute("y2", "0%");
    if (direction == null || direction === DIRECTION.SOUTH) {
      gradient.setAttribute("y2", "100%");
    } else if (direction === DIRECTION.EAST) {
      gradient.setAttribute("x2", "100%");
    } else if (direction === DIRECTION.NORTH) {
      gradient.setAttribute("y1", "100%");
    } else if (direction === DIRECTION.WEST) {
      gradient.setAttribute("x1", "100%");
    }
    let op = alpha1 < 1 ? `;stop-opacity:${alpha1}` : "";
    let stop = this.createElement("stop");
    stop.setAttribute("offset", "0%");
    stop.setAttribute("style", `stop-color:${start}${op}`);
    gradient.appendChild(stop);
    op = alpha2 < 1 ? `;stop-opacity:${alpha2}` : "";
    stop = this.createElement("stop");
    stop.setAttribute("offset", "100%");
    stop.setAttribute("style", `stop-color:${end}${op}`);
    gradient.appendChild(stop);
    return gradient;
  }
  /**
   * Private helper function to create SVG elements
   */
  addNode(filled, stroked) {
    const { node: node2 } = this;
    const s = this.state;
    if (node2) {
      if (node2.nodeName === "path") {
        if (this.path && this.path.length > 0) {
          node2.setAttribute("d", this.path.join(" "));
        } else {
          return;
        }
      }
      if (filled && s.fillColor !== NONE) {
        this.updateFill();
      } else if (!this.styleEnabled) {
        if (node2.nodeName === "ellipse" && Client_default.IS_FF) {
          node2.setAttribute("fill", "transparent");
        } else {
          node2.setAttribute("fill", NONE);
        }
        filled = false;
      }
      if (stroked && s.strokeColor !== NONE) {
        this.updateStroke();
      } else if (!this.styleEnabled) {
        node2.setAttribute("stroke", NONE);
      }
      if (s.transform && s.transform.length > 0) {
        node2.setAttribute("transform", s.transform);
      }
      if (s.shadow) {
        this.root.appendChild(this.createShadow(node2));
      }
      if (this.strokeTolerance > 0 && !filled) {
        this.root.appendChild(this.createTolerance(node2));
      }
      if (this.pointerEvents) {
        node2.setAttribute("pointer-events", this.pointerEventsValue);
      } else if (!this.pointerEvents && !this.originalRoot) {
        node2.setAttribute("pointer-events", NONE);
      }
      if (node2.nodeName !== "rect" && node2.nodeName !== "path" && node2.nodeName !== "ellipse" || node2.getAttribute("fill") !== NONE && node2.getAttribute("fill") !== "transparent" || node2.getAttribute("stroke") !== NONE || node2.getAttribute("pointer-events") !== NONE) {
        this.root.appendChild(node2);
      }
      this.node = null;
    }
  }
  /**
   * Transfers the stroke attributes from <state> to <node>.
   */
  updateFill() {
    var _a2;
    const s = this.state;
    if (s.alpha < 1 || s.fillAlpha < 1) {
      this.node.setAttribute("fill-opacity", String(s.alpha * s.fillAlpha));
    }
    if (s.fillColor !== NONE) {
      if (s.gradientColor !== NONE) {
        const id2 = this.getSvgGradient(s.fillColor, s.gradientColor, s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);
        if (((_a2 = this.root) == null ? void 0 : _a2.ownerDocument) === document && useAbsoluteIds) {
          const base = this.getBaseUrl().replace(/([()])/g, "\\$1");
          this.node.setAttribute("fill", `url(${base}#${id2})`);
        } else {
          this.node.setAttribute("fill", `url(#${id2})`);
        }
      } else {
        this.node.setAttribute("fill", s.fillColor.toLowerCase());
      }
    }
  }
  /**
   * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).
   */
  getCurrentStrokeWidth() {
    return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));
  }
  /**
   * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
   */
  updateStroke() {
    const s = this.state;
    if (s.strokeColor && s.strokeColor !== NONE) {
      this.node.setAttribute("stroke", s.strokeColor.toLowerCase());
    }
    if (s.alpha < 1 || s.strokeAlpha < 1) {
      this.node.setAttribute("stroke-opacity", String(s.alpha * s.strokeAlpha));
    }
    const sw = this.getCurrentStrokeWidth();
    if (sw !== 1) {
      this.node.setAttribute("stroke-width", String(sw));
    }
    if (this.node.nodeName === "path") {
      this.updateStrokeAttributes();
    }
    if (s.dashed) {
      this.node.setAttribute("stroke-dasharray", this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));
    }
  }
  /**
   * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.
   */
  updateStrokeAttributes() {
    const s = this.state;
    if (s.lineJoin && s.lineJoin !== "miter") {
      this.node.setAttribute("stroke-linejoin", s.lineJoin);
    }
    if (s.lineCap) {
      let value2 = s.lineCap;
      if (value2 === "flat") {
        value2 = "butt";
      }
      if (value2 !== "butt") {
        this.node.setAttribute("stroke-linecap", value2);
      }
    }
    if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit !== 10)) {
      this.node.setAttribute("stroke-miterlimit", String(s.miterLimit));
    }
  }
  /**
   * Creates the SVG dash pattern for the given state.
   */
  createDashPattern(scale) {
    const pat = [];
    if (typeof this.state.dashPattern === "string") {
      const dash = this.state.dashPattern.split(" ");
      if (dash.length > 0) {
        for (let i2 = 0; i2 < dash.length; i2 += 1) {
          pat[i2] = Number(dash[i2]) * scale;
        }
      }
    }
    return pat.join(" ");
  }
  /**
   * Creates a hit detection tolerance shape for the given node.
   */
  createTolerance(node2) {
    const tol = node2.cloneNode(true);
    const sw = parseFloat(tol.getAttribute("stroke-width") || "1") + this.strokeTolerance;
    tol.setAttribute("pointer-events", "stroke");
    tol.setAttribute("visibility", "hidden");
    tol.removeAttribute("stroke-dasharray");
    tol.setAttribute("stroke-width", String(sw));
    tol.setAttribute("fill", "none");
    tol.setAttribute("stroke", "white");
    return tol;
  }
  /**
   * Creates a shadow for the given node.
   */
  createShadow(node2) {
    const shadow = node2.cloneNode(true);
    const s = this.state;
    if (shadow.getAttribute("fill") !== "none" && (!Client_default.IS_FF || shadow.getAttribute("fill") !== "transparent")) {
      shadow.setAttribute("fill", s.shadowColor ? s.shadow : SHADOWCOLOR);
    }
    if (shadow.getAttribute("stroke") !== "none" && s.shadowColor && s.shadowColor !== NONE) {
      shadow.setAttribute("stroke", s.shadowColor);
    }
    shadow.setAttribute("transform", `translate(${this.format(s.shadowDx * s.scale)},${this.format(s.shadowDy * s.scale)})${s.transform || ""}`);
    shadow.setAttribute("opacity", String(s.shadowAlpha));
    return shadow;
  }
  /**
   * Experimental implementation for hyperlinks.
   */
  setLink(link2) {
    if (!link2) {
      this.root = this.originalRoot;
    } else {
      this.originalRoot = this.root;
      const node2 = this.createElement("a");
      if (node2.setAttributeNS == null || this.root.ownerDocument !== document) {
        node2.setAttribute("xlink:href", link2);
      } else {
        node2.setAttributeNS(NS_XLINK, "xlink:href", link2);
      }
      this.root.appendChild(node2);
      this.root = node2;
    }
  }
  /**
   * Sets the rotation of the canvas. Note that rotation cannot be concatenated.
   */
  rotate(theta, flipH, flipV, cx, cy) {
    if (theta !== 0 || flipH || flipV) {
      const s = this.state;
      cx += s.dx;
      cy += s.dy;
      cx *= s.scale;
      cy *= s.scale;
      s.transform = s.transform || "";
      if (flipH && flipV) {
        theta += 180;
      } else if (flipH !== flipV) {
        const tx = flipH ? cx : 0;
        const sx = flipH ? -1 : 1;
        const ty = flipV ? cy : 0;
        const sy = flipV ? -1 : 1;
        s.transform += `translate(${this.format(tx)},${this.format(ty)})scale(${this.format(sx)},${this.format(sy)})translate(${this.format(-tx)},${this.format(-ty)})`;
      }
      if (flipH ? !flipV : flipV) {
        theta *= -1;
      }
      if (theta !== 0) {
        s.transform += `rotate(${this.format(theta)},${this.format(cx)},${this.format(cy)})`;
      }
      s.rotation += theta;
      s.rotationCx = cx;
      s.rotationCy = cy;
    }
  }
  /**
   * Extends superclass to create path.
   */
  begin() {
    super.begin();
    this.node = this.createElement("path");
  }
  /**
   * Private helper function to create SVG elements
   */
  rect(x, y, w, h) {
    const s = this.state;
    const n = this.createElement("rect");
    n.setAttribute("x", String(this.format((x + s.dx) * s.scale)));
    n.setAttribute("y", String(this.format((y + s.dy) * s.scale)));
    n.setAttribute("width", String(this.format(w * s.scale)));
    n.setAttribute("height", String(this.format(h * s.scale)));
    this.node = n;
  }
  /**
   * Private helper function to create SVG elements
   */
  roundrect(x, y, w, h, dx, dy) {
    this.rect(x, y, w, h);
    if (dx > 0) {
      this.node.setAttribute("rx", String(this.format(dx * this.state.scale)));
    }
    if (dy > 0) {
      this.node.setAttribute("ry", String(this.format(dy * this.state.scale)));
    }
  }
  /**
   * Private helper function to create SVG elements
   */
  ellipse(x, y, w, h) {
    const s = this.state;
    const n = this.createElement("ellipse");
    n.setAttribute("cx", String(this.format((x + w / 2 + s.dx) * s.scale)));
    n.setAttribute("cy", String(this.format((y + h / 2 + s.dy) * s.scale)));
    n.setAttribute("rx", String(w / 2 * s.scale));
    n.setAttribute("ry", String(h / 2 * s.scale));
    this.node = n;
  }
  /**
   * Private helper function to create SVG elements
   */
  image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {
    src = this.converter.convert(src);
    const s = this.state;
    x += s.dx;
    y += s.dy;
    const node2 = this.createElement("image");
    node2.setAttribute("x", String(this.format(x * s.scale) + this.imageOffset));
    node2.setAttribute("y", String(this.format(y * s.scale) + this.imageOffset));
    node2.setAttribute("width", String(this.format(w * s.scale)));
    node2.setAttribute("height", String(this.format(h * s.scale)));
    if (!node2.setAttributeNS) {
      node2.setAttribute("xlink:href", src);
    } else {
      node2.setAttributeNS(NS_XLINK, "xlink:href", src);
    }
    if (!aspect) {
      node2.setAttribute("preserveAspectRatio", "none");
    }
    if (s.alpha < 1 || s.fillAlpha < 1) {
      node2.setAttribute("opacity", String(s.alpha * s.fillAlpha));
    }
    let tr = this.state.transform || "";
    if (flipH || flipV) {
      let sx = 1;
      let sy = 1;
      let dx = 0;
      let dy = 0;
      if (flipH) {
        sx = -1;
        dx = -w - 2 * x;
      }
      if (flipV) {
        sy = -1;
        dy = -h - 2 * y;
      }
      tr += `scale(${sx},${sy})translate(${dx * s.scale},${dy * s.scale})`;
    }
    if (tr.length > 0) {
      node2.setAttribute("transform", tr);
    }
    if (!this.pointerEvents) {
      node2.setAttribute("pointer-events", "none");
    }
    this.root.appendChild(node2);
  }
  /**
   * Converts the given HTML string to XHTML.
   */
  convertHtml(val) {
    const doc = new DOMParser().parseFromString(val, "text/html");
    if (doc != null) {
      val = new XMLSerializer().serializeToString(doc.body);
      if (val.substring(0, 5) === "<body") {
        val = val.substring(val.indexOf(">", 5) + 1);
      }
      if (val.substring(val.length - 7, val.length) === "</body>") {
        val = val.substring(0, val.length - 7);
      }
    }
    return val;
  }
  /**
   * Private helper function to create SVG elements
   * Note: signature changed in mxgraph 4.1.0
   */
  createDiv(str) {
    let val = str;
    if (!isNode(val)) {
      val = `<div><div>${this.convertHtml(val)}</div></div>`;
    }
    if (document.createElementNS) {
      const div = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
      if (isNode(val)) {
        const n = val;
        const div2 = document.createElement("div");
        const div3 = div2.cloneNode(false);
        if (this.root.ownerDocument !== document) {
          div2.appendChild(n.cloneNode(true));
        } else {
          div2.appendChild(n);
        }
        div3.appendChild(div2);
        div.appendChild(div3);
      } else {
        div.innerHTML = val;
      }
      return div;
    }
    if (isNode(val)) {
      val = `<div><div>${getXml(val)}</div></div>`;
    }
    val = `<div xmlns="http://www.w3.org/1999/xhtml">${val}</div>`;
    return new DOMParser().parseFromString(val, "text/xml").documentElement;
  }
  /**
   * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.
   */
  updateText(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node2) {
    if (node2 && node2.firstChild && node2.firstChild.firstChild) {
      this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node2.firstChild);
    }
  }
  /**
   * Creates a foreignObject for the given string and adds it to the given root.
   */
  addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root) {
    var _a2;
    const group = this.createElement("g");
    const fo = this.createElement("foreignObject");
    fo.setAttribute("style", "overflow: visible; text-align: left;");
    fo.setAttribute("pointer-events", "none");
    fo.appendChild(div);
    group.appendChild(fo);
    this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);
    if (((_a2 = this.root) == null ? void 0 : _a2.ownerDocument) !== document) {
      const alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);
      if (alt != null) {
        fo.setAttribute("requiredFeatures", "http://www.w3.org/TR/SVG11/feature#Extensibility");
        const sw = this.createElement("switch");
        sw.appendChild(fo);
        sw.appendChild(alt);
        group.appendChild(sw);
      }
    }
    root.appendChild(group);
  }
  /**
   * Updates existing DOM nodes for text rendering.
   */
  updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g) {
    const s = this.state.scale;
    _SvgCanvas2D.createCss(w + 2, h, align, valign, wrap, overflow, clip, this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null, this.state.fontBorderColor != null ? this.state.fontBorderColor : null, `display: flex; align-items: unsafe ${valign === ALIGN.TOP ? "flex-start" : valign === ALIGN.BOTTOM ? "flex-end" : "center"}; justify-content: unsafe ${align === ALIGN.LEFT ? "flex-start" : align === ALIGN.RIGHT ? "flex-end" : "center"}; `, this.getTextCss(), s, (dx, dy, flex, item2, block) => {
      x += this.state.dx;
      y += this.state.dy;
      const fo = g.firstChild;
      const div = fo.firstChild;
      const box = div.firstChild;
      const text2 = box.firstChild;
      const r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);
      let t = (this.foOffset !== 0 ? `translate(${this.foOffset} ${this.foOffset})` : "") + (s !== 1 ? `scale(${s})` : "");
      text2.setAttribute("style", block);
      box.setAttribute("style", item2);
      fo.setAttribute("width", `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
      fo.setAttribute("height", `${Math.ceil(1 / Math.min(1, s) * 100)}%`);
      const yp = Math.round(y + dy);
      if (yp < 0) {
        fo.setAttribute("y", String(yp));
      } else {
        fo.removeAttribute("y");
        flex += `padding-top: ${yp}px; `;
      }
      div.setAttribute("style", `${flex}margin-left: ${Math.round(x + dx)}px;`);
      t += r !== 0 ? `rotate(${r} ${x} ${y})` : "";
      if (t !== "") {
        g.setAttribute("transform", t);
      } else {
        g.removeAttribute("transform");
      }
      if (this.state.alpha !== 1) {
        g.setAttribute("opacity", String(this.state.alpha));
      } else {
        g.removeAttribute("opacity");
      }
    });
  }
  /**
   * Private helper function to create SVG elements
   */
  getTextCss() {
    const s = this.state;
    const lh = ABSOLUTE_LINE_HEIGHT ? `${s.fontSize * LINE_HEIGHT}px` : LINE_HEIGHT * this.lineHeightCorrection;
    let css = `display: inline-block; font-size: ${s.fontSize}px; font-family: ${s.fontFamily}; color: ${s.fontColor}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? this.pointerEventsValue : "none"}; `;
    const fontStyle = s.fontStyle;
    matchBinaryMask(fontStyle, FONT.BOLD) && (css += "font-weight: bold; ");
    matchBinaryMask(fontStyle, FONT.ITALIC) && (css += "font-style: italic; ");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(" ")}; `);
    return css;
  }
  /**
   * Paints the given text. Possible values for format are empty string for plain
   * text and html for HTML markup. Note that HTML markup is only supported if
   * foreignObject is supported and <foEnabled> is true. (This means IE9 and later
   * does currently not support HTML text as part of shapes.)
   */
  text(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation = 0, dir) {
    if (this.textEnabled && str != null) {
      rotation = rotation != null ? rotation : 0;
      if (this.foEnabled && format === "html") {
        const div = this.createDiv(str);
        if (div != null) {
          if (dir != null) {
            div.setAttribute("dir", dir);
          }
          this.addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);
        }
      } else {
        this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);
      }
    }
  }
  /**
   * Creates a clip for the given coordinates.
   */
  createClip(x, y, w, h) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    const id2 = `mx-clip-${x}-${y}-${w}-${h}`;
    let counter = 0;
    let tmp2 = `${id2}-${counter}`;
    while (document.getElementById(tmp2) != null) {
      tmp2 = `${id2}-${++counter}`;
    }
    const clip = this.createElement("clipPath");
    clip.setAttribute("id", tmp2);
    const rect = this.createElement("rect");
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", String(y));
    rect.setAttribute("width", String(w));
    rect.setAttribute("height", String(h));
    clip.appendChild(rect);
    return clip;
  }
  /**
   * Paints the given text. Possible values for format are empty string for
   * plain text and html for HTML markup.
   */
  plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation = 0, dir) {
    const s = this.state;
    const size = s.fontSize;
    const node2 = this.createElement("g");
    let tr = s.transform || "";
    this.updateFont(node2);
    if (!this.pointerEvents && this.originalRoot == null) {
      node2.setAttribute("pointer-events", "none");
    }
    if (rotation !== 0) {
      tr += `rotate(${rotation},${this.format(x * s.scale)},${this.format(y * s.scale)})`;
    }
    if (dir != null) {
      node2.setAttribute("direction", dir);
    }
    if (clip && w > 0 && h > 0) {
      let cx = x;
      let cy2 = y;
      if (align === ALIGN.CENTER) {
        cx -= w / 2;
      } else if (align === ALIGN.RIGHT) {
        cx -= w;
      }
      if (overflow !== "fill") {
        if (valign === ALIGN.MIDDLE) {
          cy2 -= h / 2;
        } else if (valign === ALIGN.BOTTOM) {
          cy2 -= h;
        }
      }
      const c = this.createClip(cx * s.scale - 2, cy2 * s.scale - 2, w * s.scale + 4, h * s.scale + 4);
      if (this.defs != null) {
        this.defs.appendChild(c);
      } else {
        this.root.appendChild(c);
      }
      if (!Client_default.IS_CHROMEAPP && !Client_default.IS_EDGE && this.root.ownerDocument === document) {
        const base = this.getBaseUrl().replace(/([()])/g, "\\$1");
        node2.setAttribute("clip-path", `url(${base}#${c.getAttribute("id")})`);
      } else {
        node2.setAttribute("clip-path", `url(#${c.getAttribute("id")})`);
      }
    }
    const anchor = align === ALIGN.RIGHT ? "end" : align === ALIGN.CENTER ? "middle" : "start";
    if (anchor !== "start") {
      node2.setAttribute("text-anchor", anchor);
    }
    if (!this.styleEnabled || size !== DEFAULT_FONTSIZE) {
      node2.setAttribute("font-size", `${size * s.scale}px`);
    }
    if (tr.length > 0) {
      node2.setAttribute("transform", tr);
    }
    if (s.alpha < 1) {
      node2.setAttribute("opacity", String(s.alpha));
    }
    const lines = str.split("\n");
    const lh = Math.round(size * LINE_HEIGHT);
    const textHeight = size + (lines.length - 1) * lh;
    let cy = y + size - 1;
    if (valign === ALIGN.MIDDLE) {
      if (overflow === "fill") {
        cy -= h / 2;
      } else {
        const dy = (this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight) / 2;
        cy -= dy;
      }
    } else if (valign === ALIGN.BOTTOM) {
      if (overflow === "fill") {
        cy -= h;
      } else {
        const dy = this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight;
        cy -= dy + 1;
      }
    }
    for (let i2 = 0; i2 < lines.length; i2 += 1) {
      const line = trim(lines[i2]);
      if (line) {
        const text2 = this.createElement("text");
        text2.setAttribute("x", String(this.format(x * s.scale) + this.textOffset));
        text2.setAttribute("y", String(this.format(cy * s.scale) + this.textOffset));
        write(text2, line);
        node2.appendChild(text2);
      }
      cy += lh;
    }
    this.root.appendChild(node2);
    this.addTextBackground(node2, str, x, y, w, overflow === "fill" ? h : textHeight, align, valign, overflow);
  }
  /**
   * Updates the text properties for the given node. (NOTE: For this to work in
   * IE, the given node must be a text or tspan element.)
   */
  updateFont(node2) {
    const s = this.state;
    if (s.fontColor && s.fontColor !== NONE) {
      node2.setAttribute("fill", s.fontColor);
    }
    if (!this.styleEnabled || s.fontFamily !== DEFAULT_FONTFAMILY) {
      node2.setAttribute("font-family", s.fontFamily);
    }
    const fontStyle = s.fontStyle;
    matchBinaryMask(fontStyle, FONT.BOLD) && node2.setAttribute("font-weight", "bold");
    matchBinaryMask(fontStyle, FONT.ITALIC) && node2.setAttribute("font-style", "italic");
    const txtDecor = [];
    matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && node2.setAttribute("text-decoration", txtDecor.join(" "));
  }
  /**
   * Background color and border
   */
  addTextBackground(node2, str, x, y, w, h, align, valign, overflow) {
    var _a2;
    const s = this.state;
    if (s.fontBackgroundColor != null || s.fontBorderColor != null) {
      let bbox = null;
      if (overflow === "fill" || overflow === "width") {
        if (align === ALIGN.CENTER) {
          x -= w / 2;
        } else if (align === ALIGN.RIGHT) {
          x -= w;
        }
        if (valign === ALIGN.MIDDLE) {
          y -= h / 2;
        } else if (valign === ALIGN.BOTTOM) {
          y -= h;
        }
        bbox = new Rectangle_default((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);
      } else if (node2.getBBox != null && this.root.ownerDocument === document) {
        try {
          bbox = node2.getBBox();
          bbox = new Rectangle_default(bbox.x, bbox.y + 1, bbox.width, bbox.height + 0);
        } catch (e) {
        }
      }
      if (bbox == null || bbox.width === 0 || bbox.height === 0) {
        const div = document.createElement("div");
        div.style.lineHeight = ABSOLUTE_LINE_HEIGHT ? `${s.fontSize * LINE_HEIGHT}px` : String(LINE_HEIGHT);
        div.style.fontSize = `${s.fontSize}px`;
        div.style.fontFamily = s.fontFamily;
        div.style.whiteSpace = "nowrap";
        div.style.position = "absolute";
        div.style.visibility = "hidden";
        div.style.display = "inline-block";
        matchBinaryMask(s.fontStyle, FONT.BOLD) && (div.style.fontWeight = "bold");
        matchBinaryMask(s.fontStyle, FONT.ITALIC) && (div.style.fontStyle = "italic");
        str = htmlEntities(str, false);
        div.innerHTML = str.replace(/\n/g, "<br/>");
        document.body.appendChild(div);
        const w2 = div.offsetWidth;
        const h2 = div.offsetHeight;
        document.body.removeChild(div);
        if (align === ALIGN.CENTER) {
          x -= w2 / 2;
        } else if (align === ALIGN.RIGHT) {
          x -= w2;
        }
        if (valign === ALIGN.MIDDLE) {
          y -= h2 / 2;
        } else if (valign === ALIGN.BOTTOM) {
          y -= h2;
        }
        bbox = new Rectangle_default((x + 1) * s.scale, (y + 2) * s.scale, w2 * s.scale, (h2 + 1) * s.scale);
      }
      if (bbox != null) {
        const n = this.createElement("rect");
        n.setAttribute("fill", s.fontBackgroundColor || "none");
        n.setAttribute("stroke", s.fontBorderColor || "none");
        n.setAttribute("x", String(Math.floor(bbox.x - 1)));
        n.setAttribute("y", String(Math.floor(bbox.y - 1)));
        n.setAttribute("width", String(Math.ceil(bbox.width + 2)));
        n.setAttribute("height", String(Math.ceil(bbox.height)));
        const sw = s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;
        n.setAttribute("stroke-width", String(sw));
        if (((_a2 = this.root) == null ? void 0 : _a2.ownerDocument) === document && mod(sw, 2) === 1) {
          n.setAttribute("transform", "translate(0.5, 0.5)");
        }
        node2.insertBefore(n, node2.firstChild);
      }
    }
  }
  /**
   * Paints the outline of the current path.
   */
  stroke() {
    this.addNode(false, true);
  }
  /**
   * Fills the current path.
   */
  fill() {
    this.addNode(true, false);
  }
  /**
   * Fills and paints the outline of the current path.
   */
  fillAndStroke() {
    this.addNode(true, true);
  }
};
SvgCanvas2D.createCss = (w, h, align, valign, wrap, overflow, clip, bg, border, flex, block, scale, callback) => {
  let item2 = `box-sizing: border-box; font-size: 0; text-align: ${align === ALIGN.LEFT ? "left" : align === ALIGN.RIGHT ? "right" : "center"}; `;
  const pt = getAlignmentAsPoint(align, valign);
  let ofl = "overflow: hidden; ";
  let fw = "width: 1px; ";
  let fh = "height: 1px; ";
  let dx = pt.x * w;
  let dy = pt.y * h;
  if (clip) {
    fw = `width: ${Math.round(w)}px; `;
    item2 += `max-height: ${Math.round(h)}px; `;
    dy = 0;
  } else if (overflow === "fill") {
    fw = `width: ${Math.round(w)}px; `;
    fh = `height: ${Math.round(h)}px; `;
    block += "width: 100%; height: 100%; ";
    item2 += fw + fh;
  } else if (overflow === "width") {
    fw = `width: ${Math.round(w)}px; `;
    block += "width: 100%; ";
    item2 += fw;
    dy = 0;
    if (h > 0) {
      item2 += `max-height: ${Math.round(h)}px; `;
    }
  } else {
    ofl = "";
    dy = 0;
  }
  let bgc = "";
  if (bg) {
    bgc += `background-color: ${bg}; `;
  }
  if (border) {
    bgc += `border: 1px solid ${border}; `;
  }
  if (ofl == "" || clip) {
    block += bgc;
  } else {
    item2 += bgc;
  }
  if (wrap && w > 0) {
    block += `white-space: normal; word-wrap: ${WORD_WRAP}; `;
    fw = `width: ${Math.round(w)}px; `;
    if (ofl !== "" && overflow !== "fill") {
      dy = 0;
    }
  } else {
    block += "white-space: nowrap; ";
    if (ofl === "") {
      dx = 0;
    }
  }
  callback(dx, dy, flex + fw + fh, item2 + ofl, block, ofl);
};
var SvgCanvas2D_default = SvgCanvas2D;

// node_modules/@maxgraph/core/lib/view/geometry/Shape.js
var Shape = class {
  constructor(stencil = null) {
    this.preserveImageAspect = false;
    this.overlay = null;
    this.indicator = null;
    this.indicatorShape = null;
    this.opacity = 100;
    this.isDashed = false;
    this.fill = NONE;
    this.gradient = NONE;
    this.gradientDirection = DIRECTION.EAST;
    this.fillOpacity = 100;
    this.strokeOpacity = 100;
    this.stroke = NONE;
    this.strokeWidth = 1;
    this.spacing = 0;
    this.startSize = 1;
    this.endSize = 1;
    this.startArrow = NONE;
    this.endArrow = NONE;
    this.direction = DIRECTION.EAST;
    this.flipH = false;
    this.flipV = false;
    this.isShadow = false;
    this.isRounded = false;
    this.rotation = 0;
    this.cursor = "";
    this.verticalTextRotation = 0;
    this.oldGradients = {};
    this.glass = false;
    this.dialect = null;
    this.scale = 1;
    this.antiAlias = true;
    this.minSvgStrokeWidth = 1;
    this.bounds = null;
    this.points = [];
    this.state = null;
    this.style = null;
    this.boundingBox = null;
    this.stencil = null;
    this.svgStrokeTolerance = 8;
    this.pointerEvents = true;
    this.originalPointerEvents = null;
    this.svgPointerEvents = "all";
    this.shapePointerEvents = false;
    this.stencilPointerEvents = false;
    this.outline = false;
    this.visible = true;
    this.useSvgBoundingBox = true;
    this.image = null;
    this.imageSrc = null;
    this.indicatorColor = NONE;
    this.indicatorStrokeColor = NONE;
    this.indicatorGradientColor = NONE;
    this.indicatorDirection = DIRECTION.EAST;
    this.indicatorImageSrc = null;
    if (stencil) {
      this.stencil = stencil;
    }
    this.node = this.create();
  }
  /**
   * Initializes the shape by creaing the DOM node using <create>
   * and adding it into the given container.
   *
   * @param container DOM node that will contain the shape.
   */
  init(container) {
    if (!this.node.parentNode) {
      container.appendChild(this.node);
    }
  }
  /**
   * Sets the styles to their default values.
   */
  initStyles() {
    this.strokeWidth = 1;
    this.rotation = 0;
    this.opacity = 100;
    this.fillOpacity = 100;
    this.strokeOpacity = 100;
    this.flipH = false;
    this.flipV = false;
  }
  /**
   * Returns true if HTML is allowed for this shape. This implementation always
   * returns false.
   */
  isHtmlAllowed() {
    return false;
  }
  /**
   * Returns 0, or 0.5 if <strokewidth> % 2 == 1.
   */
  getSvgScreenOffset() {
    const sw = this.stencil && this.stencil.strokeWidthValue !== "inherit" ? Number(this.stencil.strokeWidthValue) : this.strokeWidth ?? 0;
    return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;
  }
  /**
   * Creates and returns the DOM node for the shape.
   * This implementation assumes that `maxGraph` produces SVG elements.
   */
  create() {
    return document.createElementNS("http://www.w3.org/2000/svg", "g");
  }
  redraw() {
    this.updateBoundsFromPoints();
    if (this.visible && this.checkBounds()) {
      this.node.style.visibility = "visible";
      this.clear();
      this.redrawShape();
      this.updateBoundingBox();
    } else {
      this.node.style.visibility = "hidden";
      this.boundingBox = null;
    }
  }
  /**
   * Removes all child nodes and resets all CSS.
   */
  clear() {
    while (this.node.lastChild) {
      this.node.removeChild(this.node.lastChild);
    }
  }
  /**
   * Updates the bounds based on the points.
   */
  updateBoundsFromPoints() {
    const pts = this.points;
    if (pts.length > 0 && pts[0]) {
      this.bounds = new Rectangle_default(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);
      for (const pt of pts) {
        if (pt) {
          this.bounds.add(new Rectangle_default(Math.round(pt.x), Math.round(pt.y), 1, 1));
        }
      }
    }
  }
  /**
   * Returns the {@link Rectangle} for the label bounds of this shape, based on the
   * given scaled and translated bounds of the shape. This method should not
   * change the rectangle in-place. This implementation returns the given rect.
   */
  getLabelBounds(rect) {
    var _a2, _b, _c;
    const d = ((_a2 = this.style) == null ? void 0 : _a2.direction) ?? DIRECTION.EAST;
    let bounds = rect.clone();
    if (d !== DIRECTION.SOUTH && d !== DIRECTION.NORTH && this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
      bounds = bounds.clone();
      [bounds.width, bounds.height] = [bounds.height, bounds.width];
    }
    let labelMargins = this.getLabelMargins(bounds);
    if (labelMargins) {
      labelMargins = labelMargins.clone();
      let flipH = ((_b = this.style) == null ? void 0 : _b.flipH) ?? false;
      let flipV = ((_c = this.style) == null ? void 0 : _c.flipV) ?? false;
      if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {
        const tmp2 = labelMargins.x;
        labelMargins.x = labelMargins.height;
        labelMargins.height = labelMargins.width;
        labelMargins.width = labelMargins.y;
        labelMargins.y = tmp2;
        [flipH, flipV] = [flipV, flipH];
      }
      return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);
    }
    return rect;
  }
  /**
   * Returns the scaled top, left, bottom and right margin to be used for
   * computing the label bounds as an {@link Rectangle}, where the bottom and right
   * margin are defined in the width and height of the rectangle, respectively.
   */
  getLabelMargins(rect) {
    return null;
  }
  /**
   * Returns true if the bounds are not null and all of its variables are numeric.
   */
  checkBounds() {
    return !Number.isNaN(this.scale) && Number.isFinite(this.scale) && this.scale > 0 && this.bounds && !Number.isNaN(this.bounds.x) && !Number.isNaN(this.bounds.y) && !Number.isNaN(this.bounds.width) && !Number.isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;
  }
  /**
   * Updates the SVG or VML shape.
   */
  redrawShape() {
    const canvas = this.createCanvas();
    if (canvas) {
      canvas.pointerEvents = this.pointerEvents;
      this.beforePaint(canvas);
      this.paint(canvas);
      this.afterPaint(canvas);
      if (this.node !== canvas.root && canvas.root) {
        this.node.insertAdjacentHTML("beforeend", canvas.root.outerHTML);
      }
      this.destroyCanvas(canvas);
    }
  }
  /**
   * Creates a new canvas for drawing this shape. May return null.
   */
  createCanvas() {
    const canvas = this.createSvgCanvas();
    if (canvas && this.outline) {
      canvas.setStrokeWidth(this.strokeWidth);
      canvas.setStrokeColor(this.stroke);
      if (this.isDashed) {
        canvas.setDashed(this.isDashed);
      }
      canvas.setStrokeWidth = () => {
        return;
      };
      canvas.setStrokeColor = () => {
        return;
      };
      canvas.setFillColor = () => {
        return;
      };
      canvas.setGradient = () => {
        return;
      };
      canvas.setDashed = () => {
        return;
      };
      canvas.text = () => {
        return;
      };
    }
    return canvas;
  }
  /**
   * Creates and returns an {@link SvgCanvas2D} for rendering this shape.
   */
  createSvgCanvas() {
    if (!this.node)
      return null;
    const canvas = new SvgCanvas2D_default(this.node, false);
    canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;
    canvas.pointerEventsValue = this.svgPointerEvents;
    const off = this.getSvgScreenOffset();
    if (off !== 0) {
      this.node.setAttribute("transform", `translate(${off},${off})`);
    } else {
      this.node.removeAttribute("transform");
    }
    canvas.minStrokeWidth = this.minSvgStrokeWidth;
    if (!this.antiAlias) {
      canvas.format = (value2) => {
        return Math.round(value2);
      };
    }
    return canvas;
  }
  /**
   * Destroys the given canvas which was used for drawing. This implementation
   * increments the reference counts on all shared gradients used in the canvas.
   */
  destroyCanvas(canvas) {
    if (canvas instanceof SvgCanvas2D_default) {
      for (const key2 in canvas.gradients) {
        const gradient = canvas.gradients[key2];
        if (gradient) {
          gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;
        }
      }
      this.releaseSvgGradients(this.oldGradients);
      this.oldGradients = canvas.gradients;
    }
  }
  /**
   * Invoked before paint is called.
   */
  beforePaint(c) {
    return;
  }
  /**
   * Invokes after paint was called.
   */
  afterPaint(c) {
    return;
  }
  /**
   * Generic rendering code.
   */
  paint(c) {
    let strokeDrawn = false;
    if (c && this.outline) {
      const { stroke } = c;
      c.stroke = (...args) => {
        strokeDrawn = true;
        stroke.apply(c, args);
      };
      const { fillAndStroke } = c;
      c.fillAndStroke = (...args) => {
        strokeDrawn = true;
        fillAndStroke.apply(c, args);
      };
    }
    const s = this.scale;
    const bounds = this.bounds;
    if (bounds) {
      let x = bounds.x / s;
      let y = bounds.y / s;
      let w = bounds.width / s;
      let h = bounds.height / s;
      if (this.isPaintBoundsInverted()) {
        const t = (w - h) / 2;
        x += t;
        y -= t;
        const tmp2 = w;
        w = h;
        h = tmp2;
      }
      this.updateTransform(c, x, y, w, h);
      this.configureCanvas(c, x, y, w, h);
      let bg = null;
      if (!this.stencil && this.points.length === 0 && this.shapePointerEvents || this.stencil && this.stencilPointerEvents) {
        const bb = this.createBoundingBox();
        if (bb && this.node) {
          bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);
          this.node.appendChild(bg);
        }
      }
      if (this.stencil) {
        this.stencil.drawShape(c, this, x, y, w, h);
      } else {
        c.setStrokeWidth(this.strokeWidth);
        if (this.points.length > 0) {
          const pts = [];
          for (let i2 = 0; i2 < this.points.length; i2 += 1) {
            const p = this.points[i2];
            if (p) {
              pts.push(new Point_default(p.x / s, p.y / s));
            }
          }
          this.paintEdgeShape(c, pts);
        } else {
          this.paintVertexShape(c, x, y, w, h);
        }
      }
      if (bg && c.state && isNotNullish(c.state.transform)) {
        bg.setAttribute("transform", c.state.transform);
      }
      if (c && this.outline && !strokeDrawn) {
        c.rect(x, y, w, h);
        c.stroke();
      }
    }
  }
  /**
   * Sets the state of the canvas for drawing the shape.
   */
  configureCanvas(c, x, y, w, h) {
    var _a2;
    let dash = null;
    if (this.style && this.style.dashPattern != null) {
      dash = this.style.dashPattern;
    }
    c.setAlpha(this.opacity / 100);
    c.setFillAlpha(this.fillOpacity / 100);
    c.setStrokeAlpha(this.strokeOpacity / 100);
    if (this.isShadow) {
      c.setShadow(this.isShadow);
    }
    if (this.isDashed) {
      c.setDashed(this.isDashed, ((_a2 = this.style) == null ? void 0 : _a2.fixDash) ?? false);
    }
    if (dash) {
      c.setDashPattern(dash);
    }
    if (this.fill !== NONE && this.gradient !== NONE) {
      const b = this.getGradientBounds(c, x, y, w, h);
      c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);
    } else {
      c.setFillColor(this.fill);
    }
    c.setStrokeColor(this.stroke);
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getGradientBounds(c, x, y, w, h) {
    return new Rectangle_default(x, y, w, h);
  }
  /**
   * Sets the scale and rotation on the given canvas.
   */
  updateTransform(c, x, y, w, h) {
    c.scale(this.scale);
    c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);
  }
  /**
   * Paints the vertex shape.
   */
  paintVertexShape(c, x, y, w, h) {
    this.paintBackground(c, x, y, w, h);
    if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
      c.setShadow(false);
      this.paintForeground(c, x, y, w, h);
    }
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintBackground(c, x, y, w, h) {
    return;
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintForeground(c, x, y, w, h) {
    return;
  }
  /**
   * Hook for subclassers. This implementation is empty.
   */
  paintEdgeShape(c, pts) {
    return;
  }
  /**
   * Returns the arc size for the given dimension.
   */
  getArcSize(w, h) {
    var _a2, _b, _c;
    let r = 0;
    if (((_a2 = this.style) == null ? void 0 : _a2.absoluteArcSize) ?? false) {
      r = Math.min(w / 2, Math.min(h / 2, (((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE) / 2));
    } else {
      const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
      r = Math.min(w * f, h * f);
    }
    return r;
  }
  /**
   * Paints the glass gradient effect.
   */
  paintGlassEffect(c, x, y, w, h, arc) {
    const sw = Math.ceil((this.strokeWidth ?? 0) / 2);
    const size = 0.4;
    c.setGradient("#ffffff", "#ffffff", x, y, w, h * 0.6, "south", 0.9, 0.1);
    c.begin();
    arc += 2 * sw;
    if (this.isRounded) {
      c.moveTo(x - sw + arc, y - sw);
      c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);
      c.lineTo(x - sw, y + h * size);
      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
      c.lineTo(x + w + sw, y - sw + arc);
      c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);
    } else {
      c.moveTo(x - sw, y - sw);
      c.lineTo(x - sw, y + h * size);
      c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);
      c.lineTo(x + w + sw, y - sw);
    }
    c.close();
    c.fill();
  }
  /**
   * Paints the given points with rounded corners.
   */
  addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {
    if (pts.length > 0) {
      const pe = pts[pts.length - 1];
      if (close && rounded) {
        pts = pts.slice();
        const p0 = pts[0];
        const wp = new Point_default(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);
        pts.splice(0, 0, wp);
      }
      let pt = pts[0];
      let i2 = 1;
      if (initialMove) {
        c.moveTo(pt.x, pt.y);
      } else {
        c.lineTo(pt.x, pt.y);
      }
      while (i2 < (close ? pts.length : pts.length - 1)) {
        let tmp2 = pts[mod(i2, pts.length)];
        let dx = pt.x - tmp2.x;
        let dy = pt.y - tmp2.y;
        if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i2 - 1) < 0) {
          let dist = Math.sqrt(dx * dx + dy * dy);
          const nx1 = dx * Math.min(arcSize, dist / 2) / dist;
          const ny1 = dy * Math.min(arcSize, dist / 2) / dist;
          const x1 = tmp2.x + nx1;
          const y1 = tmp2.y + ny1;
          c.lineTo(x1, y1);
          let next = pts[mod(i2 + 1, pts.length)];
          while (i2 < pts.length - 2 && Math.round(next.x - tmp2.x) === 0 && Math.round(next.y - tmp2.y) === 0) {
            next = pts[mod(i2 + 2, pts.length)];
            i2++;
          }
          dx = next.x - tmp2.x;
          dy = next.y - tmp2.y;
          dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
          const nx2 = dx * Math.min(arcSize, dist / 2) / dist;
          const ny2 = dy * Math.min(arcSize, dist / 2) / dist;
          const x2 = tmp2.x + nx2;
          const y2 = tmp2.y + ny2;
          c.quadTo(tmp2.x, tmp2.y, x2, y2);
          tmp2 = new Point_default(x2, y2);
        } else {
          c.lineTo(tmp2.x, tmp2.y);
        }
        pt = tmp2;
        i2 += 1;
      }
      if (close) {
        c.close();
      } else {
        c.lineTo(pe.x, pe.y);
      }
    }
  }
  /**
   * Resets all styles.
   */
  resetStyles() {
    this.initStyles();
    this.spacing = 0;
    this.fill = NONE;
    this.gradient = NONE;
    this.gradientDirection = DIRECTION.EAST;
    this.stroke = NONE;
    this.startSize = 1;
    this.endSize = 1;
    this.startArrow = NONE;
    this.endArrow = NONE;
    this.direction = DIRECTION.EAST;
    this.isShadow = false;
    this.isDashed = false;
    this.isRounded = false;
    this.glass = false;
  }
  /**
   * Applies the style of the given <CellState> to the shape. This
   * implementation assigns the following styles to local fields:
   *
   * - <'fillColor'> => fill
   * - <'gradientColor'> => gradient
   * - <'gradientDirection'> => gradientDirection
   * - <'opacity'> => opacity
   * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity
   * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity
   * - <'strokeColor'> => stroke
   * - <'strokeWidth'> => strokewidth
   * - <'shadow'> => isShadow
   * - <'dashed'> => isDashed
   * - <'spacing'> => spacing
   * - <'startSize'> => startSize
   * - <'endSize'> => endSize
   * - <'rounded'> => isRounded
   * - <'startArrow'> => startArrow
   * - <'endArrow'> => endArrow
   * - <'rotation'> => rotation
   * - <'direction'> => direction
   * - <'glass'> => glass
   *
   * This keeps a reference to the <style>. If you need to keep a reference to
   * the cell, you can override this method and store a local reference to
   * state.cell or the <CellState> itself. If <outline> should be true, make
   * sure to set it before calling this method.
   *
   * @param state <CellState> of the corresponding cell.
   */
  apply(state2) {
    this.state = state2;
    this.style = state2.style;
    if (this.style) {
      this.fill = this.style.fillColor ?? this.fill;
      this.gradient = this.style.gradientColor ?? this.gradient;
      this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;
      this.opacity = this.style.opacity ?? this.opacity;
      this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;
      this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;
      this.stroke = this.style.strokeColor ?? this.stroke;
      this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;
      this.spacing = this.style.spacing ?? this.spacing;
      this.startSize = this.style.startSize ?? this.startSize;
      this.endSize = this.style.endSize ?? this.endSize;
      this.startArrow = this.style.startArrow ?? this.startArrow;
      this.endArrow = this.style.endArrow ?? this.endArrow;
      this.rotation = this.style.rotation ?? this.rotation;
      this.direction = this.style.direction ?? this.direction;
      this.flipH = !!this.style.flipH;
      this.flipV = !!this.style.flipV;
      if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {
        const tmp2 = this.flipH;
        this.flipH = this.flipV;
        this.flipV = tmp2;
      }
      this.isShadow = this.style.shadow ?? this.isShadow;
      this.isDashed = this.style.dashed ?? this.isDashed;
      this.isRounded = this.style.rounded ?? this.isRounded;
      this.glass = this.style.glass ?? this.glass;
    }
  }
  /**
   * Sets the cursor on the given shape.
   *
   * @param cursor The cursor to be used.
   */
  setCursor(cursor) {
    this.cursor = cursor;
    this.node.style.cursor = cursor;
  }
  /**
   * Returns the current cursor.
   */
  getCursor() {
    return this.cursor;
  }
  /**
   * Hook for subclassers.
   */
  isRoundable(c, x, y, w, h) {
    return false;
  }
  /**
   * Updates the <boundingBox> for this shape using <createBoundingBox> and
   * <augmentBoundingBox> and stores the result in <boundingBox>.
   */
  updateBoundingBox() {
    if (this.useSvgBoundingBox && this.node.ownerSVGElement) {
      try {
        const b = this.node.getBBox();
        if (b.width > 0 && b.height > 0) {
          this.boundingBox = new Rectangle_default(b.x, b.y, b.width, b.height);
          this.boundingBox.grow((this.strokeWidth ?? 0) * this.scale / 2);
          return;
        }
      } catch (e) {
      }
    }
    if (this.bounds) {
      let bbox = this.createBoundingBox();
      if (bbox) {
        this.augmentBoundingBox(bbox);
        const rot = this.getShapeRotation();
        if (rot !== 0) {
          bbox = getBoundingBox(bbox, rot);
        }
      }
      this.boundingBox = bbox;
    }
  }
  /**
   * Returns a new rectangle that represents the bounding box of the bare shape
   * with no shadows or strokewidths.
   */
  createBoundingBox() {
    if (!this.bounds)
      return null;
    const bb = this.bounds.clone();
    if (this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) || this.isPaintBoundsInverted()) {
      bb.rotate90();
    }
    return bb;
  }
  /**
   * Augments the bounding box with the strokewidth and shadow offsets.
   */
  augmentBoundingBox(bbox) {
    if (this.isShadow) {
      bbox.width += Math.ceil(SHADOW_OFFSET_X * this.scale);
      bbox.height += Math.ceil(SHADOW_OFFSET_Y * this.scale);
    }
    bbox.grow((this.strokeWidth ?? 0) * this.scale / 2);
  }
  /**
   * Returns true if the bounds should be inverted.
   */
  isPaintBoundsInverted() {
    return !this.stencil && (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH);
  }
  /**
   * Returns the rotation from the style.
   */
  getRotation() {
    return this.rotation ?? 0;
  }
  /**
   * Returns the rotation for the text label.
   */
  getTextRotation() {
    var _a2;
    let rot = this.getRotation();
    if (!(((_a2 = this.style) == null ? void 0 : _a2.horizontal) ?? true)) {
      rot += this.verticalTextRotation || -90;
    }
    return rot;
  }
  /**
   * Returns the actual rotation of the shape.
   */
  getShapeRotation() {
    let rot = this.getRotation();
    if (this.direction === DIRECTION.NORTH) {
      rot += 270;
    } else if (this.direction === DIRECTION.WEST) {
      rot += 180;
    } else if (this.direction === DIRECTION.SOUTH) {
      rot += 90;
    }
    return rot;
  }
  /**
   * Adds a transparent rectangle that catches all events.
   */
  createTransparentSvgRectangle(x, y, w, h) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", String(x));
    rect.setAttribute("y", String(y));
    rect.setAttribute("width", String(w));
    rect.setAttribute("height", String(h));
    rect.setAttribute("fill", NONE);
    rect.setAttribute("stroke", NONE);
    rect.setAttribute("pointer-events", "all");
    return rect;
  }
  redrawHtmlShape() {
    return;
  }
  /**
   * Sets a transparent background CSS style to catch all events.
   *
   * Paints the line shape.
   */
  setTransparentBackgroundImage(node2) {
    node2.style.backgroundImage = `url('${Client_default.imageBasePath}/transparent.gif')`;
  }
  /**
   * Paints the line shape.
   */
  releaseSvgGradients(grads) {
    for (const key2 in grads) {
      const gradient = grads[key2];
      if (gradient) {
        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;
        if (gradient.mxRefCount === 0 && gradient.parentNode) {
          gradient.parentNode.removeChild(gradient);
        }
      }
    }
  }
  /**
   * Destroys the shape by removing it from the DOM and releasing the DOM
   * node associated with the shape using {@link Event#release}.
   */
  destroy() {
    InternalEvent_default.release(this.node);
    if (this.node.parentNode) {
      this.node.parentNode.removeChild(this.node);
    }
    this.node.innerHTML = "";
    this.releaseSvgGradients(this.oldGradients);
    this.oldGradients = {};
  }
};
var Shape_default = Shape;

// node_modules/@maxgraph/core/lib/view/geometry/node/RectangleShape.js
var RectangleShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Returns true for non-rounded, non-rotated shapes with no glass gradient.
   */
  isHtmlAllowed() {
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    return !this.isRounded && !this.glass && this.rotation === 0 && (events || this.fill !== NONE);
  }
  /**
   * Generic background painting implementation.
   */
  paintBackground(c, x, y, w, h) {
    var _a2, _b, _c;
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (events || this.fill !== NONE || this.stroke !== NONE) {
      if (!events && this.fill === NONE) {
        c.pointerEvents = false;
      }
      if (this.isRounded) {
        let r = 0;
        if (((_a2 = this.style) == null ? void 0 : _a2.absoluteArcSize) ?? false) {
          r = Math.min(w / 2, Math.min(h / 2, (((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE) / 2));
        } else {
          const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
          r = Math.min(w * f, h * f);
        }
        c.roundrect(x, y, w, h, r, r);
      } else {
        c.rect(x, y, w, h);
      }
      c.fillAndStroke();
    }
  }
  /**
   * Adds roundable support.
   */
  isRoundable(c, x, y, w, h) {
    return true;
  }
  /**
   * Generic background painting implementation.
   */
  paintForeground(c, x, y, w, h) {
    if (this.glass && !this.outline && this.fill !== NONE) {
      this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokeWidth, h + this.strokeWidth));
    }
  }
};
var RectangleShape_default = RectangleShape;

// node_modules/@maxgraph/core/lib/view/cell/CellState.js
var CellState = class _CellState extends Rectangle_default {
  /**
   * Constructs a new object that represents the current state of the given Cell in the specified view.
   *
   * @param view {@link GraphView} that contains the state.
   * @param cell {@link Cell} that this state represents.
   * @param style the style of the Cell.
   */
  constructor(view = null, cell2 = null, style2 = null) {
    super();
    this.node = null;
    this.cellBounds = null;
    this.paintBounds = null;
    this.boundingBox = null;
    this.control = null;
    this.overlays = new Dictionary_default();
    this.invalidStyle = false;
    this.invalid = true;
    this.absolutePoints = [];
    this.visibleSourceState = null;
    this.visibleTargetState = null;
    this.terminalDistance = 0;
    this.length = 0;
    this.segments = [];
    this.shape = null;
    this.text = null;
    this.unscaledWidth = 0;
    this.unscaledHeight = 0;
    this.parentHighlight = null;
    this.point = null;
    if (view) {
      this.view = view;
    }
    if (cell2) {
      this.cell = cell2;
    }
    this.style = style2 ?? {};
    this.origin = new Point_default();
    this.absoluteOffset = new Point_default();
  }
  /**
   * Returns the {@link Rectangle} that should be used as the perimeter of the
   * cell.
   *
   * @param border Optional border to be added around the perimeter bounds.
   * @param bounds Optional {@link Rectangle} to be used as the initial bounds.
   */
  getPerimeterBounds(border = 0, bounds = new Rectangle_default(this.x, this.y, this.width, this.height)) {
    var _a2, _b;
    if (((_b = (_a2 = this.shape) == null ? void 0 : _a2.stencil) == null ? void 0 : _b.aspect) === "fixed") {
      const aspect = this.shape.stencil.computeAspect(this.shape, bounds.x, bounds.y, bounds.width, bounds.height);
      bounds.x = aspect.x;
      bounds.y = aspect.y;
      bounds.width = this.shape.stencil.w0 * aspect.width;
      bounds.height = this.shape.stencil.h0 * aspect.height;
    }
    if (border !== 0) {
      bounds.grow(border);
    }
    return bounds;
  }
  /**
   * Sets the first or last point in <absolutePoints> depending on isSource.
   *
   * @param point {@link Point} that represents the terminal point.
   * @param isSource Boolean that specifies if the first or last point should
   * be assigned.
   */
  setAbsoluteTerminalPoint(point, isSource = false) {
    if (isSource) {
      if (this.absolutePoints.length === 0) {
        this.absolutePoints.push(point);
      } else {
        this.absolutePoints[0] = point;
      }
    } else if (this.absolutePoints.length === 0) {
      this.absolutePoints.push(null);
      this.absolutePoints.push(point);
    } else if (this.absolutePoints.length === 1) {
      this.absolutePoints.push(point);
    } else {
      this.absolutePoints[this.absolutePoints.length - 1] = point;
    }
  }
  /**
   * Sets the given cursor on the shape and text shape.
   */
  setCursor(cursor) {
    if (this.shape) {
      this.shape.setCursor(cursor);
    }
    if (this.text) {
      this.text.setCursor(cursor);
    }
  }
  /**
   * Returns the visible source or target terminal cell.
   *
   * @param source Boolean that specifies if the source or target cell should be
   * returned.
   */
  getVisibleTerminal(source2 = false) {
    var _a2;
    return ((_a2 = this.getVisibleTerminalState(source2)) == null ? void 0 : _a2.cell) ?? null;
  }
  /**
   * Returns the visible source or target terminal state.
   *
   * @param source Boolean that specifies if the source or target state should be
   * returned.
   */
  getVisibleTerminalState(source2 = false) {
    return source2 ? this.visibleSourceState : this.visibleTargetState;
  }
  /**
   * Sets the visible source or target terminal state.
   *
   * @param terminalState <CellState> that represents the terminal.
   * @param source Boolean that specifies if the source or target state should be set.
   */
  setVisibleTerminalState(terminalState, source2 = false) {
    if (source2) {
      this.visibleSourceState = terminalState;
    } else {
      this.visibleTargetState = terminalState;
    }
  }
  /**
   * Returns the unscaled, untranslated bounds.
   */
  getCellBounds() {
    return this.cellBounds;
  }
  /**
   * Returns the unscaled, untranslated paint bounds. This is the same as
   * <getCellBounds> but with a 90 degree rotation if the shape's
   * isPaintBoundsInverted returns true.
   */
  getPaintBounds() {
    return this.paintBounds;
  }
  /**
   * Updates the cellBounds and paintBounds.
   */
  updateCachedBounds() {
    const view = this.view;
    const tr = view.translate;
    const s = view.scale;
    this.cellBounds = new Rectangle_default(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);
    this.paintBounds = Rectangle_default.fromRectangle(this.cellBounds);
    if (this.shape && this.shape.isPaintBoundsInverted()) {
      this.paintBounds.rotate90();
    }
  }
  /**
   * Destructor: setState
   *
   * Copies all fields from the given state to this state.
   */
  setState(state2) {
    this.view = state2.view;
    this.cell = state2.cell;
    this.style = state2.style;
    this.absolutePoints = state2.absolutePoints;
    this.origin = state2.origin;
    this.absoluteOffset = state2.absoluteOffset;
    this.boundingBox = state2.boundingBox;
    this.terminalDistance = state2.terminalDistance;
    this.segments = state2.segments;
    this.length = state2.length;
    this.x = state2.x;
    this.y = state2.y;
    this.width = state2.width;
    this.height = state2.height;
    this.unscaledWidth = state2.unscaledWidth;
    this.unscaledHeight = state2.unscaledHeight;
  }
  /**
   * Returns a clone of this {@link Point}.
   */
  clone() {
    const clone2 = new _CellState(this.view, this.cell, this.style);
    for (let i2 = 0; i2 < this.absolutePoints.length; i2 += 1) {
      const p = this.absolutePoints[i2];
      clone2.absolutePoints[i2] = p ? p.clone() : null;
    }
    if (this.origin) {
      clone2.origin = this.origin.clone();
    }
    if (this.absoluteOffset) {
      clone2.absoluteOffset = this.absoluteOffset.clone();
    }
    if (this.boundingBox) {
      clone2.boundingBox = this.boundingBox.clone();
    }
    clone2.terminalDistance = this.terminalDistance;
    clone2.segments = this.segments;
    clone2.length = this.length;
    clone2.x = this.x;
    clone2.y = this.y;
    clone2.width = this.width;
    clone2.height = this.height;
    clone2.unscaledWidth = this.unscaledWidth;
    clone2.unscaledHeight = this.unscaledHeight;
    return clone2;
  }
  /**
   * Destructor: destroy
   *
   * Destroys the state and all associated resources.
   */
  destroy() {
    this.view.graph.cellRenderer.destroy(this);
  }
  /**
   * Returns true if the given cell state is a loop.
   *
   * @param state {@link CellState} that represents a potential loop.
   */
  isLoop(state2) {
    const src = this.getVisibleTerminalState(true);
    return src && src === this.getVisibleTerminalState(false);
  }
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  /**
   * Returns the vertical alignment for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.verticalAlign}
   * property of {@link style}.
   */
  getVerticalAlign() {
    return this.style.verticalAlign ?? ALIGN.MIDDLE;
  }
  /**
   * Returns `true` if the given state has no stroke, no fill color and no image.
   */
  isTransparentState() {
    return (this.style.strokeColor ?? NONE) === NONE && (this.style.fillColor ?? NONE) === NONE && !this.getImageSrc();
  }
  /**
   * Returns the image URL for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.image} property
   * of {@link style}.
   */
  getImageSrc() {
    return this.style.image || null;
  }
  /**
   * Returns the indicator color for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorColor}
   * property of {@link style}.
   */
  getIndicatorColor() {
    return this.style.indicatorColor || null;
  }
  /**
   * Returns the indicator gradient color for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.gradientColor}
   * property of {@link style}.
   */
  getIndicatorGradientColor() {
    return this.style.gradientColor || null;
  }
  /**
   * Returns the indicator shape for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorShape}
   * property of {@link style}.
   */
  getIndicatorShape() {
    return this.style.indicatorShape || null;
  }
  /**
   * Returns the indicator image for the given cell state.
   * This implementation returns the value stored in the {@link CellStateStyle.indicatorImage}
   * property of {@link style}.
   */
  getIndicatorImageSrc() {
    return this.style.indicatorImage || null;
  }
};
var CellState_default = CellState;

// node_modules/@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js
var UndoableEdit = class {
  constructor(source2, significant = true) {
    this.changes = [];
    this.significant = true;
    this.undone = false;
    this.redone = false;
    this.source = source2;
    this.changes = [];
    this.significant = significant;
  }
  /**
   * Returns true if the this edit contains no changes.
   */
  isEmpty() {
    return this.changes.length === 0;
  }
  /**
   * Returns <significant>.
   */
  isSignificant() {
    return this.significant;
  }
  /**
   * Adds the specified change to this edit. The change is an object that is
   * expected to either have an undo and redo, or an execute function.
   */
  add(change) {
    this.changes.push(change);
  }
  /**
   * Hook to notify any listeners of the changes after an <undo> or <redo>
   * has been carried out. This implementation is empty.
   */
  notify() {
    return;
  }
  /**
   * Hook to free resources after the edit has been removed from the command
   * history. This implementation is empty.
   */
  die() {
    return;
  }
  /**
   * Undoes all changes in this edit.
   */
  undo() {
    if (!this.undone) {
      this.source.fireEvent(new EventObject_default(InternalEvent_default.START_EDIT));
      const count = this.changes.length;
      for (let i2 = count - 1; i2 >= 0; i2--) {
        const change = this.changes[i2];
        if (change.execute) {
          change.execute();
        } else if (change.undo) {
          change.undo();
        }
        this.source.fireEvent(new EventObject_default(InternalEvent_default.EXECUTED, { change }));
      }
      this.undone = true;
      this.redone = false;
      this.source.fireEvent(new EventObject_default(InternalEvent_default.END_EDIT));
    }
    this.notify();
  }
  /**
   * Redoes all changes in this edit.
   */
  redo() {
    if (!this.redone) {
      this.source.fireEvent(new EventObject_default(InternalEvent_default.START_EDIT));
      const count = this.changes.length;
      for (let i2 = 0; i2 < count; i2 += 1) {
        const change = this.changes[i2];
        if (change.execute != null) {
          change.execute();
        } else if (change.redo != null) {
          change.redo();
        }
        this.source.fireEvent(new EventObject_default(InternalEvent_default.EXECUTED, { change }));
      }
      this.undone = false;
      this.redone = true;
      this.source.fireEvent(new EventObject_default(InternalEvent_default.END_EDIT));
    }
    this.notify();
  }
};
var UndoableEdit_default = UndoableEdit;

// node_modules/@maxgraph/core/lib/view/geometry/node/ImageShape.js
var ImageShape = class extends RectangleShape_default {
  constructor(bounds, imageSrc, fill = "#FFFFFF", stroke = "#000000", strokeWidth = 1) {
    super(bounds, fill, stroke, strokeWidth);
    this.overlay = null;
    this.preserveImageAspect = true;
    this.imageSrc = imageSrc;
    this.shadow = false;
  }
  /**
   * Disables offset in IE9 for crisper image output.
   */
  getSvgScreenOffset() {
    return 0;
  }
  /**
   * Overrides to replace the fill and stroke colors with the respective values from {@link imageBackground} and {@link imageBorder}.
   *
   * Applies the style of the given {@link CellState} to the shape. This implementation assigns the following styles to local fields:
   *
   * - {@link imageBackground} => fill
   * - {@link imageBorder} => stroke
   *
   * @param {CellState} state   {@link CellState} of the corresponding cell.
   */
  apply(state2) {
    super.apply(state2);
    this.fill = NONE;
    this.stroke = NONE;
    this.gradient = NONE;
    if (this.style && this.style.imageAspect != null) {
      this.preserveImageAspect = this.style.imageAspect;
    }
  }
  /**
   * Returns true if HTML is allowed for this shape. This implementation always
   * returns false.
   */
  isHtmlAllowed() {
    return !this.preserveImageAspect;
  }
  /**
   * Disables inherited roundable support.
   */
  isRoundable(c, x, y, w, h) {
    return false;
  }
  /**
   * Generic background painting implementation.
   */
  paintVertexShape(c, x, y, w, h) {
    var _a2, _b;
    if (this.imageSrc) {
      const fill = ((_a2 = this.style) == null ? void 0 : _a2.imageBackground) ?? NONE;
      const stroke = ((_b = this.style) == null ? void 0 : _b.imageBorder) ?? NONE;
      if (fill !== NONE) {
        c.setFillColor(fill);
        c.setStrokeColor(stroke);
        c.rect(x, y, w, h);
        c.fillAndStroke();
      }
      c.image(x, y, w, h, this.imageSrc, this.preserveImageAspect, false, false);
      if (stroke !== NONE) {
        c.setShadow(false);
        c.setStrokeColor(stroke);
        c.rect(x, y, w, h);
        c.stroke();
      }
    } else {
      this.paintBackground(c, x, y, w, h);
    }
  }
};
var ImageShape_default = ImageShape;

// node_modules/@maxgraph/core/lib/view/undoable_changes/CurrentRootChange.js
var CurrentRootChange = class {
  constructor(view, root) {
    this.view = view;
    this.root = root;
    this.previous = root;
    this.isUp = root === null;
    if (!this.isUp) {
      let tmp2 = this.view.currentRoot;
      while (tmp2) {
        if (tmp2 === root) {
          this.isUp = true;
          break;
        }
        tmp2 = tmp2.getParent();
      }
    }
  }
  /**
   * Changes the current root of the view.
   */
  execute() {
    const tmp2 = this.view.currentRoot;
    this.view.currentRoot = this.previous;
    this.previous = tmp2;
    const translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);
    if (translate) {
      this.view.translate = new Point_default(-translate.x, -translate.y);
    }
    if (this.isUp) {
      this.view.clear(this.view.currentRoot, true, true);
      this.view.validate(null);
    } else {
      this.view.refresh();
    }
    const name2 = this.isUp ? InternalEvent_default.UP : InternalEvent_default.DOWN;
    this.view.fireEvent(new EventObject_default(name2, { root: this.view.currentRoot, previous: this.previous }));
    this.isUp = !this.isUp;
  }
};
var CurrentRootChange_default = CurrentRootChange;

// node_modules/@maxgraph/core/lib/view/style/StyleRegistry.js
var StyleRegistry = class _StyleRegistry {
  /**
   * Puts the given object into the registry under the given name.
   */
  static putValue(name2, obj2) {
    _StyleRegistry.values[name2] = obj2;
  }
  /**
   * Returns the value associated with the given name.
   */
  static getValue(name2) {
    return _StyleRegistry.values[name2];
  }
  /**
   * Returns the name for the given value.
   */
  static getName(value2) {
    for (const key2 in _StyleRegistry.values) {
      if (_StyleRegistry.values[key2] === value2) {
        return key2;
      }
    }
    return null;
  }
};
StyleRegistry.values = {};
var StyleRegistry_default = StyleRegistry;

// node_modules/@maxgraph/core/lib/view/GraphView.js
var GraphView = class extends EventSource_default {
  constructor(graph) {
    super();
    this.backgroundImage = null;
    this.backgroundPageShape = null;
    this.EMPTY_POINT = new Point_default();
    this.doneResource = Client_default.language !== "none" ? "done" : "";
    this.updatingDocumentResource = Client_default.language !== "none" ? "updatingDocument" : "";
    this.allowEval = false;
    this.captureDocumentGesture = true;
    this.rendering = true;
    this.currentRoot = null;
    this.graphBounds = new Rectangle_default();
    this.scale = 1;
    this.translate = new Point_default();
    this.states = new Dictionary_default();
    this.updateStyle = false;
    this.lastNode = null;
    this.lastHtmlNode = null;
    this.lastForegroundNode = null;
    this.lastForegroundHtmlNode = null;
    this.endHandler = null;
    this.moveHandler = null;
    this.graph = graph;
  }
  /**
   * Returns {@link graphBounds}.
   */
  getGraphBounds() {
    return this.graphBounds;
  }
  /**
   * Sets {@link graphBounds}.
   */
  setGraphBounds(value2) {
    this.graphBounds = value2;
  }
  /**
   * Returns the {@link scale}.
   */
  getScale() {
    return this.scale;
  }
  /**
   * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed
   * by {@link Graph.sizeDidChange}.
   *
   * @param value Decimal value that specifies the new scale (1 is 100%).
   */
  setScale(value2) {
    const previousScale = this.scale;
    if (previousScale !== value2) {
      this.scale = value2;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.SCALE, { scale: value2, previousScale }));
  }
  /**
   * Returns the {@link translate}.
   */
  getTranslate() {
    return this.translate;
  }
  isRendering() {
    return this.rendering;
  }
  setRendering(value2) {
    this.rendering = value2;
  }
  /**
   * Sets the translation and fires a {@link translate} event before calling
   * {@link revalidate} followed by {@link Graph.sizeDidChange}. The translation is the
   * negative of the origin.
   *
   * @param dx X-coordinate of the translation.
   * @param dy Y-coordinate of the translation.
   */
  setTranslate(dx, dy) {
    const previousTranslate = new Point_default(this.translate.x, this.translate.y);
    if (this.translate.x !== dx || this.translate.y !== dy) {
      this.translate.x = dx;
      this.translate.y = dy;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.TRANSLATE, {
      translate: this.translate,
      previousTranslate
    }));
  }
  isAllowEval() {
    return this.allowEval;
  }
  setAllowEval(value2) {
    this.allowEval = value2;
  }
  /**
   * Returns {@link states}.
   */
  getStates() {
    return this.states;
  }
  /**
   * Sets {@link states}.
   */
  setStates(value2) {
    this.states = value2;
  }
  /**
   * Returns the DOM node that contains the background-, draw- and
   * overlay- and decoratorpanes.
   */
  getCanvas() {
    return this.canvas;
  }
  /**
   * Returns the DOM node that represents the background layer.
   */
  getBackgroundPane() {
    return this.backgroundPane;
  }
  /**
   * Returns the DOM node that represents the main drawing layer.
   */
  getDrawPane() {
    return this.drawPane;
  }
  /**
   * Returns the DOM node that represents the layer above the drawing layer.
   */
  getOverlayPane() {
    return this.overlayPane;
  }
  /**
   * Returns the DOM node that represents the topmost drawing layer.
   */
  getDecoratorPane() {
    return this.decoratorPane;
  }
  /**
   * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.
   *
   * @param cells Array of {@link Cell} whose bounds should be returned.
   */
  getBounds(cells) {
    let result2 = null;
    if (cells.length > 0) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        if (cells[i2].isVertex() || cells[i2].isEdge()) {
          const state2 = this.getState(cells[i2]);
          if (state2) {
            if (!result2) {
              result2 = Rectangle_default.fromRectangle(state2);
            } else {
              result2.add(state2);
            }
          }
        }
      }
    }
    return result2;
  }
  /**
   * Sets and returns the current root and fires an {@link undo} event before
   * calling {@link graph.sizeDidChange}.
   *
   * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.
   */
  setCurrentRoot(root) {
    if (this.currentRoot !== root) {
      const change = new CurrentRootChange_default(this, root);
      change.execute();
      const edit = new UndoableEdit_default(this, true);
      edit.add(change);
      this.fireEvent(new EventObject_default(InternalEvent_default.UNDO, { edit }));
      this.graph.sizeDidChange();
      this.currentRoot = root;
    }
    return root;
  }
  /**
   * Sets the scale and translation and fires a {@link scale} and {@link translate} event
   * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.
   *
   * @param scale Decimal value that specifies the new scale (1 is 100%).
   * @param dx X-coordinate of the translation.
   * @param dy Y-coordinate of the translation.
   */
  scaleAndTranslate(scale, dx, dy) {
    const previousScale = this.scale;
    const previousTranslate = new Point_default(this.translate.x, this.translate.y);
    if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {
      this.scale = scale;
      this.translate.x = dx;
      this.translate.y = dy;
      if (this.isEventsEnabled()) {
        this.viewStateChanged();
      }
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.SCALE_AND_TRANSLATE, {
      scale,
      previousScale,
      translate: this.translate,
      previousTranslate
    }));
  }
  /**
   * Invoked after {@link scale} and/or {@link translate} has changed.
   */
  viewStateChanged() {
    this.revalidate();
    this.graph.sizeDidChange();
  }
  /**
   * Clears the view if {@link currentRoot} is not null and revalidates.
   */
  refresh() {
    if (this.currentRoot) {
      this.clear();
    }
    this.revalidate();
  }
  /**
   * Revalidates the complete view with all cell states.
   */
  revalidate() {
    this.invalidate();
    this.validate();
  }
  /**
   * Removes the state of the given cell and all descendants if the given
   * cell is not the current root.
   *
   * @param cell Optional {@link Cell} for which the state should be removed. Default
   * is the root of the model.
   * @param force Boolean indicating if the current root should be ignored for
   * recursion.
   */
  clear(cell2, force = false, recurse = true) {
    if (!cell2) {
      cell2 = this.graph.getDataModel().getRoot();
    }
    if (cell2) {
      this.removeState(cell2);
      if (recurse && (force || cell2 !== this.currentRoot)) {
        const childCount2 = cell2.getChildCount();
        for (let i2 = 0; i2 < childCount2; i2 += 1) {
          this.clear(cell2.getChildAt(i2), force);
        }
      } else {
        this.invalidate(cell2);
      }
    }
  }
  /**
   * Invalidates the state of the given cell, all its descendants and
   * connected edges.
   *
   * @param cell Optional {@link Cell} to be invalidated. Default is the root of the
   * model.
   */
  invalidate(cell2 = null, recurse = true, includeEdges = true) {
    const model2 = this.graph.getDataModel();
    cell2 = cell2 ?? model2.getRoot();
    if (cell2) {
      const state2 = this.getState(cell2);
      if (state2) {
        state2.invalid = true;
      }
      if (!cell2.invalidating) {
        cell2.invalidating = true;
        if (recurse) {
          const childCount2 = cell2.getChildCount();
          for (let i2 = 0; i2 < childCount2; i2 += 1) {
            const child2 = cell2.getChildAt(i2);
            this.invalidate(child2, recurse, includeEdges);
          }
        }
        if (includeEdges) {
          const edgeCount = cell2.getEdgeCount();
          for (let i2 = 0; i2 < edgeCount; i2 += 1) {
            this.invalidate(cell2.getEdgeAt(i2), recurse, includeEdges);
          }
        }
        cell2.invalidating = false;
      }
    }
  }
  /**
   * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}
   * using {@link getBoundingBox}. Finally the background is validated using
   * {@link validateBackground}.
   *
   * @param cell Optional {@link Cell} to be used as the root of the validation.
   * Default is {@link currentRoot} or the root of the model.
   */
  validate(cell2 = null) {
    const t0 = GlobalConfig.logger.enter("GraphView.validate");
    this.resetValidationState();
    const c = cell2 || (this.currentRoot ?? this.graph.getDataModel().getRoot());
    if (c) {
      const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));
      this.setGraphBounds(graphBounds ?? this.getEmptyBounds());
      this.validateBackground();
      this.resetValidationState();
    }
    GlobalConfig.logger.leave("GraphView.validate", t0);
  }
  /**
   * Returns the bounds for an empty graph. This returns a rectangle at
   * {@link translate} with the size of 0 x 0.
   */
  getEmptyBounds() {
    return new Rectangle_default(this.translate.x * this.scale, this.translate.y * this.scale);
  }
  /**
   * Returns the bounding box of the shape and the label for the given
   * {@link CellState} and its children if recurse is true.
   *
   * @param state {@link CellState} whose bounding box should be returned.
   * @param recurse Optional boolean indicating if the children should be included.
   * Default is true.
   */
  getBoundingBox(state2 = null, recurse = true) {
    let bbox = null;
    if (state2) {
      if (state2.shape && state2.shape.boundingBox) {
        bbox = state2.shape.boundingBox.clone();
      }
      if (state2.text && state2.text.boundingBox) {
        if (bbox) {
          bbox.add(state2.text.boundingBox);
        } else {
          bbox = state2.text.boundingBox.clone();
        }
      }
      if (recurse) {
        const childCount2 = state2.cell.getChildCount();
        for (let i2 = 0; i2 < childCount2; i2 += 1) {
          const bounds = this.getBoundingBox(this.getState(state2.cell.getChildAt(i2)));
          if (bounds) {
            if (!bbox) {
              bbox = bounds;
            } else {
              bbox.add(bounds);
            }
          }
        }
      }
    }
    return bbox;
  }
  /**
   * Creates and returns the shape used as the background page.
   *
   * @param bounds {@link mxRectangle} that represents the bounds of the shape.
   */
  createBackgroundPageShape(bounds) {
    return new RectangleShape_default(bounds, "white", "black");
  }
  /**
   * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.
   */
  validateBackground() {
    this.validateBackgroundImage();
    this.validateBackgroundPage();
  }
  /**
   * Validates the background image.
   */
  validateBackgroundImage() {
    const bg = this.graph.getBackgroundImage();
    if (bg) {
      if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {
        if (this.backgroundImage) {
          this.backgroundImage.destroy();
        }
        const bounds = new Rectangle_default(0, 0, 1, 1);
        this.backgroundImage = new ImageShape_default(bounds, bg.src);
        this.backgroundImage.dialect = this.graph.dialect;
        this.backgroundImage.init(this.backgroundPane);
        this.backgroundImage.redraw();
      }
      this.redrawBackgroundImage(this.backgroundImage, bg);
    } else if (this.backgroundImage) {
      this.backgroundImage.destroy();
      this.backgroundImage = null;
    }
  }
  /**
   * Validates the background page.
   */
  validateBackgroundPage() {
    const graph = this.graph;
    if (graph.pageVisible) {
      const bounds = this.getBackgroundPageBounds();
      if (this.backgroundPageShape == null) {
        this.backgroundPageShape = this.createBackgroundPageShape(bounds);
        this.backgroundPageShape.scale = this.scale;
        this.backgroundPageShape.isShadow = true;
        this.backgroundPageShape.dialect = this.graph.dialect;
        this.backgroundPageShape.init(this.backgroundPane);
        this.backgroundPageShape.redraw();
        if (this.backgroundPageShape.node) {
          if (graph.isNativeDblClickEnabled()) {
            InternalEvent_default.addListener(this.backgroundPageShape.node, "dblclick", (evt2) => {
              graph.dblClick(evt2);
            });
          }
          InternalEvent_default.addGestureListeners(this.backgroundPageShape.node, (evt2) => {
            graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2));
          }, (evt2) => {
            const tooltipHandler = graph.getPlugin("TooltipHandler");
            if (tooltipHandler && tooltipHandler.isHideOnHover()) {
              tooltipHandler.hide();
            }
            if (graph.isMouseDown && !isConsumed(evt2)) {
              graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2));
            }
          }, (evt2) => {
            graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2));
          });
        }
      } else {
        this.backgroundPageShape.scale = this.scale;
        this.backgroundPageShape.bounds = bounds;
        this.backgroundPageShape.redraw();
      }
    } else if (this.backgroundPageShape) {
      this.backgroundPageShape.destroy();
      this.backgroundPageShape = null;
    }
  }
  /**
   * Returns the bounds for the background page.
   */
  getBackgroundPageBounds() {
    const fmt = this.graph.pageFormat;
    const ps = this.scale * this.graph.pageScale;
    return new Rectangle_default(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);
  }
  /**
   * Updates the bounds and redraws the background image.
   *
   * Example:
   *
   * If the background image should not be scaled, this can be replaced with
   * the following.
   *
   * @example
   * ```javascript
   * redrawBackground(backgroundImage, bg)
   * {
   *   backgroundImage.bounds.x = this.translate.x;
   *   backgroundImage.bounds.y = this.translate.y;
   *   backgroundImage.bounds.width = bg.width;
   *   backgroundImage.bounds.height = bg.height;
   *
   *   backgroundImage.redraw();
   * };
   * ```
   *
   * @param backgroundImage {@link mxImageShape} that represents the background image.
   * @param bg {@link mxImage} that specifies the image and its dimensions.
   */
  redrawBackgroundImage(backgroundImage, bg) {
    backgroundImage.scale = this.scale;
    if (backgroundImage.bounds) {
      const bounds = backgroundImage.bounds;
      bounds.x = this.scale * this.translate.x;
      bounds.y = this.scale * this.translate.y;
      bounds.width = this.scale * bg.width;
      bounds.height = this.scale * bg.height;
    }
    backgroundImage.redraw();
  }
  /**
   * Recursively creates the cell state for the given cell if visible is true and
   * the given cell is visible. If the cell is not visible but the state exists
   * then it is removed using {@link removeState}.
   *
   * @param cell {@link mxCell} whose {@link CellState} should be created.
   * @param visible Optional boolean indicating if the cell should be visible. Default
   * is true.
   */
  validateCell(cell2, visible = true) {
    visible = visible && cell2.isVisible();
    const state2 = this.getState(cell2, visible);
    if (state2 && !visible) {
      this.removeState(cell2);
    } else {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        this.validateCell(cell2.getChildAt(i2), visible && (!cell2.isCollapsed() || cell2 === this.currentRoot));
      }
    }
    return cell2;
  }
  /**
   * Validates and repaints the {@link CellState} for the given {@link Cell}.
   *
   * @param cell {@link mxCell} whose {@link CellState} should be validated.
   * @param recurse Optional boolean indicating if the children of the cell should be
   * validated. Default is true.
   */
  validateCellState(cell2, recurse = true) {
    let state2 = null;
    if (cell2) {
      state2 = this.getState(cell2);
      if (state2) {
        if (state2.invalid) {
          state2.invalid = false;
          if (!state2.style || state2.invalidStyle) {
            state2.style = this.graph.getCellStyle(state2.cell);
            state2.invalidStyle = false;
          }
          if (cell2 !== this.currentRoot) {
            this.validateCellState(cell2.getParent(), false);
          }
          state2.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, true), false), true);
          state2.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell2, false), false), false);
          this.updateCellState(state2);
          if (cell2 !== this.currentRoot && !state2.invalid) {
            this.graph.cellRenderer.redraw(state2, false, this.isRendering());
            state2.updateCachedBounds();
          }
        }
        if (recurse && !state2.invalid) {
          if (state2.shape) {
            this.stateValidated(state2);
          }
          const childCount2 = cell2.getChildCount();
          for (let i2 = 0; i2 < childCount2; i2 += 1) {
            this.validateCellState(cell2.getChildAt(i2));
          }
        }
      }
    }
    return state2;
  }
  /**
   * Updates the given {@link CellState}.
   *
   * @param state {@link CellState} to be updated.
   */
  updateCellState(state2) {
    const absoluteOffset = state2.absoluteOffset;
    const origin = state2.origin;
    absoluteOffset.x = 0;
    absoluteOffset.y = 0;
    origin.x = 0;
    origin.y = 0;
    state2.length = 0;
    if (state2.cell !== this.currentRoot) {
      const parent2 = state2.cell.getParent();
      const pState = parent2 ? this.getState(parent2) : null;
      if (pState && pState.cell !== this.currentRoot) {
        origin.x += pState.origin.x;
        origin.y += pState.origin.y;
      }
      let offset = this.graph.getChildOffsetForCell(state2.cell);
      if (offset) {
        origin.x += offset.x;
        origin.y += offset.y;
      }
      const geo = state2.cell.getGeometry();
      if (geo) {
        if (!state2.cell.isEdge()) {
          offset = geo.offset ? geo.offset : this.EMPTY_POINT;
          if (geo.relative && pState) {
            if (pState.cell.isEdge()) {
              const point = this.getPoint(pState, geo);
              if (point) {
                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;
                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;
              }
            } else {
              origin.x += geo.x * pState.unscaledWidth + offset.x;
              origin.y += geo.y * pState.unscaledHeight + offset.y;
            }
          } else {
            absoluteOffset.x = this.scale * offset.x;
            absoluteOffset.y = this.scale * offset.y;
            origin.x += geo.x;
            origin.y += geo.y;
          }
        }
        state2.x = this.scale * (this.translate.x + origin.x);
        state2.y = this.scale * (this.translate.y + origin.y);
        state2.width = this.scale * geo.width;
        state2.unscaledWidth = geo.width;
        state2.height = this.scale * geo.height;
        state2.unscaledHeight = geo.height;
        if (state2.cell.isVertex()) {
          this.updateVertexState(state2, geo);
        }
        if (state2.cell.isEdge()) {
          this.updateEdgeState(state2, geo);
        }
      }
    }
    state2.updateCachedBounds();
  }
  /**
   * Validates the given cell state.
   */
  updateVertexState(state2, geo) {
    const parent2 = state2.cell.getParent();
    const pState = parent2 ? this.getState(parent2) : null;
    if (geo.relative && pState && !pState.cell.isEdge()) {
      const alpha = toRadians(pState.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const ct = new Point_default(state2.getCenterX(), state2.getCenterY());
        const cx = new Point_default(pState.getCenterX(), pState.getCenterY());
        const pt = getRotatedPoint(ct, cos, sin, cx);
        state2.x = pt.x - state2.width / 2;
        state2.y = pt.y - state2.height / 2;
      }
    }
    this.updateVertexLabelOffset(state2);
  }
  /**
   * Validates the given cell state.
   */
  updateEdgeState(state2, geo) {
    const source2 = state2.getVisibleTerminalState(true);
    const target2 = state2.getVisibleTerminalState(false);
    if (state2.cell.getTerminal(true) && !source2 || !source2 && !geo.getTerminalPoint(true) || state2.cell.getTerminal(false) && !target2 || !target2 && !geo.getTerminalPoint(false)) {
      this.clear(state2.cell, true);
    } else {
      this.updateFixedTerminalPoints(state2, source2, target2);
      this.updatePoints(state2, geo.points, source2, target2);
      this.updateFloatingTerminalPoints(state2, source2, target2);
      const pts = state2.absolutePoints;
      if (state2.cell !== this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {
        this.clear(state2.cell, true);
      } else {
        this.updateEdgeBounds(state2);
        this.updateEdgeLabelOffset(state2);
      }
    }
  }
  /**
   * Updates the absoluteOffset of the given vertex cell state. This takes
   * into account the label position styles.
   *
   * @param state {@link CellState} whose absolute offset should be updated.
   */
  updateVertexLabelOffset(state2) {
    const h = state2.style.labelPosition ?? ALIGN.CENTER;
    if (h === ALIGN.LEFT) {
      let lw = state2.style.labelWidth ?? null;
      if (lw != null) {
        lw *= this.scale;
      } else {
        lw = state2.width;
      }
      state2.absoluteOffset.x -= lw;
    } else if (h === ALIGN.RIGHT) {
      state2.absoluteOffset.x += state2.width;
    } else if (h === ALIGN.CENTER) {
      const lw = state2.style.labelWidth ?? null;
      if (lw != null) {
        const align = state2.style.align ?? ALIGN.CENTER;
        let dx = 0;
        if (align === ALIGN.CENTER) {
          dx = 0.5;
        } else if (align === ALIGN.RIGHT) {
          dx = 1;
        }
        if (dx !== 0) {
          state2.absoluteOffset.x -= (lw * this.scale - state2.width) * dx;
        }
      }
    }
    const v = state2.style.verticalLabelPosition ?? ALIGN.MIDDLE;
    if (v === ALIGN.TOP) {
      state2.absoluteOffset.y -= state2.height;
    } else if (v === ALIGN.BOTTOM) {
      state2.absoluteOffset.y += state2.height;
    }
  }
  /**
   * Resets the current validation state.
   */
  resetValidationState() {
    this.lastNode = null;
    this.lastHtmlNode = null;
    this.lastForegroundNode = null;
    this.lastForegroundHtmlNode = null;
  }
  /**
   * Invoked when a state has been processed in {@link validatePoints}. This is used
   * to update the order of the DOM nodes of the shape.
   *
   * @param state {@link CellState} that represents the cell state.
   */
  stateValidated(state2) {
    const graph = this.graph;
    const fg = state2.cell.isEdge() && graph.keepEdgesInForeground || state2.cell.isVertex() && graph.keepEdgesInBackground;
    const htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;
    const node2 = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;
    const result2 = graph.cellRenderer.insertStateAfter(state2, node2, htmlNode);
    if (fg) {
      this.lastForegroundHtmlNode = result2[1];
      this.lastForegroundNode = result2[0];
    } else {
      this.lastHtmlNode = result2[1];
      this.lastNode = result2[0];
    }
  }
  /**
   * Sets the initial absolute terminal points in the given state before the edge
   * style is computed.
   *
   * @param edge {@link CellState} whose initial terminal points should be updated.
   * @param source {@link CellState} which represents the source terminal.
   * @param target {@link CellState} which represents the target terminal.
   */
  updateFixedTerminalPoints(edge2, source2, target2) {
    this.updateFixedTerminalPoint(edge2, source2, true, this.graph.getConnectionConstraint(edge2, source2, true));
    this.updateFixedTerminalPoint(edge2, target2, false, this.graph.getConnectionConstraint(edge2, target2, false));
  }
  /**
   * Sets the fixed source or target terminal point on the given edge.
   *
   * @param edge <CellState> whose terminal point should be updated.
   * @param terminal <CellState> which represents the actual terminal.
   * @param source Boolean that specifies if the terminal is the source.
   * @param constraint {@link ConnectionConstraint} that specifies the connection.
   */
  updateFixedTerminalPoint(edge2, terminal, source2, constraint) {
    edge2.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge2, terminal, source2, constraint), source2);
  }
  /**
   * Returns the fixed source or target terminal point for the given edge.
   *
   * @param edge <CellState> whose terminal point should be returned.
   * @param terminal <CellState> which represents the actual terminal.
   * @param source Boolean that specifies if the terminal is the source.
   * @param constraint {@link ConnectionConstraint} that specifies the connection.
   */
  getFixedTerminalPoint(edge2, terminal, source2, constraint) {
    let pt = null;
    if (constraint && terminal) {
      pt = this.graph.getConnectionPoint(terminal, constraint, false);
    }
    if (!pt && !terminal) {
      const s = this.scale;
      const tr = this.translate;
      const orig = edge2.origin;
      const geo = edge2.cell.getGeometry();
      pt = geo.getTerminalPoint(source2);
      if (pt) {
        pt = new Point_default(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));
      }
    }
    return pt;
  }
  /**
   * Updates the bounds of the given cell state to reflect the bounds of the stencil
   * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if
   * the bounds have been modified or null otherwise.
   *
   * @param edge {@link CellState} whose bounds should be updated.
   */
  updateBoundsFromStencil(state2) {
    let previous = null;
    if (state2 && state2.shape && state2.shape.stencil && state2.shape.stencil.aspect === "fixed") {
      previous = Rectangle_default.fromRectangle(state2);
      const asp = state2.shape.stencil.computeAspect(
        null,
        // this argument is not used
        state2.x,
        state2.y,
        state2.width,
        state2.height
      );
      state2.setRect(asp.x, asp.y, state2.shape.stencil.w0 * asp.width, state2.shape.stencil.h0 * asp.height);
    }
    return previous;
  }
  /**
   * Updates the absolute points in the given state using the specified array
   * of {@link Point} as the relative points.
   *
   * @param edge {@link CellState} whose absolute points should be updated.
   * @param points Array of {@link Point} that constitute the relative points.
   * @param source {@link CellState} that represents the source terminal.
   * @param target {@link CellState} that represents the target terminal.
   */
  updatePoints(edge2, points2, source2, target2) {
    const pts = [];
    pts.push(edge2.absolutePoints[0]);
    const edgeStyle2 = this.getEdgeStyle(edge2, points2, source2, target2);
    if (edgeStyle2 && source2) {
      const src = this.getTerminalPort(edge2, source2, true);
      const trg = target2 ? this.getTerminalPort(edge2, target2, false) : null;
      const srcBounds = this.updateBoundsFromStencil(src);
      const trgBounds = this.updateBoundsFromStencil(trg);
      edgeStyle2(edge2, src, trg, points2, pts);
      if (src && srcBounds) {
        src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);
      }
      if (trg && trgBounds) {
        trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);
      }
    } else if (points2) {
      for (let i2 = 0; i2 < points2.length; i2 += 1) {
        if (points2[i2]) {
          const pt = clone(points2[i2]);
          pts.push(this.transformControlPoint(edge2, pt));
        }
      }
    }
    const tmp2 = edge2.absolutePoints;
    pts.push(tmp2[tmp2.length - 1]);
    edge2.absolutePoints = pts;
  }
  /**
   * Transforms the given control point to an absolute point.
   */
  transformControlPoint(state2, pt, ignoreScale = false) {
    if (state2 && pt) {
      const orig = state2.origin;
      const scale = ignoreScale ? 1 : this.scale;
      return new Point_default(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));
    }
    return null;
  }
  /**
   * Returns true if the given edge should be routed with {@link graph.defaultLoopStyle}
   * or the {@link CellStateStyle.STYLE_LOOP} defined for the given edge.
   * This implementation returns `true` if the given edge is a loop and does not
   */
  isLoopStyleEnabled(edge2, points2 = [], source2 = null, target2 = null) {
    const sc = this.graph.getConnectionConstraint(edge2, source2, true);
    const tc = this.graph.getConnectionConstraint(edge2, target2, false);
    if ((points2 == null || points2.length < 2) && !((edge2.style.orthogonalLoop ?? false) || (sc == null || sc.point == null) && (tc == null || tc.point == null))) {
      return source2 != null && source2 === target2;
    }
    return false;
  }
  /**
   * Returns the edge style function to be used to render the given edge state.
   */
  getEdgeStyle(edge, points = [], source = null, target = null) {
    let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? edge.style.loopStyle ?? this.graph.defaultLoopStyle : !(edge.style.noEdgeStyle ?? false) ? edge.style.edgeStyle : null;
    if (typeof edgeStyle === "string") {
      let tmp = StyleRegistry_default.getValue(edgeStyle);
      if (!tmp && this.isAllowEval()) {
        tmp = eval(edgeStyle);
      }
      edgeStyle = tmp;
    }
    if (typeof edgeStyle === "function") {
      return edgeStyle;
    }
    return null;
  }
  /**
   * Updates the terminal points in the given state after the edge style was
   * computed for the edge.
   *
   * @param state {@link CellState} whose terminal points should be updated.
   * @param source {@link CellState} that represents the source terminal.
   * @param target {@link CellState} that represents the target terminal.
   */
  updateFloatingTerminalPoints(state2, source2, target2) {
    const pts = state2.absolutePoints;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    if (!pe && target2) {
      this.updateFloatingTerminalPoint(state2, target2, source2, false);
    }
    if (!p0 && source2) {
      this.updateFloatingTerminalPoint(state2, source2, target2, true);
    }
  }
  /**
   * Updates the absolute terminal point in the given state for the given
   * start and end state, where start is the source if source is true.
   *
   * @param edge {@link CellState} whose terminal point should be updated.
   * @param start {@link CellState} for the terminal on "this" side of the edge.
   * @param end {@link CellState} for the terminal on the other side of the edge.
   * @param source Boolean indicating if start is the source terminal state.
   */
  updateFloatingTerminalPoint(edge2, start, end, source2) {
    edge2.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge2, start, end, source2), source2);
  }
  /**
   * Returns the floating terminal point for the given edge, start and end
   * state, where start is the source if source is true.
   *
   * @param edge {@link CellState} whose terminal point should be returned.
   * @param start {@link CellState} for the terminal on "this" side of the edge.
   * @param end {@link CellState} for the terminal on the other side of the edge.
   * @param source Boolean indicating if start is the source terminal state.
   */
  getFloatingTerminalPoint(edge2, start, end, source2) {
    start = this.getTerminalPort(edge2, start, source2);
    let next = this.getNextPoint(edge2, end, source2);
    const orth = this.graph.isOrthogonal(edge2);
    const alpha = toRadians(start.style.rotation ?? 0);
    const center = new Point_default(start.getCenterX(), start.getCenterY());
    if (alpha !== 0) {
      const cos = Math.cos(-alpha);
      const sin = Math.sin(-alpha);
      next = getRotatedPoint(next, cos, sin, center);
    }
    let border = edge2.style.perimeterSpacing ?? 0;
    border += edge2.style[source2 ? "sourcePerimeterSpacing" : "targetPerimeterSpacing"] ?? 0;
    let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);
    if (pt && alpha !== 0) {
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      pt = getRotatedPoint(pt, cos, sin, center);
    }
    return pt;
  }
  /**
   * Returns an {@link CellState} that represents the source or target terminal or
   * port for the given edge.
   *
   * @param state {@link CellState} that represents the state of the edge.
   * @param terminal {@link CellState} that represents the terminal.
   * @param source Boolean indicating if the given terminal is the source terminal.
   */
  getTerminalPort(state2, terminal, source2 = false) {
    const key2 = source2 ? "sourcePort" : "targetPort";
    const id2 = state2.style[key2];
    if (id2) {
      const cell2 = this.graph.getDataModel().getCell(id2);
      if (cell2) {
        const tmp2 = this.getState(cell2, false);
        if (tmp2) {
          terminal = tmp2;
        }
      }
    }
    return terminal;
  }
  /**
   * Returns an {@link Point} that defines the location of the intersection point between
   * the perimeter and the line between the center of the shape and the given point.
   *
   * @param terminal {@link CellState} for the source or target terminal.
   * @param next {@link Point} that lies outside the given terminal.
   * @param orthogonal Boolean that specifies if the orthogonal projection onto
   * the perimeter should be returned. If this is false then the intersection
   * of the perimeter and the line between the next and the center point is
   * returned.
   * @param border Optional border between the perimeter and the shape.
   */
  getPerimeterPoint(terminal, next, orthogonal, border = 0) {
    let point = null;
    if (terminal != null) {
      const perimeter2 = this.getPerimeterFunction(terminal);
      if (perimeter2 != null && next != null) {
        const bounds = this.getPerimeterBounds(terminal, border);
        if (bounds.width > 0 || bounds.height > 0) {
          point = new Point_default(next.x, next.y);
          let flipH = false;
          let flipV = false;
          if (terminal.cell.isVertex()) {
            flipH = !!terminal.style.flipH;
            flipV = !!terminal.style.flipV;
            if (flipH) {
              point.x = 2 * bounds.getCenterX() - point.x;
            }
            if (flipV) {
              point.y = 2 * bounds.getCenterY() - point.y;
            }
          }
          point = perimeter2(bounds, terminal, point, orthogonal);
          if (point != null) {
            if (flipH) {
              point.x = 2 * bounds.getCenterX() - point.x;
            }
            if (flipV) {
              point.y = 2 * bounds.getCenterY() - point.y;
            }
          }
        }
      }
      if (point == null) {
        point = this.getPoint(terminal);
      }
    }
    return point;
  }
  /**
   * Returns the x-coordinate of the center point for automatic routing.
   */
  getRoutingCenterX(state2) {
    const f = state2.style ? state2.style.routingCenterX ?? 0 : 0;
    return state2.getCenterX() + f * state2.width;
  }
  /**
   * Returns the y-coordinate of the center point for automatic routing.
   */
  getRoutingCenterY(state2) {
    const f = state2.style ? state2.style.routingCenterY ?? 0 : 0;
    return state2.getCenterY() + f * state2.height;
  }
  /**
   * Returns the perimeter bounds for the given terminal, edge pair as an
   * {@link Rectangle}.
   *
   * If you have a model where each terminal has a relative child that should
   * act as the graphical endpoint for a connection from/to the terminal, then
   * this method can be replaced as follows:
   *
   * @example
   * ```javascript
   * var oldGetPerimeterBounds = getPerimeterBounds;
   * getPerimeterBounds(terminal, edge, isSource)
   * {
   *   var model = this.graph.getDataModel();
   *   var childCount = model.getChildCount(terminal.cell);
   *
   *   if (childCount > 0)
   *   {
   *     var child = model.getChildAt(terminal.cell, 0);
   *     var geo = model.getGeometry(child);
   *
   *     if (geo != null &&
   *         geo.relative)
   *     {
   *       var state = this.getState(child);
   *
   *       if (state != null)
   *       {
   *         terminal = state;
   *       }
   *     }
   *   }
   *
   *   return oldGetPerimeterBounds.apply(this, arguments);
   * };
   * ```
   *
   * @param terminal CellState that represents the terminal.
   * @param border Number that adds a border between the shape and the perimeter.
   */
  getPerimeterBounds(terminal, border = 0) {
    border += terminal.style.perimeterSpacing ?? 0;
    return terminal.getPerimeterBounds(border * this.scale);
  }
  /**
   * Returns the perimeter function for the given state.
   */
  getPerimeterFunction(state) {
    let perimeter = state.style.perimeter;
    if (typeof perimeter === "string") {
      let tmp = StyleRegistry_default.getValue(perimeter);
      if (tmp == null && this.isAllowEval()) {
        tmp = eval(perimeter);
      }
      perimeter = tmp;
    }
    if (typeof perimeter === "function") {
      return perimeter;
    }
    return null;
  }
  /**
   * Returns the nearest point in the list of absolute points or the center
   * of the opposite terminal.
   *
   * @param edge {@link CellState} that represents the edge.
   * @param opposite {@link CellState} that represents the opposite terminal.
   * @param source Boolean indicating if the next point for the source or target
   * should be returned.
   */
  getNextPoint(edge2, opposite, source2 = false) {
    const pts = edge2.absolutePoints;
    let point = null;
    if (pts.length >= 2) {
      const count = pts.length;
      point = pts[source2 ? Math.min(1, count - 1) : Math.max(0, count - 2)];
    }
    if (!point && opposite) {
      point = new Point_default(opposite.getCenterX(), opposite.getCenterY());
    }
    return point;
  }
  /**
   * Returns the nearest ancestor terminal that is visible. The edge appears
   * to be connected to this terminal on the display. The result of this method
   * is cached in {@link CellState.getVisibleTerminalState}.
   *
   * @param edge {@link mxCell} whose visible terminal should be returned.
   * @param source Boolean that specifies if the source or target terminal
   * should be returned.
   */
  getVisibleTerminal(edge2, source2) {
    const model2 = this.graph.getDataModel();
    let result2 = edge2.getTerminal(source2);
    let best = result2;
    while (result2 && result2 !== this.currentRoot) {
      if (best && !best.isVisible() || result2.isCollapsed()) {
        best = result2;
      }
      result2 = result2.getParent();
    }
    if (best && (!model2.contains(best) || best.getParent() === model2.getRoot() || best === this.currentRoot)) {
      best = null;
    }
    return best;
  }
  /**
   * Updates the given state using the bounding box of t
   * he absolute points.
   * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and
   * {@link CellState.segments}.
   *
   * @param state {@link CellState} whose bounds should be updated.
   */
  updateEdgeBounds(state2) {
    const points2 = state2.absolutePoints;
    const p0 = points2[0];
    const pe = points2[points2.length - 1];
    if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {
      const dx = pe.x - p0.x;
      const dy = pe.y - p0.y;
      state2.terminalDistance = Math.sqrt(dx * dx + dy * dy);
    } else {
      state2.terminalDistance = 0;
    }
    let length = 0;
    const segments = [];
    let pt = p0;
    if (pt) {
      let minX = pt.x;
      let minY = pt.y;
      let maxX = minX;
      let maxY = minY;
      for (let i2 = 1; i2 < points2.length; i2 += 1) {
        const tmp2 = points2[i2];
        if (tmp2) {
          const dx = pt.x - tmp2.x;
          const dy = pt.y - tmp2.y;
          const segment = Math.sqrt(dx * dx + dy * dy);
          segments.push(segment);
          length += segment;
          pt = tmp2;
          minX = Math.min(pt.x, minX);
          minY = Math.min(pt.y, minY);
          maxX = Math.max(pt.x, maxX);
          maxY = Math.max(pt.y, maxY);
        }
      }
      state2.length = length;
      state2.segments = segments;
      const markerSize = 1;
      state2.x = minX;
      state2.y = minY;
      state2.width = Math.max(markerSize, maxX - minX);
      state2.height = Math.max(markerSize, maxY - minY);
    }
  }
  /**
   * Returns the absolute point on the edge for the given relative
   * {@link Geometry} as an {@link Point}. The edge is represented by the given
   * {@link CellState}.
   *
   * @param state {@link CellState} that represents the state of the parent edge.
   * @param geometry {@link mxGeometry} that represents the relative location.
   */
  getPoint(state2, geometry = null) {
    let x = state2.getCenterX();
    let y = state2.getCenterY();
    if (state2.segments != null && (geometry == null || geometry.relative)) {
      const gx = geometry != null ? geometry.x / 2 : 0;
      const pointCount = state2.absolutePoints.length;
      const dist = Math.round((gx + 0.5) * state2.length);
      let segment = state2.segments[0];
      let length = 0;
      let index = 1;
      while (dist >= Math.round(length + segment) && index < pointCount - 1) {
        length += segment;
        segment = state2.segments[index++];
      }
      const factor = segment === 0 ? 0 : (dist - length) / segment;
      const p0 = state2.absolutePoints[index - 1];
      const pe = state2.absolutePoints[index];
      if (p0 != null && pe != null) {
        let gy = 0;
        let offsetX = 0;
        let offsetY = 0;
        if (geometry != null) {
          gy = geometry.y;
          const { offset } = geometry;
          if (offset != null) {
            offsetX = offset.x;
            offsetY = offset.y;
          }
        }
        const dx = pe.x - p0.x;
        const dy = pe.y - p0.y;
        const nx = segment === 0 ? 0 : dy / segment;
        const ny = segment === 0 ? 0 : dx / segment;
        x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;
        y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;
      }
    } else if (geometry != null) {
      const { offset } = geometry;
      if (offset != null) {
        x += offset.x;
        y += offset.y;
      }
    }
    return new Point_default(x, y);
  }
  /**
   * Gets the relative point that describes the given, absolute label
   * position for the given edge state.
   *
   * @param state {@link CellState} that represents the state of the parent edge.
   * @param x Specifies the x-coordinate of the absolute label location.
   * @param y Specifies the y-coordinate of the absolute label location.
   */
  getRelativePoint(edgeState, x, y) {
    const geometry = edgeState.cell.getGeometry();
    if (geometry) {
      const absolutePoints = edgeState.absolutePoints;
      const pointCount = absolutePoints.length;
      if (geometry.relative && pointCount > 1) {
        const totalLength = edgeState.length;
        const { segments } = edgeState;
        let p0 = absolutePoints[0];
        let pe = absolutePoints[1];
        let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
        let length = 0;
        let index = 0;
        let tmp2 = 0;
        for (let i2 = 2; i2 < pointCount; i2 += 1) {
          p0 = pe;
          pe = absolutePoints[i2];
          const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);
          tmp2 += segments[i2 - 2];
          if (dist <= minDist) {
            minDist = dist;
            index = i2 - 1;
            length = tmp2;
          }
        }
        const seg = segments[index];
        p0 = absolutePoints[index];
        pe = absolutePoints[index + 1];
        const x2 = p0.x;
        const y2 = p0.y;
        const x1 = pe.x;
        const y1 = pe.y;
        let px = x;
        let py = y;
        const xSegment = x2 - x1;
        const ySegment = y2 - y1;
        px -= x1;
        py -= y1;
        let projlenSq = 0;
        px = xSegment - px;
        py = ySegment - py;
        const dotprod = px * xSegment + py * ySegment;
        if (dotprod <= 0) {
          projlenSq = 0;
        } else {
          projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);
        }
        let projlen = Math.sqrt(projlenSq);
        if (projlen > seg) {
          projlen = seg;
        }
        let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));
        const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);
        if (direction === -1) {
          yDistance = -yDistance;
        }
        return new Point_default((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);
      }
    }
    return new Point_default();
  }
  /**
   * Updates {@link CellState.absoluteOffset} for the given state. The absolute
   * offset is normally used for the position of the edge label. Is is
   * calculated from the geometry as an absolute offset from the center
   * between the two endpoints if the geometry is absolute, or as the
   * relative distance between the center along the line and the absolute
   * orthogonal distance if the geometry is relative.
   *
   * @param state {@link CellState} whose absolute offset should be updated.
   */
  updateEdgeLabelOffset(state2) {
    const points2 = state2.absolutePoints;
    const absoluteOffset = state2.absoluteOffset;
    absoluteOffset.x = state2.getCenterX();
    absoluteOffset.y = state2.getCenterY();
    if (points2.length > 0 && state2.segments) {
      const geometry = state2.cell.getGeometry();
      if (geometry) {
        if (geometry.relative) {
          const offset = this.getPoint(state2, geometry);
          state2.absoluteOffset = offset;
        } else {
          const p0 = points2[0];
          const pe = points2[points2.length - 1];
          if (p0 && pe) {
            const dx = pe.x - p0.x;
            const dy = pe.y - p0.y;
            let x0 = 0;
            let y0 = 0;
            const off = geometry.offset;
            if (off) {
              x0 = off.x;
              y0 = off.y;
            }
            const x = p0.x + dx / 2 + x0 * this.scale;
            const y = p0.y + dy / 2 + y0 * this.scale;
            absoluteOffset.x = x;
            absoluteOffset.y = y;
          }
        }
      }
    }
  }
  /**
   * Returns the {@link CellState} for the given cell. If create is true, then
   * the state is created if it does not yet exist.
   *
   * @param cell {@link mxCell} for which the {@link CellState} should be returned.
   * @param create Optional boolean indicating if a new state should be created
   * if it does not yet exist. Default is false.
   */
  getState(cell2, create = false) {
    let state2 = this.states.get(cell2);
    if (create && (!state2 || this.updateStyle) && cell2.isVisible()) {
      if (!state2) {
        state2 = this.createState(cell2);
        this.states.put(cell2, state2);
      } else {
        state2.style = this.graph.getCellStyle(cell2);
      }
    }
    return state2;
  }
  /**
   * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array
   * contains all states that are not null, that is, the returned array may
   * have less elements than the given array. If no argument is given, then
   * this returns {@link states}.
   */
  getCellStates(cells = null) {
    if (!cells) {
      return this.states.getValues();
    }
    const result2 = [];
    for (const cell2 of cells) {
      const state2 = this.getState(cell2);
      if (state2) {
        result2.push(state2);
      }
    }
    return result2;
  }
  /**
   * Removes and returns the {@link CellState} for the given cell.
   *
   * @param cell {@link mxCell} for which the {@link CellState} should be removed.
   */
  removeState(cell2) {
    const state2 = this.states.remove(cell2);
    if (state2) {
      this.graph.cellRenderer.destroy(state2);
      state2.invalid = true;
      state2.destroy();
    }
    return state2;
  }
  /**
   * Creates and returns an {@link CellState} for the given cell and initializes
   * it using {@link cellRenderer.initialize}.
   *
   * @param cell {@link mxCell} for which a new {@link CellState} should be created.
   */
  createState(cell2) {
    return new CellState_default(this, cell2, this.graph.getCellStyle(cell2));
  }
  /**
   * Returns true if the event origin is one of the drawing panes or
   * containers of the view.
   */
  isContainerEvent(evt2) {
    const source2 = getSource(evt2);
    return source2 && (source2 === this.graph.container || // @ts-ignore parentNode may exist
    source2.parentNode === this.backgroundPane || // @ts-ignore parentNode may exist
    source2.parentNode && source2.parentNode.parentNode === this.backgroundPane || source2 === this.canvas.parentNode || source2 === this.canvas || source2 === this.backgroundPane || source2 === this.drawPane || source2 === this.overlayPane || source2 === this.decoratorPane);
  }
  /**
   * Returns true if the event origin is one of the scrollbars of the
   * container in IE. Such events are ignored.
   */
  isScrollEvent(evt2) {
    const graph = this.graph;
    const offset = getOffset(graph.container);
    const pt = new Point_default(evt2.clientX - offset.x, evt2.clientY - offset.y);
    const container = graph.container;
    const outWidth = container.offsetWidth;
    const inWidth = container.clientWidth;
    if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {
      return true;
    }
    const outHeight = container.offsetHeight;
    const inHeight = container.clientHeight;
    return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;
  }
  /**
   * Initializes the graph event dispatch loop for the specified container
   * and invokes {@link create} to create the required DOM nodes for the display.
   */
  init() {
    this.installListeners();
    this.createSvg();
  }
  /**
   * Installs the required listeners in the container.
   */
  installListeners() {
    const graph = this.graph;
    const { container } = graph;
    if (Client_default.IS_TOUCH) {
      InternalEvent_default.addListener(container, "gesturestart", (evt2) => {
        graph.fireGestureEvent(evt2);
        InternalEvent_default.consume(evt2);
      });
      InternalEvent_default.addListener(container, "gesturechange", (evt2) => {
        graph.fireGestureEvent(evt2);
        InternalEvent_default.consume(evt2);
      });
      InternalEvent_default.addListener(container, "gestureend", (evt2) => {
        graph.fireGestureEvent(evt2);
        InternalEvent_default.consume(evt2);
      });
    }
    let pointerId = null;
    InternalEvent_default.addGestureListeners(container, (evt2) => {
      if (this.isContainerEvent(evt2) && (!Client_default.IS_GC && !Client_default.IS_SF || !this.isScrollEvent(evt2))) {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2));
        pointerId = evt2.pointerId;
      }
    }, (evt2) => {
      if (this.isContainerEvent(evt2) && // @ts-ignore
      (pointerId === null || evt2.pointerId === pointerId)) {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2));
      }
    }, (evt2) => {
      if (this.isContainerEvent(evt2)) {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2));
      }
      pointerId = null;
    });
    InternalEvent_default.addListener(container, "dblclick", (evt2) => {
      if (this.isContainerEvent(evt2)) {
        graph.dblClick(evt2);
      }
    });
    const getState = (evt2) => {
      let state2 = null;
      if (Client_default.IS_TOUCH) {
        const x = getClientX(evt2);
        const y = getClientY(evt2);
        const pt = convertPoint(container, x, y);
        const cell2 = graph.getCellAt(pt.x, pt.y);
        if (cell2)
          state2 = graph.view.getState(cell2);
      }
      return state2;
    };
    graph.addMouseListener({
      mouseDown: (sender, me) => {
        const popupMenuHandler = graph.getPlugin("PopupMenuHandler");
        popupMenuHandler == null ? void 0 : popupMenuHandler.hideMenu();
      },
      mouseMove: () => {
        return;
      },
      mouseUp: () => {
        return;
      }
    });
    this.moveHandler = (evt2) => {
      const tooltipHandler = graph.getPlugin("TooltipHandler");
      if (tooltipHandler && tooltipHandler.isHideOnHover()) {
        tooltipHandler.hide();
      }
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt2) && graph.container.style.display !== "none" && graph.container.style.visibility !== "hidden" && !isConsumed(evt2)) {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, getState(evt2)));
      }
    };
    this.endHandler = (evt2) => {
      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt2) && graph.container.style.display !== "none" && graph.container.style.visibility !== "hidden") {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2));
      }
    };
    InternalEvent_default.addGestureListeners(document, null, this.moveHandler, this.endHandler);
  }
  /**
   * Creates and returns the DOM nodes for the SVG display.
   */
  createSvg() {
    const { container } = this.graph;
    const canvas = this.canvas = document.createElementNS("http://www.w3.org/2000/svg", "g");
    this.backgroundPane = document.createElementNS("http://www.w3.org/2000/svg", "g");
    canvas.appendChild(this.backgroundPane);
    this.drawPane = document.createElementNS("http://www.w3.org/2000/svg", "g");
    canvas.appendChild(this.drawPane);
    this.overlayPane = document.createElementNS("http://www.w3.org/2000/svg", "g");
    canvas.appendChild(this.overlayPane);
    this.decoratorPane = document.createElementNS("http://www.w3.org/2000/svg", "g");
    canvas.appendChild(this.decoratorPane);
    const root = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    root.style.left = "0px";
    root.style.top = "0px";
    root.style.width = "100%";
    root.style.height = "100%";
    root.style.display = "block";
    root.appendChild(this.canvas);
    if (container != null) {
      container.appendChild(root);
      this.updateContainerStyle(container);
    }
  }
  /**
   * Function: createHtml
   *
   * Creates the DOM nodes for the HTML display.
   */
  createHtml() {
    const container = this.graph.container;
    if (container != null) {
      this.canvas = this.createHtmlPane("100%", "100%");
      this.canvas.style.overflow = "hidden";
      this.backgroundPane = this.createHtmlPane("1px", "1px");
      this.drawPane = this.createHtmlPane("1px", "1px");
      this.overlayPane = this.createHtmlPane("1px", "1px");
      this.decoratorPane = this.createHtmlPane("1px", "1px");
      this.canvas.appendChild(this.backgroundPane);
      this.canvas.appendChild(this.drawPane);
      this.canvas.appendChild(this.overlayPane);
      this.canvas.appendChild(this.decoratorPane);
      container.appendChild(this.canvas);
      this.updateContainerStyle(container);
    }
  }
  /**
   * Function: updateHtmlCanvasSize
   *
   * Updates the size of the HTML canvas.
   */
  updateHtmlCanvasSize(width, height) {
    if (this.graph.container != null) {
      const ow = this.graph.container.offsetWidth;
      const oh = this.graph.container.offsetHeight;
      if (ow < width) {
        this.canvas.style.width = width + "px";
      } else {
        this.canvas.style.width = "100%";
      }
      if (oh < height) {
        this.canvas.style.height = height + "px";
      } else {
        this.canvas.style.height = "100%";
      }
    }
  }
  /**
   * Function: createHtmlPane
   *
   * Creates and returns a drawing pane in HTML (DIV).
   */
  createHtmlPane(width, height) {
    const pane = document.createElement("DIV");
    if (width != null && height != null) {
      pane.style.position = "absolute";
      pane.style.left = "0px";
      pane.style.top = "0px";
      pane.style.width = width;
      pane.style.height = height;
    } else {
      pane.style.position = "relative";
    }
    return pane;
  }
  /**
   * Updates the style of the container after installing the SVG DOM elements.
   */
  updateContainerStyle(container) {
    const style2 = getCurrentStyle(container);
    if (style2 != null && style2.position == "static") {
      container.style.position = "relative";
    }
    if (Client_default.IS_POINTER) {
      container.style.touchAction = "none";
    }
  }
  /**
   * Destroys the view and all its resources.
   */
  destroy() {
    let root = null;
    if (this.canvas && this.canvas instanceof SVGElement) {
      root = this.canvas.ownerSVGElement;
    }
    if (!root) {
      root = this.canvas;
    }
    if (root && root.parentNode) {
      this.clear(this.currentRoot, true);
      InternalEvent_default.removeGestureListeners(document, null, this.moveHandler, this.endHandler);
      InternalEvent_default.release(this.graph.container);
      root.parentNode.removeChild(root);
      this.moveHandler = null;
      this.endHandler = null;
      this.canvas = null;
      this.backgroundPane = null;
      this.drawPane = null;
      this.overlayPane = null;
      this.decoratorPane = null;
    }
  }
};
var GraphView_default = GraphView;

// node_modules/@maxgraph/core/lib/view/geometry/edge/PolylineShape.js
var PolylineShape = class extends Shape_default {
  /**
   * Constructs a new polyline shape.
   *
   * @param points Array of <{@link Point} that define the points. This is stored in {@link Shape.points}.
   * @param stroke String that defines the stroke color. Default is 'black'. This is stored in {@link Shape.stroke}.
   * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link Shape.strokeWidth}.
   */
  constructor(points2, stroke, strokeWidth = 1) {
    super();
    this.points = points2;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Returns 0.
   */
  getRotation() {
    return 0;
  }
  /**
   * Returns 0.
   */
  getShapeRotation() {
    return 0;
  }
  /**
   * Returns false.
   */
  isPaintBoundsInverted() {
    return false;
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    const prev = c.pointerEventsValue;
    c.pointerEventsValue = "stroke";
    if (!this.style || !this.style.curved) {
      this.paintLine(c, pts, this.isRounded);
    } else {
      this.paintCurvedLine(c, pts);
    }
    c.pointerEventsValue = prev;
  }
  /**
   * Paints the line shape.
   */
  paintLine(c, pts, rounded) {
    var _a2;
    const arcSize = ((_a2 = this.style) == null ? void 0 : _a2.arcSize) ?? LINE_ARCSIZE;
    c.begin();
    this.addPoints(c, pts, rounded, arcSize, false);
    c.stroke();
  }
  /**
   * Paints the line shape.
   */
  paintCurvedLine(c, pts) {
    c.begin();
    const pt = pts[0];
    const n = pts.length;
    c.moveTo(pt.x, pt.y);
    for (let i2 = 1; i2 < n - 2; i2 += 1) {
      const p02 = pts[i2];
      const p12 = pts[i2 + 1];
      const ix = (p02.x + p12.x) / 2;
      const iy = (p02.y + p12.y) / 2;
      c.quadTo(p02.x, p02.y, ix, iy);
    }
    const p0 = pts[n - 2];
    const p1 = pts[n - 1];
    c.quadTo(p0.x, p0.y, p1.x, p1.y);
    c.stroke();
  }
};
var PolylineShape_default = PolylineShape;

// node_modules/@maxgraph/core/lib/view/geometry/edge/MarkerShape.js
var MarkerShape = class _MarkerShape {
  /**
   * Adds a factory method that updates a given endpoint and returns a
   * function to paint the marker onto the given canvas.
   */
  static addMarker(type, funct2) {
    _MarkerShape.markers[type] = funct2;
  }
  /**
   * Returns a function to paint the given marker.
   */
  static createMarker(canvas, shape2, type, pe, unitX, unitY, size, source2, sw, filled) {
    const markerFunction = _MarkerShape.markers[type];
    return markerFunction ? markerFunction(canvas, shape2, type, pe, unitX, unitY, size, source2, sw, filled) : null;
  }
};
MarkerShape.markers = {};
var MarkerShape_default = MarkerShape;
function createArrow(widthFactor) {
  return (canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) => {
    const endOffsetX = unitX * sw * 1.118;
    const endOffsetY = unitY * sw * 1.118;
    unitX *= size + sw;
    unitY *= size + sw;
    const pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    const f = type !== ARROW.CLASSIC && type !== ARROW.CLASSIC_THIN ? 1 : 3 / 4;
    pe.x += -unitX * f - endOffsetX;
    pe.y += -unitY * f - endOffsetY;
    return () => {
      canvas.begin();
      canvas.moveTo(pt.x, pt.y);
      canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
      if (type === ARROW.CLASSIC || type === ARROW.CLASSIC_THIN) {
        canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
      }
      canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
      canvas.close();
      if (filled) {
        canvas.fillAndStroke();
      } else {
        canvas.stroke();
      }
    };
  };
}
function createOpenArrow(widthFactor) {
  return (canvas, _shape, _type, pe, unitX, unitY, size, _source, sw, _filled) => {
    const endOffsetX = unitX * sw * 1.118;
    const endOffsetY = unitY * sw * 1.118;
    unitX *= size + sw;
    unitY *= size + sw;
    const pt = pe.clone();
    pt.x -= endOffsetX;
    pt.y -= endOffsetY;
    pe.x += -endOffsetX * 2;
    pe.y += -endOffsetY * 2;
    return () => {
      canvas.begin();
      canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
      canvas.lineTo(pt.x, pt.y);
      canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
      canvas.stroke();
    };
  };
}
var oval = (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, filled) => {
  const a = size / 2;
  const pt = pe.clone();
  pe.x -= unitX * a;
  pe.y -= unitY * a;
  return () => {
    canvas.ellipse(pt.x - a, pt.y - a, size, size);
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
};
function diamond(canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) {
  const swFactor = type === ARROW.DIAMOND ? 0.7071 : 0.9862;
  const endOffsetX = unitX * sw * swFactor;
  const endOffsetY = unitY * sw * swFactor;
  unitX *= size + sw;
  unitY *= size + sw;
  const pt = pe.clone();
  pt.x -= endOffsetX;
  pt.y -= endOffsetY;
  pe.x += -unitX - endOffsetX;
  pe.y += -unitY - endOffsetY;
  const tk = type === ARROW.DIAMOND ? 2 : 3.4;
  return () => {
    canvas.begin();
    canvas.moveTo(pt.x, pt.y);
    canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);
    canvas.lineTo(pt.x - unitX, pt.y - unitY);
    canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);
    canvas.close();
    if (filled) {
      canvas.fillAndStroke();
    } else {
      canvas.stroke();
    }
  };
}
var isDefaultMarkersRegistered = false;
var registerDefaultEdgeMarkers = () => {
  if (!isDefaultMarkersRegistered) {
    MarkerShape.addMarker("classic", createArrow(2));
    MarkerShape.addMarker("classicThin", createArrow(3));
    MarkerShape.addMarker("block", createArrow(2));
    MarkerShape.addMarker("blockThin", createArrow(3));
    MarkerShape.addMarker("open", createOpenArrow(2));
    MarkerShape.addMarker("openThin", createOpenArrow(3));
    MarkerShape.addMarker("oval", oval);
    MarkerShape.addMarker("diamond", diamond);
    MarkerShape.addMarker("diamondThin", diamond);
    isDefaultMarkersRegistered = true;
  }
};

// node_modules/@maxgraph/core/lib/view/geometry/edge/ConnectorShape.js
var ConnectorShape = class extends PolylineShape_default {
  constructor(points2, stroke, strokewidth) {
    super(points2, stroke, strokewidth);
  }
  /**
   * Updates the <boundingBox> for this shape using <createBoundingBox>
   * and augmentBoundingBox and stores the result in <boundingBox>.
   */
  updateBoundingBox() {
    var _a2;
    this.useSvgBoundingBox = !!((_a2 = this.style) == null ? void 0 : _a2.curved);
    super.updateBoundingBox();
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    var _a2, _b, _c, _d;
    const sourceMarker = this.createMarker(c, pts, true);
    const targetMarker = this.createMarker(c, pts, false);
    super.paintEdgeShape(c, pts);
    c.setShadow(false);
    c.setDashed(false);
    if (sourceMarker) {
      const strokeColor = ((_a2 = this.style) == null ? void 0 : _a2.startStrokeColor) ?? this.stroke;
      c.setStrokeColor(strokeColor);
      c.setFillColor(((_b = this.style) == null ? void 0 : _b.startFillColor) ?? strokeColor);
      sourceMarker();
    }
    if (targetMarker) {
      const strokeColor = ((_c = this.style) == null ? void 0 : _c.endStrokeColor) ?? this.stroke;
      c.setStrokeColor(strokeColor);
      c.setFillColor(((_d = this.style) == null ? void 0 : _d.endFillColor) ?? strokeColor);
      targetMarker();
    }
  }
  /**
   * Prepares the marker by adding offsets in pts and returning a function to paint the marker.
   */
  createMarker(c, pts, source2) {
    if (!this.style)
      return null;
    let result2 = null;
    const n = pts.length;
    const type = (source2 ? this.style.startArrow : this.style.endArrow) || NONE;
    let p0 = source2 ? pts[1] : pts[n - 2];
    const pe = source2 ? pts[0] : pts[n - 1];
    if (type !== NONE && p0 !== null && pe !== null) {
      let count = 1;
      while (count < n - 1 && Math.round(p0.x - pe.x) === 0 && Math.round(p0.y - pe.y) === 0) {
        p0 = source2 ? pts[1 + count] : pts[n - 2 - count];
        count++;
      }
      const dx = pe.x - p0.x;
      const dy = pe.y - p0.y;
      const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));
      const unitX = dx / dist;
      const unitY = dy / dist;
      const size = (source2 ? this.style.startSize : this.style.endSize) ?? DEFAULT_MARKERSIZE;
      const filled = (source2 ? this.style.startFill : this.style.endFill) ?? true;
      result2 = MarkerShape_default.createMarker(c, this, type, pe, unitX, unitY, size, source2, this.strokeWidth, filled);
    }
    return result2;
  }
  /**
   * Augments the bounding box with the strokewidth and shadow offsets.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    if (!this.style)
      return;
    let size = 0;
    if (this.style.startArrow !== NONE) {
      size = (this.style.startSize ?? DEFAULT_MARKERSIZE) + 1;
    }
    if (this.style.endArrow !== NONE) {
      size = Math.max(size, this.style.endSize ?? DEFAULT_MARKERSIZE) + 1;
    }
    bbox.grow(size * this.scale);
  }
};
var ConnectorShape_default = ConnectorShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/TextShape.js
var TextShape = class extends Shape_default {
  constructor(value2, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = "black", family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = "visible", labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {
    super();
    this.margin = null;
    this.unrotatedBoundingBox = null;
    this.flipH = false;
    this.flipV = false;
    this.baseSpacingTop = 0;
    this.baseSpacingBottom = 0;
    this.baseSpacingLeft = 0;
    this.baseSpacingRight = 0;
    this.replaceLinefeeds = true;
    this.verticalTextRotation = -90;
    this.ignoreClippedStringSize = true;
    this.ignoreStringSize = false;
    this.lastValue = null;
    this.cacheEnabled = true;
    this.value = value2;
    this.bounds = bounds;
    this.color = color ?? "black";
    this.align = align ?? ALIGN.CENTER;
    this.valign = valign ?? ALIGN.MIDDLE;
    this.family = family ?? DEFAULT_FONTFAMILY;
    this.size = size ?? DEFAULT_FONTSIZE;
    this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;
    this.spacing = spacing ?? 2;
    this.spacingTop = this.spacing + (spacingTop ?? 0);
    this.spacingRight = this.spacing + (spacingRight ?? 0);
    this.spacingBottom = this.spacing + (spacingBottom ?? 0);
    this.spacingLeft = this.spacing + (spacingLeft ?? 0);
    this.horizontal = horizontal ?? true;
    this.background = background;
    this.border = border;
    this.wrap = wrap ?? false;
    this.clipped = clipped ?? false;
    this.overflow = overflow ?? "visible";
    this.labelPadding = labelPadding ?? 0;
    this.textDirection = textDirection;
    this.rotation = 0;
    this.updateMargin();
  }
  /**
   * Disables offset in IE9 for crisper image output.
   */
  getSvgScreenOffset() {
    return 0;
  }
  /**
   * Returns true if the bounds are not null and all of its variables are numeric.
   */
  checkBounds() {
    return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);
  }
  /**
   * Generic rendering code.
   */
  paint(c, update = false) {
    const s = this.scale;
    const x = this.bounds.x / s;
    const y = this.bounds.y / s;
    const w = this.bounds.width / s;
    const h = this.bounds.height / s;
    this.updateTransform(c, x, y, w, h);
    this.configureCanvas(c, x, y, w, h);
    if (update) {
      c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);
    } else {
      const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;
      const fmt = realHtml ? "html" : "";
      let val = this.value;
      if (!realHtml && fmt === "html") {
        val = htmlEntities(val, false);
      }
      if (fmt === "html" && !isNode(this.value)) {
        val = replaceTrailingNewlines(val, "<div><br></div>");
      }
      val = !isNode(this.value) && this.replaceLinefeeds && fmt === "html" ? val.replace(/\n/g, "<br/>") : val;
      let dir = this.textDirection;
      if (dir === TEXT_DIRECTION.AUTO && !realHtml) {
        dir = this.getAutoDirection();
      }
      if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {
        dir = TEXT_DIRECTION.DEFAULT;
      }
      c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);
    }
  }
  /**
   * Renders the text using the given DOM nodes.
   */
  redraw() {
    if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue === this.value && (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {
      if (this.node.nodeName === "DIV") {
        this.redrawHtmlShape();
        this.updateBoundingBox();
      } else {
        const canvas = this.createCanvas();
        if (canvas) {
          canvas.pointerEvents = this.pointerEvents;
          this.paint(canvas, true);
          this.destroyCanvas(canvas);
          this.updateBoundingBox();
        }
      }
    } else {
      super.redraw();
      if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {
        this.lastValue = this.value;
      } else {
        this.lastValue = null;
      }
    }
  }
  /**
   * Resets all styles.
   */
  resetStyles() {
    super.resetStyles();
    this.color = "black";
    this.align = ALIGN.CENTER;
    this.valign = ALIGN.MIDDLE;
    this.family = DEFAULT_FONTFAMILY;
    this.size = DEFAULT_FONTSIZE;
    this.fontStyle = DEFAULT_FONTSTYLE;
    this.spacing = 2;
    this.spacingTop = 2;
    this.spacingRight = 2;
    this.spacingBottom = 2;
    this.spacingLeft = 2;
    this.horizontal = true;
    this.background = NONE;
    this.border = NONE;
    this.textDirection = DEFAULT_TEXT_DIRECTION;
    this.margin = null;
  }
  /**
   * Extends mxShape to update the text styles.
   *
   * @param state <CellState> of the corresponding cell.
   */
  apply(state2) {
    const old = this.spacing;
    super.apply(state2);
    if (this.style) {
      this.fontStyle = this.style.fontStyle ?? this.fontStyle;
      this.family = this.style.fontFamily ?? this.family;
      this.size = this.style.fontSize ?? this.size;
      this.color = this.style.fontColor ?? this.color;
      this.align = this.style.align ?? this.align;
      this.valign = this.style.verticalAlign ?? this.valign;
      this.spacing = this.style.spacing ?? this.spacing;
      this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;
      this.spacingRight = (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;
      this.spacingBottom = (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;
      this.spacingLeft = (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;
      this.horizontal = this.style.horizontal ?? this.horizontal;
      this.background = this.style.labelBackgroundColor ?? this.background;
      this.border = this.style.labelBorderColor ?? this.border;
      this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;
      this.opacity = this.style.textOpacity ?? 100;
      this.updateMargin();
    }
    this.flipV = false;
    this.flipH = false;
  }
  /**
   * Used to determine the automatic text direction. Returns
   * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}
   * depending on the contents of <value>. This is not invoked for HTML, wrapped
   * content or if <value> is a DOM node.
   */
  getAutoDirection() {
    const tmp2 = /[A-Za-z\u05d0-\u065f\u066a-\u06ef\u06fa-\u07ff\ufb1d-\ufdff\ufe70-\ufefc]/.exec(String(this.value));
    return tmp2 && tmp2.length > 0 && tmp2[0] > "z" ? TEXT_DIRECTION.RTL : TEXT_DIRECTION.LTR;
  }
  /**
   * Returns the node that contains the rendered input.
   */
  getContentNode() {
    let result2 = this.node;
    if (result2) {
      if (!result2.ownerSVGElement) {
        result2 = this.node.firstChild.firstChild;
      } else {
        result2 = result2.firstChild.firstChild.firstChild.firstChild.firstChild;
      }
    }
    return result2;
  }
  /**
   * Updates the <boundingBox> for this shape using the given node and position.
   */
  updateBoundingBox() {
    var _a2, _b, _c;
    let { node: node2 } = this;
    this.boundingBox = this.bounds.clone();
    const rot = this.getTextRotation();
    const h = ((_a2 = this.style) == null ? void 0 : _a2.labelPosition) ?? ALIGN.CENTER;
    const v = ((_b = this.style) == null ? void 0 : _b.verticalLabelPosition) ?? ALIGN.MIDDLE;
    if (!this.ignoreStringSize && node2 && this.overflow !== "fill" && (!this.clipped || !this.ignoreClippedStringSize || h !== ALIGN.CENTER || v !== ALIGN.MIDDLE)) {
      let ow = null;
      let oh = null;
      if (node2.firstChild && node2.firstChild.firstChild && node2.firstChild.firstChild.nodeName === "foreignObject") {
        node2 = node2.firstChild.firstChild.firstChild.firstChild;
        oh = node2.offsetHeight * this.scale;
        if (this.overflow === "width") {
          ow = this.boundingBox.width;
        } else {
          ow = node2.offsetWidth * this.scale;
        }
      } else {
        try {
          const b = node2.getBBox();
          if (typeof this.value === "string" && ((_c = trim(this.value)) == null ? void 0 : _c.length) === 0) {
            this.boundingBox = null;
          } else if (b.width === 0 && b.height === 0) {
            this.boundingBox = null;
          } else {
            this.boundingBox = new Rectangle_default(b.x, b.y, b.width, b.height);
          }
          return;
        } catch (e) {
        }
      }
      if (ow && oh) {
        this.boundingBox = new Rectangle_default(this.bounds.x, this.bounds.y, ow, oh);
      }
    }
    if (this.boundingBox) {
      const margin = this.margin;
      if (rot !== 0) {
        const bbox = getBoundingBox(new Rectangle_default(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point_default(0, 0));
        this.unrotatedBoundingBox = Rectangle_default.fromRectangle(this.boundingBox);
        this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;
        this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;
        this.boundingBox.x += bbox.x;
        this.boundingBox.y += bbox.y;
        this.boundingBox.width = bbox.width;
        this.boundingBox.height = bbox.height;
      } else {
        this.boundingBox.x += margin.x * this.boundingBox.width;
        this.boundingBox.y += margin.y * this.boundingBox.height;
        this.unrotatedBoundingBox = null;
      }
    }
  }
  /**
   * Returns 0 to avoid using rotation in the canvas via updateTransform.
   */
  getShapeRotation() {
    return 0;
  }
  /**
   * Returns the rotation for the text label of the corresponding shape.
   */
  getTextRotation() {
    return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;
  }
  /**
   * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the
   * horizontal style is false.
   */
  isPaintBoundsInverted() {
    return !this.horizontal && !!this.state && this.state.cell.isVertex();
  }
  /**
   * Sets the state of the canvas for drawing the shape.
   */
  configureCanvas(c, x, y, w, h) {
    super.configureCanvas(c, x, y, w, h);
    c.setFontColor(this.color);
    c.setFontBackgroundColor(this.background);
    c.setFontBorderColor(this.border);
    c.setFontFamily(this.family);
    c.setFontSize(this.size);
    c.setFontStyle(this.fontStyle);
  }
  /**
   * Private helper function to create SVG elements
   */
  getHtmlValue() {
    let val = this.value;
    if (this.dialect !== DIALECT.STRICTHTML) {
      val = htmlEntities(val, false);
    }
    val = replaceTrailingNewlines(val, "<div><br></div>");
    val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
    return val;
  }
  /**
   * Private helper function to create SVG elements
   */
  getTextCss() {
    const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;
    let css = `display: inline-block; font-size: ${this.size}px; font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? "all" : "none"}; `;
    matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += "font-weight: bold; ");
    matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += "font-style: italic; ");
    const txtDecor = [];
    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(" ")}; `);
    return css;
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  redrawHtmlShape() {
    const w = Math.max(0, Math.round(this.bounds.width / this.scale));
    const h = Math.max(0, Math.round(this.bounds.height / this.scale));
    const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;
    const block = this.getTextCss();
    const margin = this.margin;
    const node2 = this.node;
    SvgCanvas2D_default.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex2, item2, block2, ofl) => {
      const r = this.getTextRotation();
      let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : "") + (r !== 0 ? `rotate(${r}deg) ` : "") + (margin.x !== 0 || margin.y !== 0 ? `translate(${margin.x * 100}%,${margin.y * 100}%)` : "");
      if (tr !== "") {
        tr = `transform-origin: 0 0; transform: ${tr}; `;
      }
      if (ofl === "") {
        flex2 += item2;
        item2 = `display:inline-block; min-width: 100%; ${tr}`;
      } else {
        item2 += tr;
        if (Client_default.IS_SF) {
          item2 += "-webkit-clip-path: content-box;";
        }
      }
      if (this.opacity < 100) {
        block2 += `opacity: ${this.opacity / 100}; `;
      }
      node2.setAttribute("style", flex2);
      const html = isNode(this.value) ? (
        // @ts-ignore
        this.value.outerHTML
      ) : this.getHtmlValue();
      if (!node2.firstChild) {
        node2.innerHTML = `<div><div>${html}</div></div>`;
      }
      node2.firstChild.firstChild.setAttribute("style", block2);
      node2.firstChild.setAttribute("style", item2);
    });
  }
  /**
   * Sets the inner HTML of the given element to the <value>.
   */
  updateInnerHtml(elt2) {
    if (isNode(this.value)) {
      elt2.innerHTML = this.value.outerHTML;
    } else {
      let val = this.value;
      if (this.dialect !== DIALECT.STRICTHTML) {
        val = htmlEntities(val, false);
      }
      val = replaceTrailingNewlines(val, "<div>&nbsp;</div>");
      val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
      val = `<div style="display:inline-block;_display:inline;">${val}</div>`;
      elt2.innerHTML = val;
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateValue() {
    const node2 = this.node;
    if (isNode(this.value)) {
      node2.innerHTML = "";
      node2.appendChild(this.value);
    } else {
      let val = this.value;
      if (this.dialect !== DIALECT.STRICTHTML) {
        val = htmlEntities(val, false);
      }
      val = replaceTrailingNewlines(val, "<div><br></div>");
      val = this.replaceLinefeeds ? val.replace(/\n/g, "<br/>") : val;
      const bg = this.background !== NONE ? this.background : null;
      const bd = this.border !== NONE ? this.border : null;
      if (this.overflow === "fill" || this.overflow === "width") {
        if (bg) {
          node2.style.backgroundColor = bg;
        }
        if (bd) {
          node2.style.border = `1px solid ${bd}`;
        }
      } else {
        let css = "";
        if (bg) {
          css += `background-color:${htmlEntities(bg, true)};`;
        }
        if (bd) {
          css += `border:1px solid ${htmlEntities(bd, true)};`;
        }
        const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;
        val = `<div style="zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;padding-bottom:1px;padding-right:1px;line-height:${lh}">${val}</div>`;
      }
      node2.innerHTML = val;
      const divs = node2.getElementsByTagName("div");
      if (divs.length > 0) {
        let dir = this.textDirection;
        if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {
          dir = this.getAutoDirection();
        }
        if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {
          divs[divs.length - 1].setAttribute("dir", dir);
        } else {
          divs[divs.length - 1].removeAttribute("dir");
        }
      }
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateFont(node2) {
    const { style: style2 } = node2;
    style2.lineHeight = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;
    style2.fontSize = `${this.size}px`;
    style2.fontFamily = this.family;
    style2.verticalAlign = "top";
    style2.color = this.color;
    matchBinaryMask(this.fontStyle, FONT.BOLD) ? style2.fontWeight = "bold" : style2.fontWeight = "";
    matchBinaryMask(this.fontStyle, FONT.ITALIC) ? style2.fontStyle = "italic" : style2.fontStyle = "";
    const txtDecor = [];
    matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push("underline");
    matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push("line-through");
    txtDecor.length > 0 && (style2.textDecoration = txtDecor.join(" "));
    if (this.align === ALIGN.CENTER) {
      style2.textAlign = "center";
    } else if (this.align === ALIGN.RIGHT) {
      style2.textAlign = "right";
    } else {
      style2.textAlign = "left";
    }
  }
  /**
   * Updates the HTML node(s) to reflect the latest bounds and scale.
   */
  updateSize(node2, enableWrap = false) {
    const w = Math.max(0, Math.round(this.bounds.width / this.scale));
    const h = Math.max(0, Math.round(this.bounds.height / this.scale));
    const { style: style2 } = node2;
    if (this.clipped) {
      style2.overflow = "hidden";
      style2.maxHeight = `${h}px`;
      style2.maxWidth = `${w}px`;
    } else if (this.overflow === "fill") {
      style2.width = `${w + 1}px`;
      style2.height = `${h + 1}px`;
      style2.overflow = "hidden";
    } else if (this.overflow === "width") {
      style2.width = `${w + 1}px`;
      style2.maxHeight = `${h + 1}px`;
      style2.overflow = "hidden";
    }
    if (this.wrap && w > 0) {
      style2.wordWrap = WORD_WRAP;
      style2.whiteSpace = "normal";
      style2.width = `${w}px`;
      if (enableWrap && this.overflow !== "fill" && this.overflow !== "width") {
        let sizeDiv = node2;
        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === "DIV") {
          sizeDiv = sizeDiv.firstChild;
          if (node2.style.wordWrap === "break-word") {
            sizeDiv.style.width = "100%";
          }
        }
        let tmp2 = sizeDiv.offsetWidth;
        if (tmp2 === 0) {
          const prev = node2.parentNode;
          node2.style.visibility = "hidden";
          document.body.appendChild(node2);
          tmp2 = sizeDiv.offsetWidth;
          node2.style.visibility = "";
          prev.appendChild(node2);
        }
        tmp2 += 3;
        if (this.clipped) {
          tmp2 = Math.min(tmp2, w);
        }
        style2.width = `${tmp2}px`;
      }
    } else {
      style2.whiteSpace = "nowrap";
    }
  }
  /**
   * Returns the spacing as an {@link Point}.
   */
  updateMargin() {
    this.margin = getAlignmentAsPoint(this.align, this.valign);
  }
  /**
   * Returns the spacing as an {@link Point}.
   */
  getSpacing() {
    let dx = 0;
    let dy = 0;
    if (this.align === ALIGN.CENTER) {
      dx = (this.spacingLeft - this.spacingRight) / 2;
    } else if (this.align === ALIGN.RIGHT) {
      dx = -this.spacingRight - this.baseSpacingRight;
    } else {
      dx = this.spacingLeft + this.baseSpacingLeft;
    }
    if (this.valign === ALIGN.MIDDLE) {
      dy = (this.spacingTop - this.spacingBottom) / 2;
    } else if (this.valign === ALIGN.BOTTOM) {
      dy = -this.spacingBottom - this.baseSpacingBottom;
    } else {
      dy = this.spacingTop + this.baseSpacingTop;
    }
    return new Point_default(dx, dy);
  }
};
var TextShape_default = TextShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/StencilShapeRegistry.js
var StencilShapeRegistry = class _StencilShapeRegistry {
  /**
   * Adds the given {@link Stencil}.
   * @static
   * @param {string} name
   * @param {StencilShape} stencil
   */
  static addStencil(name2, stencil) {
    _StencilShapeRegistry.stencils[name2] = stencil;
  }
  /**
   * Returns the {@link Stencil} for the given name.
   * @static
   * @param {string} name
   * @returns {StencilShape}
   */
  static getStencil(name2) {
    return _StencilShapeRegistry.stencils[name2];
  }
};
StencilShapeRegistry.stencils = {};
var StencilShapeRegistry_default = StencilShapeRegistry;

// node_modules/@maxgraph/core/lib/view/cell/CellRenderer.js
var placeholderStyleValues = ["inherit", "swimlane", "indicated"];
var placeholderStyleProperties = [
  "fillColor",
  "strokeColor",
  "gradientColor",
  "fontColor"
];
var CellRenderer = class _CellRenderer {
  constructor() {
    this.defaultEdgeShape = ConnectorShape_default;
    this.defaultVertexShape = RectangleShape_default;
    this.defaultTextShape = TextShape_default;
    this.legacyControlPosition = true;
    this.legacySpacing = true;
    this.antiAlias = true;
    this.minSvgStrokeWidth = 1;
    this.forceControlClickHandler = false;
  }
  /**
   * Registers the given constructor under the specified key in this instance of the renderer.
   * @example
   * ```
   * CellRenderer.registerShape(Constants.SHAPE_RECTANGLE, RectangleShape);
   * ```
   *
   * @param key the shape name.
   * @param shape constructor of the {@link Shape} subclass.
   */
  static registerShape(key2, shape2) {
    _CellRenderer.defaultShapes[key2] = shape2;
  }
  /**
   * Initializes the shape in the given state by calling its init method with
   * the correct container after configuring it using {@link configureShape}.
   *
   * @param state <CellState> for which the shape should be initialized.
   */
  initializeShape(state2) {
    if (state2.shape) {
      state2.shape.dialect = state2.view.graph.dialect;
      this.configureShape(state2);
      state2.shape.init(state2.view.getDrawPane());
    }
  }
  /**
   * Creates and returns the shape for the given cell state.
   *
   * @param state {@link CellState} for which the shape should be created.
   */
  createShape(state2) {
    let shape2 = null;
    const stencil = StencilShapeRegistry_default.getStencil(state2.style.shape);
    if (stencil) {
      shape2 = new Shape_default(stencil);
    } else {
      const ctor = this.getShapeConstructor(state2);
      shape2 = new ctor();
    }
    return shape2;
  }
  /**
   * Creates the indicator shape for the given cell state.
   *
   * @param state {@link CellState} for which the indicator shape should be created.
   */
  createIndicatorShape(state2) {
    if (state2.shape) {
      state2.shape.indicatorShape = this.getShape(state2.getIndicatorShape() || null);
    }
  }
  /**
   * Returns the shape for the given name from {@link defaultShapes}.
   */
  getShape(name2) {
    return name2 ? _CellRenderer.defaultShapes[name2] : null;
  }
  /**
   * Returns the constructor to be used for creating the shape.
   */
  getShapeConstructor(state2) {
    let ctor = this.getShape(state2.style.shape || null);
    if (!ctor) {
      ctor = state2.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;
    }
    return ctor;
  }
  /**
   * Configures the shape for the given cell state.
   *
   * @param state <CellState> for which the shape should be configured.
   */
  configureShape(state2) {
    const shape2 = state2.shape;
    if (shape2) {
      shape2.apply(state2);
      shape2.imageSrc = state2.getImageSrc() || null;
      shape2.indicatorColor = state2.getIndicatorColor() || NONE;
      shape2.indicatorStrokeColor = state2.style.indicatorStrokeColor || NONE;
      shape2.indicatorGradientColor = state2.getIndicatorGradientColor() || NONE;
      if (state2.style.indicatorDirection) {
        shape2.indicatorDirection = state2.style.indicatorDirection;
      }
      shape2.indicatorImageSrc = state2.getIndicatorImageSrc() || null;
      this.postConfigureShape(state2);
    }
  }
  /**
   * Replaces any reserved words used for attributes, eg. inherit,
   * indicated or swimlane for colors in the shape for the given state.
   * This implementation resolves these keywords on the fill, stroke
   * and gradient color keys.
   */
  postConfigureShape(state2) {
    if (state2.shape) {
      this.resolveColor(state2, "indicatorGradientColor", "gradientColor");
      this.resolveColor(state2, "indicatorColor", "fillColor");
      this.resolveColor(state2, "gradient", "gradientColor");
      this.resolveColor(state2, "stroke", "strokeColor");
      this.resolveColor(state2, "fill", "fillColor");
    }
  }
  /**
   * Check if style properties supporting placeholders requires resolution.
   */
  checkPlaceholderStyles(state2) {
    for (const property of placeholderStyleProperties) {
      if (placeholderStyleValues.includes(state2.style[property])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets
   * the respective color on the shape.
   */
  resolveColor(state2, field, key2) {
    const shape2 = key2 === "fontColor" ? state2.text : state2.shape;
    if (shape2) {
      const graph = state2.view.graph;
      const value2 = shape2[field];
      let referenced = null;
      if (value2 === "inherit") {
        referenced = state2.cell.getParent();
      } else if (value2 === "swimlane") {
        shape2[field] = key2 === "strokeColor" || key2 === "fontColor" ? "#000000" : "#ffffff";
        if (state2.cell.getTerminal(false)) {
          referenced = state2.cell.getTerminal(false);
        } else {
          referenced = state2.cell;
        }
        referenced = graph.getSwimlane(referenced);
        key2 = graph.swimlaneIndicatorColorAttribute;
      } else if (value2 === "indicated" && state2.shape) {
        shape2[field] = state2.shape.indicatorColor;
      } else if (key2 !== "fillColor" && value2 === "fillColor" && state2.shape) {
        shape2[field] = state2.style.fillColor;
      } else if (key2 !== "strokeColor" && value2 === "strokeColor" && state2.shape) {
        shape2[field] = state2.style.strokeColor;
      }
      if (referenced) {
        const rstate = graph.getView().getState(referenced);
        shape2[field] = null;
        if (rstate) {
          const rshape = key2 === "fontColor" ? rstate.text : rstate.shape;
          if (rshape && field !== "indicatorColor") {
            shape2[field] = rshape[field];
          } else {
            shape2[field] = rstate.style[key2];
          }
        }
      }
    }
  }
  /**
   * Returns the value to be used for the label.
   *
   * @param state <CellState> for which the label should be created.
   */
  getLabelValue(state2) {
    const graph = state2.view.graph;
    return graph.getLabel(state2.cell);
  }
  /**
   * Creates the label for the given cell state.
   *
   * @param state <CellState> for which the label should be created.
   */
  createLabel(state2, value2) {
    const graph = state2.view.graph;
    if ((state2.style.fontSize || 0) > 0 || state2.style.fontSize == null) {
      const isForceHtml = graph.isHtmlLabel(state2.cell) || isNode(value2);
      state2.text = new this.defaultTextShape(value2, new Rectangle_default(), state2.style.align ?? ALIGN.CENTER, state2.getVerticalAlign(), state2.style.fontColor, state2.style.fontFamily, state2.style.fontSize, state2.style.fontStyle, state2.style.spacing, state2.style.spacingTop, state2.style.spacingRight, state2.style.spacingBottom, state2.style.spacingLeft, state2.style.horizontal, state2.style.labelBackgroundColor, state2.style.labelBorderColor, graph.isWrapping(state2.cell) && graph.isHtmlLabel(state2.cell), graph.isLabelClipped(state2.cell), state2.style.overflow, state2.style.labelPadding, state2.style.textDirection ?? DEFAULT_TEXT_DIRECTION);
      state2.text.opacity = state2.style.textOpacity ?? 100;
      state2.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
      state2.text.style = state2.style;
      state2.text.state = state2;
      this.initializeLabel(state2, state2.text);
      let forceGetCell = false;
      const getState = (evt2) => {
        let result2 = state2;
        if (Client_default.IS_TOUCH || forceGetCell) {
          const x = getClientX(evt2);
          const y = getClientY(evt2);
          const pt = convertPoint(graph.container, x, y);
          result2 = graph.view.getState(graph.getCellAt(pt.x, pt.y));
        }
        return result2;
      };
      InternalEvent_default.addGestureListeners(state2.text.node, (evt2) => {
        if (this.isLabelEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2, state2));
          const source2 = getSource(evt2);
          forceGetCell = // @ts-ignore nodeName should exist.
          graph.dialect !== DIALECT.SVG && source2.nodeName === "IMG";
        }
      }, (evt2) => {
        if (this.isLabelEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, getState(evt2)));
        }
      }, (evt2) => {
        if (this.isLabelEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2, getState(evt2)));
          forceGetCell = false;
        }
      });
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent_default.addListener(state2.text.node, "dblclick", (evt2) => {
          if (this.isLabelEvent(state2, evt2)) {
            graph.dblClick(evt2, state2.cell);
            InternalEvent_default.consume(evt2);
          }
        });
      }
    }
  }
  /**
   * Initiailzes the label with a suitable container.
   *
   * @param state <CellState> whose label should be initialized.
   */
  initializeLabel(state2, shape2) {
    if (Client_default.IS_SVG && Client_default.NO_FO && shape2.dialect !== DIALECT.SVG) {
      const graph = state2.view.graph;
      shape2.init(graph.container);
    } else {
      shape2.init(state2.view.getDrawPane());
    }
  }
  /**
   * Creates the actual shape for showing the overlay for the given cell state.
   *
   * @param state <CellState> for which the overlay should be created.
   */
  createCellOverlays(state2) {
    const graph = state2.view.graph;
    const overlays = graph.getCellOverlays(state2.cell);
    const dict = new Dictionary_default();
    for (let i2 = 0; i2 < overlays.length; i2 += 1) {
      const shape2 = state2.overlays.remove(overlays[i2]);
      if (!shape2) {
        const tmp2 = new ImageShape_default(new Rectangle_default(), overlays[i2].image.src);
        tmp2.dialect = graph.dialect;
        tmp2.preserveImageAspect = false;
        tmp2.overlay = overlays[i2];
        this.initializeOverlay(state2, tmp2);
        this.installCellOverlayListeners(state2, overlays[i2], tmp2);
        if (overlays[i2].cursor) {
          tmp2.node.style.cursor = overlays[i2].cursor;
        }
        dict.put(overlays[i2], tmp2);
      } else {
        dict.put(overlays[i2], shape2);
      }
    }
    state2.overlays.visit((id2, shape2) => {
      shape2.destroy();
    });
    state2.overlays = dict;
  }
  /**
   * Initializes the given overlay.
   *
   * @param state <CellState> for which the overlay should be created.
   * @param overlay {@link ImageShape} that represents the overlay.
   */
  initializeOverlay(state2, overlay) {
    overlay.init(state2.view.getOverlayPane());
  }
  /**
   * Installs the listeners for the given <CellState>, <CellOverlay> and
   * {@link Shape} that represents the overlay.
   */
  installCellOverlayListeners(state2, overlay, shape2) {
    const graph = state2.view.graph;
    InternalEvent_default.addListener(shape2.node, "click", (evt2) => {
      if (graph.isEditing()) {
        graph.stopEditing(!graph.isInvokesStopCellEditing());
      }
      overlay.fireEvent(new EventObject_default(InternalEvent_default.CLICK, { event: evt2, cell: state2.cell }));
    });
    InternalEvent_default.addGestureListeners(shape2.node, (evt2) => {
      InternalEvent_default.consume(evt2);
    }, (evt2) => {
      graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, state2));
    });
    if (Client_default.IS_TOUCH) {
      InternalEvent_default.addListener(shape2.node, "touchend", (evt2) => {
        overlay.fireEvent(new EventObject_default(InternalEvent_default.CLICK, { event: evt2, cell: state2.cell }));
      });
    }
  }
  /**
   * Creates the control for the given cell state.
   *
   * @param state <CellState> for which the control should be created.
   */
  createControl(state2) {
    const graph = state2.view.graph;
    const image = graph.getFoldingImage(state2);
    if (graph.isFoldingEnabled() && image) {
      if (!state2.control) {
        const b = new Rectangle_default(0, 0, image.width, image.height);
        state2.control = new ImageShape_default(b, image.src);
        state2.control.preserveImageAspect = false;
        state2.control.dialect = graph.dialect;
        this.initControl(state2, state2.control, true, this.createControlClickHandler(state2));
      }
    } else if (state2.control) {
      state2.control.destroy();
      state2.control = null;
    }
  }
  /**
   * Hook for creating the click handler for the folding icon.
   *
   * @param state <CellState> whose control click handler should be returned.
   */
  createControlClickHandler(state2) {
    const graph = state2.view.graph;
    return (evt2) => {
      if (this.forceControlClickHandler || graph.isEnabled()) {
        const collapse = !state2.cell.isCollapsed();
        graph.foldCells(collapse, false, [state2.cell], false, evt2);
        InternalEvent_default.consume(evt2);
      }
    };
  }
  /**
   * Initializes the given control and returns the corresponding DOM node.
   *
   * @param state <CellState> for which the control should be initialized.
   * @param control {@link Shape} to be initialized.
   * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.
   * @param clickHandler Optional function to implement clicks on the control.
   */
  initControl(state2, control, handleEvents, clickHandler) {
    const graph = state2.view.graph;
    const isForceHtml = graph.isHtmlLabel(state2.cell) && Client_default.NO_FO && graph.dialect === DIALECT.SVG;
    if (isForceHtml) {
      control.dialect = DIALECT.PREFERHTML;
      control.init(graph.container);
      control.node.style.zIndex = String(1);
    } else {
      control.init(state2.view.getOverlayPane());
    }
    const node2 = control.node;
    if (clickHandler && !Client_default.IS_IOS) {
      if (graph.isEnabled()) {
        node2.style.cursor = "pointer";
      }
      InternalEvent_default.addListener(node2, "click", clickHandler);
    }
    if (handleEvents) {
      let first = null;
      InternalEvent_default.addGestureListeners(node2, (evt2) => {
        first = new Point_default(getClientX(evt2), getClientY(evt2));
        graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2, state2));
        InternalEvent_default.consume(evt2);
      }, (evt2) => {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, state2));
      }, (evt2) => {
        graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2, state2));
        InternalEvent_default.consume(evt2);
      });
      if (clickHandler && Client_default.IS_IOS) {
        node2.addEventListener("touchend", (evt2) => {
          if (first) {
            const tol = graph.getEventTolerance();
            if (Math.abs(first.x - getClientX(evt2)) < tol && Math.abs(first.y - getClientY(evt2)) < tol) {
              clickHandler.call(clickHandler, evt2);
              InternalEvent_default.consume(evt2);
            }
          }
        }, true);
      }
    }
    return node2;
  }
  /**
   * Returns true if the event is for the shape of the given state. This
   * implementation always returns true.
   *
   * @param state <CellState> whose shape fired the event.
   * @param evt Mouse event which was fired.
   */
  isShapeEvent(state2, evt2) {
    return true;
  }
  /**
   * Returns true if the event is for the label of the given state. This
   * implementation always returns true.
   *
   * @param state <CellState> whose label fired the event.
   * @param evt Mouse event which was fired.
   */
  isLabelEvent(state2, evt2) {
    return true;
  }
  /**
   * Installs the event listeners for the given cell state.
   *
   * @param state <CellState> for which the event listeners should be isntalled.
   */
  installListeners(state2) {
    const graph = state2.view.graph;
    const getState = (evt2) => {
      let result2 = state2;
      const source2 = getSource(evt2);
      if (source2 && graph.dialect !== DIALECT.SVG && // @ts-ignore nodeName should exist
      source2.nodeName === "IMG" || Client_default.IS_TOUCH) {
        const x = getClientX(evt2);
        const y = getClientY(evt2);
        const pt = convertPoint(graph.container, x, y);
        const cell2 = graph.getCellAt(pt.x, pt.y);
        result2 = cell2 ? graph.view.getState(cell2) : null;
      }
      return result2;
    };
    if (state2.shape) {
      InternalEvent_default.addGestureListeners(state2.shape.node, (evt2) => {
        if (this.isShapeEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2, state2));
        }
      }, (evt2) => {
        if (this.isShapeEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, getState(evt2)));
        }
      }, (evt2) => {
        if (this.isShapeEvent(state2, evt2)) {
          graph.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2, getState(evt2)));
        }
      });
      if (graph.isNativeDblClickEnabled()) {
        InternalEvent_default.addListener(state2.shape.node, "dblclick", (evt2) => {
          if (this.isShapeEvent(state2, evt2)) {
            graph.dblClick(evt2, state2.cell);
            InternalEvent_default.consume(evt2);
          }
        });
      }
    }
  }
  /**
   * Redraws the label for the given cell state.
   *
   * @param state <CellState> whose label should be redrawn.
   */
  redrawLabel(state2, forced) {
    const graph = state2.view.graph;
    const value2 = this.getLabelValue(state2);
    const wrapping = graph.isWrapping(state2.cell);
    const clipping = graph.isLabelClipped(state2.cell);
    const isForceHtml = graph.isHtmlLabel(state2.cell) || value2 && isNode(value2);
    const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;
    const overflow = state2.style.overflow ?? "visible";
    if (state2.text && (state2.text.wrap !== wrapping || state2.text.clipped !== clipping || state2.text.overflow !== overflow || state2.text.dialect !== dialect)) {
      state2.text.destroy();
      state2.text = null;
    }
    if (state2.text == null && value2 != null && (isNode(value2) || value2.length > 0)) {
      this.createLabel(state2, value2);
    } else if (state2.text != null && (value2 == null || value2.length == 0)) {
      state2.text.destroy();
      state2.text = null;
    }
    if (state2.text != null) {
      if (forced) {
        if (state2.text.lastValue != null && this.isTextShapeInvalid(state2, state2.text)) {
          state2.text.lastValue = null;
        }
        state2.text.resetStyles();
        state2.text.apply(state2);
        state2.text.valign = state2.getVerticalAlign();
      }
      const bounds = this.getLabelBounds(state2);
      const nextScale = this.getTextScale(state2);
      this.resolveColor(state2, "color", "fontColor");
      if (forced || state2.text.value !== value2 || state2.text.wrap !== wrapping || state2.text.overflow !== overflow || state2.text.clipped !== clipping || state2.text.scale !== nextScale || state2.text.dialect !== dialect || state2.text.bounds == null || !state2.text.bounds.equals(bounds)) {
        state2.text.dialect = dialect;
        state2.text.value = value2;
        state2.text.bounds = bounds;
        state2.text.scale = nextScale;
        state2.text.wrap = wrapping;
        state2.text.clipped = clipping;
        state2.text.overflow = overflow;
        const vis = state2.text.node.style.visibility;
        this.redrawLabelShape(state2.text);
        state2.text.node.style.visibility = vis;
      }
    }
  }
  /**
   * Returns true if the style for the text shape has changed.
   *
   * @param state <CellState> whose label should be checked.
   * @param shape {@link Text} shape to be checked.
   */
  isTextShapeInvalid(state2, shape2) {
    function check(property, stylename, defaultValue) {
      let result2 = false;
      if (stylename === "spacingTop" || stylename === "spacingRight" || stylename === "spacingBottom" || stylename === "spacingLeft") {
        result2 = // @ts-ignore
        parseFloat(String(shape2[property])) - parseFloat(String(shape2.spacing)) !== (state2.style[stylename] || defaultValue);
      } else {
        result2 = shape2[property] !== (state2.style[stylename] || defaultValue);
      }
      return result2;
    }
    return check("fontStyle", "fontStyle", DEFAULT_FONTSTYLE) || check("family", "fontFamily", DEFAULT_FONTFAMILY) || check("size", "fontSize", DEFAULT_FONTSIZE) || check("color", "fontColor", "black") || check("align", "align", "") || check("valign", "verticalAlign", "") || check("spacing", "spacing", 2) || check("spacingTop", "spacingTop", 0) || check("spacingRight", "spacingRight", 0) || check("spacingBottom", "spacingBottom", 0) || check("spacingLeft", "spacingLeft", 0) || check("horizontal", "horizontal", true) || check("background", "labelBackgroundColor", null) || check("border", "labelBorderColor", null) || check("opacity", "textOpacity", 100) || check("textDirection", "textDirection", DEFAULT_TEXT_DIRECTION);
  }
  /**
   * Called to invoked redraw on the given text shape.
   *
   * @param shape {@link Text} shape to be redrawn.
   */
  redrawLabelShape(shape2) {
    shape2.redraw();
  }
  /**
   * Returns the scaling used for the label of the given state
   *
   * @param state <CellState> whose label scale should be returned.
   */
  getTextScale(state2) {
    return state2.view.scale;
  }
  /**
   * Returns the bounds to be used to draw the label of the given state.
   *
   * @param state <CellState> whose label bounds should be returned.
   */
  getLabelBounds(state2) {
    const { scale } = state2.view;
    const isEdge = state2.cell.isEdge();
    let bounds = new Rectangle_default(state2.absoluteOffset.x, state2.absoluteOffset.y);
    if (isEdge) {
      const spacing = state2.text.getSpacing();
      bounds.x += spacing.x * scale;
      bounds.y += spacing.y * scale;
      const geo = state2.cell.getGeometry();
      if (geo != null) {
        bounds.width = Math.max(0, geo.width * scale);
        bounds.height = Math.max(0, geo.height * scale);
      }
    } else {
      if (state2.text.isPaintBoundsInverted()) {
        const tmp2 = bounds.x;
        bounds.x = bounds.y;
        bounds.y = tmp2;
      }
      bounds.x += state2.x;
      bounds.y += state2.y;
      bounds.width = Math.max(1, state2.width);
      bounds.height = Math.max(1, state2.height);
    }
    if (state2.text.isPaintBoundsInverted()) {
      const t = (state2.width - state2.height) / 2;
      bounds.x += t;
      bounds.y -= t;
      const tmp2 = bounds.width;
      bounds.width = bounds.height;
      bounds.height = tmp2;
    }
    if (state2.shape != null) {
      const hpos = state2.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state2.style.verticalLabelPosition ?? ALIGN.MIDDLE;
      if (hpos === ALIGN.CENTER && vpos === ALIGN.MIDDLE) {
        bounds = state2.shape.getLabelBounds(bounds);
      }
    }
    const lw = state2.style.labelWidth ?? null;
    if (lw != null) {
      bounds.width = lw * scale;
    }
    if (!isEdge) {
      this.rotateLabelBounds(state2, bounds);
    }
    return bounds;
  }
  /**
   * Adds the shape rotation to the given label bounds and
   * applies the alignment and offsets.
   *
   * @param state <CellState> whose label bounds should be rotated.
   * @param bounds {@link Rectangle} the rectangle to be rotated.
   */
  rotateLabelBounds(state2, bounds) {
    bounds.y -= state2.text.margin.y * bounds.height;
    bounds.x -= state2.text.margin.x * bounds.width;
    if (!this.legacySpacing || state2.style.overflow !== "fill" && state2.style.overflow !== "width") {
      const s = state2.view.scale;
      const spacing = state2.text.getSpacing();
      bounds.x += spacing.x * s;
      bounds.y += spacing.y * s;
      const hpos = state2.style.labelPosition ?? ALIGN.CENTER;
      const vpos = state2.style.verticalLabelPosition ?? ALIGN.MIDDLE;
      const lw = state2.style.labelWidth ?? null;
      bounds.width = Math.max(0, bounds.width - (hpos === ALIGN.CENTER && lw == null ? (
        // @ts-ignore
        state2.text.spacingLeft * s + state2.text.spacingRight * s
      ) : 0));
      bounds.height = Math.max(0, bounds.height - (vpos === ALIGN.MIDDLE ? (
        // @ts-ignore
        state2.text.spacingTop * s + state2.text.spacingBottom * s
      ) : 0));
    }
    const theta = state2.text.getTextRotation();
    if (theta !== 0 && state2 != null && // @ts-ignore
    state2.cell.isVertex()) {
      const cx = state2.getCenterX();
      const cy = state2.getCenterY();
      if (bounds.x !== cx || bounds.y !== cy) {
        const rad = theta * (Math.PI / 180);
        const pt = getRotatedPoint(new Point_default(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new Point_default(cx, cy));
        bounds.x = pt.x;
        bounds.y = pt.y;
      }
    }
  }
  /**
   * Redraws the overlays for the given cell state.
   *
   * @param state <CellState> whose overlays should be redrawn.
   */
  redrawCellOverlays(state2, forced = false) {
    this.createCellOverlays(state2);
    if (state2.overlays != null) {
      const rot = mod(state2.style.rotation ?? 0, 90);
      const rad = toRadians(rot);
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);
      state2.overlays.visit((id2, shape2) => {
        const bounds = shape2.overlay.getBounds(state2);
        if (!state2.cell.isEdge()) {
          if (state2.shape != null && rot !== 0) {
            let cx = bounds.getCenterX();
            let cy = bounds.getCenterY();
            const point = getRotatedPoint(new Point_default(cx, cy), cos, sin, new Point_default(state2.getCenterX(), state2.getCenterY()));
            cx = point.x;
            cy = point.y;
            bounds.x = Math.round(cx - bounds.width / 2);
            bounds.y = Math.round(cy - bounds.height / 2);
          }
        }
        if (forced || shape2.bounds == null || shape2.scale !== state2.view.scale || !shape2.bounds.equals(bounds)) {
          shape2.bounds = bounds;
          shape2.scale = state2.view.scale;
          shape2.redraw();
        }
      });
    }
  }
  /**
   * Redraws the control for the given cell state.
   *
   * @param state <CellState> whose control should be redrawn.
   */
  redrawControl(state2, forced = false) {
    const image = state2.view.graph.getFoldingImage(state2);
    if (state2.control != null && image != null) {
      const bounds = this.getControlBounds(state2, image.width, image.height);
      const r = this.legacyControlPosition ? state2.style.rotation ?? 0 : state2.shape.getTextRotation();
      const s = state2.view.scale;
      if (forced || state2.control.scale !== s || !state2.control.bounds.equals(bounds) || state2.control.rotation !== r) {
        state2.control.rotation = r;
        state2.control.bounds = bounds;
        state2.control.scale = s;
        state2.control.redraw();
      }
    }
  }
  /**
   * Returns the bounds to be used to draw the control (folding icon) of the
   * given state.
   */
  getControlBounds(state2, w, h) {
    if (state2.control != null) {
      const s = state2.view.scale;
      let cx = state2.getCenterX();
      let cy = state2.getCenterY();
      if (!state2.cell.isEdge()) {
        cx = state2.x + w * s;
        cy = state2.y + h * s;
        if (state2.shape != null) {
          let rot = state2.shape.getShapeRotation();
          if (this.legacyControlPosition) {
            rot = state2.style.rotation ?? 0;
          } else if (state2.shape.isPaintBoundsInverted()) {
            const t = (state2.width - state2.height) / 2;
            cx += t;
            cy -= t;
          }
          if (rot !== 0) {
            const rad = toRadians(rot);
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const point = getRotatedPoint(new Point_default(cx, cy), cos, sin, new Point_default(state2.getCenterX(), state2.getCenterY()));
            cx = point.x;
            cy = point.y;
          }
        }
      }
      return state2.cell.isEdge() ? new Rectangle_default(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s)) : new Rectangle_default(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));
    }
    return null;
  }
  /**
   * Inserts the given array of {@link Shapes} after the given nodes in the DOM.
   *
   * @param shapes Array of {@link Shapes} to be inserted.
   * @param node Node in <drawPane> after which the shapes should be inserted.
   * @param htmlNode Node in the graph container after which the shapes should be inserted that
   * will not go into the <drawPane> (eg. HTML labels without foreignObjects).
   */
  insertStateAfter(state2, node2, htmlNode) {
    const graph = state2.view.graph;
    const shapes = this.getShapesForState(state2);
    for (let i2 = 0; i2 < shapes.length; i2 += 1) {
      if (shapes[i2] != null && shapes[i2].node != null) {
        const html = (
          // @ts-ignore
          shapes[i2].node.parentNode !== state2.view.getDrawPane() && // @ts-ignore
          shapes[i2].node.parentNode !== state2.view.getOverlayPane()
        );
        const temp = html ? htmlNode : node2;
        if (temp != null && temp.nextSibling !== shapes[i2].node) {
          if (temp.nextSibling == null) {
            temp.parentNode.appendChild(shapes[i2].node);
          } else {
            temp.parentNode.insertBefore(shapes[i2].node, temp.nextSibling);
          }
        } else if (temp == null) {
          const shapeNode = shapes[i2].node;
          if (shapeNode.parentNode === graph.container) {
            let { canvas } = state2.view;
            while (canvas != null && canvas.parentNode !== graph.container) {
              canvas = canvas.parentNode;
            }
            if (canvas != null && canvas.nextSibling != null) {
              if (canvas.nextSibling !== shapeNode) {
                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);
              }
            } else {
              shapeNode.parentNode.appendChild(shapeNode);
            }
          } else if (shapeNode.parentNode != null && shapeNode.parentNode.firstChild != null && shapeNode.parentNode.firstChild != shapeNode) {
            shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);
          }
        }
        if (html) {
          htmlNode = shapes[i2].node;
        } else {
          node2 = shapes[i2].node;
        }
      }
    }
    return [node2, htmlNode];
  }
  /**
   * Returns the {@link Shapes} for the given cell state in the order in which they should
   * appear in the DOM.
   *
   * @param state <CellState> whose shapes should be returned.
   */
  getShapesForState(state2) {
    return [state2.shape, state2.text, state2.control];
  }
  /**
   * Updates the bounds or points and scale of the shapes for the given cell
   * state. This is called in mxGraphView.validatePoints as the last step of
   * updating all cells.
   *
   * @param state <CellState> for which the shapes should be updated.
   * @param force Optional boolean that specifies if the cell should be reconfiured
   * and redrawn without any additional checks.
   * @param rendering Optional boolean that specifies if the cell should actually
   * be drawn into the DOM. If this is false then redraw and/or reconfigure
   * will not be called on the shape.
   */
  redraw(state2, force = false, rendering = true) {
    const shapeChanged = this.redrawShape(state2, force, rendering);
    if (state2.shape != null && rendering) {
      this.redrawLabel(state2, shapeChanged);
      this.redrawCellOverlays(state2, shapeChanged);
      this.redrawControl(state2, shapeChanged);
    }
  }
  /**
   * Redraws the shape for the given cell state.
   *
   * @param state <CellState> whose label should be redrawn.
   */
  redrawShape(state2, force = false, rendering = true) {
    let shapeChanged = false;
    const graph = state2.view.graph;
    if (state2.shape != null && state2.shape.style != null && state2.style != null && state2.shape.style.shape !== state2.style.shape) {
      state2.shape.destroy();
      state2.shape = null;
    }
    if (state2.shape == null && graph.container != null && state2.cell !== state2.view.currentRoot && (state2.cell.isVertex() || state2.cell.isEdge())) {
      state2.shape = this.createShape(state2);
      if (state2.shape != null) {
        state2.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;
        state2.shape.antiAlias = this.antiAlias;
        this.createIndicatorShape(state2);
        this.initializeShape(state2);
        this.createCellOverlays(state2);
        this.installListeners(state2);
        const selectionCellsHandler = graph.getPlugin("SelectionCellsHandler");
        selectionCellsHandler == null ? void 0 : selectionCellsHandler.updateHandler(state2);
      }
    } else if (!force && state2.shape != null && (!equalEntries(state2.shape.style, state2.style) || this.checkPlaceholderStyles(state2))) {
      state2.shape.resetStyles();
      this.configureShape(state2);
      const selectionCellsHandler = graph.getPlugin("SelectionCellsHandler");
      selectionCellsHandler == null ? void 0 : selectionCellsHandler.updateHandler(state2);
      force = true;
    }
    if (state2.shape != null && state2.shape.indicatorShape != this.getShape(state2.getIndicatorShape())) {
      if (state2.shape.indicator != null) {
        state2.shape.indicator.destroy();
        state2.shape.indicator = null;
      }
      this.createIndicatorShape(state2);
      if (state2.shape.indicatorShape != null) {
        state2.shape.indicator = new state2.shape.indicatorShape();
        state2.shape.indicator.dialect = state2.shape.dialect;
        state2.shape.indicator.init(state2.node);
        force = true;
      }
    }
    if (state2.shape) {
      this.createControl(state2);
      if (force || this.isShapeInvalid(state2, state2.shape)) {
        if (state2.absolutePoints.length > 0) {
          state2.shape.points = state2.absolutePoints.slice();
          state2.shape.bounds = null;
        } else {
          state2.shape.points = [];
          state2.shape.bounds = new Rectangle_default(state2.x, state2.y, state2.width, state2.height);
        }
        state2.shape.scale = state2.view.scale;
        if (rendering == null || rendering) {
          this.doRedrawShape(state2);
        } else {
          state2.shape.updateBoundingBox();
        }
        shapeChanged = true;
      }
    }
    return shapeChanged;
  }
  /**
   * Invokes redraw on the shape of the given state.
   */
  doRedrawShape(state2) {
    var _a2;
    (_a2 = state2.shape) == null ? void 0 : _a2.redraw();
  }
  /**
   * Returns true if the given shape must be repainted.
   */
  isShapeInvalid(state2, shape2) {
    return shape2.bounds == null || shape2.scale !== state2.view.scale || state2.absolutePoints.length === 0 && !shape2.bounds.equals(state2) || state2.absolutePoints.length > 0 && !equalPoints(shape2.points, state2.absolutePoints);
  }
  /**
   * Destroys the shapes associated with the given cell state.
   *
   * @param state <CellState> for which the shapes should be destroyed.
   */
  destroy(state2) {
    if (state2.shape) {
      if (state2.text) {
        state2.text.destroy();
        state2.text = null;
      }
      state2.overlays.visit((id2, shape2) => {
        shape2.destroy();
      });
      state2.overlays = new Dictionary_default();
      if (state2.control) {
        state2.control.destroy();
        state2.control = null;
      }
      state2.shape.destroy();
      state2.shape = null;
    }
  }
};
CellRenderer.defaultShapes = {};
var CellRenderer_default = CellRenderer;

// node_modules/@maxgraph/core/lib/view/undoable_changes/ChildChange.js
var ChildChange = class {
  constructor(model2, parent2, child2, index = 0) {
    this.model = model2;
    this.parent = parent2;
    this.previous = parent2;
    this.child = child2;
    this.index = index;
    this.previousIndex = index;
  }
  /**
   * Changes the parent of {@link child}` using
   * <Transactions.parentForCellChanged> and
   * removes or restores the cell's
   * connections.
   */
  execute() {
    let tmp2 = this.child.getParent();
    const tmp22 = tmp2 ? tmp2.getIndex(this.child) : 0;
    if (!this.previous) {
      this.connect(this.child, false);
    }
    tmp2 = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);
    if (this.previous) {
      this.connect(this.child, true);
    }
    this.parent = this.previous;
    this.previous = tmp2;
    this.index = this.previousIndex;
    this.previousIndex = tmp22;
  }
  /**
   * Disconnects the given cell recursively from its
   * terminals and stores the previous terminal in the
   * cell's terminals.
   *
   * @warning doc from mxGraph source code is incorrect
   */
  connect(cell2, isConnect = true) {
    const source2 = cell2.getTerminal(true);
    const target2 = cell2.getTerminal(false);
    if (source2) {
      if (isConnect) {
        this.model.terminalForCellChanged(cell2, source2, true);
      } else {
        this.model.terminalForCellChanged(cell2, null, true);
      }
    }
    if (target2) {
      if (isConnect) {
        this.model.terminalForCellChanged(cell2, target2, false);
      } else {
        this.model.terminalForCellChanged(cell2, null, false);
      }
    }
    cell2.setTerminal(source2, true);
    cell2.setTerminal(target2, false);
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      this.connect(cell2.getChildAt(i2), isConnect);
    }
  }
};
var ChildChange_default = ChildChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/CollapseChange.js
var CollapseChange = class {
  constructor(model2, cell2, collapsed) {
    this.model = model2;
    this.cell = cell2;
    this.collapsed = collapsed;
    this.previous = collapsed;
  }
  /**
   * Changes the collapsed state of {@link cell}` to {@link previous}` using
   * <Transactions.collapsedStateForCellChanged>.
   */
  execute() {
    this.collapsed = this.previous;
    this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);
  }
};
var CollapseChange_default = CollapseChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/GeometryChange.js
var GeometryChange = class {
  constructor(model2, cell2, geometry) {
    this.model = model2;
    this.cell = cell2;
    this.geometry = geometry;
    this.previous = geometry;
  }
  /**
   * Changes the geometry of {@link cell}` ro {@link previous}` using
   * <Transactions.geometryForCellChanged>.
   */
  execute() {
    this.geometry = this.previous;
    this.previous = this.model.geometryForCellChanged(this.cell, this.previous);
  }
};
var GeometryChange_default = GeometryChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/RootChange.js
var RootChange = class {
  constructor(model2, root) {
    this.model = model2;
    this.root = root;
    this.previous = root;
  }
  /**
   * Carries out a change of the root using
   * <Transactions.rootChanged>.
   */
  execute() {
    this.root = this.previous;
    this.previous = this.model.rootChanged(this.previous);
  }
};
var RootChange_default = RootChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/StyleChange.js
var StyleChange = class {
  constructor(model2, cell2, style2) {
    this.model = model2;
    this.cell = cell2;
    this.style = style2;
    this.previous = style2;
  }
  /**
   * Changes the style of {@link cell}` to {@link previous}` using
   * <Transactions.styleForCellChanged>.
   */
  execute() {
    this.style = this.previous;
    this.previous = this.model.styleForCellChanged(this.cell, this.previous);
  }
};
var StyleChange_default = StyleChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/TerminalChange.js
var TerminalChange = class {
  constructor(model2, cell2, terminal, source2) {
    this.model = model2;
    this.cell = cell2;
    this.terminal = terminal;
    this.previous = terminal;
    this.source = source2;
  }
  /**
   * Changes the terminal of {@link cell}` to {@link previous}` using
   * <Transactions.terminalForCellChanged>.
   */
  execute() {
    this.terminal = this.previous;
    this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);
  }
};
var TerminalChange_default = TerminalChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/ValueChange.js
var ValueChange = class {
  constructor(model2, cell2, value2) {
    this.model = model2;
    this.cell = cell2;
    this.value = value2;
    this.previous = value2;
  }
  /**
   * Changes the value of {@link cell}` to {@link previous}` using
   * <Transactions.valueForCellChanged>.
   */
  execute() {
    this.value = this.previous;
    this.previous = this.model.valueForCellChanged(this.cell, this.previous);
  }
};
var ValueChange_default = ValueChange;

// node_modules/@maxgraph/core/lib/view/undoable_changes/VisibleChange.js
var VisibleChange = class {
  constructor(model2, cell2, visible) {
    this.model = model2;
    this.cell = cell2;
    this.visible = visible;
    this.previous = visible;
  }
  /**
   * Changes the visible state of {@link cell}` to {@link previous}` using
   * <Transactions.visibleStateForCellChanged>.
   */
  execute() {
    this.visible = this.previous;
    this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);
  }
};
var VisibleChange_default = VisibleChange;

// node_modules/@maxgraph/core/lib/util/cellArrayUtils.js
var cellArrayUtils_exports = {};
__export(cellArrayUtils_exports, {
  cloneCell: () => cloneCell,
  cloneCells: () => cloneCells,
  filterCells: () => filterCells,
  getOpposites: () => getOpposites,
  getParents: () => getParents,
  getTopmostCells: () => getTopmostCells
});
var filterCells = (filter) => (cells) => {
  const result2 = [];
  for (let i2 = 0; i2 < cells.length; i2 += 1) {
    if (filter(cells[i2])) {
      result2.push(cells[i2]);
    }
  }
  return result2;
};
var getOpposites = (edges, terminal, includeSources = true, includeTargets = true) => {
  return edges.reduce((terminals, edge2) => {
    const source2 = edge2.getTerminal(true);
    const target2 = edge2.getTerminal(false);
    if (source2 === terminal && target2 != null && target2 !== terminal && includeTargets) {
      terminals.push(target2);
    } else if (target2 === terminal && source2 != null && source2 !== terminal && includeSources) {
      terminals.push(source2);
    }
    return terminals;
  }, []);
};
var getTopmostCells = (cells) => {
  const dict = new Dictionary_default();
  const tmp2 = [];
  for (let i2 = 0; i2 < cells.length; i2 += 1) {
    dict.put(cells[i2], true);
  }
  for (let i2 = 0; i2 < cells.length; i2 += 1) {
    const cell2 = cells[i2];
    let topmost = true;
    let parent2 = cell2.getParent();
    while (parent2 != null) {
      if (dict.get(parent2)) {
        topmost = false;
        break;
      }
      parent2 = parent2.getParent();
    }
    if (topmost) {
      tmp2.push(cell2);
    }
  }
  return tmp2;
};
var getParents = (cells) => {
  const parents = [];
  const dict = new Dictionary_default();
  for (const cell2 of cells) {
    const parent2 = cell2.getParent();
    if (parent2 != null && !dict.get(parent2)) {
      dict.put(parent2, true);
      parents.push(parent2);
    }
  }
  return parents;
};
var cloneCell = (cell2 = null, includeChildren = true) => {
  if (!cell2) {
    return null;
  }
  return cloneCells([cell2], includeChildren)[0];
};
var cloneCells = (cells, includeChildren = true, mapping = {}) => {
  const clones = [];
  for (const cell2 of cells) {
    clones.push(cloneCellImpl(cell2, mapping, includeChildren));
  }
  for (let i2 = 0; i2 < clones.length; i2 += 1) {
    if (clones[i2] != null) {
      restoreClone(clones[i2], cells[i2], mapping);
    }
  }
  return clones;
};
var cloneCellImpl = (cell2, mapping = {}, includeChildren = false) => {
  const identity = ObjectIdentity_default.get(cell2);
  let clone2 = mapping ? mapping[identity] : null;
  if (clone2 == null) {
    clone2 = cell2.clone();
    mapping[identity] = clone2;
    if (includeChildren) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const cloneChild = cloneCellImpl(cell2.getChildAt(i2), mapping, true);
        clone2.insert(cloneChild);
      }
    }
  }
  return clone2;
};
var restoreClone = (clone2, cell2, mapping) => {
  const source2 = cell2.getTerminal(true);
  if (source2 != null) {
    const tmp2 = mapping[ObjectIdentity_default.get(source2)];
    if (tmp2 != null) {
      tmp2.insertEdge(clone2, true);
    }
  }
  const target2 = cell2.getTerminal(false);
  if (target2 != null) {
    const tmp2 = mapping[ObjectIdentity_default.get(target2)];
    if (tmp2 != null) {
      tmp2.insertEdge(clone2, false);
    }
  }
  const childCount2 = clone2.getChildCount();
  for (let i2 = 0; i2 < childCount2; i2 += 1) {
    restoreClone(clone2.getChildAt(i2), cell2.getChildAt(i2), mapping);
  }
};

// node_modules/@maxgraph/core/lib/view/GraphDataModel.js
var GraphDataModel = class extends EventSource_default {
  constructor(root = null) {
    super();
    this.root = null;
    this.cells = {};
    this.maintainEdgeParent = true;
    this.ignoreRelativeEdgeParent = true;
    this.createIds = true;
    this.prefix = "";
    this.postfix = "";
    this.nextId = 0;
    this.currentEdit = null;
    this.updateLevel = 0;
    this.endingUpdate = false;
    this.currentEdit = this.createUndoableEdit();
    if (root != null) {
      this.setRoot(root);
    } else {
      this.clear();
    }
  }
  /**
   * Sets a new root using {@link createRoot}.
   */
  clear() {
    this.setRoot(this.createRoot());
  }
  /**
   * Returns {@link createIds}.
   */
  isCreateIds() {
    return this.createIds;
  }
  /**
   * Sets {@link createIds}.
   */
  setCreateIds(value2) {
    this.createIds = value2;
  }
  /**
   * Creates a new root cell with a default layer (child 0).
   */
  createRoot() {
    const cell2 = new Cell_default();
    cell2.insert(new Cell_default());
    return cell2;
  }
  /**
   * Returns the {@link Cell} for the specified Id or null if no cell can be
   * found for the given Id.
   *
   * @param {string} id  A string representing the Id of the cell.
   */
  getCell(id2) {
    return this.cells ? this.cells[id2] : null;
  }
  filterCells(cells, filter) {
    return filterCells(filter)(cells);
  }
  getRoot(cell2 = null) {
    return cell2 ? cell2.getRoot() : this.root;
  }
  /**
   * Sets the {@link root} of the model using {@link RootChange} and adds the change to
   * the current transaction. This resets all datastructures in the model and
   * is the preferred way of clearing an existing model. Returns the new
   * root.
   *
   * Example:
   *
   * ```javascript
   * var root = new mxCell();
   * root.insert(new mxCell());
   * model.setRoot(root);
   * ```
   *
   * @param {Cell} root  that specifies the new root.
   */
  setRoot(root) {
    this.execute(new RootChange_default(this, root));
    return root;
  }
  /**
   * Inner callback to change the root of the model and update the internal
   * datastructures, such as {@link cells} and {@link nextId}. Returns the previous root.
   *
   * @param {Cell} root  that specifies the new root.
   */
  rootChanged(root) {
    const oldRoot = this.root;
    this.root = root;
    this.nextId = 0;
    this.cells = null;
    this.cellAdded(root);
    return oldRoot;
  }
  /**
   * Returns true if the given cell is the root of the model and a non-null
   * value.
   *
   * @param {Cell} cell  that represents the possible root.
   */
  isRoot(cell2 = null) {
    return cell2 != null && this.root === cell2;
  }
  /**
   * Returns true if {@link isRoot} returns true for the parent of the given cell.
   *
   * @param cell  that represents the possible layer.
   */
  isLayer(cell2) {
    return cell2 ? this.isRoot(cell2.getParent()) : false;
  }
  /**
   * Returns true if the model contains the given {@link Cell}.
   *
   * @param {Cell} cell  that specifies the cell.
   */
  contains(cell2) {
    return this.root.isAncestor(cell2);
  }
  /**
   * Adds the specified child to the parent at the given index using
   * {@link ChildChange} and adds the change to the current transaction. If no
   * index is specified then the child is appended to the parent's array of
   * children. Returns the inserted child.
   *
   * @param {Cell} parent  that specifies the parent to contain the child.
   * @param {Cell} child  that specifies the child to be inserted.
   * @param index  Optional integer that specifies the index of the child.
   */
  add(parent2, child2, index = null) {
    if (child2 !== parent2 && parent2 != null && child2 != null) {
      if (index == null) {
        index = parent2.getChildCount();
      }
      const parentChanged = parent2 !== child2.getParent();
      this.execute(new ChildChange_default(this, parent2, child2, index));
      if (this.maintainEdgeParent && parentChanged) {
        this.updateEdgeParents(child2);
      }
    }
    return child2;
  }
  /**
   * Inner callback to update {@link cells} when a cell has been added. This
   * implementation resolves collisions by creating new Ids. To change the
   * ID of a cell after it was inserted into the model, use the following
   * code:
   *
   * (code
   * delete model.cells[cell.getId()];
   * cell.setId(newId);
   * model.cells[cell.getId()] = cell;
   * ```
   *
   * If the change of the ID should be part of the command history, then the
   * cell should be removed from the model and a clone with the new ID should
   * be reinserted into the model instead.
   *
   * @param {Cell} cell  that specifies the cell that has been added.
   */
  cellAdded(cell2) {
    if (cell2 != null) {
      if (cell2.getId() == null && this.createIds) {
        cell2.setId(this.createId(cell2));
      }
      if (cell2.getId() != null) {
        let collision = this.getCell(cell2.getId());
        if (collision !== cell2) {
          while (collision != null) {
            cell2.setId(this.createId(cell2));
            collision = this.getCell(cell2.getId());
          }
          if (this.cells == null) {
            this.cells = {};
          }
          this.cells[cell2.getId()] = cell2;
        }
      }
      if (isNumeric(String(cell2.getId()))) {
        this.nextId = Math.max(this.nextId, parseInt(cell2.getId()));
      }
      for (const child2 of cell2.getChildren()) {
        this.cellAdded(child2);
      }
    }
  }
  /**
   * Hook method to create an Id for the specified cell. This implementation
   * concatenates {@link prefix}, id and {@link postfix} to create the Id and increments
   * {@link nextId}. The cell is ignored by this implementation, but can be used in
   * overridden methods to prefix the Ids with eg. the cell type.
   *
   * @param {Cell} cell  to create the Id for.
   */
  createId(cell2) {
    const id2 = this.nextId;
    this.nextId++;
    return this.prefix + id2 + this.postfix;
  }
  /**
   * Updates the parent for all edges that are connected to cell or one of
   * its descendants using {@link updateEdgeParent}.
   */
  updateEdgeParents(cell2, root = this.getRoot(cell2)) {
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      this.updateEdgeParents(child2, root);
    }
    const edgeCount = cell2.getEdgeCount();
    const edges = [];
    for (let i2 = 0; i2 < edgeCount; i2 += 1) {
      edges.push(cell2.getEdgeAt(i2));
    }
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const edge2 = edges[i2];
      if (root.isAncestor(edge2)) {
        this.updateEdgeParent(edge2, root);
      }
    }
  }
  /**
   * Inner callback to update the parent of the specified {@link Cell} to the
   * nearest-common-ancestor of its two terminals.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} root  that represents the current root of the model.
   */
  updateEdgeParent(edge2, root) {
    let source2 = edge2.getTerminal(true);
    let target2 = edge2.getTerminal(false);
    let cell2 = null;
    while (source2 != null && !source2.isEdge() && source2.geometry != null && source2.geometry.relative) {
      source2 = source2.getParent();
    }
    while (target2 != null && this.ignoreRelativeEdgeParent && !target2.isEdge() && target2.geometry != null && target2.geometry.relative) {
      target2 = target2.getParent();
    }
    if (root.isAncestor(source2) && root.isAncestor(target2)) {
      if (source2 === target2) {
        cell2 = source2 ? source2.getParent() : null;
      } else if (source2) {
        cell2 = source2.getNearestCommonAncestor(target2);
      }
      if (cell2 != null && (cell2.getParent() !== this.root || cell2.isAncestor(edge2)) && edge2 && edge2.getParent() !== cell2) {
        let geo = edge2.getGeometry();
        if (geo != null) {
          const origin1 = edge2.getParent().getOrigin();
          const origin2 = cell2.getOrigin();
          const dx = origin2.x - origin1.x;
          const dy = origin2.y - origin1.y;
          geo = geo.clone();
          geo.translate(-dx, -dy);
          this.setGeometry(edge2, geo);
        }
        this.add(cell2, edge2, cell2.getChildCount());
      }
    }
  }
  /**
   * Removes the specified cell from the model using {@link ChildChange} and adds
   * the change to the current transaction. This operation will remove the
   * cell and all of its children from the model. Returns the removed cell.
   *
   * @param {Cell} cell  that should be removed.
   */
  remove(cell2) {
    if (cell2 === this.root) {
      this.setRoot(null);
    } else if (cell2.getParent() != null) {
      this.execute(new ChildChange_default(this, null, cell2));
    }
    return cell2;
  }
  /**
   * Inner callback to update {@link cells} when a cell has been removed.
   *
   * @param {Cell} cell  that specifies the cell that has been removed.
   */
  cellRemoved(cell2) {
    if (cell2 != null && this.cells != null) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = childCount2 - 1; i2 >= 0; i2--) {
        this.cellRemoved(cell2.getChildAt(i2));
      }
      if (this.cells != null && cell2.getId() != null) {
        delete this.cells[cell2.getId()];
      }
    }
  }
  /**
   * Inner callback to update the parent of a cell using {@link Cell#insert}
   * on the parent and return the previous parent.
   *
   * @param {Cell} cell  to update the parent for.
   * @param {Cell} parent  that specifies the new parent of the cell.
   * @param index  Optional integer that defines the index of the child
   * in the parent's child array.
   */
  parentForCellChanged(cell2, parent2, index) {
    const previous = cell2.getParent();
    if (parent2 != null) {
      if (parent2 !== previous || previous.getIndex(cell2) !== index) {
        parent2.insert(cell2, index);
      }
    } else if (previous != null) {
      const oldIndex = previous.getIndex(cell2);
      previous.remove(oldIndex);
    }
    const par = parent2 ? this.contains(parent2) : null;
    const pre = this.contains(previous);
    if (par && !pre) {
      this.cellAdded(cell2);
    } else if (pre && !par) {
      this.cellRemoved(cell2);
    }
    return previous;
  }
  /**
   * Sets the source or target terminal of the given {@link Cell} using
   * {@link TerminalChange} and adds the change to the current transaction.
   * This implementation updates the parent of the edge using {@link updateEdgeParent}
   * if required.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} terminal  that specifies the new terminal.
   * @param isSource  Boolean indicating if the terminal is the new source or
   * target terminal of the edge.
   */
  // setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
  setTerminal(edge2, terminal, isSource) {
    const terminalChanged = terminal !== edge2.getTerminal(isSource);
    this.execute(new TerminalChange_default(this, edge2, terminal, isSource));
    if (this.maintainEdgeParent && terminalChanged) {
      this.updateEdgeParent(edge2, this.getRoot());
    }
    return terminal;
  }
  /**
   * Sets the source and target {@link Cell} of the given {@link Cell} in a single
   * transaction using {@link setTerminal} for each end of the edge.
   *
   * @param {Cell} edge  that specifies the edge.
   * @param {Cell} source  that specifies the new source terminal.
   * @param {Cell} target  that specifies the new target terminal.
   */
  // setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;
  setTerminals(edge2, source2, target2) {
    this.beginUpdate();
    try {
      this.setTerminal(edge2, source2, true);
      this.setTerminal(edge2, target2, false);
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Inner helper function to update the terminal of the edge using
   * {@link Cell#insertEdge} and return the previous terminal.
   *
   * @param {Cell} edge  that specifies the edge to be updated.
   * @param {Cell} terminal  that specifies the new terminal.
   * @param isSource  Boolean indicating if the terminal is the new source or
   * target terminal of the edge.
   */
  // terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;
  terminalForCellChanged(edge2, terminal, isSource = false) {
    const previous = edge2.getTerminal(isSource);
    if (terminal != null) {
      terminal.insertEdge(edge2, isSource);
    } else if (previous != null) {
      previous.removeEdge(edge2, isSource);
    }
    return previous;
  }
  /**
   * Returns all edges between the given source and target pair. If directed
   * is true, then only edges from the source to the target are returned,
   * otherwise, all edges between the two cells are returned.
   *
   * @param {Cell} source  that defines the source terminal of the edge to be
   * returned.
   * @param {Cell} target  that defines the target terminal of the edge to be
   * returned.
   * @param directed  Optional boolean that specifies if the direction of the
   * edge should be taken into account. Default is false.
   */
  getEdgesBetween(source2, target2, directed = false) {
    const tmp1 = source2.getEdgeCount();
    const tmp2 = target2.getEdgeCount();
    let terminal = source2;
    let edgeCount = tmp1;
    if (tmp2 < tmp1) {
      edgeCount = tmp2;
      terminal = target2;
    }
    const result2 = [];
    for (let i2 = 0; i2 < edgeCount; i2 += 1) {
      const edge2 = terminal.getEdgeAt(i2);
      const src = edge2.getTerminal(true);
      const trg = edge2.getTerminal(false);
      const directedMatch = src === source2 && trg === target2;
      const oppositeMatch = trg === source2 && src === target2;
      if (directedMatch || !directed && oppositeMatch) {
        result2.push(edge2);
      }
    }
    return result2;
  }
  /**
   * Sets the user object of then given {@link Cell} using {@link ValueChange}
   * and adds the change to the current transaction.
   *
   * @param {Cell} cell  whose user object should be changed.
   * @param value  Object that defines the new user object.
   */
  setValue(cell2, value2) {
    this.execute(new ValueChange_default(this, cell2, value2));
    return value2;
  }
  /**
   * Inner callback to update the user object of the given {@link Cell}
   * using {@link Cell#valueChanged} and return the previous value,
   * that is, the return value of {@link Cell#valueChanged}.
   *
   * To change a specific attribute in an XML node, the following code can be
   * used.
   *
   * ```javascript
   * graph.getDataModel().valueForCellChanged(cell, value)
   * {
   *   var previous = cell.value.getAttribute('label');
   *   cell.value.setAttribute('label', value);
   *
   *   return previous;
   * };
   * ```
   */
  valueForCellChanged(cell2, value2) {
    return cell2.valueChanged(value2);
  }
  /**
   * Sets the {@link Geometry} of the given {@link Cell}. The actual update
   * of the cell is carried out in {@link geometryForCellChanged}. The
   * {@link GeometryChange} action is used to encapsulate the change.
   *
   * @param {Cell} cell  whose geometry should be changed.
   * @param {Geometry} geometry  that defines the new geometry.
   */
  setGeometry(cell2, geometry) {
    if (geometry !== cell2.getGeometry()) {
      this.execute(new GeometryChange_default(this, cell2, geometry));
    }
    return geometry;
  }
  /**
   * Inner callback to update the {@link Geometry} of the given {@link Cell} using
   * {@link Cell#setGeometry} and return the previous {@link Geometry}.
   */
  geometryForCellChanged(cell2, geometry) {
    const previous = cell2.getGeometry();
    cell2.setGeometry(geometry);
    return previous;
  }
  /**
   * Sets the style of the given {@link Cell} using {@link StyleChange} and adds the change to the current transaction.
   *
   * **IMPORTANT**: Do not pass {@link Cell.getStyle} as value of the `style` parameter. Otherwise, no style change is performed, so the view won't be updated.
   * Always get a clone of the style of the cell with {@link Cell.getClonedStyle}, then update it and pass the updated style to this method.
   *
   * @param cell  whose style should be changed.
   * @param style the new cell style to set.
   */
  setStyle(cell2, style2) {
    if (style2 !== cell2.getStyle()) {
      this.execute(new StyleChange_default(this, cell2, style2));
    }
  }
  /**
   * Inner callback to update the style of the given {@link Cell}  using {@link Cell#setStyle} and return the previous style.
   *
   * **IMPORTANT**: to fully work, this method should not receive `cell.getStyle` as value of the `style` parameter. See {@link setStyle} for more information.
   *
   * @param cell  whose style should be changed.
   * @param style the new cell style to set.
   */
  styleForCellChanged(cell2, style2) {
    const previous = cell2.getStyle();
    cell2.setStyle(style2);
    return previous;
  }
  /**
   * Sets the collapsed state of the given {@link Cell} using {@link CollapseChange}
   * and adds the change to the current transaction.
   *
   * @param {Cell} cell  whose collapsed state should be changed.
   * @param collapsed  Boolean that specifies the new collpased state.
   */
  setCollapsed(cell2, collapsed) {
    if (collapsed !== cell2.isCollapsed()) {
      this.execute(new CollapseChange_default(this, cell2, collapsed));
    }
    return collapsed;
  }
  /**
   * Inner callback to update the collapsed state of the
   * given {@link Cell} using {@link Cell#setCollapsed} and return
   * the previous collapsed state.
   *
   * @param {Cell} cell  that specifies the cell to be updated.
   * @param collapsed  Boolean that specifies the new collapsed state.
   */
  collapsedStateForCellChanged(cell2, collapsed) {
    const previous = cell2.isCollapsed();
    cell2.setCollapsed(collapsed);
    return previous;
  }
  /**
   * Sets the visible state of the given {@link Cell} using {@link VisibleChange} and
   * adds the change to the current transaction.
   *
   * @param {Cell} cell  whose visible state should be changed.
   * @param visible  Boolean that specifies the new visible state.
   */
  setVisible(cell2, visible) {
    if (visible !== cell2.isVisible()) {
      this.execute(new VisibleChange_default(this, cell2, visible));
    }
    return visible;
  }
  /**
   * Inner callback to update the visible state of the
   * given {@link Cell} using {@link Cell#setCollapsed} and return
   * the previous visible state.
   *
   * @param {Cell} cell  that specifies the cell to be updated.
   * @param visible  Boolean that specifies the new visible state.
   */
  visibleStateForCellChanged(cell2, visible) {
    const previous = cell2.isVisible();
    cell2.setVisible(visible);
    return previous;
  }
  /**
   * Executes the given edit and fires events if required. The edit object
   * requires an execute function which is invoked. The edit is added to the
   * {@link currentEdit} between {@link beginUpdate} and {@link endUpdate} calls, so that
   * events will be fired if this execute is an individual transaction, that
   * is, if no previous {@link beginUpdate} calls have been made without calling
   * {@link endUpdate}. This implementation fires an {@link execute} event before
   * executing the given change.
   *
   * @param change  Object that described the change.
   */
  execute(change) {
    change.execute();
    this.beginUpdate();
    this.currentEdit.add(change);
    this.fireEvent(new EventObject_default(InternalEvent_default.EXECUTE, { change }));
    this.fireEvent(new EventObject_default(InternalEvent_default.EXECUTED, { change }));
    this.endUpdate();
  }
  /**
   * Updates the model in a transaction.
   * This is a shortcut to the usage of {@link beginUpdate} and the {@link endUpdate} methods.
   *
   * ```javascript
   * const model = graph.getDataModel();
   * const parent = graph.getDefaultParent();
   * const index = model.getChildCount(parent);
   * model.batchUpdate(() => {
   *   model.add(parent, v1, index);
   *   model.add(parent, v2, index+1);
   * });
   * ```
   *
   * @param fn the update to be performed in the transaction.
   */
  batchUpdate(fn) {
    this.beginUpdate();
    try {
      fn();
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Increments the {@link updateLevel} by one. The event notification
   * is queued until {@link updateLevel} reaches 0 by use of
   * {@link endUpdate}.
   *
   * All changes on {@link GraphDataModel} are transactional,
   * that is, they are executed in a single undoable change
   * on the model (without transaction isolation).
   * Therefore, if you want to combine any
   * number of changes into a single undoable change,
   * you should group any two or more API calls that
   * modify the graph model between {@link beginUpdate}
   * and {@link endUpdate} calls as shown here:
   *
   * ```javascript
   * const model = graph.getDataModel();
   * const parent = graph.getDefaultParent();
   * const index = model.getChildCount(parent);
   * model.beginUpdate();
   * try
   * {
   *   model.add(parent, v1, index);
   *   model.add(parent, v2, index+1);
   * }
   * finally
   * {
   *   model.endUpdate();
   * }
   * ```
   *
   * Of course there is a shortcut for appending a
   * sequence of cells into the default parent:
   *
   * ```javascript
   * graph.addCells([v1, v2]).
   * ```
   */
  beginUpdate() {
    this.updateLevel += 1;
    this.fireEvent(new EventObject_default(InternalEvent_default.BEGIN_UPDATE));
    if (this.updateLevel === 1) {
      this.fireEvent(new EventObject_default(InternalEvent_default.START_EDIT));
    }
  }
  /**
   * Decrements the {@link updateLevel} by one and fires an {@link undo}
   * event if the {@link updateLevel} reaches 0. This function
   * indirectly fires a {@link change} event by invoking the notify
   * function on the {@link currentEdit} und then creates a new
   * {@link currentEdit} using {@link createUndoableEdit}.
   *
   * The {@link undo} event is fired only once per edit, whereas
   * the {@link change} event is fired whenever the notify
   * function is invoked, that is, on undo and redo of
   * the edit.
   */
  endUpdate() {
    this.updateLevel -= 1;
    if (this.updateLevel === 0) {
      this.fireEvent(new EventObject_default(InternalEvent_default.END_EDIT));
    }
    if (!this.endingUpdate) {
      this.endingUpdate = this.updateLevel === 0;
      this.fireEvent(new EventObject_default(InternalEvent_default.END_UPDATE, { edit: this.currentEdit }));
      try {
        if (this.endingUpdate && !this.currentEdit.isEmpty()) {
          this.fireEvent(new EventObject_default(InternalEvent_default.BEFORE_UNDO, { edit: this.currentEdit }));
          const tmp2 = this.currentEdit;
          this.currentEdit = this.createUndoableEdit();
          tmp2.notify();
          this.fireEvent(new EventObject_default(InternalEvent_default.UNDO, { edit: tmp2 }));
        }
      } finally {
        this.endingUpdate = false;
      }
    }
  }
  /**
   * Creates a new {@link UndoableEdit} that implements the
   * notify function to fire a {@link change} and {@link notify} event
   * through the {@link UndoableEdit}'s source.
   *
   * @param significant  Optional boolean that specifies if the edit to be created is
   * significant. Default is true.
   */
  createUndoableEdit(significant = true) {
    const edit = new UndoableEdit_default(this, significant);
    edit.notify = () => {
      edit.source.fireEvent(new EventObject_default(InternalEvent_default.CHANGE, { edit, changes: edit.changes }));
      edit.source.fireEvent(new EventObject_default(InternalEvent_default.NOTIFY, { edit, changes: edit.changes }));
    };
    return edit;
  }
  /**
   * Merges the children of the given cell into the given target cell inside
   * this model. All cells are cloned unless there is a corresponding cell in
   * the model with the same id, in which case the source cell is ignored and
   * all edges are connected to the corresponding cell in this model. Edges
   * are considered to have no identity and are always cloned unless the
   * cloneAllEdges flag is set to false, in which case edges with the same
   * id in the target model are reconnected to reflect the terminals of the
   * source edges.
   */
  mergeChildren(from, to, cloneAllEdges = true) {
    this.beginUpdate();
    try {
      const mapping = {};
      this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);
      for (const key2 in mapping) {
        const cell2 = mapping[key2];
        let terminal = cell2.getTerminal(true);
        if (terminal != null) {
          terminal = mapping[CellPath_default.create(terminal)];
          this.setTerminal(cell2, terminal, true);
        }
        terminal = cell2.getTerminal(false);
        if (terminal != null) {
          terminal = mapping[CellPath_default.create(terminal)];
          this.setTerminal(cell2, terminal, false);
        }
      }
    } finally {
      this.endUpdate();
    }
  }
  /**
   * Clones the children of the source cell into the given target cell in
   * this model and adds an entry to the mapping that maps from the source
   * cell to the target cell with the same id or the clone of the source cell
   * that was inserted into this model.
   */
  mergeChildrenImpl(from, to, cloneAllEdges, mapping = {}) {
    this.beginUpdate();
    try {
      const childCount2 = from.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const cell2 = from.getChildAt(i2);
        if (typeof cell2.getId === "function") {
          const id2 = cell2.getId();
          let target2 = id2 != null && (!cell2.isEdge() || !cloneAllEdges) ? this.getCell(id2) : null;
          if (target2 == null) {
            const clone2 = cell2.clone();
            clone2.setId(id2);
            clone2.setTerminal(cell2.getTerminal(true), true);
            clone2.setTerminal(cell2.getTerminal(false), false);
            target2 = to.insert(clone2);
            this.cellAdded(target2);
          }
          mapping[CellPath_default.create(cell2)] = target2;
          this.mergeChildrenImpl(cell2, target2, cloneAllEdges, mapping);
        }
      }
    } finally {
      this.endUpdate();
    }
  }
};
var GraphDataModel_default = GraphDataModel;

// node_modules/@maxgraph/core/lib/view/style/Stylesheet.js
var Stylesheet = class {
  constructor() {
    this.styles = /* @__PURE__ */ new Map();
    this.putDefaultVertexStyle(this.createDefaultVertexStyle());
    this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());
  }
  /**
   * Creates and returns the default vertex style.
   */
  createDefaultVertexStyle() {
    const style2 = {};
    style2.shape = SHAPE.RECTANGLE;
    style2.perimeter = "rectanglePerimeter";
    style2.verticalAlign = ALIGN.MIDDLE;
    style2.align = ALIGN.CENTER;
    style2.fillColor = "#C3D9FF";
    style2.strokeColor = "#6482B9";
    style2.fontColor = "#774400";
    return style2;
  }
  /**
   * Creates and returns the default edge style.
   */
  createDefaultEdgeStyle() {
    const style2 = {};
    style2.shape = SHAPE.CONNECTOR;
    style2.endArrow = ARROW.CLASSIC;
    style2.verticalAlign = ALIGN.MIDDLE;
    style2.align = ALIGN.CENTER;
    style2.strokeColor = "#6482B9";
    style2.fontColor = "#446299";
    return style2;
  }
  /**
   * Sets the default style for vertices using `defaultVertex` as the style name.
   * @param style The style to be stored.
   */
  putDefaultVertexStyle(style2) {
    this.putCellStyle("defaultVertex", style2);
  }
  /**
   * Sets the default style for edges using `defaultEdge` as the style name.
   * @param style The style to be stored.
   */
  putDefaultEdgeStyle(style2) {
    this.putCellStyle("defaultEdge", style2);
  }
  /**
   * Returns the default style for vertices.
   */
  getDefaultVertexStyle() {
    return this.styles.get("defaultVertex");
  }
  /**
   * Returns the default style for edges.
   */
  getDefaultEdgeStyle() {
    return this.styles.get("defaultEdge");
  }
  /**
   * Stores the given {@link CellStateStyle} under the given name in {@link styles}.
   *
   * ### Example
   *
   * The following example adds a new style called `rounded` into an existing stylesheet:
   *
   * ```javascript
   * const style = {} as CellStateStyle;
   * style.shape = SHAPE.RECTANGLE;
   * style.perimeter = PERIMETER.RECTANGLE;
   * style.rounded = true;
   * graph.getStylesheet().putCellStyle('rounded', style);
   * ```
   *
   * ### Description
   *
   * Note that not all properties will be interpreted by all shapes. For example, the 'line' shape ignores the fill color.
   * The final call to this method associates the style with a name in the stylesheet.
   *
   * The style is used in a cell with the following code:
   * ```javascript
   * // model is an instance of GraphDataModel
   * // style is an instance of CellStyle
   * model.setStyle(cell, { baseStyleNames: ['rounded'] });
   * ```
   *
   * @param name Name for the style to be stored.
   * @param style The instance of the style to be stored.
   */
  putCellStyle(name2, style2) {
    this.styles.set(name2, style2);
  }
  /**
   * Returns a {@link CellStateStyle} computed by merging the default style, styles referenced in the specified `baseStyleNames`
   * and the properties of the `cellStyle` parameter.
   *
   * The properties are merged by taking the properties from various styles in the following order:
   *   - default style (if {@link CellStyle.ignoreDefaultStyle} is not set to `true`, otherwise it is ignored)
   *   - registered styles referenced in `baseStyleNames`, in the order of the array
   *   - `cellStyle` parameter
   *
   * To fully unset a style property i.e. the property is not set even if a value is set in the default style or in the referenced styles,
   * set the `cellStyle` property to `none`. For example. `cellStyle.fillColor = 'none'`
   *
   * @param cellStyle An object that represents the style.
   * @param defaultStyle Default style used as reference to compute the returned style.
   */
  getCellStyle(cellStyle, defaultStyle) {
    let style2 = cellStyle.ignoreDefaultStyle ? {} : { ...defaultStyle };
    if (cellStyle.baseStyleNames) {
      style2 = cellStyle.baseStyleNames.reduce((acc, styleName) => {
        return {
          ...acc,
          ...this.styles.get(styleName)
        };
      }, style2);
    }
    for (const key2 of Object.keys(cellStyle)) {
      if (cellStyle[key2] !== void 0) {
        cellStyle[key2] == NONE ? delete style2[key2] : style2[key2] = cellStyle[key2];
      }
    }
    "baseStyleNames" in style2 && delete style2.baseStyleNames;
    "ignoreDefaultStyle" in style2 && delete style2.ignoreDefaultStyle;
    return style2;
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/shared.js
function scalePointArray(points2, scale) {
  let result2 = [];
  if (points2 != null) {
    for (let i2 = 0; i2 < points2.length; i2 += 1) {
      if (points2[i2] != null) {
        result2[i2] = new Point_default(Math.round(points2[i2].x / scale * 10) / 10, Math.round(points2[i2].y / scale * 10) / 10);
      } else {
        result2[i2] = null;
      }
    }
  } else {
    result2 = null;
  }
  return result2;
}
function scaleCellState(state2, scale) {
  let result2 = null;
  if (state2 != null) {
    result2 = state2.clone();
    result2.setRect(Math.round(state2.x / scale * 10) / 10, Math.round(state2.y / scale * 10) / 10, Math.round(state2.width / scale * 10) / 10, Math.round(state2.height / scale * 10) / 10);
  }
  return result2;
}

// node_modules/@maxgraph/core/lib/view/style/edge/SideToSide.js
var SideToSide = (state2, source2, target2, points2, result2) => {
  const { view } = state2;
  let pt = points2 != null && points2.length > 0 ? points2[0] : null;
  const pts = state2.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (pt != null) {
    pt = view.transformControlPoint(state2, pt);
  }
  if (p0 != null) {
    source2 = new CellState_default();
    source2.x = p0.x;
    source2.y = p0.y;
  }
  if (pe != null) {
    target2 = new CellState_default();
    target2.x = pe.x;
    target2.y = pe.y;
  }
  if (source2 != null && target2 != null) {
    const l = Math.max(source2.x, target2.x);
    const r = Math.min(source2.x + source2.width, target2.x + target2.width);
    const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);
    let y1 = view.getRoutingCenterY(source2);
    let y2 = view.getRoutingCenterY(target2);
    if (pt != null) {
      if (pt.y >= source2.y && pt.y <= source2.y + source2.height) {
        y1 = pt.y;
      }
      if (pt.y >= target2.y && pt.y <= target2.y + target2.height) {
        y2 = pt.y;
      }
    }
    if (!contains(target2, x, y1) && !contains(source2, x, y1)) {
      result2.push(new Point_default(x, y1));
    }
    if (!contains(target2, x, y2) && !contains(source2, x, y2)) {
      result2.push(new Point_default(x, y2));
    }
    if (result2.length === 1) {
      if (pt != null) {
        if (!contains(target2, x, pt.y) && !contains(source2, x, pt.y)) {
          result2.push(new Point_default(x, pt.y));
        }
      } else {
        const t = Math.max(source2.y, target2.y);
        const b = Math.min(source2.y + source2.height, target2.y + target2.height);
        result2.push(new Point_default(x, t + (b - t) / 2));
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/TopToBottom.js
var TopToBottom = (state2, source2, target2, points2, result2) => {
  const { view } = state2;
  let pt = points2 != null && points2.length > 0 ? points2[0] : null;
  const pts = state2.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (pt != null) {
    pt = view.transformControlPoint(state2, pt);
  }
  if (p0 != null) {
    source2 = new CellState_default();
    source2.x = p0.x;
    source2.y = p0.y;
  }
  if (pe != null) {
    target2 = new CellState_default();
    target2.x = pe.x;
    target2.y = pe.y;
  }
  if (source2 != null && target2 != null) {
    const t = Math.max(source2.y, target2.y);
    const b = Math.min(source2.y + source2.height, target2.y + target2.height);
    let x = view.getRoutingCenterX(source2);
    if (pt != null && pt.x >= source2.x && pt.x <= source2.x + source2.width) {
      x = pt.x;
    }
    const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);
    if (!contains(target2, x, y) && !contains(source2, x, y)) {
      result2.push(new Point_default(x, y));
    }
    if (pt != null && pt.x >= target2.x && pt.x <= target2.x + target2.width) {
      x = pt.x;
    } else {
      x = view.getRoutingCenterX(target2);
    }
    if (!contains(target2, x, y) && !contains(source2, x, y)) {
      result2.push(new Point_default(x, y));
    }
    if (result2.length === 1) {
      if (pt != null && result2.length === 1) {
        if (!contains(target2, pt.x, y) && !contains(source2, pt.x, y)) {
          result2.push(new Point_default(pt.x, y));
        }
      } else {
        const l = Math.max(source2.x, target2.x);
        const r = Math.min(source2.x + source2.width, target2.x + target2.width);
        result2.push(new Point_default(l + (r - l) / 2, y));
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/Elbow.js
var ElbowConnector = (state2, source2, target2, points2, result2) => {
  let pt = points2 != null && points2.length > 0 ? points2[0] : null;
  let vertical = false;
  let horizontal = false;
  if (source2 != null && target2 != null) {
    if (pt != null) {
      const left = Math.min(source2.x, target2.x);
      const right = Math.max(source2.x + source2.width, target2.x + target2.width);
      const top = Math.min(source2.y, target2.y);
      const bottom = Math.max(source2.y + source2.height, target2.y + target2.height);
      pt = state2.view.transformControlPoint(state2, pt);
      vertical = pt.y < top || pt.y > bottom;
      horizontal = pt.x < left || pt.x > right;
    } else {
      const left = Math.max(source2.x, target2.x);
      const right = Math.min(source2.x + source2.width, target2.x + target2.width);
      vertical = left === right;
      if (!vertical) {
        const top = Math.max(source2.y, target2.y);
        const bottom = Math.min(source2.y + source2.height, target2.y + target2.height);
        horizontal = top === bottom;
      }
    }
  }
  if (!horizontal && (vertical || state2.style.elbow === ELBOW.VERTICAL)) {
    TopToBottom(state2, source2, target2, points2, result2);
  } else {
    SideToSide(state2, source2, target2, points2, result2);
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/EntityRelation.js
var EntityRelation = (state2, source2, target2, _points, result2) => {
  const { view } = state2;
  const segment = getValue(state2.style, "segment", ENTITY_SEGMENT) * view.scale;
  const pts = state2.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  let isSourceLeft = false;
  if (source2 != null) {
    const sourceGeometry = source2.cell.getGeometry();
    if (sourceGeometry.relative) {
      isSourceLeft = sourceGeometry.x <= 0.5;
    } else if (target2 != null) {
      isSourceLeft = (pe != null ? pe.x : target2.x + target2.width) < (p0 != null ? p0.x : source2.x);
    }
  }
  if (p0 != null) {
    source2 = new CellState_default();
    source2.x = p0.x;
    source2.y = p0.y;
  } else if (source2 != null) {
    const constraint = getPortConstraints(source2, state2, true, DIRECTION_MASK.NONE);
    if (constraint !== DIRECTION_MASK.NONE && constraint !== DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {
      isSourceLeft = constraint === DIRECTION_MASK.WEST;
    }
  } else {
    return;
  }
  let isTargetLeft = true;
  if (target2 != null) {
    const targetGeometry = target2.cell.getGeometry();
    if (targetGeometry.relative) {
      isTargetLeft = targetGeometry.x <= 0.5;
    } else if (source2 != null) {
      isTargetLeft = (p0 != null ? p0.x : source2.x + source2.width) < (pe != null ? pe.x : target2.x);
    }
  }
  if (pe != null) {
    target2 = new CellState_default();
    target2.x = pe.x;
    target2.y = pe.y;
  } else if (target2 != null) {
    const constraint = getPortConstraints(target2, state2, false, DIRECTION_MASK.NONE);
    if (constraint !== DIRECTION_MASK.NONE && constraint != DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {
      isTargetLeft = constraint === DIRECTION_MASK.WEST;
    }
  }
  if (source2 != null && target2 != null) {
    const x0 = isSourceLeft ? source2.x : source2.x + source2.width;
    const y0 = view.getRoutingCenterY(source2);
    const xe = isTargetLeft ? target2.x : target2.x + target2.width;
    const ye = view.getRoutingCenterY(target2);
    const seg = segment;
    let dx = isSourceLeft ? -seg : seg;
    const dep = new Point_default(x0 + dx, y0);
    dx = isTargetLeft ? -seg : seg;
    const arr = new Point_default(xe + dx, ye);
    if (isSourceLeft === isTargetLeft) {
      const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
      result2.push(new Point_default(x, y0));
      result2.push(new Point_default(x, ye));
    } else if (dep.x < arr.x === isSourceLeft) {
      const midY = y0 + (ye - y0) / 2;
      result2.push(dep);
      result2.push(new Point_default(dep.x, midY));
      result2.push(new Point_default(arr.x, midY));
      result2.push(arr);
    } else {
      result2.push(dep);
      result2.push(arr);
    }
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/Loop.js
var Loop = (state2, source2, _target, points2, result2) => {
  const pts = state2.absolutePoints;
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  if (p0 != null && pe != null) {
    if (points2 != null && points2.length > 0) {
      for (let i2 = 0; i2 < points2.length; i2 += 1) {
        let pt = points2[i2];
        pt = state2.view.transformControlPoint(state2, pt);
        result2.push(new Point_default(pt.x, pt.y));
      }
    }
    return;
  }
  if (source2 != null) {
    const { view } = state2;
    const { graph } = view;
    let pt = points2 != null && points2.length > 0 ? points2[0] : null;
    if (pt != null) {
      pt = view.transformControlPoint(state2, pt);
      if (contains(source2, pt.x, pt.y)) {
        pt = null;
      }
    }
    let x = 0;
    let dx = 0;
    let y = 0;
    let dy = 0;
    const seg = getValue(state2.style, "segment", graph.gridSize) * view.scale;
    const dir = getValue(state2.style, "direction", DIRECTION.WEST);
    if (dir === DIRECTION.NORTH || dir === DIRECTION.SOUTH) {
      x = view.getRoutingCenterX(source2);
      dx = seg;
    } else {
      y = view.getRoutingCenterY(source2);
      dy = seg;
    }
    if (pt == null || pt.x < source2.x || pt.x > source2.x + source2.width) {
      if (pt != null) {
        x = pt.x;
        dy = Math.max(Math.abs(y - pt.y), dy);
      } else if (dir === DIRECTION.NORTH) {
        y = source2.y - 2 * dx;
      } else if (dir === DIRECTION.SOUTH) {
        y = source2.y + source2.height + 2 * dx;
      } else if (dir === DIRECTION.EAST) {
        x = source2.x - 2 * dy;
      } else {
        x = source2.x + source2.width + 2 * dy;
      }
    } else if (pt !== null) {
      x = view.getRoutingCenterX(source2);
      dx = Math.max(Math.abs(x - pt.x), dy);
      y = pt.y;
      dy = 0;
    }
    result2.push(new Point_default(x - dx, y - dy));
    result2.push(new Point_default(x + dx, y + dy));
  }
};

// node_modules/@maxgraph/core/lib/view/style/edge/Segment.js
var SegmentConnector = (state2, sourceScaled, targetScaled, controlHints, result2) => {
  const pts = scalePointArray(state2.absolutePoints, state2.view.scale);
  const source2 = scaleCellState(sourceScaled, state2.view.scale);
  const target2 = scaleCellState(targetScaled, state2.view.scale);
  const tol = 1;
  let lastPushed = result2.length > 0 ? result2[0] : null;
  let horizontal = true;
  let hint = null;
  function pushPoint(pt2) {
    pt2.x = Math.round(pt2.x * state2.view.scale * 10) / 10;
    pt2.y = Math.round(pt2.y * state2.view.scale * 10) / 10;
    if (lastPushed == null || Math.abs(lastPushed.x - pt2.x) >= tol || Math.abs(lastPushed.y - pt2.y) >= Math.max(1, state2.view.scale)) {
      result2.push(pt2);
      lastPushed = pt2;
    }
    return lastPushed;
  }
  let pt = pts[0];
  if (pt == null && source2 != null) {
    pt = new Point_default(state2.view.getRoutingCenterX(source2), state2.view.getRoutingCenterY(source2));
  } else if (pt != null) {
    pt = pt.clone();
  }
  const lastInx = pts.length - 1;
  let pe = null;
  if (controlHints != null && controlHints.length > 0) {
    let hints = [];
    for (let i2 = 0; i2 < controlHints.length; i2 += 1) {
      const tmp2 = state2.view.transformControlPoint(state2, controlHints[i2], true);
      if (tmp2 != null) {
        hints.push(tmp2);
      }
    }
    if (hints.length === 0) {
      return;
    }
    if (pt != null && hints[0] != null) {
      if (Math.abs(hints[0].x - pt.x) < tol) {
        hints[0].x = pt.x;
      }
      if (Math.abs(hints[0].y - pt.y) < tol) {
        hints[0].y = pt.y;
      }
    }
    pe = pts[lastInx];
    if (pe != null && hints[hints.length - 1] != null) {
      if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {
        hints[hints.length - 1].x = pe.x;
      }
      if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {
        hints[hints.length - 1].y = pe.y;
      }
    }
    hint = hints[0];
    let currentTerm = source2;
    let currentPt = pts[0];
    let hozChan = false;
    let vertChan = false;
    let currentHint = hint;
    if (currentPt != null) {
      currentTerm = null;
    }
    for (let i2 = 0; i2 < 2; i2 += 1) {
      const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;
      const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;
      const inHozChan = currentTerm != null && currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height;
      const inVertChan = currentTerm != null && currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width;
      hozChan = fixedHozAlign || currentPt == null && inHozChan;
      vertChan = fixedVertAlign || currentPt == null && inVertChan;
      if (!(i2 == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign))) {
        if (currentPt != null && !fixedHozAlign && !fixedVertAlign && (inHozChan || inVertChan)) {
          horizontal = !inHozChan;
          break;
        }
        if (vertChan || hozChan) {
          horizontal = hozChan;
          if (i2 === 1) {
            horizontal = hints.length % 2 === 0 ? hozChan : vertChan;
          }
          break;
        }
      }
      currentTerm = target2;
      currentPt = pts[lastInx];
      if (currentPt != null) {
        currentTerm = null;
      }
      currentHint = hints[hints.length - 1];
      if (fixedVertAlign && fixedHozAlign) {
        hints = hints.slice(1);
      }
    }
    if (horizontal && (pts[0] != null && pts[0].y !== hint.y || pts[0] == null && source2 != null && (hint.y < source2.y || hint.y > source2.y + source2.height))) {
      pushPoint(new Point_default(pt.x, hint.y));
    } else if (!horizontal && (pts[0] != null && pts[0].x !== hint.x || pts[0] == null && source2 != null && (hint.x < source2.x || hint.x > source2.x + source2.width))) {
      pushPoint(new Point_default(hint.x, pt.y));
    }
    if (horizontal) {
      pt.y = hint.y;
    } else {
      pt.x = hint.x;
    }
    for (let i2 = 0; i2 < hints.length; i2 += 1) {
      horizontal = !horizontal;
      hint = hints[i2];
      if (horizontal) {
        pt.y = hint.y;
      } else {
        pt.x = hint.x;
      }
      pushPoint(pt.clone());
    }
  } else {
    hint = pt;
    horizontal = true;
  }
  pt = pts[lastInx];
  if (pt == null && target2 != null) {
    pt = new Point_default(state2.view.getRoutingCenterX(target2), state2.view.getRoutingCenterY(target2));
  }
  if (pt != null) {
    if (hint != null) {
      if (horizontal && (pts[lastInx] != null && pts[lastInx].y !== hint.y || pts[lastInx] == null && target2 != null && (hint.y < target2.y || hint.y > target2.y + target2.height))) {
        pushPoint(new Point_default(pt.x, hint.y));
      } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x !== hint.x || pts[lastInx] == null && target2 != null && (hint.x < target2.x || hint.x > target2.x + target2.width))) {
        pushPoint(new Point_default(hint.x, pt.y));
      }
    }
  }
  if (pts[0] == null && source2 != null) {
    while (result2.length > 1 && result2[1] != null && contains(source2, result2[1].x, result2[1].y)) {
      result2.splice(1, 1);
    }
  }
  if (pts[lastInx] == null && target2 != null) {
    while (result2.length > 1 && result2[result2.length - 1] != null && contains(target2, result2[result2.length - 1].x, result2[result2.length - 1].y)) {
      result2.splice(result2.length - 1, 1);
    }
  }
  if (pe != null && result2[result2.length - 1] != null && Math.abs(pe.x - result2[result2.length - 1].x) <= tol && Math.abs(pe.y - result2[result2.length - 1].y) <= tol) {
    result2.splice(result2.length - 1, 1);
    if (result2[result2.length - 1] != null) {
      if (Math.abs(result2[result2.length - 1].x - pe.x) < tol) {
        result2[result2.length - 1].x = pe.x;
      }
      if (Math.abs(result2[result2.length - 1].y - pe.y) < tol) {
        result2[result2.length - 1].y = pe.y;
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/view/style/EdgeStyle.js
var _a;
var EdgeStyle = class {
  // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,
  static getJettySize(state2, isSource) {
    let value2 = getValue(state2.style, isSource ? "sourceJettySize" : "targetJettySize", getValue(state2.style, "jettySize", _a.orthBuffer));
    if (value2 === "auto") {
      const type = getValue(state2.style, isSource ? "startArrow" : "endArrow", NONE);
      if (type !== NONE) {
        const size = getNumber(state2.style, isSource ? "startSize" : "endSize", DEFAULT_MARKERSIZE);
        value2 = Math.max(2, Math.ceil((size + _a.orthBuffer) / _a.orthBuffer)) * _a.orthBuffer;
      } else {
        value2 = 2 * _a.orthBuffer;
      }
    }
    return value2;
  }
  static getRoutePattern(dir, quad, dx, dy) {
    let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];
    let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];
    sourceIndex -= quad;
    targetIndex -= quad;
    if (sourceIndex < 1) {
      sourceIndex += 4;
    }
    if (targetIndex < 1) {
      targetIndex += 4;
    }
    let result2 = _a.routePatterns[sourceIndex - 1][targetIndex - 1];
    if (dx === 0 || dy === 0) {
      if (_a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {
        result2 = _a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];
      }
    }
    return result2;
  }
};
_a = EdgeStyle;
EdgeStyle.EntityRelation = EntityRelation;
EdgeStyle.Loop = Loop;
EdgeStyle.ElbowConnector = ElbowConnector;
EdgeStyle.SideToSide = SideToSide;
EdgeStyle.TopToBottom = TopToBottom;
EdgeStyle.SegmentConnector = SegmentConnector;
EdgeStyle.orthBuffer = 10;
EdgeStyle.orthPointsFallback = true;
EdgeStyle.dirVectors = [
  [-1, 0],
  [0, -1],
  [1, 0],
  [0, 1],
  [-1, 0],
  [0, -1],
  [1, 0]
];
EdgeStyle.wayPoints1 = [
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0],
  [0, 0]
];
EdgeStyle.routePatterns = [
  [
    [513, 2308, 2081, 2562],
    [513, 1090, 514, 2184, 2114, 2561],
    [513, 1090, 514, 2564, 2184, 2562],
    [513, 2308, 2561, 1090, 514, 2568, 2308]
  ],
  [
    [514, 1057, 513, 2308, 2081, 2562],
    [514, 2184, 2114, 2561],
    [514, 2184, 2562, 1057, 513, 2564, 2184],
    [514, 1057, 513, 2568, 2308, 2561]
  ],
  [
    [1090, 514, 1057, 513, 2308, 2081, 2562],
    [2114, 2561],
    [1090, 2562, 1057, 513, 2564, 2184],
    [1090, 514, 1057, 513, 2308, 2561, 2568]
  ],
  [
    [2081, 2562],
    [1057, 513, 1090, 514, 2184, 2114, 2561],
    [1057, 513, 1090, 514, 2184, 2562, 2564],
    [1057, 2561, 1090, 514, 2568, 2308]
  ]
];
EdgeStyle.inlineRoutePatterns = [
  [null, [2114, 2568], null, null],
  [null, [514, 2081, 2114, 2568], null, null],
  [null, [2114, 2561], null, null],
  [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null]
];
EdgeStyle.vertexSeperations = [];
EdgeStyle.limits = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0]
];
EdgeStyle.LEFT_MASK = 32;
EdgeStyle.TOP_MASK = 64;
EdgeStyle.RIGHT_MASK = 128;
EdgeStyle.BOTTOM_MASK = 256;
EdgeStyle.LEFT = 1;
EdgeStyle.TOP = 2;
EdgeStyle.RIGHT = 4;
EdgeStyle.BOTTOM = 8;
EdgeStyle.SIDE_MASK = 480;
EdgeStyle.CENTER_MASK = 512;
EdgeStyle.SOURCE_MASK = 1024;
EdgeStyle.TARGET_MASK = 2048;
EdgeStyle.VERTEX_MASK = 3072;
EdgeStyle.OrthConnector = (state2, sourceScaled, targetScaled, controlHints, result2) => {
  const pts = scalePointArray(state2.absolutePoints, state2.view.scale);
  const source2 = scaleCellState(sourceScaled, state2.view.scale);
  const target2 = scaleCellState(targetScaled, state2.view.scale);
  const sourceEdge = source2 == null ? false : source2.cell.isEdge();
  const targetEdge = target2 == null ? false : target2.cell.isEdge();
  const p0 = pts[0];
  const pe = pts[pts.length - 1];
  let sourceX = source2 != null ? source2.x : p0.x;
  let sourceY = source2 != null ? source2.y : p0.y;
  let sourceWidth = source2 != null ? source2.width : 0;
  let sourceHeight = source2 != null ? source2.height : 0;
  let targetX = target2 != null ? target2.x : pe.x;
  let targetY = target2 != null ? target2.y : pe.y;
  let targetWidth = target2 != null ? target2.width : 0;
  let targetHeight = target2 != null ? target2.height : 0;
  let sourceBuffer = _a.getJettySize(state2, true);
  let targetBuffer = _a.getJettySize(state2, false);
  if (source2 != null && target2 === source2) {
    targetBuffer = Math.max(sourceBuffer, targetBuffer);
    sourceBuffer = targetBuffer;
  }
  const totalBuffer = targetBuffer + sourceBuffer;
  let tooShort = false;
  if (p0 != null && pe != null) {
    const dx2 = pe.x - p0.x;
    const dy2 = pe.y - p0.y;
    tooShort = dx2 * dx2 + dy2 * dy2 < totalBuffer * totalBuffer;
  }
  if (tooShort || _a.orthPointsFallback && controlHints != null && controlHints.length > 0 || sourceEdge || targetEdge) {
    _a.SegmentConnector(state2, sourceScaled, targetScaled, controlHints, result2);
    return;
  }
  const portConstraint = [DIRECTION_MASK.ALL, DIRECTION_MASK.ALL];
  let rotation = 0;
  if (source2 != null) {
    portConstraint[0] = getPortConstraints(source2, state2, true, DIRECTION_MASK.ALL);
    rotation = source2.style.rotation ?? 0;
    if (rotation !== 0) {
      const newRect = getBoundingBox(new Rectangle_default(sourceX, sourceY, sourceWidth, sourceHeight), rotation);
      sourceX = newRect.x;
      sourceY = newRect.y;
      sourceWidth = newRect.width;
      sourceHeight = newRect.height;
    }
  }
  if (target2 != null) {
    portConstraint[1] = getPortConstraints(target2, state2, false, DIRECTION_MASK.ALL);
    rotation = target2.style.rotation ?? 0;
    if (rotation !== 0) {
      const newRect = getBoundingBox(new Rectangle_default(targetX, targetY, targetWidth, targetHeight), rotation);
      targetX = newRect.x;
      targetY = newRect.y;
      targetWidth = newRect.width;
      targetHeight = newRect.height;
    }
  }
  const dir = [0, 0];
  const geo = [
    [sourceX, sourceY, sourceWidth, sourceHeight],
    [targetX, targetY, targetWidth, targetHeight]
  ];
  const buffer = [sourceBuffer, targetBuffer];
  for (let i2 = 0; i2 < 2; i2 += 1) {
    _a.limits[i2][1] = geo[i2][0] - buffer[i2];
    _a.limits[i2][2] = geo[i2][1] - buffer[i2];
    _a.limits[i2][4] = geo[i2][0] + geo[i2][2] + buffer[i2];
    _a.limits[i2][8] = geo[i2][1] + geo[i2][3] + buffer[i2];
  }
  const sourceCenX = geo[0][0] + geo[0][2] / 2;
  const sourceCenY = geo[0][1] + geo[0][3] / 2;
  const targetCenX = geo[1][0] + geo[1][2] / 2;
  const targetCenY = geo[1][1] + geo[1][3] / 2;
  const dx = sourceCenX - targetCenX;
  const dy = sourceCenY - targetCenY;
  let quad = 0;
  if (dx < 0) {
    if (dy < 0) {
      quad = 2;
    } else {
      quad = 1;
    }
  } else if (dy <= 0) {
    quad = 3;
    if (dx === 0) {
      quad = 2;
    }
  }
  let currentTerm = null;
  if (source2 != null) {
    currentTerm = p0;
  }
  const constraint = [
    [0.5, 0.5],
    [0.5, 0.5]
  ];
  for (let i2 = 0; i2 < 2; i2 += 1) {
    if (currentTerm != null) {
      constraint[i2][0] = (currentTerm.x - geo[i2][0]) / geo[i2][2];
      if (Math.abs(currentTerm.x - geo[i2][0]) <= 1) {
        dir[i2] = DIRECTION_MASK.WEST;
      } else if (Math.abs(currentTerm.x - geo[i2][0] - geo[i2][2]) <= 1) {
        dir[i2] = DIRECTION_MASK.EAST;
      }
      constraint[i2][1] = (currentTerm.y - geo[i2][1]) / geo[i2][3];
      if (Math.abs(currentTerm.y - geo[i2][1]) <= 1) {
        dir[i2] = DIRECTION_MASK.NORTH;
      } else if (Math.abs(currentTerm.y - geo[i2][1] - geo[i2][3]) <= 1) {
        dir[i2] = DIRECTION_MASK.SOUTH;
      }
    }
    currentTerm = null;
    if (target2 != null) {
      currentTerm = pe;
    }
  }
  const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);
  const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);
  const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);
  const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);
  _a.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);
  _a.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);
  _a.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);
  _a.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);
  const dirPref = [];
  const horPref = [];
  const vertPref = [];
  horPref[0] = sourceLeftDist >= sourceRightDist ? DIRECTION_MASK.WEST : DIRECTION_MASK.EAST;
  vertPref[0] = sourceTopDist >= sourceBottomDist ? DIRECTION_MASK.NORTH : DIRECTION_MASK.SOUTH;
  horPref[1] = reversePortConstraints(horPref[0]);
  vertPref[1] = reversePortConstraints(vertPref[0]);
  const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;
  const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;
  const prefOrdering = [
    [0, 0],
    [0, 0]
  ];
  let preferredOrderSet = false;
  for (let i2 = 0; i2 < 2; i2 += 1) {
    if (dir[i2] !== 0) {
      continue;
    }
    if ((horPref[i2] & portConstraint[i2]) === 0) {
      horPref[i2] = reversePortConstraints(horPref[i2]);
    }
    if ((vertPref[i2] & portConstraint[i2]) === 0) {
      vertPref[i2] = reversePortConstraints(vertPref[i2]);
    }
    prefOrdering[i2][0] = vertPref[i2];
    prefOrdering[i2][1] = horPref[i2];
  }
  if (preferredVertDist > 0 && preferredHorizDist > 0) {
    if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {
      prefOrdering[0][0] = horPref[0];
      prefOrdering[0][1] = vertPref[0];
      prefOrdering[1][0] = vertPref[1];
      prefOrdering[1][1] = horPref[1];
      preferredOrderSet = true;
    } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {
      prefOrdering[0][0] = vertPref[0];
      prefOrdering[0][1] = horPref[0];
      prefOrdering[1][0] = horPref[1];
      prefOrdering[1][1] = vertPref[1];
      preferredOrderSet = true;
    }
  }
  if (preferredVertDist > 0 && !preferredOrderSet) {
    prefOrdering[0][0] = vertPref[0];
    prefOrdering[0][1] = horPref[0];
    prefOrdering[1][0] = vertPref[1];
    prefOrdering[1][1] = horPref[1];
    preferredOrderSet = true;
  }
  if (preferredHorizDist > 0 && !preferredOrderSet) {
    prefOrdering[0][0] = horPref[0];
    prefOrdering[0][1] = vertPref[0];
    prefOrdering[1][0] = horPref[1];
    prefOrdering[1][1] = vertPref[1];
    preferredOrderSet = true;
  }
  for (let i2 = 0; i2 < 2; i2 += 1) {
    if (dir[i2] !== 0) {
      continue;
    }
    if ((prefOrdering[i2][0] & portConstraint[i2]) === 0) {
      prefOrdering[i2][0] = prefOrdering[i2][1];
    }
    dirPref[i2] = prefOrdering[i2][0] & portConstraint[i2];
    dirPref[i2] |= (prefOrdering[i2][1] & portConstraint[i2]) << 8;
    dirPref[i2] |= (prefOrdering[1 - i2][i2] & portConstraint[i2]) << 16;
    dirPref[i2] |= (prefOrdering[1 - i2][1 - i2] & portConstraint[i2]) << 24;
    if ((dirPref[i2] & 15) === 0) {
      dirPref[i2] = dirPref[i2] << 8;
    }
    if ((dirPref[i2] & 3840) === 0) {
      dirPref[i2] = dirPref[i2] & 15 | dirPref[i2] >> 8;
    }
    if ((dirPref[i2] & 983040) === 0) {
      dirPref[i2] = dirPref[i2] & 65535 | (dirPref[i2] & 251658240) >> 8;
    }
    dir[i2] = dirPref[i2] & 15;
    if (portConstraint[i2] === DIRECTION_MASK.WEST || portConstraint[i2] === DIRECTION_MASK.NORTH || portConstraint[i2] === DIRECTION_MASK.EAST || portConstraint[i2] === DIRECTION_MASK.SOUTH) {
      dir[i2] = portConstraint[i2];
    }
  }
  let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];
  let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];
  sourceIndex -= quad;
  targetIndex -= quad;
  if (sourceIndex < 1) {
    sourceIndex += 4;
  }
  if (targetIndex < 1) {
    targetIndex += 4;
  }
  const routePattern = _a.routePatterns[sourceIndex - 1][targetIndex - 1];
  _a.wayPoints1[0][0] = geo[0][0];
  _a.wayPoints1[0][1] = geo[0][1];
  switch (dir[0]) {
    case DIRECTION_MASK.WEST:
      _a.wayPoints1[0][0] -= sourceBuffer;
      _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
      break;
    case DIRECTION_MASK.SOUTH:
      _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
      _a.wayPoints1[0][1] += geo[0][3] + sourceBuffer;
      break;
    case DIRECTION_MASK.EAST:
      _a.wayPoints1[0][0] += geo[0][2] + sourceBuffer;
      _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];
      break;
    case DIRECTION_MASK.NORTH:
      _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];
      _a.wayPoints1[0][1] -= sourceBuffer;
      break;
  }
  let currentIndex = 0;
  let lastOrientation = (dir[0] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;
  const initialOrientation = lastOrientation;
  let currentOrientation = 0;
  for (let i2 = 0; i2 < routePattern.length; i2 += 1) {
    const nextDirection = routePattern[i2] & 15;
    let directionIndex = nextDirection === DIRECTION_MASK.EAST ? 3 : nextDirection;
    directionIndex += quad;
    if (directionIndex > 4) {
      directionIndex -= 4;
    }
    const direction = _a.dirVectors[directionIndex - 1];
    currentOrientation = directionIndex % 2 > 0 ? 0 : 1;
    if (currentOrientation !== lastOrientation) {
      currentIndex++;
      _a.wayPoints1[currentIndex][0] = _a.wayPoints1[currentIndex - 1][0];
      _a.wayPoints1[currentIndex][1] = _a.wayPoints1[currentIndex - 1][1];
    }
    const tar = (routePattern[i2] & _a.TARGET_MASK) > 0;
    const sou = (routePattern[i2] & _a.SOURCE_MASK) > 0;
    let side = (routePattern[i2] & _a.SIDE_MASK) >> 5;
    side <<= quad;
    if (side > 15) {
      side >>= 4;
    }
    const center = (routePattern[i2] & _a.CENTER_MASK) > 0;
    if ((sou || tar) && side < 9) {
      let limit = 0;
      const souTar = sou ? 0 : 1;
      if (center && currentOrientation === 0) {
        limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];
      } else if (center) {
        limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];
      } else {
        limit = _a.limits[souTar][side];
      }
      if (currentOrientation === 0) {
        const lastX = _a.wayPoints1[currentIndex][0];
        const deltaX = (limit - lastX) * direction[0];
        if (deltaX > 0) {
          _a.wayPoints1[currentIndex][0] += direction[0] * deltaX;
        }
      } else {
        const lastY = _a.wayPoints1[currentIndex][1];
        const deltaY = (limit - lastY) * direction[1];
        if (deltaY > 0) {
          _a.wayPoints1[currentIndex][1] += direction[1] * deltaY;
        }
      }
    } else if (center) {
      _a.wayPoints1[currentIndex][0] += direction[0] * Math.abs(_a.vertexSeperations[directionIndex] / 2);
      _a.wayPoints1[currentIndex][1] += direction[1] * Math.abs(_a.vertexSeperations[directionIndex] / 2);
    }
    if (currentIndex > 0 && _a.wayPoints1[currentIndex][currentOrientation] === _a.wayPoints1[currentIndex - 1][currentOrientation]) {
      currentIndex--;
    } else {
      lastOrientation = currentOrientation;
    }
  }
  for (let i2 = 0; i2 <= currentIndex; i2 += 1) {
    if (i2 === currentIndex) {
      const targetOrientation = (dir[1] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;
      const sameOrient = targetOrientation === initialOrientation ? 0 : 1;
      if (sameOrient !== (currentIndex + 1) % 2) {
        break;
      }
    }
    result2.push(new Point_default(Math.round(_a.wayPoints1[i2][0] * state2.view.scale * 10) / 10, Math.round(_a.wayPoints1[i2][1] * state2.view.scale * 10) / 10));
  }
  let index = 1;
  while (index < result2.length) {
    if (result2[index - 1] == null || result2[index] == null || result2[index - 1].x !== result2[index].x || result2[index - 1].y !== result2[index].y) {
      index++;
    } else {
      result2.splice(index, 1);
    }
  }
};
EdgeStyle.MANHATTAN_STEP = 12;
EdgeStyle.MANHATTAN_MAXIMUM_LOOPS = 2e3;
EdgeStyle.MANHATTAN_START_DIRECTIONS = [
  DIRECTION.NORTH,
  DIRECTION.EAST,
  DIRECTION.SOUTH,
  DIRECTION.WEST
];
EdgeStyle.MANHATTAN_END_DIRECTIONS = [
  DIRECTION.NORTH,
  DIRECTION.EAST,
  DIRECTION.SOUTH,
  DIRECTION.WEST
];
EdgeStyle.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE = 90;
EdgeStyle.MANHATTAN_PADDING_BOX = new Geometry_default(-_a.MANHATTAN_STEP, -_a.MANHATTAN_STEP, _a.MANHATTAN_STEP * 2, _a.MANHATTAN_STEP * 2);
EdgeStyle.ManhattanConnector = (state2, source2, target2, points2, result2) => {
  function moveAndExpand(target3, source3) {
    target3.x += source3.x || 0;
    target3.y += source3.y || 0;
    target3.width += source3.width || 0;
    target3.height += source3.height || 0;
    return target3;
  }
  function snapCoordinateToGrid(value2, gridSize) {
    return gridSize * Math.round(value2 / gridSize);
  }
  function snapPointToGrid(p, gx, gy) {
    p.x = snapCoordinateToGrid(p.x, gx);
    p.y = snapCoordinateToGrid(p.y, gy || gx);
    return p;
  }
  function isPointInRectangle(rect, p) {
    return p.x >= rect.x && p.x <= rect.x + rect.width && p.y >= rect.y && p.y <= rect.y + rect.height;
  }
  function getRectangleCenter(rect) {
    return new Point_default(rect.x + rect.width / 2, rect.y + rect.height / 2);
  }
  function getDifferencePoint(p1, p2) {
    return new Point_default(p1.x - p2.x, p1.y - p2.y);
  }
  function movePoint(p, moveX, moveY) {
    p.x += moveX || 0;
    p.y += moveY || 0;
    return p;
  }
  function getPointTheta(p1, p2) {
    const p = p2.clone();
    const y = -(p.y - p1.y);
    const x = p.x - p1.x;
    const PRECISION = 10;
    const rad = y.toFixed(PRECISION) == "0" && x.toFixed(PRECISION) == "0" ? 0 : Math.atan2(y, x);
    return 180 * rad / Math.PI;
  }
  function normalizePoint(point) {
    return new Point_default(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);
  }
  function getManhattanDistance(p1, p2) {
    return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);
  }
  function toPointFromString(pointString) {
    const xy = pointString.split(pointString.indexOf("@") === -1 ? " " : "@");
    return new Point_default(parseInt(xy[0], 10), parseInt(xy[1], 10));
  }
  function pointToString(point) {
    return `${point.x}@${point.y}`;
  }
  function getCellAbsoluteBounds(cellState) {
    var _a2;
    const graph = cellState.view.graph;
    const cellBounds = (_a2 = graph.getCellBounds(cellState.cell, false, false)) == null ? void 0 : _a2.clone();
    if (!cellBounds)
      return void 0;
    const view = graph.view;
    const { scale, translate } = view;
    const { x, y } = translate;
    const round = (v) => Math.round(v * 10) / 10;
    const res = new Rectangle_default(round(cellBounds.x / scale - x), round(cellBounds.y / scale - y), round(cellBounds.width / scale), round(cellBounds.height / scale));
    return res;
  }
  const mStep = _a.MANHATTAN_STEP;
  const config = {
    // Padding applied on the element bounding boxes
    paddingBox: _a.MANHATTAN_PADDING_BOX,
    // An array of directions to find next points on the route
    directions: [
      {
        offsetX: mStep,
        offsetY: 0,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point_default(0, 0), new Point_default(mStep, 0)))
      },
      {
        offsetX: 0,
        offsetY: mStep,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point_default(0, 0), new Point_default(0, mStep)))
      },
      {
        offsetX: -mStep,
        offsetY: 0,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point_default(0, 0), new Point_default(-mStep, 0)))
      },
      {
        offsetX: 0,
        offsetY: -mStep,
        cost: mStep,
        angle: normalizeAngle(getPointTheta(new Point_default(0, 0), new Point_default(0, -mStep)))
      }
    ],
    directionMap: {
      east: { x: 1, y: 0 },
      south: { x: 0, y: 1 },
      west: { x: -1, y: 0 },
      north: { x: 0, y: -1 }
    },
    // A penalty received for direction change
    penaltiesGenerator: (angle) => {
      if (angle == 45 || angle == 90 || angle == 180)
        return _a.MANHATTAN_STEP / 2;
      return 0;
    },
    // If a function is provided, it's used to route the link while dragging an end
    // i.e. function(from, to, opts) { return []; }
    draggingRoute: null,
    previousDirAngle: 0
  };
  class ObstacleMap {
    constructor(opt) {
      this.options = opt;
      this.mapGridSize = 100;
      this.map = /* @__PURE__ */ new Map();
    }
    // Builds a map of all elements for quicker obstacle queries
    // The svg is divided to  cells, where each of them holds an information which
    // elements belong to it. When we query whether a point is in an obstacle we don't need
    // to go through all obstacles, we check only those in a particular cell.
    build(source3, target3) {
      const graph = (source3 == null ? void 0 : source3.view.graph) || (target3 == null ? void 0 : target3.view.graph);
      if (!graph)
        return;
      return Array.from(graph.getView().getCellStates()).filter((s) => s.cell && s.cell.isVertex() && !s.cell.isEdge()).map((s) => getCellAbsoluteBounds(s)).map((bbox) => bbox ? moveAndExpand(bbox, this.options.paddingBox) : null).forEach((bbox) => {
        if (!bbox)
          return;
        const origin = snapPointToGrid(new Point_default(bbox.x, bbox.y), this.mapGridSize);
        const corner = snapPointToGrid(new Point_default(bbox.x + bbox.width, bbox.y + bbox.height), this.mapGridSize);
        for (let x = origin.x; x <= corner.x; x += this.mapGridSize) {
          for (let y = origin.y; y <= corner.y; y += this.mapGridSize) {
            const gridKey = x + "@" + y;
            const rectArr = this.map.get(gridKey) || [];
            if (!this.map.has(gridKey))
              this.map.set(gridKey, rectArr);
            rectArr.push(bbox);
          }
        }
      });
    }
    isPointAccessible(point) {
      const mapKey = pointToString(snapPointToGrid(point.clone(), this.mapGridSize));
      const obstacles = this.map.get(mapKey);
      if (obstacles) {
        return obstacles.every((obstacle) => !isPointInRectangle(obstacle, point));
      }
      return true;
    }
  }
  class SortedSet {
    constructor() {
      this.items = [];
      this.hash = /* @__PURE__ */ new Map();
    }
    add(key2, value2) {
      const hashItem = this.hash.get(key2);
      if (hashItem) {
        hashItem.value = value2;
        this.items.splice(this.items.indexOf(key2), 1);
      } else {
        this.hash.set(key2, {
          value: value2,
          open: true
        });
      }
      this.items.push(key2);
      this.items.sort((i1, i2) => {
        const hashItem1 = this.hash.get(i1);
        const hashItem2 = this.hash.get(i2);
        if (!hashItem1 || !hashItem2)
          return 0;
        return hashItem1.value - hashItem2.value;
      });
    }
    remove(key2) {
      const hashItem = this.hash.get(key2);
      if (hashItem)
        hashItem.open = false;
    }
    isOpen(key2) {
      const hashItem = this.hash.get(key2);
      return hashItem && hashItem.open == true;
    }
    isClose(key2) {
      const hashItem = this.hash.get(key2);
      return hashItem && hashItem.open == false;
    }
    isEmpty() {
      return this.items.length == 0;
    }
    pop() {
      const key2 = this.items.shift();
      if (key2)
        this.remove(key2);
      return key2;
    }
  }
  function reconstructRoute(parents, endPoint, startCenter, endCenter) {
    const route = [];
    let previousDirection = normalizePoint(getDifferencePoint(endCenter, endPoint));
    let current = endPoint;
    let parent2;
    while (parents[pointToString(current)]) {
      parent2 = parents[pointToString(current)];
      if (!parent2)
        continue;
      const direction = normalizePoint(getDifferencePoint(current, parent2));
      if (!direction.equals(previousDirection)) {
        route.unshift(current);
        previousDirection = direction;
      }
      current = parent2;
    }
    const startDirection = normalizePoint(getDifferencePoint(current, startCenter));
    if (!startDirection.equals(previousDirection)) {
      route.unshift(current);
    }
    return route;
  }
  function getRectPoints(bbox, directionList, opt) {
    const step = _a.MANHATTAN_STEP;
    const center = getRectangleCenter(bbox);
    const res = [];
    for (const direction of directionList) {
      const directionPoint = opt.directionMap[direction];
      const x = directionPoint.x * bbox.width / 2;
      const y = directionPoint.y * bbox.height / 2;
      const point = movePoint(center.clone(), x, y);
      if (isPointInRectangle(bbox, point)) {
        movePoint(point, directionPoint.x * step, directionPoint.y * step);
      }
      res.push(snapPointToGrid(point, step));
    }
    return res;
  }
  function normalizeAngle(angle) {
    return angle % 360 + (angle < 0 ? 360 : 0);
  }
  function getDirectionAngle(start, end, directionLength) {
    const q = 360 / directionLength;
    return Math.floor(normalizeAngle(getPointTheta(start, end) + q / 2) / q) * q;
  }
  function getDirectionChange(angle1, angle2) {
    const dirChange = Math.abs(angle1 - angle2);
    return dirChange > 180 ? 360 - dirChange : dirChange;
  }
  function estimateCost(from, endPoints) {
    let min = Infinity;
    for (let i2 = 0, len = endPoints.length; i2 < len; i2++) {
      const cost = getManhattanDistance(from, endPoints[i2]);
      if (cost < min)
        min = cost;
    }
    return min;
  }
  function alignPointToCell(point, edgeState, cellState, isSourceCell) {
    const cellBounds = getCellAbsoluteBounds(cellState);
    const y = isSourceCell ? edgeState.style.exitY : edgeState.style.entryY;
    const onlyHorizontalDirections = isSourceCell ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH) : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH);
    if (y != void 0 && onlyHorizontalDirections) {
      const cellHeight = (cellBounds == null ? void 0 : cellBounds.height) || 0;
      point.y = (cellBounds == null ? void 0 : cellBounds.y) != void 0 ? (cellBounds == null ? void 0 : cellBounds.y) + cellHeight * y : point.y - cellHeight / 2 + cellHeight * y;
    }
    const x = isSourceCell ? edgeState.style.exitX : edgeState.style.entryX;
    const onlyVerticalDirections = isSourceCell ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST) : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST);
    if (x != void 0 && onlyVerticalDirections) {
      const cellWidth = (cellBounds == null ? void 0 : cellBounds.width) || 0;
      point.x = (cellBounds == null ? void 0 : cellBounds.x) != void 0 ? (cellBounds == null ? void 0 : cellBounds.x) + cellWidth * x : point.x - cellWidth / 2 + cellWidth * (x || 0);
    }
  }
  function findRoute(start, end, obstacleMap, opt) {
    const step = _a.MANHATTAN_STEP;
    const startPoints = getRectPoints(start, _a.MANHATTAN_START_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));
    const startCenter = snapPointToGrid(getRectangleCenter(start), step);
    const endPoints = getRectPoints(end, _a.MANHATTAN_END_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));
    const endCenter = snapPointToGrid(getRectangleCenter(end), step);
    if (startPoints.length > 0 && endPoints.length > 0) {
      const openSet = new SortedSet();
      const parents = {};
      const costs = {};
      startPoints.forEach((p) => {
        const key2 = pointToString(p);
        openSet.add(key2, estimateCost(p, endPoints));
        costs[key2] = 0;
      });
      let loopsRemain = _a.MANHATTAN_MAXIMUM_LOOPS;
      const endPointsKeys = endPoints.map((p) => pointToString(p));
      let currentDirectionAngle;
      let previousDirectionAngle;
      while (!openSet.isEmpty() && loopsRemain > 0) {
        const currentKey = openSet.pop();
        if (currentKey == void 0) {
          continue;
        }
        const currentPoint = toPointFromString(currentKey);
        const currentCost = costs[currentKey];
        previousDirectionAngle = currentDirectionAngle;
        currentDirectionAngle = parents[currentKey] ? getDirectionAngle(parents[currentKey], currentPoint, opt.directions.length) : opt.previousDirAngle != 0 ? opt.previousDirAngle : getDirectionAngle(startCenter, currentPoint, opt.directions.length);
        if (endPointsKeys.indexOf(currentKey) >= 0) {
          const directionChangedAngle = getDirectionChange(currentDirectionAngle, getDirectionAngle(currentPoint, endCenter, opt.directions.length));
          if (currentPoint.equals(endCenter) || directionChangedAngle < 180) {
            opt.previousDirAngle = currentDirectionAngle;
            return reconstructRoute(parents, currentPoint, startCenter, endCenter);
          }
        }
        for (let i2 = 0; i2 < opt.directions.length; i2++) {
          const direction = opt.directions[i2];
          const directionChangedAngle = getDirectionChange(currentDirectionAngle, direction.angle);
          if (previousDirectionAngle && directionChangedAngle > _a.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE) {
            continue;
          }
          const neighborPoint = movePoint(currentPoint.clone(), direction.offsetX, direction.offsetY);
          const neighborKey = pointToString(neighborPoint);
          if (openSet.isClose(neighborKey) || !obstacleMap.isPointAccessible(neighborPoint)) {
            continue;
          }
          const costFromStart = currentCost + direction.cost + opt.penaltiesGenerator(directionChangedAngle);
          if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
            parents[neighborKey] = currentPoint;
            costs[neighborKey] = costFromStart;
            openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
          }
        }
        loopsRemain--;
      }
      return null;
    }
    return null;
  }
  function router(state3, source3, target3, points3, result3, opt) {
    if (points3 != null && points3.length > 0 || source3 == null || target3 == null) {
      _a.SegmentConnector(state3, source3, target3, points3, result3);
      return;
    }
    let sourceBBox = getCellAbsoluteBounds(source3);
    sourceBBox = sourceBBox ? moveAndExpand(sourceBBox, opt.paddingBox) : void 0;
    let targetBBox = getCellAbsoluteBounds(target3);
    targetBBox = targetBBox ? moveAndExpand(targetBBox, opt.paddingBox) : void 0;
    const obstacleMap = new ObstacleMap(opt);
    obstacleMap.build(source3, target3);
    if (!sourceBBox || !targetBBox) {
      return _a.OrthConnector(state3, source3, target3, points3, result3);
    }
    const routePoints = findRoute(sourceBBox, targetBBox, obstacleMap, opt);
    if (routePoints == null || routePoints.length == 0) {
      return _a.OrthConnector(state3, source3, target3, points3, result3);
    }
    if (state3.style) {
      if (state3.visibleSourceState && routePoints.length > 0) {
        alignPointToCell(routePoints[0], state3, state3.visibleSourceState, true);
      }
      if (state3.visibleTargetState && routePoints.length > 1) {
        alignPointToCell(routePoints[routePoints.length - 1], state3, state3.visibleTargetState, false);
      }
    }
    const scale = state3.view.scale;
    routePoints.forEach((pt) => result3.push(new Point_default(Math.round((pt.x + state3.view.translate.x) * scale * 10) / 10, Math.round((pt.y + state3.view.translate.y) * scale * 10) / 10)));
  }
  router(state2, source2, target2, points2, result2, config);
};
var EdgeStyle_default = EdgeStyle;

// node_modules/@maxgraph/core/lib/view/cell/CellHighlight.js
var CellHighlight = class {
  constructor(graph, highlightColor, strokeWidth, dashed) {
    this.strokeWidth = 0;
    this.dashed = false;
    this.opacity = 100;
    this.shape = null;
    this.keepOnTop = false;
    this.state = null;
    this.spacing = 2;
    this.graph = graph;
    this.highlightColor = highlightColor ?? DEFAULT_VALID_COLOR;
    this.strokeWidth = strokeWidth ?? HIGHLIGHT_STROKEWIDTH;
    this.dashed = dashed ?? false;
    this.opacity = HIGHLIGHT_OPACITY;
    this.repaintHandler = () => {
      if (this.state) {
        const tmp2 = this.graph.view.getState(this.state.cell);
        if (!tmp2) {
          this.hide();
        } else {
          this.state = tmp2;
          this.repaint();
        }
      }
    };
    this.graph.getView().addListener(InternalEvent_default.SCALE, this.repaintHandler);
    this.graph.getView().addListener(InternalEvent_default.TRANSLATE, this.repaintHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.repaintHandler);
    this.resetHandler = () => {
      this.hide();
    };
    this.graph.getView().addListener(InternalEvent_default.DOWN, this.resetHandler);
    this.graph.getView().addListener(InternalEvent_default.UP, this.resetHandler);
  }
  /**
   * Sets the color of the rectangle used to highlight drop targets.
   *
   * @param {string} color - String that represents the new highlight color.
   */
  setHighlightColor(color) {
    this.highlightColor = color;
    if (this.shape) {
      this.shape.stroke = color;
    }
  }
  /**
   * Creates and returns the highlight shape for the given state.
   */
  drawHighlight() {
    var _a2;
    this.shape = this.createShape();
    this.repaint();
    if (this.shape) {
      const node2 = this.shape.node;
      if (!this.keepOnTop && ((_a2 = node2 == null ? void 0 : node2.parentNode) == null ? void 0 : _a2.firstChild) !== node2 && node2.parentNode) {
        node2.parentNode.insertBefore(node2, node2.parentNode.firstChild);
      }
    }
  }
  /**
   * Creates and returns the highlight shape for the given state.
   */
  createShape() {
    if (!this.state)
      return null;
    const shape2 = this.graph.cellRenderer.createShape(this.state);
    shape2.svgStrokeTolerance = this.graph.getEventTolerance();
    shape2.points = this.state.absolutePoints;
    shape2.apply(this.state);
    shape2.stroke = this.highlightColor;
    shape2.opacity = this.opacity;
    shape2.isDashed = this.dashed;
    shape2.isShadow = false;
    shape2.dialect = DIALECT.SVG;
    shape2.init(this.graph.getView().getOverlayPane());
    InternalEvent_default.redirectMouseEvents(shape2.node, this.graph, this.state);
    if (this.graph.dialect !== DIALECT.SVG) {
      shape2.pointerEvents = false;
    } else {
      shape2.svgPointerEvents = "stroke";
    }
    return shape2;
  }
  /**
   * Updates the highlight after a change of the model or view.
   */
  getStrokeWidth(state2 = null) {
    return this.strokeWidth;
  }
  /**
   * Updates the highlight after a change of the model or view.
   */
  repaint() {
    if (this.state && this.shape) {
      this.shape.scale = this.state.view.scale;
      if (this.state.cell.isEdge()) {
        this.shape.strokeWidth = this.getStrokeWidth();
        this.shape.points = this.state.absolutePoints;
        this.shape.outline = false;
      } else {
        this.shape.bounds = new Rectangle_default(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);
        this.shape.rotation = this.state.style.rotation ?? 0;
        this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;
        this.shape.outline = true;
      }
      if (this.state.shape) {
        this.shape.setCursor(this.state.shape.getCursor());
      }
      this.shape.redraw();
    }
  }
  /**
   * Resets the state of the cell marker.
   */
  hide() {
    this.highlight(null);
  }
  /**
   * Marks the {@link arkedState} and fires a {@link ark} event.
   */
  highlight(state2 = null) {
    if (this.state !== state2) {
      if (this.shape) {
        this.shape.destroy();
        this.shape = null;
      }
      this.state = state2;
      if (this.state) {
        this.drawHighlight();
      }
    }
  }
  /**
   * Returns true if this highlight is at the given position.
   */
  isHighlightAt(x, y) {
    let hit = false;
    if (this.shape && document.elementFromPoint) {
      let elt2 = document.elementFromPoint(x, y);
      while (elt2) {
        if (elt2 === this.shape.node) {
          hit = true;
          break;
        }
        elt2 = elt2.parentNode;
      }
    }
    return hit;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    const graph = this.graph;
    graph.getView().removeListener(this.resetHandler);
    graph.getView().removeListener(this.repaintHandler);
    graph.getDataModel().removeListener(this.repaintHandler);
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
  }
};
var CellHighlight_default = CellHighlight;

// node_modules/@maxgraph/core/lib/view/cell/CellMarker.js
var CellMarker = class extends EventSource_default {
  constructor(graph, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super();
    this.enabled = true;
    this.hotspot = DEFAULT_HOTSPOT;
    this.hotspotEnabled = false;
    this.currentColor = NONE;
    this.validState = null;
    this.markedState = null;
    this.graph = graph;
    this.validColor = validColor;
    this.invalidColor = invalidColor;
    this.hotspot = hotspot;
    this.highlight = new CellHighlight_default(graph);
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets the <hotspot>.
   */
  setHotspot(hotspot) {
    this.hotspot = hotspot;
  }
  /**
   * Returns the <hotspot>.
   */
  getHotspot() {
    return this.hotspot;
  }
  /**
   * Specifies whether the hotspot should be used in <intersects>.
   */
  setHotspotEnabled(enabled2) {
    this.hotspotEnabled = enabled2;
  }
  /**
   * Returns true if hotspot is used in <intersects>.
   */
  isHotspotEnabled() {
    return this.hotspotEnabled;
  }
  /**
   * Returns true if <validState> is not null.
   */
  hasValidState() {
    return !!this.validState;
  }
  /**
   * Returns the <validState>.
   */
  getValidState() {
    return this.validState;
  }
  /**
   * Returns the {@link arkedState}.
   */
  getMarkedState() {
    return this.markedState;
  }
  /**
   * Resets the state of the cell marker.
   */
  reset() {
    this.validState = null;
    if (this.markedState) {
      this.markedState = null;
      this.unmark();
    }
  }
  /**
   * Processes the given event and cell and marks the state returned by
   * <getState> with the color returned by <getMarkerColor>. If the
   * markerColor is not null, then the state is stored in {@link arkedState}. If
   * <isValidState> returns true, then the state is stored in <validState>
   * regardless of the marker color. The state is returned regardless of the
   * marker color and valid state.
   */
  process(me) {
    let state2 = null;
    if (this.isEnabled()) {
      state2 = this.getState(me);
      this.setCurrentState(state2, me);
    }
    return state2;
  }
  /**
   * Sets and marks the current valid state.
   */
  setCurrentState(state2, me, color) {
    const isValid = state2 ? this.isValidState(state2) : false;
    color = color ?? this.getMarkerColor(me.getEvent(), state2, isValid);
    if (isValid) {
      this.validState = state2;
    } else {
      this.validState = null;
    }
    if (state2 !== this.markedState || color !== this.currentColor) {
      this.currentColor = color;
      if (state2 && this.currentColor !== NONE) {
        this.markedState = state2;
        this.mark();
      } else if (this.markedState) {
        this.markedState = null;
        this.unmark();
      }
    }
  }
  /**
   * Marks the given cell using the given color, or <validColor> if no color is specified.
   */
  markCell(cell2, color) {
    const state2 = this.graph.getView().getState(cell2);
    if (state2) {
      this.currentColor = color ?? this.validColor;
      this.markedState = state2;
      this.mark();
    }
  }
  /**
   * Marks the {@link arkedState} and fires a {@link ark} event.
   */
  mark() {
    this.highlight.setHighlightColor(this.currentColor);
    this.highlight.highlight(this.markedState);
    this.fireEvent(new EventObject_default(InternalEvent_default.MARK, "state", this.markedState));
  }
  /**
   * Hides the marker and fires a {@link ark} event.
   */
  unmark() {
    this.mark();
  }
  /**
   * Returns true if the given <CellState> is a valid state. If this
   * returns true, then the state is stored in <validState>. The return value
   * of this method is used as the argument for <getMarkerColor>.
   */
  isValidState(state2) {
    return true;
  }
  /**
   * Returns the valid- or invalidColor depending on the value of isValid.
   * The given <CellState> is ignored by this implementation.
   */
  getMarkerColor(evt2, state2, isValid) {
    return isValid ? this.validColor : this.invalidColor;
  }
  /**
   * Uses <getCell>, <getStateToMark> and <intersects> to return the
   * <CellState> for the given {@link MouseEvent}.
   */
  getState(me) {
    const view = this.graph.getView();
    const cell2 = this.getCell(me);
    if (!cell2)
      return null;
    const state2 = this.getStateToMark(view.getState(cell2));
    return state2 && this.intersects(state2, me) ? state2 : null;
  }
  /**
   * Returns the <Cell> for the given event and cell. This returns the
   * given cell.
   */
  getCell(me) {
    return me.getCell();
  }
  /**
   * Returns the <CellState> to be marked for the given <CellState> under
   * the mouse. This returns the given state.
   */
  getStateToMark(state2) {
    return state2;
  }
  /**
   * Returns true if the given coordinate pair intersects the given state.
   * This returns true if the <hotspot> is 0 or the coordinates are inside
   * the hotspot for the given cell state.
   */
  intersects(state2, me) {
    const x = me.getGraphX();
    const y = me.getGraphY();
    if (this.hotspotEnabled) {
      return intersectsHotspot(state2, x, y, this.hotspot, MIN_HOTSPOT_SIZE, MAX_HOTSPOT_SIZE);
    }
    return true;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    this.highlight.destroy();
  }
};
var CellMarker_default = CellMarker;

// node_modules/@maxgraph/core/lib/view/other/ConnectionConstraint.js
var ConnectionConstraint = class {
  constructor(point, perimeter2 = true, name2 = null, dx = 0, dy = 0) {
    this.perimeter = true;
    this.name = null;
    this.dx = 0;
    this.dy = 0;
    this.point = point;
    this.perimeter = perimeter2;
    this.name = name2;
    this.dx = dx;
    this.dy = dy;
  }
};
var ConnectionConstraint_default = ConnectionConstraint;

// node_modules/@maxgraph/core/lib/view/handler/ConstraintHandler.js
var ConstraintHandler = class {
  constructor(graph) {
    this.pointImage = new ImageBox_default(`${Client_default.imageBasePath}/point.gif`, 5, 5);
    this.currentFocus = null;
    this.currentFocusArea = null;
    this.focusIcons = [];
    this.constraints = null;
    this.currentConstraint = null;
    this.focusHighlight = null;
    this.focusPoints = [];
    this.currentPoint = null;
    this.enabled = true;
    this.highlightColor = DEFAULT_VALID_COLOR;
    this.mouseleaveHandler = null;
    this.graph = graph;
    this.resetHandler = () => {
      if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {
        this.reset();
      } else {
        this.redraw();
      }
    };
    this.graph.model.addListener(InternalEvent_default.CHANGE, this.resetHandler);
    this.graph.view.addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.resetHandler);
    this.graph.view.addListener(InternalEvent_default.TRANSLATE, this.resetHandler);
    this.graph.view.addListener(InternalEvent_default.SCALE, this.resetHandler);
    this.graph.addListener(InternalEvent_default.ROOT, this.resetHandler);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param {boolean} enabled - Boolean that specifies the new enabled state.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    for (let i2 = 0; i2 < this.focusIcons.length; i2 += 1) {
      this.focusIcons[i2].destroy();
    }
    this.focusIcons = [];
    if (this.focusHighlight) {
      this.focusHighlight.destroy();
      this.focusHighlight = null;
    }
    this.currentConstraint = null;
    this.currentFocusArea = null;
    this.currentPoint = null;
    this.currentFocus = null;
    this.focusPoints = [];
  }
  /**
   * Returns the tolerance to be used for intersecting connection points. This
   * implementation returns {@link mxGraph.tolerance}.
   *
   * @param me {@link mxMouseEvent} whose tolerance should be returned.
   */
  getTolerance(me) {
    return this.graph.getEventTolerance();
  }
  /**
   * Returns the tolerance to be used for intersecting connection points.
   */
  getImageForConstraint(state2, constraint, point) {
    return this.pointImage;
  }
  /**
   * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This
   * implementation always returns false.
   */
  isEventIgnored(me, source2 = false) {
    return false;
  }
  /**
   * Returns true if the given state should be ignored. This always returns false.
   */
  isStateIgnored(state2, source2 = false) {
    return false;
  }
  /**
   * Destroys the {@link focusIcons} if they exist.
   */
  destroyIcons() {
    for (let i2 = 0; i2 < this.focusIcons.length; i2 += 1) {
      this.focusIcons[i2].destroy();
    }
    this.focusIcons = [];
    this.focusPoints = [];
  }
  /**
   * Destroys the {@link focusHighlight} if one exists.
   */
  destroyFocusHighlight() {
    if (this.focusHighlight) {
      this.focusHighlight.destroy();
      this.focusHighlight = null;
    }
  }
  /**
   * Returns true if the current focused state should not be changed for the given event.
   * This returns true if shift and alt are pressed.
   */
  isKeepFocusEvent(me) {
    return isShiftDown(me.getEvent());
  }
  /**
   * Returns the cell for the given event.
   */
  getCellForEvent(me, point) {
    let cell2 = me.getCell();
    if (!cell2 && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {
      cell2 = this.graph.getCellAt(point.x, point.y);
    }
    if (cell2 && !cell2.isConnectable()) {
      const parent2 = cell2.getParent();
      if (parent2 && parent2.isVertex() && parent2.isConnectable()) {
        cell2 = parent2;
      }
    }
    if (cell2) {
      return this.graph.isCellLocked(cell2) ? null : cell2;
    } else {
      return null;
    }
  }
  /**
   * Updates the state of this handler based on the given {@link mxMouseEvent}.
   * Source is a boolean indicating if the cell is a source or target.
   */
  update(me, source2, existingEdge, point) {
    if (this.isEnabled() && !this.isEventIgnored(me)) {
      if (!this.mouseleaveHandler && this.graph.container) {
        this.mouseleaveHandler = () => {
          this.reset();
        };
        InternalEvent_default.addListener(this.graph.container, "mouseleave", this.resetHandler);
      }
      const tol = this.getTolerance(me);
      const x = point ? point.x : me.getGraphX();
      const y = point ? point.y : me.getGraphY();
      const grid = new Rectangle_default(x - tol, y - tol, 2 * tol, 2 * tol);
      const mouse = new Rectangle_default(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);
      const state2 = this.graph.view.getState(this.getCellForEvent(me, point));
      if (!this.isKeepFocusEvent(me) && (!this.currentFocusArea || !this.currentFocus || state2 || !this.currentFocus.cell.isVertex() || !intersects2(this.currentFocusArea, mouse)) && state2 !== this.currentFocus) {
        this.currentFocusArea = null;
        this.currentFocus = null;
        this.setFocus(me, state2, source2);
      }
      this.currentConstraint = null;
      this.currentPoint = null;
      let minDistSq = null;
      let tmp2;
      if (this.focusIcons.length > 0 && this.constraints && (!state2 || this.currentFocus === state2)) {
        const cx = mouse.getCenterX();
        const cy = mouse.getCenterY();
        for (let i2 = 0; i2 < this.focusIcons.length; i2 += 1) {
          const dx = cx - this.focusIcons[i2].bounds.getCenterX();
          const dy = cy - this.focusIcons[i2].bounds.getCenterY();
          tmp2 = dx * dx + dy * dy;
          if ((this.intersects(this.focusIcons[i2], mouse, source2, existingEdge) || point && this.intersects(this.focusIcons[i2], grid, source2, existingEdge)) && (minDistSq === null || tmp2 < minDistSq)) {
            this.currentConstraint = this.constraints[i2];
            this.currentPoint = this.focusPoints[i2];
            minDistSq = tmp2;
            tmp2 = this.focusIcons[i2].bounds.clone();
            tmp2.grow(HIGHLIGHT_SIZE + 1);
            tmp2.width -= 1;
            tmp2.height -= 1;
            if (!this.focusHighlight) {
              const hl = this.createHighlightShape();
              hl.dialect = DIALECT.SVG;
              hl.pointerEvents = false;
              hl.init(this.graph.getView().getOverlayPane());
              this.focusHighlight = hl;
              const getState = () => {
                return this.currentFocus ? this.currentFocus : state2;
              };
              InternalEvent_default.redirectMouseEvents(hl.node, this.graph, getState);
            }
            this.focusHighlight.bounds = tmp2;
            this.focusHighlight.redraw();
          }
        }
      }
      if (!this.currentConstraint) {
        this.destroyFocusHighlight();
      }
    } else {
      this.currentConstraint = null;
      this.currentFocus = null;
      this.currentPoint = null;
    }
  }
  /**
   * Transfers the focus to the given state as a source or target terminal. If
   * the handler is not enabled then the outline is painted, but the constraints
   * are ignored.
   */
  redraw() {
    if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {
      const state2 = this.graph.view.getState(this.currentFocus.cell);
      this.currentFocus = state2;
      this.currentFocusArea = new Rectangle_default(state2.x, state2.y, state2.width, state2.height);
      for (let i2 = 0; i2 < this.constraints.length; i2 += 1) {
        const cp = this.graph.getConnectionPoint(state2, this.constraints[i2]);
        const img = this.getImageForConstraint(state2, this.constraints[i2], cp);
        const bounds = new Rectangle_default(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
        this.focusIcons[i2].bounds = bounds;
        this.focusIcons[i2].redraw();
        this.currentFocusArea.add(this.focusIcons[i2].bounds);
        this.focusPoints[i2] = cp;
      }
    }
  }
  /**
   * Transfers the focus to the given state as a source or target terminal. If
   * the handler is not enabled then the outline is painted, but the constraints
   * are ignored.
   */
  setFocus(me, state2, source2) {
    var _a2;
    this.constraints = state2 && !this.isStateIgnored(state2, source2) && state2.cell.isConnectable() ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state2, source2) ?? [] : [] : null;
    if (this.constraints && state2) {
      this.currentFocus = state2;
      this.currentFocusArea = new Rectangle_default(state2.x, state2.y, state2.width, state2.height);
      for (let i2 = 0; i2 < this.focusIcons.length; i2 += 1) {
        this.focusIcons[i2].destroy();
      }
      this.focusIcons = [];
      this.focusPoints = [];
      for (let i2 = 0; i2 < this.constraints.length; i2 += 1) {
        const cp = this.graph.getConnectionPoint(state2, this.constraints[i2]);
        const img = this.getImageForConstraint(state2, this.constraints[i2], cp);
        const { src } = img;
        const bounds = new Rectangle_default(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);
        const icon2 = new ImageShape_default(bounds, src);
        icon2.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
        icon2.preserveImageAspect = false;
        icon2.init(this.graph.getView().getDecoratorPane());
        if (icon2.node.previousSibling) {
          (_a2 = icon2.node.parentNode) == null ? void 0 : _a2.insertBefore(icon2.node, icon2.node.parentNode.firstChild);
        }
        const getState = () => {
          return this.currentFocus ? this.currentFocus : state2;
        };
        icon2.redraw();
        InternalEvent_default.redirectMouseEvents(icon2.node, this.graph, getState);
        this.currentFocusArea.add(icon2.bounds);
        this.focusIcons.push(icon2);
        this.focusPoints.push(cp);
      }
      this.currentFocusArea.grow(this.getTolerance(me));
    } else {
      this.destroyIcons();
      this.destroyFocusHighlight();
    }
  }
  /**
   * Create the shape used to paint the highlight.
   *
   * Returns true if the given icon intersects the given point.
   */
  createHighlightShape() {
    const hl = new RectangleShape_default(new Rectangle_default(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);
    hl.opacity = HIGHLIGHT_OPACITY;
    return hl;
  }
  /**
   * Returns true if the given icon intersects the given rectangle.
   */
  intersects(icon2, mouse, source2, existingEdge) {
    return intersects2(icon2.bounds, mouse);
  }
  /**
   * Destroy this handler.
   */
  onDestroy() {
    this.reset();
    this.graph.model.removeListener(this.resetHandler);
    this.graph.view.removeListener(this.resetHandler);
    this.graph.removeListener(this.resetHandler);
    if (this.mouseleaveHandler && this.graph.container) {
      InternalEvent_default.removeListener(this.graph.container, "mouseleave", this.mouseleaveHandler);
      this.mouseleaveHandler = null;
    }
  }
};
var ConstraintHandler_default = ConstraintHandler;

// node_modules/@maxgraph/core/lib/view/handler/EdgeHandler.js
var EdgeHandler = class {
  constructor(state2) {
    this.error = null;
    this.bends = [];
    this.cloneEnabled = true;
    this.addEnabled = false;
    this.removeEnabled = false;
    this.dblClickRemoveEnabled = false;
    this.mergeRemoveEnabled = false;
    this.straightRemoveEnabled = false;
    this.virtualBendsEnabled = false;
    this.virtualBendOpacity = 20;
    this.parentHighlightEnabled = false;
    this.preferHtml = false;
    this.allowHandleBoundsCheck = true;
    this.snapToTerminals = false;
    this.handleImage = null;
    this.labelHandleImage = null;
    this.tolerance = 0;
    this.outlineConnect = false;
    this.manageLabelHandle = false;
    this.currentPoint = null;
    this.parentHighlight = null;
    this.index = null;
    this.isSource = false;
    this.isTarget = false;
    this.isLabel = false;
    this.points = [];
    this.snapPoint = null;
    this.abspoints = [];
    this.startX = 0;
    this.startY = 0;
    this.outline = true;
    this.active = true;
    this.state = state2;
    this.graph = this.state.view.graph;
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler_default(this.graph);
    this.points = [];
    this.abspoints = this.getSelectionPoints(this.state);
    this.shape = this.createSelectionShape(this.abspoints);
    this.shape.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
    this.shape.init(this.graph.getView().getOverlayPane());
    this.shape.pointerEvents = false;
    this.shape.setCursor(CURSOR.MOVABLE_EDGE);
    InternalEvent_default.redirectMouseEvents(this.shape.node, this.graph, this.state);
    this.preferHtml = this.state.text != null && this.state.text.node.parentNode === this.graph.container;
    if (!this.preferHtml) {
      const sourceState = this.state.getVisibleTerminalState(true);
      if (sourceState != null) {
        this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode === this.graph.container;
      }
      if (!this.preferHtml) {
        const targetState = this.state.getVisibleTerminalState(false);
        if (targetState != null) {
          this.preferHtml = targetState.text != null && targetState.text.node.parentNode === this.graph.container;
        }
      }
    }
    const selectionHandler = this.graph.getPlugin("SelectionHandler");
    if (selectionHandler && (this.graph.getSelectionCount() < selectionHandler.maxCells || selectionHandler.maxCells <= 0)) {
      this.bends = this.createBends();
      if (this.isVirtualBendsEnabled()) {
        this.virtualBends = this.createVirtualBends();
      }
    }
    this.label = new Point_default(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape = this.createLabelHandleShape();
    this.initBend(this.labelShape);
    this.labelShape.setCursor(CURSOR.LABEL_HANDLE);
    this.customHandles = this.createCustomHandles();
    this.updateParentHighlight();
    this.redraw();
    this.escapeHandler = (sender, evt2) => {
      const dirty = this.index != null;
      this.reset();
      if (dirty) {
        this.graph.cellRenderer.redraw(this.state, false, state2.view.isRendering());
      }
    };
    this.state.view.graph.addListener(InternalEvent_default.ESCAPE, this.escapeHandler);
  }
  /**
   * Returns true if the parent highlight should be visible. This implementation
   * always returns true.
   */
  isParentHighlightVisible() {
    const parent2 = this.state.cell.getParent();
    return parent2 ? !this.graph.isCellSelected(parent2) : null;
  }
  /**
   * Updates the highlight of the parent if <parentHighlightEnabled> is true.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent2 = this.state.cell.getParent();
      const pstate = parent2 ? this.graph.view.getState(parent2) : null;
      if (this.parentHighlight) {
        if (parent2 && parent2.isVertex() && visible) {
          const b = this.parentHighlight.bounds;
          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
            this.parentHighlight.bounds = Rectangle_default.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate && pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }
          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled && visible) {
        if (parent2 && parent2.isVertex() && pstate && !pstate.parentHighlight) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          if (pstate.style.rotation) {
            this.parentHighlight.rotation = pstate.style.rotation;
          }
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }
  /**
   * Returns an array of custom handles. This implementation returns an empty array.
   */
  createCustomHandles() {
    return [];
  }
  /**
   * Returns true if virtual bends should be added. This returns true if
   * <virtualBendsEnabled> is true and the current style allows and
   * renders custom waypoints.
   */
  isVirtualBendsEnabled(evt2) {
    return this.virtualBendsEnabled && (this.state.style.edgeStyle == null || this.state.style.edgeStyle === NONE || this.state.style.noEdgeStyle) && this.state.style.shape !== "arrow";
  }
  /**
   * Returns true if the given cell allows new connections to be created. This implementation
   * always returns true.
   */
  isCellEnabled(cell2) {
    return true;
  }
  /**
   * Returns true if the given event is a trigger to add a new Point. This
   * implementation returns true if shift is pressed.
   */
  isAddPointEvent(evt2) {
    return isShiftDown(evt2);
  }
  /**
   * Returns true if the given event is a trigger to remove a point. This
   * implementation returns true if shift is pressed.
   */
  isRemovePointEvent(evt2) {
    return isShiftDown(evt2);
  }
  /**
   * Returns the list of points that defines the selection stroke.
   */
  getSelectionPoints(state2) {
    return state2.absolutePoints;
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds) {
    const shape2 = new RectangleShape_default(Rectangle_default.fromRectangle(bounds), NONE, this.getSelectionColor());
    shape2.strokeWidth = this.getSelectionStrokeWidth();
    shape2.isDashed = this.isSelectionDashed();
    return shape2;
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(points2) {
    const c = this.state.shape.constructor;
    const shape2 = new c();
    shape2.outline = true;
    shape2.apply(this.state);
    shape2.isDashed = this.isSelectionDashed();
    shape2.stroke = this.getSelectionColor();
    shape2.isShadow = false;
    return shape2;
  }
  /**
   * Returns {@link EDGE_SELECTION_COLOR}.
   */
  getSelectionColor() {
    return EDGE_SELECTION_COLOR;
  }
  /**
   * Returns {@link EDGE_SELECTION_STROKEWIDTH}.
   */
  getSelectionStrokeWidth() {
    return EDGE_SELECTION_STROKEWIDTH;
  }
  /**
   * Returns {@link EDGE_SELECTION_DASHED}.
   */
  isSelectionDashed() {
    return EDGE_SELECTION_DASHED;
  }
  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell2) {
    return true;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link marker}.
   */
  getCellAt(x, y) {
    return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link marker}.
   */
  createMarker() {
    return new EdgeHandlerCellMarker(this.graph, this);
  }
  /**
   * Returns the error message or an empty string if the connection for the
   * given source, target pair is not valid. Otherwise it returns null. This
   * implementation uses {@link Graph#getEdgeValidationError}.
   *
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   */
  validateConnection(source2, target2) {
    return this.graph.getEdgeValidationError(this.state.cell, source2, target2);
  }
  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of {@link RectangleShape}.
   */
  createBends() {
    const { cell: cell2 } = this.state;
    const bends = [];
    for (let i2 = 0; i2 < this.abspoints.length; i2 += 1) {
      if (this.isHandleVisible(i2)) {
        const source2 = i2 === 0;
        const target2 = i2 === this.abspoints.length - 1;
        const terminal = source2 || target2;
        if (terminal || this.graph.isCellBendable(cell2)) {
          ((index) => {
            const bend = this.createHandleShape(index);
            this.initBend(bend, () => {
              if (this.dblClickRemoveEnabled) {
                this.removePoint(this.state, index);
              }
            });
            if (this.isHandleEnabled(i2)) {
              bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);
            }
            bends.push(bend);
            if (!terminal) {
              this.points.push(new Point_default(0, 0));
              bend.node.style.visibility = "hidden";
            }
          })(i2);
        }
      }
    }
    return bends;
  }
  /**
   * Creates and returns the bends used for modifying the edge. This is
   * typically an array of {@link RectangleShape}.
   */
  // createVirtualBends(): mxRectangleShape[];
  createVirtualBends() {
    const { cell: cell2 } = this.state;
    const last = this.abspoints[0];
    const bends = [];
    if (this.graph.isCellBendable(cell2)) {
      for (let i2 = 1; i2 < this.abspoints.length; i2 += 1) {
        ((bend) => {
          this.initBend(bend);
          bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);
          bends.push(bend);
        })(this.createHandleShape());
      }
    }
    return bends;
  }
  /**
   * Creates the shape used to display the given bend.
   */
  isHandleEnabled(index) {
    return true;
  }
  /**
   * Returns true if the handle at the given index is visible.
   */
  isHandleVisible(index) {
    const source2 = this.state.getVisibleTerminalState(true);
    const target2 = this.state.getVisibleTerminalState(false);
    const geo = this.state.cell.getGeometry();
    const edgeStyle2 = geo ? this.graph.view.getEdgeStyle(this.state, geo.points || void 0, source2, target2) : null;
    return edgeStyle2 !== EdgeStyle_default.EntityRelation || index === 0 || index === this.abspoints.length - 1;
  }
  /**
   * Creates the shape used to display the given bend. Note that the index may be
   * null for special cases, such as when called from
   * {@link ElbowEdgeHandler#createVirtualBend}. Only images and rectangles should be
   * returned if support for HTML labels with not foreign objects is required.
   * Index if null for virtual handles.
   */
  createHandleShape(index) {
    if (this.handleImage) {
      const shape2 = new ImageShape_default(new Rectangle_default(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);
      shape2.preserveImageAspect = false;
      return shape2;
    }
    let s = HANDLE_SIZE;
    if (this.preferHtml) {
      s -= 1;
    }
    return new RectangleShape_default(new Rectangle_default(0, 0, s, s), HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);
  }
  /**
   * Creates the shape used to display the the label handle.
   */
  createLabelHandleShape() {
    if (this.labelHandleImage) {
      const shape2 = new ImageShape_default(new Rectangle_default(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);
      shape2.preserveImageAspect = false;
      return shape2;
    }
    const s = LABEL_HANDLE_SIZE;
    return new RectangleShape_default(new Rectangle_default(0, 0, s, s), LABEL_HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);
  }
  /**
   * Helper method to initialize the given bend.
   *
   * @param bend {@link Shape} that represents the bend to be initialized.
   */
  initBend(bend, dblClick) {
    if (this.preferHtml) {
      bend.dialect = DIALECT.STRICTHTML;
      bend.init(this.graph.container);
    } else {
      bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      bend.init(this.graph.getView().getOverlayPane());
    }
    InternalEvent_default.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);
    if (Client_default.IS_TOUCH) {
      bend.node.setAttribute("pointer-events", "none");
    }
  }
  /**
   * Returns the index of the handle for the given event.
   */
  getHandleForEvent(me) {
    let result2 = null;
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle_default(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    let minDistSq = Number.POSITIVE_INFINITY;
    function checkShape(shape2) {
      if (shape2 && shape2.bounds && shape2.node && shape2.node.style.display !== "none" && shape2.node.style.visibility !== "hidden" && (me.isSource(shape2) || hit && intersects2(shape2.bounds, hit))) {
        const dx = me.getGraphX() - shape2.bounds.getCenterX();
        const dy = me.getGraphY() - shape2.bounds.getCenterY();
        const tmp2 = dx * dx + dy * dy;
        if (tmp2 <= minDistSq) {
          minDistSq = tmp2;
          return true;
        }
      }
      return false;
    }
    if (this.isCustomHandleEvent(me) && this.customHandles) {
      for (let i2 = this.customHandles.length - 1; i2 >= 0; i2--) {
        if (checkShape(this.customHandles[i2].shape)) {
          return InternalEvent_default.CUSTOM_HANDLE - i2;
        }
      }
    }
    if (me.isSource(this.state.text) || checkShape(this.labelShape)) {
      result2 = InternalEvent_default.LABEL_HANDLE;
    }
    for (let i2 = 0; i2 < this.bends.length; i2 += 1) {
      if (checkShape(this.bends[i2])) {
        result2 = i2;
      }
    }
    if (this.virtualBends && this.isAddVirtualBendEvent(me)) {
      for (let i2 = 0; i2 < this.virtualBends.length; i2 += 1) {
        if (checkShape(this.virtualBends[i2])) {
          result2 = InternalEvent_default.VIRTUAL_HANDLE - i2;
        }
      }
    }
    return result2;
  }
  /**
   * Returns true if the given event allows virtual bends to be added. This
   * implementation returns true.
   */
  isAddVirtualBendEvent(me) {
    return true;
  }
  /**
   * Returns true if the given event allows custom handles to be changed. This
   * implementation returns true.
   */
  isCustomHandleEvent(me) {
    return true;
  }
  /**
   * Handles the event by checking if a special element of the handler
   * was clicked, in which case the index parameter is non-null. The
   * indices may be one of <LABEL_HANDLE> or the number of the respective
   * control point. The source and target points are used for reconnecting
   * the edge.
   */
  mouseDown(sender, me) {
    const handle = this.getHandleForEvent(me);
    if (handle !== null && this.bends[handle]) {
      const b = this.bends[handle].bounds;
      if (b)
        this.snapPoint = new Point_default(b.getCenterX(), b.getCenterY());
    }
    if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {
      this.addPoint(this.state, me.getEvent());
      me.consume();
    } else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {
      const cell2 = me.getCell();
      if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {
        this.removePoint(this.state, handle);
      } else if (handle !== InternalEvent_default.LABEL_HANDLE || cell2 && this.graph.isLabelMovable(cell2)) {
        if (this.virtualBends && handle <= InternalEvent_default.VIRTUAL_HANDLE) {
          setOpacity(this.virtualBends[InternalEvent_default.VIRTUAL_HANDLE - handle].node, 100);
        }
        this.start(me.getX(), me.getY(), handle);
      }
      me.consume();
    }
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(x, y, index) {
    this.startX = x;
    this.startY = y;
    this.isSource = this.bends.length === 0 ? false : index === 0;
    this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;
    this.isLabel = index === InternalEvent_default.LABEL_HANDLE;
    if (this.isSource || this.isTarget) {
      const { cell: cell2 } = this.state;
      const terminal = cell2.getTerminal(this.isSource);
      if (terminal == null && this.graph.isTerminalPointMovable(cell2, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell2, terminal, this.isSource)) {
        this.index = index;
      }
    } else {
      this.index = index;
    }
    if (this.index !== null && this.index <= InternalEvent_default.CUSTOM_HANDLE && this.index > InternalEvent_default.VIRTUAL_HANDLE) {
      if (this.customHandles != null) {
        for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
          if (i2 !== InternalEvent_default.CUSTOM_HANDLE - this.index) {
            this.customHandles[i2].setVisible(false);
          }
        }
      }
    }
  }
  /**
   * Returns a clone of the current preview state for the given point and terminal.
   */
  clonePreviewState(point, terminal) {
    return this.state.clone();
  }
  /**
   * Returns the tolerance for the guides. Default value is
   * gridSize * scale / 2.
   */
  getSnapToTerminalTolerance() {
    return this.graph.getGridSize() * this.graph.getView().scale / 2;
  }
  /**
   * Hook for subclassers do show details while the handler is active.
   */
  updateHint(me, point) {
    return;
  }
  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the unscaled width or height. This uses Math.round.
   */
  roundLength(length) {
    return Math.round(length);
  }
  /**
   * Returns true if <snapToTerminals> is true and if alt is not pressed.
   */
  isSnapToTerminalsEvent(me) {
    return this.snapToTerminals && !isAltDown(me.getEvent());
  }
  /**
   * Returns the point for the given event.
   */
  // getPointForEvent(me: mxMouseEvent): mxPoint;
  getPointForEvent(me) {
    const view = this.graph.getView();
    const { scale } = view;
    const point = new Point_default(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);
    const tt = this.getSnapToTerminalTolerance();
    let overrideX = false;
    let overrideY = false;
    if (tt > 0 && this.isSnapToTerminalsEvent(me)) {
      const snapToPoint = (pt) => {
        if (pt) {
          const { x } = pt;
          if (Math.abs(point.x - x) < tt) {
            point.x = x;
            overrideX = true;
          }
          const { y } = pt;
          if (Math.abs(point.y - y) < tt) {
            point.y = y;
            overrideY = true;
          }
        }
      };
      const snapToTerminal = (terminal) => {
        if (terminal) {
          snapToPoint(new Point_default(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));
        }
      };
      snapToTerminal(this.state.getVisibleTerminalState(true));
      snapToTerminal(this.state.getVisibleTerminalState(false));
      for (let i2 = 0; i2 < this.state.absolutePoints.length; i2 += 1) {
        snapToPoint(this.state.absolutePoints[i2]);
      }
    }
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      const tr = view.translate;
      if (!overrideX) {
        point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      }
      if (!overrideY) {
        point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
      }
    }
    return point;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  getPreviewTerminalState(me) {
    this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);
    if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {
      if (this.marker.highlight && this.marker.highlight.shape && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {
        if (this.marker.highlight.shape.stroke !== "transparent") {
          this.marker.highlight.shape.stroke = "transparent";
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
      }
      const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);
      const otherCell = other ? other.cell : null;
      const source2 = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;
      const target2 = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;
      this.error = this.validateConnection(source2, target2);
      let result2 = null;
      if (this.error === null) {
        result2 = this.constraintHandler.currentFocus;
      }
      if (this.error !== null || result2 && !this.isCellEnabled(result2.cell)) {
        this.constraintHandler.reset();
      }
      return result2;
    }
    if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {
      this.marker.process(me);
      const state2 = this.marker.getValidState();
      if (state2 && !this.isCellEnabled(state2.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
      }
      return this.marker.getValidState();
    }
    this.marker.reset();
    return null;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   *
   * @param pt {@link Point} that contains the current pointer position.
   * @param me Optional {@link MouseEvent} that contains the current event.
   */
  getPreviewPoints(pt, me) {
    const geometry = this.state.cell.getGeometry();
    if (!geometry)
      return null;
    let points2 = (geometry.points || []).slice();
    const point = new Point_default(pt.x, pt.y);
    let result2 = null;
    if (!this.isSource && !this.isTarget && this.index !== null) {
      this.convertPoint(point, false);
      if (this.index <= InternalEvent_default.VIRTUAL_HANDLE) {
        points2.splice(InternalEvent_default.VIRTUAL_HANDLE - this.index, 0, point);
      }
      if (!this.isSource && !this.isTarget) {
        for (let i2 = 0; i2 < this.bends.length; i2 += 1) {
          if (i2 !== this.index) {
            const bend = this.bends[i2];
            if (bend && contains(bend.bounds, pt.x, pt.y)) {
              if (this.index <= InternalEvent_default.VIRTUAL_HANDLE) {
                points2.splice(InternalEvent_default.VIRTUAL_HANDLE - this.index, 1);
              } else {
                points2.splice(this.index - 1, 1);
              }
              result2 = points2;
            }
          }
        }
        if (!result2 && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {
          const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();
          const abs = this.state.absolutePoints.slice();
          abs[this.index] = pt;
          const src = this.state.getVisibleTerminalState(true);
          if (src != null) {
            const c = this.graph.getConnectionConstraint(this.state, src, true);
            if (c == null || this.graph.getConnectionPoint(src, c) == null) {
              abs[0] = new Point_default(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));
            }
          }
          const trg = this.state.getVisibleTerminalState(false);
          if (trg != null) {
            const c = this.graph.getConnectionConstraint(this.state, trg, false);
            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {
              abs[abs.length - 1] = new Point_default(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));
            }
          }
          const checkRemove = (idx, tmp2) => {
            if (idx > 0 && idx < abs.length - 1 && ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp2.x, tmp2.y) < tol) {
              points2.splice(idx - 1, 1);
              result2 = points2;
            }
          };
          checkRemove(this.index, pt);
        }
      }
      if (result2 == null && this.index > InternalEvent_default.VIRTUAL_HANDLE) {
        points2[this.index - 1] = point;
      }
    } else if (this.graph.isResetEdgesOnConnect()) {
      points2 = [];
    }
    return result2 != null ? result2 : points2;
  }
  /**
   * Returns true if <outlineConnect> is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me) {
    if (!this.currentPoint)
      return false;
    const offset = getOffset(this.graph.container);
    const evt2 = me.getEvent();
    const clientX = getClientX(evt2);
    const clientY = getClientY(evt2);
    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  updatePreviewState(edgeState, point, terminalState, me, outline = false) {
    const sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);
    const targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);
    let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);
    let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);
    let constraint = this.constraintHandler.currentConstraint;
    if (constraint == null && outline) {
      if (terminalState != null) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point_default(me.getGraphX(), me.getGraphY());
        }
        constraint = this.graph.getOutlineConstraint(point, terminalState, me);
        this.constraintHandler.setFocus(me, terminalState, this.isSource);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      } else {
        constraint = new ConnectionConstraint_default(null);
      }
    }
    if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {
      const s = this.graph.view.scale;
      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
        this.marker.highlight.shape.stroke = outline ? OUTLINE_HIGHLIGHT_COLOR : "transparent";
        this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      } else if (this.marker.hasValidState()) {
        const cell2 = me.getCell();
        this.marker.highlight.shape.stroke = cell2 && cell2.isConnectable() && this.marker.getValidState() !== me.getState() ? "transparent" : DEFAULT_VALID_COLOR;
        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
        this.marker.highlight.repaint();
      }
    }
    if (this.isSource) {
      sourceConstraint = constraint;
    } else if (this.isTarget) {
      targetConstraint = constraint;
    }
    if (this.isSource || this.isTarget) {
      if (constraint != null && constraint.point != null) {
        edgeState.style[this.isSource ? "exitX" : "entryX"] = constraint.point.x;
        edgeState.style[this.isSource ? "exitY" : "entryY"] = constraint.point.y;
      } else {
        delete edgeState.style[this.isSource ? "exitX" : "entryX"];
        delete edgeState.style[this.isSource ? "exitY" : "entryY"];
      }
    }
    edgeState.setVisibleTerminalState(sourceState, true);
    edgeState.setVisibleTerminalState(targetState, false);
    if (!this.isSource || sourceState != null) {
      edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);
    }
    if (!this.isTarget || targetState != null) {
      edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);
    }
    if ((this.isSource || this.isTarget) && terminalState == null) {
      edgeState.setAbsoluteTerminalPoint(point, this.isSource);
      if (this.marker.getMarkedState() == null) {
        this.error = this.graph.isAllowDanglingEdges() ? null : "";
      }
    }
    edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);
    edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);
  }
  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender, me) {
    var _a2;
    if (this.index != null && this.marker != null) {
      this.currentPoint = this.getPointForEvent(me);
      this.error = null;
      if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent()) && this.snapPoint != null) {
        if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {
          this.currentPoint.x = this.snapPoint.x;
        } else {
          this.currentPoint.y = this.snapPoint.y;
        }
      }
      if (this.index <= InternalEvent_default.CUSTOM_HANDLE && this.index > InternalEvent_default.VIRTUAL_HANDLE) {
        if (this.customHandles != null) {
          this.customHandles[InternalEvent_default.CUSTOM_HANDLE - this.index].processEvent(me);
          this.customHandles[InternalEvent_default.CUSTOM_HANDLE - this.index].positionChanged();
          if (this.shape != null && this.shape.node != null) {
            this.shape.node.style.display = "none";
          }
        }
      } else if (this.isLabel && this.label) {
        this.label.x = this.currentPoint.x;
        this.label.y = this.currentPoint.y;
      } else {
        this.points = this.getPreviewPoints(this.currentPoint, me);
        let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;
        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {
          this.currentPoint = this.constraintHandler.currentPoint.clone();
        } else if (this.outlineConnect) {
          const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;
          if (outline) {
            terminalState = this.marker.highlight.state;
          } else if (terminalState != null && terminalState !== me.getState() && ((_a2 = me.getCell()) == null ? void 0 : _a2.isConnectable()) && this.marker.highlight.shape != null) {
            this.marker.highlight.shape.stroke = "transparent";
            this.marker.highlight.repaint();
            terminalState = null;
          }
        }
        if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {
          terminalState = null;
          this.marker.reset();
        }
        if (this.currentPoint) {
          const clone2 = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);
          this.updatePreviewState(clone2, this.currentPoint, terminalState, me, this.outline);
          const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;
          this.setPreviewColor(color);
          this.abspoints = clone2.absolutePoints;
          this.active = true;
          this.updateHint(me, this.currentPoint);
        }
      }
      this.drawPreview();
      InternalEvent_default.consume(me.getEvent());
      me.consume();
    }
  }
  /**
   * Handles the event to applying the previewed changes on the edge by
   * using {@link moveLabel}, <connect> or <changePoints>.
   */
  mouseUp(sender, me) {
    if (this.index != null && this.marker != null) {
      if (this.shape != null && this.shape.node != null) {
        this.shape.node.style.display = "";
      }
      let edge2 = this.state.cell;
      const { index } = this;
      this.index = null;
      if (me.getX() !== this.startX || me.getY() !== this.startY) {
        const clone2 = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();
        if (this.error != null) {
          if (this.error.length > 0) {
            this.graph.validationAlert(this.error);
          }
        } else if (index <= InternalEvent_default.CUSTOM_HANDLE && index > InternalEvent_default.VIRTUAL_HANDLE) {
          if (this.customHandles != null) {
            const model2 = this.graph.getDataModel();
            model2.beginUpdate();
            try {
              this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index].execute(me);
              if (this.shape != null && this.shape.node != null) {
                this.shape.apply(this.state);
                this.shape.redraw();
              }
            } finally {
              model2.endUpdate();
            }
          }
        } else if (this.isLabel && this.label) {
          this.moveLabel(this.state, this.label.x, this.label.y);
        } else if (this.isSource || this.isTarget) {
          let terminal = null;
          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
            terminal = this.constraintHandler.currentFocus.cell;
          }
          if (!terminal && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke !== "transparent" && this.marker.highlight.shape.stroke !== "white") {
            terminal = this.marker.validState.cell;
          }
          if (terminal) {
            const model2 = this.graph.getDataModel();
            const parent2 = edge2.getParent();
            model2.beginUpdate();
            try {
              if (clone2) {
                let geo = edge2.getGeometry();
                const cloned = this.graph.cloneCell(edge2);
                model2.add(parent2, cloned, parent2.getChildCount());
                if (geo != null) {
                  geo = geo.clone();
                  model2.setGeometry(cloned, geo);
                }
                const other = edge2.getTerminal(!this.isSource);
                this.graph.connectCell(cloned, other, !this.isSource);
                edge2 = cloned;
              }
              edge2 = this.connect(edge2, terminal, this.isSource, clone2, me);
            } finally {
              model2.endUpdate();
            }
          } else if (this.graph.isAllowDanglingEdges()) {
            const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];
            pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);
            pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);
            const parent2 = edge2.getParent();
            const pstate = parent2 ? this.graph.getView().getState(parent2) : null;
            if (pstate != null) {
              pt.x -= pstate.origin.x;
              pt.y -= pstate.origin.y;
            }
            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;
            edge2 = this.changeTerminalPoint(edge2, pt, this.isSource, clone2);
          }
        } else if (this.active) {
          edge2 = this.changePoints(edge2, this.points, clone2);
        } else {
          this.graph.getView().invalidate(this.state.cell);
          this.graph.getView().validate(this.state.cell);
        }
      } else if (this.graph.isToggleEvent(me.getEvent())) {
        this.graph.selectCellForEvent(this.state.cell, me.getEvent());
      }
      if (this.marker != null) {
        this.reset();
        if (edge2 !== this.state.cell) {
          this.graph.setSelectionCell(edge2);
        }
      }
      me.consume();
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.active) {
      this.refresh();
    }
    this.error = null;
    this.index = null;
    this.points = [];
    this.snapPoint = null;
    this.isLabel = false;
    this.isSource = false;
    this.isTarget = false;
    this.active = false;
    if (this.marker) {
      this.marker.reset();
    }
    this.constraintHandler.reset();
    if (this.customHandles) {
      for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
        this.customHandles[i2].reset();
      }
    }
    this.setPreviewColor(EDGE_SELECTION_COLOR);
    this.removeHint();
    this.redraw();
  }
  /**
   * Sets the color of the preview to the given value.
   */
  setPreviewColor(color) {
    this.shape.stroke = color;
  }
  /**
   * Converts the given point in-place from screen to unscaled, untranslated
   * graph coordinates and applies the grid. Returns the given, modified
   * point instance.
   *
   * @param point {@link Point} to be converted.
   * @param gridEnabled Boolean that specifies if the grid should be applied.
   */
  convertPoint(point, gridEnabled) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    if (gridEnabled) {
      point.x = this.graph.snap(point.x);
      point.y = this.graph.snap(point.y);
    }
    point.x = Math.round(point.x / scale - tr.x);
    point.y = Math.round(point.y / scale - tr.y);
    const parent2 = this.state.cell.getParent();
    const pstate = parent2 ? this.graph.getView().getState(parent2) : parent2;
    if (pstate) {
      point.x -= pstate.origin.x;
      point.y -= pstate.origin.y;
    }
    return point;
  }
  /**
   * Changes the coordinates for the label of the given edge.
   *
   * @param edge <Cell> that represents the edge.
   * @param x Integer that specifies the x-coordinate of the new location.
   * @param y Integer that specifies the y-coordinate of the new location.
   */
  moveLabel(edgeState, x, y) {
    const model2 = this.graph.getDataModel();
    let geometry = edgeState.cell.getGeometry();
    if (geometry != null) {
      const { scale } = this.graph.getView();
      geometry = geometry.clone();
      if (geometry.relative) {
        let pt = this.graph.getView().getRelativePoint(edgeState, x, y);
        geometry.x = Math.round(pt.x * 1e4) / 1e4;
        geometry.y = Math.round(pt.y);
        geometry.offset = new Point_default(0, 0);
        pt = this.graph.view.getPoint(edgeState, geometry);
        geometry.offset = new Point_default(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));
      } else {
        const points2 = edgeState.absolutePoints;
        const p0 = points2[0];
        const pe = points2[points2.length - 1];
        if (p0 != null && pe != null) {
          const cx = p0.x + (pe.x - p0.x) / 2;
          const cy = p0.y + (pe.y - p0.y) / 2;
          geometry.offset = new Point_default(Math.round((x - cx) / scale), Math.round((y - cy) / scale));
          geometry.x = 0;
          geometry.y = 0;
        }
      }
      model2.setGeometry(edgeState.cell, geometry);
    }
  }
  /**
   * Changes the terminal or terminal point of the given edge in the graph
   * model.
   *
   * @param edge <Cell> that represents the edge to be reconnected.
   * @param terminal <Cell> that represents the new terminal.
   * @param isSource Boolean indicating if the new terminal is the source or
   * target terminal.
   * @param isClone Boolean indicating if the new connection should be a clone of
   * the old edge.
   * @param me {@link MouseEvent} that contains the mouse up event.
   */
  connect(edge2, terminal, isSource, isClone, me) {
    const parent2 = edge2.getParent();
    this.graph.batchUpdate(() => {
      let constraint = this.constraintHandler.currentConstraint;
      if (constraint == null) {
        constraint = new ConnectionConstraint_default(null);
      }
      this.graph.connectCell(edge2, terminal, isSource, constraint);
    });
    return edge2;
  }
  /**
   * Changes the terminal point of the given edge.
   */
  changeTerminalPoint(edge2, point, isSource, clone2) {
    const model2 = this.graph.getDataModel();
    model2.batchUpdate(() => {
      if (clone2) {
        const parent2 = edge2.getParent();
        const terminal = edge2.getTerminal(!isSource);
        edge2 = this.graph.cloneCell(edge2);
        model2.add(parent2, edge2, parent2.getChildCount());
        model2.setTerminal(edge2, terminal, !isSource);
      }
      let geo = edge2.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.setTerminalPoint(point, isSource);
        model2.setGeometry(edge2, geo);
        this.graph.connectCell(edge2, null, isSource, new ConnectionConstraint_default(null));
      }
    });
    return edge2;
  }
  /**
   * Changes the control points of the given edge in the graph model.
   */
  changePoints(edge2, points2, clone2) {
    const model2 = this.graph.getDataModel();
    model2.batchUpdate(() => {
      if (clone2) {
        const parent2 = edge2.getParent();
        const source2 = edge2.getTerminal(true);
        const target2 = edge2.getTerminal(false);
        edge2 = this.graph.cloneCell(edge2);
        model2.add(parent2, edge2, parent2.getChildCount());
        model2.setTerminal(edge2, source2, true);
        model2.setTerminal(edge2, target2, false);
      }
      let geo = edge2.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.points = points2;
        model2.setGeometry(edge2, geo);
      }
    });
    return edge2;
  }
  /**
   * Adds a control point for the given state and event.
   */
  addPoint(state2, evt2) {
    const pt = convertPoint(this.graph.container, getClientX(evt2), getClientY(evt2));
    const gridEnabled = this.graph.isGridEnabledEvent(evt2);
    this.convertPoint(pt, gridEnabled);
    this.addPointAt(state2, pt.x, pt.y);
    InternalEvent_default.consume(evt2);
  }
  /**
   * Adds a control point at the given point.
   */
  addPointAt(state2, x, y) {
    let geo = state2.cell.getGeometry();
    const pt = new Point_default(x, y);
    if (geo != null) {
      geo = geo.clone();
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      let offset = new Point_default(t.x * s, t.y * s);
      const parent2 = this.state.cell.getParent();
      if (parent2 && parent2.isVertex()) {
        const pState = this.graph.view.getState(parent2);
        if (pState)
          offset = new Point_default(pState.x, pState.y);
      }
      const index = findNearestSegment(state2, pt.x * s + offset.x, pt.y * s + offset.y);
      if (geo.points == null) {
        geo.points = [pt];
      } else {
        geo.points.splice(index, 0, pt);
      }
      this.graph.getDataModel().setGeometry(state2.cell, geo);
      this.refresh();
      this.redraw();
    }
  }
  /**
   * Removes the control point at the given index from the given state.
   */
  removePoint(state2, index) {
    if (index > 0 && index < this.abspoints.length - 1) {
      let geo = this.state.cell.getGeometry();
      if (geo != null && geo.points != null) {
        geo = geo.clone();
        (geo.points || []).splice(index - 1, 1);
        this.graph.getDataModel().setGeometry(state2.cell, geo);
        this.refresh();
        this.redraw();
      }
    }
  }
  /**
   * Returns the fillcolor for the handle at the given index.
   */
  getHandleFillColor(index) {
    const isSource = index === 0;
    const { cell: cell2 } = this.state;
    const terminal = cell2.getTerminal(isSource);
    let color = HANDLE_FILLCOLOR;
    if (terminal != null && !this.graph.isCellDisconnectable(cell2, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell2, isSource)) {
      color = LOCKED_HANDLE_FILLCOLOR;
    } else if (terminal != null && this.graph.isCellDisconnectable(cell2, terminal, isSource)) {
      color = CONNECT_HANDLE_FILLCOLOR;
    }
    return color;
  }
  /**
   * Redraws the preview, and the bends- and label control points.
   */
  redraw(ignoreHandles) {
    this.abspoints = this.state.absolutePoints.slice();
    const g = this.state.cell.getGeometry();
    if (g) {
      const pts = g.points;
      if (this.bends != null && this.bends.length > 0) {
        if (pts != null) {
          if (this.points == null) {
            this.points = [];
          }
          for (let i2 = 1; i2 < this.bends.length - 1; i2 += 1) {
            if (this.bends[i2] != null && this.abspoints[i2] != null) {
              this.points[i2 - 1] = pts[i2 - 1];
            }
          }
        }
      }
    }
    this.drawPreview();
    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }
  /**
   * Redraws the handles.
   */
  redrawHandles() {
    const { cell: cell2 } = this.state;
    let b = this.labelShape.bounds;
    this.label = new Point_default(this.state.absoluteOffset.x, this.state.absoluteOffset.y);
    this.labelShape.bounds = new Rectangle_default(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
    const lab = this.graph.getLabel(cell2);
    this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell2);
    if (this.bends != null && this.bends.length > 0) {
      const n = this.abspoints.length - 1;
      const p0 = this.abspoints[0];
      const x0 = p0.x;
      const y0 = p0.y;
      b = this.bends[0].bounds;
      this.bends[0].bounds = new Rectangle_default(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);
      this.bends[0].fill = this.getHandleFillColor(0);
      this.bends[0].redraw();
      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[0].bounds);
      }
      const pe = this.abspoints[n];
      const xn = pe.x;
      const yn = pe.y;
      const bn = this.bends.length - 1;
      b = this.bends[bn].bounds;
      this.bends[bn].bounds = new Rectangle_default(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);
      this.bends[bn].fill = this.getHandleFillColor(bn);
      this.bends[bn].redraw();
      if (this.manageLabelHandle) {
        this.checkLabelHandle(this.bends[bn].bounds);
      }
      this.redrawInnerBends(p0, pe);
    }
    if (this.virtualBends && this.virtualBends.length > 0) {
      let last = this.abspoints[0];
      for (let i2 = 0; i2 < this.virtualBends.length; i2 += 1) {
        if (this.virtualBends[i2] != null && this.abspoints[i2 + 1] != null) {
          const pt = this.abspoints[i2 + 1];
          const b2 = this.virtualBends[i2];
          const x = last.x + (pt.x - last.x) / 2;
          const y = last.y + (pt.y - last.y) / 2;
          if (b2.bounds) {
            b2.bounds = new Rectangle_default(Math.floor(x - b2.bounds.width / 2), Math.floor(y - b2.bounds.height / 2), b2.bounds.width, b2.bounds.height);
            b2.redraw();
          }
          setOpacity(b2.node, this.virtualBendOpacity);
          last = pt;
          if (this.manageLabelHandle) {
            this.checkLabelHandle(b2.bounds);
          }
        }
      }
    }
    this.labelShape.redraw();
    if (this.customHandles) {
      for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
        const shape2 = this.customHandles[i2].shape;
        if (shape2) {
          const temp = shape2.node.style.display;
          this.customHandles[i2].redraw();
          shape2.node.style.display = temp;
          shape2.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i2]) ? "" : "hidden";
        }
      }
    }
  }
  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle) {
    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
  }
  /**
   * Shortcut to <hideSizers>.
   */
  setHandlesVisible(visible) {
    for (let i2 = 0; i2 < this.bends.length; i2 += 1) {
      this.bends[i2].node.style.display = visible ? "" : "none";
    }
    if (this.virtualBends) {
      for (let i2 = 0; i2 < this.virtualBends.length; i2 += 1) {
        this.virtualBends[i2].node.style.display = visible ? "" : "none";
      }
    }
    this.labelShape.node.style.display = visible ? "" : "none";
    if (this.customHandles) {
      for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
        this.customHandles[i2].setVisible(visible);
      }
    }
  }
  /**
   * Updates and redraws the inner bends.
   *
   * @param p0 {@link Point} that represents the location of the first point.
   * @param pe {@link Point} that represents the location of the last point.
   */
  redrawInnerBends(p0, pe) {
    for (let i2 = 1; i2 < this.bends.length - 1; i2 += 1) {
      if (this.bends[i2] != null) {
        if (this.abspoints[i2] != null) {
          const { x } = this.abspoints[i2];
          const { y } = this.abspoints[i2];
          const b = this.bends[i2].bounds;
          this.bends[i2].node.style.visibility = "visible";
          this.bends[i2].bounds = new Rectangle_default(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);
          if (this.manageLabelHandle) {
            this.checkLabelHandle(this.bends[i2].bounds);
          } else if (this.handleImage == null && this.labelShape.visible && intersects2(this.bends[i2].bounds, this.labelShape.bounds)) {
            const w = HANDLE_SIZE + 3;
            const h = HANDLE_SIZE + 3;
            this.bends[i2].bounds = new Rectangle_default(Math.round(x - w / 2), Math.round(y - h / 2), w, h);
          }
          this.bends[i2].redraw();
        } else {
          this.bends[i2].destroy();
        }
      }
    }
  }
  /**
   * Checks if the label handle intersects the given bounds and moves it if it
   * intersects.
   */
  checkLabelHandle(b) {
    const b2 = this.labelShape.bounds;
    if (intersects2(b, b2)) {
      if (b.getCenterY() < b2.getCenterY()) {
        b2.y = b.y + b.height;
      } else {
        b2.y = b.y - b2.height;
      }
    }
  }
  /**
   * Redraws the preview.
   */
  drawPreview() {
    try {
      if (this.isLabel) {
        const b = this.labelShape.bounds;
        const bounds = new Rectangle_default(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);
        if (!b.equals(bounds)) {
          this.labelShape.bounds = bounds;
          this.labelShape.redraw();
        }
      }
      if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {
        this.shape.apply(this.state);
        this.shape.points = this.abspoints.slice();
        this.shape.scale = this.state.view.scale;
        this.shape.isDashed = this.isSelectionDashed();
        this.shape.stroke = this.getSelectionColor();
        this.shape.strokeWidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;
        this.shape.isShadow = false;
        this.shape.redraw();
      }
      this.updateParentHighlight();
    } catch (e) {
    }
  }
  /**
   * Refreshes the bends of this handler.
   */
  refresh() {
    if (this.state != null) {
      this.abspoints = this.getSelectionPoints(this.state);
      this.points = [];
      this.destroyBends(this.bends);
      this.bends = this.createBends();
      if (this.virtualBends) {
        this.destroyBends(this.virtualBends);
        this.virtualBends = this.createVirtualBends();
      }
      if (this.customHandles) {
        this.destroyBends(this.customHandles);
        this.customHandles = this.createCustomHandles();
      }
      if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {
        this.labelShape.node.parentNode.appendChild(this.labelShape.node);
      }
    }
  }
  /**
   * Returns true if <destroy> was called.
   */
  isDestroyed() {
    return this.shape == null;
  }
  /**
   * Destroys all elements in <bends>.
   */
  destroyBends(bends) {
    if (bends != null) {
      for (let i2 = 0; i2 < bends.length; i2 += 1) {
        if (bends[i2] != null) {
          bends[i2].destroy();
        }
      }
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes. This does
   * normally not need to be called as handlers are destroyed automatically
   * when the corresponding cell is deselected.
   */
  onDestroy() {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.marker.destroy();
    this.marker = null;
    this.shape.destroy();
    this.shape = null;
    if (this.parentHighlight) {
      const parent2 = this.state.cell.getParent();
      const pstate = parent2 ? this.graph.view.getState(parent2) : null;
      if (pstate && pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }
      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }
    this.labelShape.destroy();
    this.labelShape = null;
    this.constraintHandler.onDestroy();
    this.constraintHandler = null;
    if (this.virtualBends) {
      this.destroyBends(this.virtualBends);
      this.virtualBends = [];
    }
    if (this.customHandles) {
      this.destroyBends(this.customHandles);
      this.customHandles = [];
    }
    this.destroyBends(this.bends);
    this.bends = [];
    this.removeHint();
  }
};
var EdgeHandlerCellMarker = class extends CellMarker_default {
  constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super(graph, validColor, invalidColor, hotspot);
    this.getCell = (me) => {
      let cell2 = super.getCell(me);
      if ((cell2 === this.edgeHandler.state.cell || !cell2) && this.edgeHandler.currentPoint) {
        cell2 = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);
      }
      if (cell2 && !cell2.isConnectable()) {
        const parent2 = cell2.getParent();
        if (parent2 && parent2.isVertex() && parent2.isConnectable()) {
          cell2 = parent2;
        }
      }
      if (cell2) {
        if (this.graph.isSwimlane(cell2) && this.edgeHandler.currentPoint && this.graph.hitsSwimlaneContent(cell2, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y) || !this.edgeHandler.isConnectableCell(cell2) || cell2 === this.edgeHandler.state.cell || cell2 && !this.edgeHandler.graph.connectableEdges && cell2.isEdge() || this.edgeHandler.state.cell.isAncestor(cell2)) {
          cell2 = null;
        }
      }
      if (cell2 && !cell2.isConnectable()) {
        cell2 = null;
      }
      return cell2;
    };
    this.isValidState = (state2) => {
      const cell2 = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);
      const cellState = this.edgeHandler.graph.view.getState(cell2);
      const other = this.edgeHandler.graph.view.getTerminalPort(state2, cellState, !this.edgeHandler.isSource);
      const otherCell = other ? other.cell : null;
      const source2 = this.edgeHandler.isSource ? state2.cell : otherCell;
      const target2 = this.edgeHandler.isSource ? otherCell : state2.cell;
      this.edgeHandler.error = this.edgeHandler.validateConnection(source2, target2);
      return !this.edgeHandler.error;
    };
    this.edgeHandler = edgeHandler;
  }
};
var EdgeHandler_default = EdgeHandler;

// node_modules/@maxgraph/core/lib/view/geometry/node/EllipseShape.js
var EllipseShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Paints the ellipse shape.
   */
  paintVertexShape(c, x, y, w, h) {
    c.ellipse(x, y, w, h);
    c.fillAndStroke();
  }
};
var EllipseShape_default = EllipseShape;

// node_modules/@maxgraph/core/lib/view/handler/config.js
var VertexHandlerConfig = {
  /**
   * Enable rotation handle
   * @default false
   */
  rotationEnabled: false
};

// node_modules/@maxgraph/core/lib/view/handler/VertexHandler.js
var VertexHandler = class {
  /**
   * Specifies if a rotation handle should be visible.
   *
   * This implementation returns {@link VertexHandlerConfig.rotationEnabled}.
   * @since 0.12.0
   */
  isRotationEnabled() {
    return VertexHandlerConfig.rotationEnabled;
  }
  /**
   * Constructs an event handler that allows to resize vertices and groups.
   *
   * @param state {@link CellState} of the cell to be resized.
   */
  constructor(state2) {
    this.sizers = [];
    this.singleSizer = false;
    this.index = null;
    this.allowHandleBoundsCheck = true;
    this.handleImage = null;
    this.handlesVisible = true;
    this.tolerance = 0;
    this.parentHighlightEnabled = false;
    this.rotationRaster = true;
    this.rotationCursor = "crosshair";
    this.livePreview = false;
    this.movePreviewToFront = false;
    this.manageSizers = false;
    this.constrainGroupByChildren = false;
    this.rotationHandleVSpacing = -16;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    this.minBounds = null;
    this.x0 = 0;
    this.y0 = 0;
    this.customHandles = [];
    this.inTolerance = false;
    this.startX = 0;
    this.startY = 0;
    this.rotationShape = null;
    this.currentAlpha = 100;
    this.startAngle = 0;
    this.startDist = 0;
    this.ghostPreview = null;
    this.livePreviewActive = false;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.parentState = null;
    this.parentHighlight = null;
    this.unscaledBounds = null;
    this.preview = null;
    this.labelShape = null;
    this.edgeHandlers = [];
    this.EMPTY_POINT = new Point_default();
    this.state = state2;
    this.graph = this.state.view.graph;
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle_default(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.selectionBorder = this.createSelectionShape(this.bounds);
    this.selectionBorder.dialect = DIALECT.SVG;
    this.selectionBorder.pointerEvents = false;
    this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    this.selectionBorder.init(this.graph.getView().getOverlayPane());
    InternalEvent_default.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);
    if (this.graph.isCellMovable(this.state.cell)) {
      this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);
    }
    const selectionHandler = this.graph.getPlugin("SelectionHandler");
    if (selectionHandler && (selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells)) {
      const resizable = this.graph.isCellResizable(this.state.cell);
      this.sizers = [];
      if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {
        let i2 = 0;
        if (resizable) {
          if (!this.singleSizer) {
            this.sizers.push(this.createSizer("nw-resize", i2++));
            this.sizers.push(this.createSizer("n-resize", i2++));
            this.sizers.push(this.createSizer("ne-resize", i2++));
            this.sizers.push(this.createSizer("w-resize", i2++));
            this.sizers.push(this.createSizer("e-resize", i2++));
            this.sizers.push(this.createSizer("sw-resize", i2++));
            this.sizers.push(this.createSizer("s-resize", i2++));
          }
          this.sizers.push(this.createSizer("se-resize", i2++));
        }
        const geo = this.state.cell.getGeometry();
        if (geo != null && !geo.relative && //!this.graph.isSwimlane(this.state.cell) &&      disable for now
        this.graph.isLabelMovable(this.state.cell)) {
          this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent_default.LABEL_HANDLE, LABEL_HANDLE_SIZE, LABEL_HANDLE_FILLCOLOR);
          this.sizers.push(this.labelShape);
        }
      } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {
        this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent_default.LABEL_HANDLE, void 0, LABEL_HANDLE_FILLCOLOR);
        this.sizers.push(this.labelShape);
      }
    }
    if (this.isRotationHandleVisible()) {
      this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent_default.ROTATION_HANDLE, HANDLE_SIZE + 3, HANDLE_FILLCOLOR);
      this.sizers.push(this.rotationShape);
    }
    this.customHandles = this.createCustomHandles();
    this.redraw();
    if (this.constrainGroupByChildren) {
      this.updateMinBounds();
    }
    this.escapeHandler = (_sender, _evt) => {
      if (this.livePreview && this.index != null) {
        this.state.view.graph.cellRenderer.redraw(this.state, true);
        this.state.view.invalidate(this.state.cell);
        this.state.invalid = false;
        this.state.view.validate();
      }
      this.reset();
    };
    this.state.view.graph.addListener(InternalEvent_default.ESCAPE, this.escapeHandler);
  }
  /**
   * Returns `true` if the rotation handle should be showing.
   */
  isRotationHandleVisible() {
    const selectionHandler = this.graph.getPlugin("SelectionHandler");
    const selectionHandlerCheck = selectionHandler ? selectionHandler.maxCells <= 0 || this.graph.getSelectionCount() < selectionHandler.maxCells : true;
    return this.graph.isEnabled() && this.isRotationEnabled() && this.graph.isCellRotatable(this.state.cell) && selectionHandlerCheck;
  }
  /**
   * Returns `true` if the aspect ratio if the cell should be maintained.
   */
  isConstrainedEvent(me) {
    return isShiftDown(me.getEvent()) || this.state.style.aspect === "fixed";
  }
  /**
   * Returns `true` if the center of the vertex should be maintained during the resize.
   */
  isCenteredEvent(state2, me) {
    return false;
  }
  /**
   * Returns an array of custom handles.
   *
   * This implementation returns an empty array.
   */
  createCustomHandles() {
    return [];
  }
  /**
   * Initializes the shapes required for this vertex handler.
   */
  updateMinBounds() {
    const children = this.graph.getChildCells(this.state.cell);
    if (children.length > 0) {
      this.minBounds = this.graph.view.getBounds(children);
      if (this.minBounds) {
        const s = this.state.view.scale;
        const t = this.state.view.translate;
        this.minBounds.x -= this.state.x;
        this.minBounds.y -= this.state.y;
        this.minBounds.x /= s;
        this.minBounds.y /= s;
        this.minBounds.width /= s;
        this.minBounds.height /= s;
        this.x0 = this.state.x / s - t.x;
        this.y0 = this.state.y / s - t.y;
      }
    }
  }
  /**
   * Returns the Rectangle that defines the bounds of the selection border.
   */
  getSelectionBounds(state2) {
    return new Rectangle_default(Math.round(state2.x), Math.round(state2.y), Math.round(state2.width), Math.round(state2.height));
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createParentHighlightShape(bounds) {
    return this.createSelectionShape(bounds);
  }
  /**
   * Creates the shape used to draw the selection border.
   */
  createSelectionShape(bounds) {
    const shape2 = new RectangleShape_default(Rectangle_default.fromRectangle(bounds), NONE, this.getSelectionColor());
    shape2.strokeWidth = this.getSelectionStrokeWidth();
    shape2.isDashed = this.isSelectionDashed();
    return shape2;
  }
  /**
   * Returns {@link VERTEX_SELECTION_COLOR}.
   */
  getSelectionColor() {
    return VERTEX_SELECTION_COLOR;
  }
  /**
   * Returns {@link VERTEX_SELECTION_STROKEWIDTH}.
   */
  getSelectionStrokeWidth() {
    return VERTEX_SELECTION_STROKEWIDTH;
  }
  /**
   * Returns {@link VERTEX_SELECTION_DASHED}.
   */
  isSelectionDashed() {
    return VERTEX_SELECTION_DASHED;
  }
  /**
   * Creates a sizer handle for the specified cursor and index and returns
   * the new {@link RectangleShape} that represents the handle.
   */
  createSizer(cursor, index, size = HANDLE_SIZE, fillColor = HANDLE_FILLCOLOR) {
    const bounds = new Rectangle_default(0, 0, size, size);
    const sizer = this.createSizerShape(bounds, index, fillColor);
    if (sizer.bounds && sizer.isHtmlAllowed() && this.state.text && this.state.text.node.parentNode === this.graph.container) {
      sizer.bounds.height -= 1;
      sizer.bounds.width -= 1;
      sizer.dialect = DIALECT.STRICTHTML;
      sizer.init(this.graph.container);
    } else {
      sizer.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      sizer.init(this.graph.getView().getOverlayPane());
    }
    InternalEvent_default.redirectMouseEvents(sizer.node, this.graph, this.state);
    if (this.graph.isEnabled()) {
      sizer.setCursor(cursor);
    }
    if (!this.isSizerVisible(index)) {
      sizer.visible = false;
    }
    return sizer;
  }
  /**
   * Returns `true` if the sizer for the given index is visible.
   *
   * This implementation returns `true` for all given indices.
   */
  isSizerVisible(_index) {
    return true;
  }
  /**
   * Creates the shape used for the sizer handle for the specified bounds an
   * index. Only images and rectangles should be returned if support for HTML
   * labels with not foreign objects is required.
   */
  createSizerShape(bounds, index, fillColor = HANDLE_FILLCOLOR) {
    if (this.handleImage) {
      bounds = new Rectangle_default(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);
      const shape2 = new ImageShape_default(bounds, this.handleImage.src);
      shape2.preserveImageAspect = false;
      return shape2;
    }
    if (index === InternalEvent_default.ROTATION_HANDLE) {
      return new EllipseShape_default(bounds, fillColor, HANDLE_STROKECOLOR);
    }
    return new RectangleShape_default(bounds, fillColor, HANDLE_STROKECOLOR);
  }
  /**
   * Helper method to create an {@link Rectangle} around the given center point
   * with a width and height of 2*s or 6, if no s is given.
   */
  moveSizerTo(shape2, x, y) {
    if (shape2 && shape2.bounds) {
      shape2.bounds.x = Math.floor(x - shape2.bounds.width / 2);
      shape2.bounds.y = Math.floor(y - shape2.bounds.height / 2);
      if (shape2.node && shape2.node.style.display !== "none") {
        shape2.redraw();
      }
    }
  }
  /**
   * Returns the index of the handle for the given event. This returns the index
   * of the sizer from where the event originated or {@link InternalEvent.LABEL_HANDLE}.
   */
  getHandleForEvent(me) {
    const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;
    const hit = this.allowHandleBoundsCheck && tol > 0 ? new Rectangle_default(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
    const checkShape = (shape2) => {
      const st = shape2 && shape2.constructor !== ImageShape_default && this.allowHandleBoundsCheck ? shape2.strokeWidth + shape2.svgStrokeTolerance : null;
      const real = st ? new Rectangle_default(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st) : hit;
      return shape2 && shape2.bounds && (me.isSource(shape2) || real && intersects2(shape2.bounds, real) && shape2.node.style.display !== "none" && shape2.node.style.visibility !== "hidden");
    };
    if (checkShape(this.rotationShape)) {
      return InternalEvent_default.ROTATION_HANDLE;
    }
    if (checkShape(this.labelShape)) {
      return InternalEvent_default.LABEL_HANDLE;
    }
    for (let i2 = 0; i2 < this.sizers.length; i2 += 1) {
      if (checkShape(this.sizers[i2])) {
        return i2;
      }
    }
    if (this.customHandles != null && this.isCustomHandleEvent(me)) {
      for (let i2 = this.customHandles.length - 1; i2 >= 0; i2--) {
        if (checkShape(this.customHandles[i2].shape)) {
          return InternalEvent_default.CUSTOM_HANDLE - i2;
        }
      }
    }
    return null;
  }
  /**
   * Returns `true` if the given event allows custom handles to be changed.
   *
   * This implementation returns `true`.
   */
  isCustomHandleEvent(me) {
    return true;
  }
  /**
   * Handles the event if a handle has been clicked. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.graph.isEnabled()) {
      const handle = this.getHandleForEvent(me);
      if (handle) {
        this.start(me.getGraphX(), me.getGraphY(), handle);
        me.consume();
      }
    }
  }
  /**
   * Called if {@link livePreview} is enabled to check if a border should be painted.
   *
   * This implementation returns `true` if the shape is transparent.
   */
  isLivePreviewBorder() {
    return this.state.shape && this.state.shape.fill === NONE && this.state.shape.stroke === NONE;
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(x, y, index) {
    this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;
    this.inTolerance = true;
    this.childOffsetX = 0;
    this.childOffsetY = 0;
    this.index = index;
    this.startX = x;
    this.startY = y;
    if (this.index <= InternalEvent_default.CUSTOM_HANDLE && this.isGhostPreview()) {
      this.ghostPreview = this.createGhostPreview();
    } else {
      const { model: model2 } = this.state.view.graph;
      const parent2 = this.state.cell.getParent();
      if (this.state.view.currentRoot !== parent2 && parent2 && (parent2.isVertex() || parent2.isEdge())) {
        this.parentState = this.state.view.graph.view.getState(parent2);
      }
      this.selectionBorder.node.style.display = index === InternalEvent_default.ROTATION_HANDLE ? "inline" : "none";
      if (!this.livePreviewActive || this.isLivePreviewBorder()) {
        this.preview = this.createSelectionShape(this.bounds);
        if (!(Client_default.IS_SVG && Number(this.state.style.rotation || "0") !== 0) && this.state.text != null && this.state.text.node.parentNode === this.graph.container) {
          this.preview.dialect = DIALECT.STRICTHTML;
          this.preview.init(this.graph.container);
        } else {
          this.preview.dialect = DIALECT.SVG;
          this.preview.init(this.graph.view.getOverlayPane());
        }
      }
      if (index === InternalEvent_default.ROTATION_HANDLE) {
        const pos = this.getRotationHandlePosition();
        const dx = pos.x - this.state.getCenterX();
        const dy = pos.y - this.state.getCenterY();
        this.startAngle = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : 0;
        this.startDist = Math.sqrt(dx * dx + dy * dy);
      }
      if (this.livePreviewActive) {
        this.hideSizers();
        if (index === InternalEvent_default.ROTATION_HANDLE && this.rotationShape) {
          this.rotationShape.node.style.display = "";
        } else if (index === InternalEvent_default.LABEL_HANDLE && this.labelShape) {
          this.labelShape.node.style.display = "";
        } else if (this.sizers[index]) {
          this.sizers[index].node.style.display = "";
        } else if (index <= InternalEvent_default.CUSTOM_HANDLE) {
          this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index].setVisible(true);
        }
        const edges = this.state.cell.getEdges();
        this.edgeHandlers = [];
        const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
        for (let i2 = 0; i2 < edges.length; i2 += 1) {
          const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(edges[i2]);
          if (handler) {
            this.edgeHandlers.push(handler);
          }
        }
      }
    }
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  createGhostPreview() {
    const shape2 = this.graph.cellRenderer.createShape(this.state);
    shape2.init(this.graph.view.getOverlayPane());
    shape2.scale = this.state.view.scale;
    shape2.bounds = this.bounds;
    shape2.outline = true;
    return shape2;
  }
  /**
   * Shortcut to {@link hideSizers}.
   */
  setHandlesVisible(visible) {
    this.handlesVisible = visible;
    for (let i2 = 0; i2 < this.sizers.length; i2 += 1) {
      this.sizers[i2].node.style.display = visible ? "" : "none";
    }
    for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
      this.customHandles[i2].setVisible(visible);
    }
  }
  /**
   * Hides all sizers except.
   *
   * Starts the handling of the mouse gesture.
   */
  hideSizers() {
    this.setHandlesVisible(false);
  }
  /**
   * Checks if the coordinates for the given event are within the
   * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is
   * ignored.
   */
  checkTolerance(me) {
    if (this.inTolerance && this.startX !== null && this.startY !== null) {
      if (isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {
        this.inTolerance = false;
      }
    }
  }
  /**
   * Hook for subclasses do show details while the handler is active.
   */
  updateHint(me) {
    return;
  }
  /**
   * Hooks for subclasses to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the angle. This uses {@link Math.round}.
   */
  roundAngle(angle) {
    return Math.round(angle * 10) / 10;
  }
  /**
   * Hook for rounding the unscaled width or height. This uses {@link Math.round}.
   */
  roundLength(length) {
    return Math.round(length * 100) / 100;
  }
  /**
   * Handles the event by updating the preview.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && this.index != null) {
      this.checkTolerance(me);
      if (!this.inTolerance) {
        if (this.index <= InternalEvent_default.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            this.customHandles[InternalEvent_default.CUSTOM_HANDLE - this.index].processEvent(me);
            this.customHandles[InternalEvent_default.CUSTOM_HANDLE - this.index].active = true;
            if (this.ghostPreview != null) {
              this.ghostPreview.apply(this.state);
              this.ghostPreview.strokeWidth = this.getSelectionStrokeWidth() / this.ghostPreview.scale / this.ghostPreview.scale;
              this.ghostPreview.isDashed = this.isSelectionDashed();
              this.ghostPreview.stroke = this.getSelectionColor();
              this.ghostPreview.redraw();
              if (this.selectionBounds != null) {
                this.selectionBorder.node.style.display = "none";
              }
            } else {
              if (this.movePreviewToFront) {
                this.moveToFront();
              }
              this.customHandles[InternalEvent_default.CUSTOM_HANDLE - this.index].positionChanged();
            }
          }
        } else if (this.index === InternalEvent_default.LABEL_HANDLE) {
          this.moveLabel(me);
        } else {
          if (this.index === InternalEvent_default.ROTATION_HANDLE) {
            this.rotateVertex(me);
          } else {
            this.resizeVertex(me);
          }
          this.updateHint(me);
        }
      }
      me.consume();
    } else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {
      me.consume(false);
    }
  }
  /**
   * Returns `true` if a ghost preview should be used for custom handles.
   */
  isGhostPreview() {
    return this.state.cell.getChildCount() > 0;
  }
  /**
   * Moves the vertex.
   */
  moveLabel(me) {
    const point = new Point_default(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;
    if (this.graph.isGridEnabledEvent(me.getEvent())) {
      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;
      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;
    }
    const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;
    this.moveSizerTo(this.sizers[index], point.x, point.y);
  }
  /**
   * Rotates the vertex.
   */
  rotateVertex(me) {
    const point = new Point_default(me.getGraphX(), me.getGraphY());
    let dx = this.state.x + this.state.width / 2 - point.x;
    let dy = this.state.y + this.state.height / 2 - point.y;
    this.currentAlpha = dx !== 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;
    if (dx > 0) {
      this.currentAlpha -= 180;
    }
    this.currentAlpha -= this.startAngle;
    if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {
      let raster;
      dx = point.x - this.state.getCenterX();
      dy = point.y - this.state.getCenterY();
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist - this.startDist < 2) {
        raster = 15;
      } else if (dist - this.startDist < 25) {
        raster = 5;
      } else {
        raster = 1;
      }
      this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;
    } else {
      this.currentAlpha = this.roundAngle(this.currentAlpha);
    }
    this.selectionBorder.rotation = this.currentAlpha;
    this.selectionBorder.redraw();
    if (this.livePreviewActive) {
      this.redrawHandles();
    }
  }
  /**
   * Resizes the vertex.
   */
  resizeVertex(me) {
    const ct = new Point_default(this.state.getCenterX(), this.state.getCenterY());
    const alpha = toRadians(this.state.style.rotation ?? 0);
    const point = new Point_default(me.getGraphX(), me.getGraphY());
    const tr = this.graph.view.translate;
    const { scale } = this.graph.view;
    let cos = Math.cos(-alpha);
    let sin = Math.sin(-alpha);
    let dx = point.x - this.startX;
    let dy = point.y - this.startY;
    const tx = cos * dx - sin * dy;
    const ty = sin * dx + cos * dy;
    dx = tx;
    dy = ty;
    const geo = this.state.cell.getGeometry();
    if (geo && this.index !== null) {
      this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point_default(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));
    }
    if (geo && !geo.relative) {
      let max = this.graph.getMaximumGraphBounds();
      if (max != null && this.parentState != null) {
        max = Rectangle_default.fromRectangle(max);
        max.x -= (this.parentState.x - tr.x * scale) / scale;
        max.y -= (this.parentState.y - tr.y * scale) / scale;
      }
      if (this.graph.isConstrainChild(this.state.cell)) {
        let tmp2 = this.graph.getCellContainmentArea(this.state.cell);
        if (tmp2 != null) {
          const overlap = this.graph.getOverlap(this.state.cell);
          if (overlap > 0) {
            tmp2 = Rectangle_default.fromRectangle(tmp2);
            tmp2.x -= tmp2.width * overlap;
            tmp2.y -= tmp2.height * overlap;
            tmp2.width += 2 * tmp2.width * overlap;
            tmp2.height += 2 * tmp2.height * overlap;
          }
          if (!max) {
            max = tmp2;
          } else {
            max = Rectangle_default.fromRectangle(max);
            max.intersect(tmp2);
          }
        }
      }
      if (max && this.unscaledBounds) {
        if (this.unscaledBounds.x < max.x) {
          this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
          this.unscaledBounds.x = max.x;
        }
        if (this.unscaledBounds.y < max.y) {
          this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
          this.unscaledBounds.y = max.y;
        }
        if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {
          this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;
        }
        if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {
          this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;
        }
      }
    }
    if (this.unscaledBounds) {
      const old = this.bounds;
      this.bounds = new Rectangle_default((this.parentState ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);
      if (geo && geo.relative && this.parentState) {
        this.bounds.x += this.state.x - this.parentState.x;
        this.bounds.y += this.state.y - this.parentState.y;
      }
      cos = Math.cos(alpha);
      sin = Math.sin(alpha);
      const c2 = new Point_default(this.bounds.getCenterX(), this.bounds.getCenterY());
      dx = c2.x - ct.x;
      dy = c2.y - ct.y;
      const dx2 = cos * dx - sin * dy;
      const dy2 = sin * dx + cos * dy;
      const dx3 = dx2 - dx;
      const dy3 = dy2 - dy;
      const dx4 = this.bounds.x - this.state.x;
      const dy4 = this.bounds.y - this.state.y;
      const dx5 = cos * dx4 - sin * dy4;
      const dy5 = sin * dx4 + cos * dy4;
      this.bounds.x += dx3;
      this.bounds.y += dy3;
      this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
      this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
      this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
      this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);
      if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {
        this.childOffsetX = this.state.x - this.bounds.x + dx5;
        this.childOffsetY = this.state.y - this.bounds.y + dy5;
      } else {
        this.childOffsetX = 0;
        this.childOffsetY = 0;
      }
      if (!old.equals(this.bounds)) {
        if (this.livePreviewActive) {
          this.updateLivePreview(me);
        }
        if (this.preview != null) {
          this.drawPreview();
        } else {
          this.updateParentHighlight();
        }
      }
    }
  }
  /**
   * Repaints the live preview.
   */
  updateLivePreview(me) {
    const { scale } = this.graph.view;
    const tr = this.graph.view.translate;
    const tempState = this.state.clone();
    this.state.x = this.bounds.x;
    this.state.y = this.bounds.y;
    this.state.origin = new Point_default(this.state.x / scale - tr.x, this.state.y / scale - tr.y);
    this.state.width = this.bounds.width;
    this.state.height = this.bounds.height;
    let off = this.state.absoluteOffset;
    off = new Point_default(off.x, off.y);
    this.state.absoluteOffset.x = 0;
    this.state.absoluteOffset.y = 0;
    const geo = this.state.cell.getGeometry();
    if (geo != null) {
      const offset = geo.offset || this.EMPTY_POINT;
      if (offset != null && !geo.relative) {
        this.state.absoluteOffset.x = this.state.view.scale * offset.x;
        this.state.absoluteOffset.y = this.state.view.scale * offset.y;
      }
      this.state.view.updateVertexLabelOffset(this.state);
    }
    this.state.view.graph.cellRenderer.redraw(this.state, true);
    this.state.view.invalidate(this.state.cell);
    this.state.invalid = false;
    this.state.view.validate();
    this.redrawHandles();
    if (this.movePreviewToFront) {
      this.moveToFront();
    }
    if (this.state.control != null && this.state.control.node != null) {
      this.state.control.node.style.visibility = "hidden";
    }
    this.state.setState(tempState);
  }
  /**
   * Handles the event by applying the changes to the geometry.
   */
  moveToFront() {
    if (this.state.text && this.state.text.node && this.state.text.node.nextSibling || this.state.shape && this.state.shape.node && this.state.shape.node.nextSibling && (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node)) {
      if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {
        this.state.shape.node.parentNode.appendChild(this.state.shape.node);
      }
      if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {
        this.state.text.node.parentNode.appendChild(this.state.text.node);
      }
    }
  }
  /**
   * Handles the event by applying the changes to the geometry.
   */
  mouseUp(sender, me) {
    if (this.index != null && this.state != null) {
      const point = new Point_default(me.getGraphX(), me.getGraphY());
      const { index } = this;
      this.index = null;
      if (this.ghostPreview == null) {
        this.state.view.invalidate(this.state.cell, false, false);
        this.state.view.validate();
      }
      this.graph.batchUpdate(() => {
        if (index <= InternalEvent_default.CUSTOM_HANDLE) {
          if (this.customHandles != null) {
            const style2 = this.state.view.graph.getCellStyle(this.state.cell);
            this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index].active = false;
            this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index].execute(me);
            if (this.customHandles != null && this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index] != null) {
              this.state.style = style2;
              this.customHandles[InternalEvent_default.CUSTOM_HANDLE - index].positionChanged();
            }
          }
        } else if (index === InternalEvent_default.ROTATION_HANDLE) {
          if (this.currentAlpha != null) {
            const delta = this.currentAlpha - (this.state.style.rotation ?? 0);
            if (delta !== 0) {
              this.rotateCell(this.state.cell, delta);
            }
          } else {
            this.rotateClick();
          }
        } else {
          const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());
          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(-alpha);
          const sin = Math.sin(-alpha);
          let dx = point.x - this.startX;
          let dy = point.y - this.startY;
          const tx = cos * dx - sin * dy;
          const ty = sin * dx + cos * dy;
          dx = tx;
          dy = ty;
          const s = this.graph.view.scale;
          const recurse = this.isRecursiveResize(this.state, me);
          this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);
        }
      });
      me.consume();
      this.reset();
      this.redrawHandles();
    }
  }
  /**
   * Returns the `recursiveResize` status of the given state.
   * @param state the given {@link CellState}. This implementation takes the value of this state.
   * @param me the mouse event.
   */
  isRecursiveResize(state2, me) {
    return this.graph.isRecursiveResize(this.state);
  }
  /**
   * Hook for subclasses to implement a single click on the rotation handle.
   * This code is executed as part of the model transaction.
   *
   * This implementation is empty.
   */
  rotateClick() {
    return;
  }
  /**
   * Rotates the given cell and its children by the given angle in degrees.
   *
   * @param cell {@link Cell} to be rotated.
   * @param angle Angle in degrees.
   * @param parent if set, consider the parent in the rotation computation.
   */
  rotateCell(cell2, angle, parent2) {
    if (angle !== 0) {
      const model2 = this.graph.getDataModel();
      if (cell2.isVertex() || cell2.isEdge()) {
        if (!cell2.isEdge()) {
          const style2 = this.graph.getCurrentCellStyle(cell2);
          const total = (style2.rotation || 0) + angle;
          this.graph.setCellStyles("rotation", total, [cell2]);
        }
        let geo = cell2.getGeometry();
        if (geo && parent2) {
          const pgeo = parent2.getGeometry();
          if (pgeo != null && !parent2.isEdge()) {
            geo = geo.clone();
            geo.rotate(angle, new Point_default(pgeo.width / 2, pgeo.height / 2));
            model2.setGeometry(cell2, geo);
          }
          if (cell2.isVertex() && !geo.relative || cell2.isEdge()) {
            const childCount2 = cell2.getChildCount();
            for (let i2 = 0; i2 < childCount2; i2 += 1) {
              this.rotateCell(cell2.getChildAt(i2), angle, cell2);
            }
          }
        }
      }
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.index !== null && this.sizers[this.index].node.style.display === "none") {
      this.sizers[this.index].node.style.display = "";
    }
    this.index = null;
    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }
    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }
    if (this.livePreviewActive) {
      for (let i2 = 0; i2 < this.sizers.length; i2 += 1) {
        this.sizers[i2].node.style.display = "";
      }
      if (this.state.control && this.state.control.node) {
        this.state.control.node.style.visibility = "";
      }
    }
    for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
      if (this.customHandles[i2].active) {
        this.customHandles[i2].active = false;
        this.customHandles[i2].reset();
      } else {
        this.customHandles[i2].setVisible(true);
      }
    }
    this.selectionBorder.node.style.display = "inline";
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle_default(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
    this.removeHint();
    this.redrawHandles();
    this.edgeHandlers = [];
    this.handlesVisible = true;
    this.unscaledBounds = null;
  }
  /**
   * Uses the given vector to change the bounds of the given cell
   * in the graph using {@link Graph#resizeCell}.
   */
  resizeCell(cell2, dx, dy, index, gridEnabled, constrained, recurse) {
    let geo = cell2.getGeometry();
    if (geo) {
      if (index === InternalEvent_default.LABEL_HANDLE && this.labelShape && this.labelShape.bounds) {
        const alpha = -toRadians(this.state.style.rotation ?? 0);
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const { scale } = this.graph.view;
        const pt = getRotatedPoint(new Point_default(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);
        geo = geo.clone();
        if (geo.offset == null) {
          geo.offset = pt;
        } else {
          geo.offset.x += pt.x;
          geo.offset.y += pt.y;
        }
        this.graph.model.setGeometry(cell2, geo);
      } else if (this.unscaledBounds) {
        const { scale } = this.graph.view;
        if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {
          this.moveChildren(cell2, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));
        }
        this.graph.resizeCell(cell2, this.unscaledBounds, recurse);
      }
    }
  }
  /**
   * Moves the children of the given cell by the given vector.
   */
  moveChildren(cell2, dx, dy) {
    const model2 = this.graph.getDataModel();
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      let geo = child2.getGeometry();
      if (geo != null) {
        geo = geo.clone();
        geo.translate(dx, dy);
        model2.setGeometry(child2, geo);
      }
    }
  }
  /**
   * Returns the union of the given bounds and location for the specified
   * handle index.
   *
   * To override this to limit the size of vertex via a minWidth/-Height style,
   * the following code can be used.
   *
   * ```javascript
   * let vertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = vertexHandlerUnion.apply(this, arguments);
   *
   *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));
   *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));
   *
   *   return result;
   * };
   * ```
   *
   * The minWidth/-Height style can then be used as follows:
   *
   * ```javascript
   * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');
   * ```
   *
   * To override this to update the height for a wrapped text if the width of a vertex is
   * changed, the following can be used.
   *
   * ```javascript
   * let mxVertexHandlerUnion = union;
   * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>
   * {
   *   let result = mxVertexHandlerUnion.apply(this, arguments);
   *   let s = this.state;
   *
   *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&
   *       s.text != null && s.style.whiteSpace == 'wrap')
   *   {
   *     let label = this.graph.getLabel(s.cell);
   *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);
   *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft
   *
   *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;
   *   }
   *
   *   return result;
   * };
   * ```
   */
  union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {
    gridEnabled = gridEnabled && this.graph.isGridEnabled();
    if (this.singleSizer) {
      let x = bounds.x + bounds.width + dx;
      let y = bounds.y + bounds.height + dy;
      if (gridEnabled) {
        x = this.graph.snap(x / scale) * scale;
        y = this.graph.snap(y / scale) * scale;
      }
      const rect = new Rectangle_default(bounds.x, bounds.y, 0, 0);
      rect.add(new Rectangle_default(x, y, 0, 0));
      return rect;
    }
    const w0 = bounds.width;
    const h0 = bounds.height;
    let left = bounds.x - tr.x * scale;
    let right = left + w0;
    let top = bounds.y - tr.y * scale;
    let bottom = top + h0;
    const cx = left + w0 / 2;
    const cy = top + h0 / 2;
    if (index > 4) {
      bottom += dy;
      if (gridEnabled) {
        bottom = this.graph.snap(bottom / scale) * scale;
      } else {
        bottom = Math.round(bottom / scale) * scale;
      }
    } else if (index < 3) {
      top += dy;
      if (gridEnabled) {
        top = this.graph.snap(top / scale) * scale;
      } else {
        top = Math.round(top / scale) * scale;
      }
    }
    if (index === 0 || index === 3 || index === 5) {
      left += dx;
      if (gridEnabled) {
        left = this.graph.snap(left / scale) * scale;
      } else {
        left = Math.round(left / scale) * scale;
      }
    } else if (index === 2 || index === 4 || index === 7) {
      right += dx;
      if (gridEnabled) {
        right = this.graph.snap(right / scale) * scale;
      } else {
        right = Math.round(right / scale) * scale;
      }
    }
    let width = right - left;
    let height = bottom - top;
    if (constrained) {
      const geo = this.state.cell.getGeometry();
      if (geo != null) {
        const aspect = geo.width / geo.height;
        if (index === 1 || index === 2 || index === 7 || index === 6) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }
        if (index === 0) {
          left = right - width;
          top = bottom - height;
        }
      }
    }
    if (centered) {
      width += width - w0;
      height += height - h0;
      const cdx = cx - (left + width / 2);
      const cdy = cy - (top + height / 2);
      left += cdx;
      top += cdy;
      right += cdx;
      bottom += cdy;
    }
    if (width < 0) {
      left += width;
      width = Math.abs(width);
    }
    if (height < 0) {
      top += height;
      height = Math.abs(height);
    }
    const result2 = new Rectangle_default(left + tr.x * scale, top + tr.y * scale, width, height);
    if (this.minBounds != null) {
      result2.width = Math.max(result2.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result2.x));
      result2.height = Math.max(result2.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result2.y));
    }
    return result2;
  }
  /**
   * Redraws the handles and the preview.
   */
  redraw(ignoreHandles) {
    this.selectionBounds = this.getSelectionBounds(this.state);
    this.bounds = new Rectangle_default(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);
    this.drawPreview();
    if (!ignoreHandles) {
      this.redrawHandles();
    }
  }
  /**
   * Returns the padding to be used for drawing handles for the current <bounds>.
   */
  getHandlePadding() {
    const result2 = new Point_default(0, 0);
    let tol = this.tolerance;
    if (this.sizers.length > 0 && this.sizers[0].bounds && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
      tol /= 2;
      result2.x = this.sizers[0].bounds.width + tol;
      result2.y = this.sizers[0].bounds.height + tol;
    }
    return result2;
  }
  /**
   * Returns the bounds used to paint the resize handles.
   */
  getSizerBounds() {
    return this.bounds;
  }
  /**
   * Redraws the handles. To hide certain handles the following code can be used.
   *
   * ```javascript
   * redrawHandles()
   * {
   *   mxVertexHandlerRedrawHandles.apply(this, arguments);
   *
   *   if (this.sizers != null && this.sizers.length > 7)
   *   {
   *     this.sizers[1].node.style.display = 'none';
   *     this.sizers[6].node.style.display = 'none';
   *   }
   * };
   * ```
   */
  redrawHandles() {
    let s = this.getSizerBounds();
    const tol = this.tolerance;
    this.horizontalOffset = 0;
    this.verticalOffset = 0;
    for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
      const shape2 = this.customHandles[i2].shape;
      if (shape2) {
        const temp = shape2.node.style.display;
        this.customHandles[i2].redraw();
        shape2.node.style.display = temp;
        shape2.node.style.visibility = this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i2]) ? "" : "hidden";
      }
    }
    if (this.sizers.length > 0 && this.sizers[0]) {
      if (this.index === null && this.manageSizers && this.sizers.length >= 8) {
        const padding = this.getHandlePadding();
        this.horizontalOffset = padding.x;
        this.verticalOffset = padding.y;
        if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {
          s = new Rectangle_default(s.x, s.y, s.width, s.height);
          s.x -= this.horizontalOffset / 2;
          s.width += this.horizontalOffset;
          s.y -= this.verticalOffset / 2;
          s.height += this.verticalOffset;
        }
        if (this.sizers.length >= 8) {
          if (this.sizers[0].bounds && (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {
            this.sizers[0].node.style.display = "none";
            this.sizers[2].node.style.display = "none";
            this.sizers[5].node.style.display = "none";
            this.sizers[7].node.style.display = "none";
          } else if (this.handlesVisible) {
            this.sizers[0].node.style.display = "";
            this.sizers[2].node.style.display = "";
            this.sizers[5].node.style.display = "";
            this.sizers[7].node.style.display = "";
          }
        }
      }
      const r = s.x + s.width;
      const b = s.y + s.height;
      if (this.singleSizer) {
        this.moveSizerTo(this.sizers[0], r, b);
      } else {
        const cx = s.x + s.width / 2;
        const cy = s.y + s.height / 2;
        if (this.sizers.length >= 8) {
          const crs = [
            "nw-resize",
            "n-resize",
            "ne-resize",
            "e-resize",
            "se-resize",
            "s-resize",
            "sw-resize",
            "w-resize"
          ];
          const alpha = toRadians(this.state.style.rotation ?? 0);
          const cos = Math.cos(alpha);
          const sin = Math.sin(alpha);
          const da = Math.round(alpha * 4 / Math.PI);
          const ct = new Point_default(s.getCenterX(), s.getCenterY());
          let pt = getRotatedPoint(new Point_default(s.x, s.y), cos, sin, ct);
          this.moveSizerTo(this.sizers[0], pt.x, pt.y);
          this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);
          pt.x = cx;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[1], pt.x, pt.y);
          this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);
          pt.x = r;
          pt.y = s.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[2], pt.x, pt.y);
          this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);
          pt.x = s.x;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[3], pt.x, pt.y);
          this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);
          pt.x = r;
          pt.y = cy;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[4], pt.x, pt.y);
          this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);
          pt.x = s.x;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[5], pt.x, pt.y);
          this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);
          pt.x = cx;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[6], pt.x, pt.y);
          this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);
          pt.x = r;
          pt.y = b;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[7], pt.x, pt.y);
          this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);
          pt.x = cx + this.state.absoluteOffset.x;
          pt.y = cy + this.state.absoluteOffset.y;
          pt = getRotatedPoint(pt, cos, sin, ct);
          this.moveSizerTo(this.sizers[8], pt.x, pt.y);
        } else if (this.state.width >= 2 && this.state.height >= 2) {
          this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);
        } else {
          this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);
        }
      }
    }
    if (this.rotationShape) {
      const alpha = toRadians(this.currentAlpha);
      const cos = Math.cos(alpha);
      const sin = Math.sin(alpha);
      const ct = new Point_default(this.state.getCenterX(), this.state.getCenterY());
      const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);
      if (this.rotationShape.node != null) {
        this.moveSizerTo(this.rotationShape, pt.x, pt.y);
        this.rotationShape.node.style.visibility = this.state.view.graph.isEditing() || !this.handlesVisible ? "hidden" : "";
      }
    }
    if (this.selectionBorder != null) {
      this.selectionBorder.rotation = this.state.style.rotation ?? 0;
    }
    if (this.edgeHandlers != null) {
      for (let i2 = 0; i2 < this.edgeHandlers.length; i2 += 1) {
        this.edgeHandlers[i2].redraw();
      }
    }
  }
  /**
   * Returns true if the given custom handle is visible.
   */
  isCustomHandleVisible(handle) {
    return !this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1;
  }
  /**
   * Returns an {@link Point} that defines the rotation handle position.
   */
  getRotationHandlePosition() {
    return new Point_default(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);
  }
  /**
   * Returns `true` if the parent highlight should be visible.
   *
   * This implementation always returns `true`.
   */
  isParentHighlightVisible() {
    const parent2 = this.state.cell.getParent();
    return parent2 ? !this.graph.isCellSelected(parent2) : false;
  }
  /**
   * Updates the highlight of the parent if {@link parentHighlightEnabled} is `true`.
   */
  updateParentHighlight() {
    if (!this.isDestroyed()) {
      const visible = this.isParentHighlightVisible();
      const parent2 = this.state.cell.getParent();
      const pstate = parent2 ? this.graph.view.getState(parent2) : null;
      if (this.parentHighlight) {
        if (parent2 && parent2.isVertex() && visible) {
          const b = this.parentHighlight.bounds;
          if (pstate && b && (b.x !== pstate.x || b.y !== pstate.y || b.width !== pstate.width || b.height !== pstate.height)) {
            this.parentHighlight.bounds = Rectangle_default.fromRectangle(pstate);
            this.parentHighlight.redraw();
          }
        } else {
          if (pstate != null && pstate.parentHighlight === this.parentHighlight) {
            pstate.parentHighlight = null;
          }
          this.parentHighlight.destroy();
          this.parentHighlight = null;
        }
      } else if (this.parentHighlightEnabled && visible) {
        if (parent2 && parent2.isVertex() && pstate != null && pstate.parentHighlight == null) {
          this.parentHighlight = this.createParentHighlightShape(pstate);
          this.parentHighlight.dialect = DIALECT.SVG;
          this.parentHighlight.pointerEvents = false;
          this.parentHighlight.rotation = pstate.style.rotation ?? 0;
          this.parentHighlight.init(this.graph.getView().getOverlayPane());
          this.parentHighlight.redraw();
          pstate.parentHighlight = this.parentHighlight;
        }
      }
    }
  }
  /**
   * Redraws the preview.
   */
  drawPreview() {
    if (this.preview != null) {
      this.preview.bounds = this.bounds;
      if (this.preview.node.parentNode === this.graph.container) {
        this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);
        this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);
      }
      this.preview.rotation = this.state.style.rotation ?? 0;
      this.preview.redraw();
    }
    this.selectionBorder.bounds = this.getSelectionBorderBounds();
    this.selectionBorder.redraw();
    this.updateParentHighlight();
  }
  /**
   * Returns the bounds for the selection border.
   */
  getSelectionBorderBounds() {
    return this.bounds;
  }
  /**
   * Returns `true` if this handler was destroyed or not initialized.
   */
  isDestroyed() {
    return this.selectionBorder == null;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.state.view.graph.removeListener(this.escapeHandler);
    this.escapeHandler = () => {
      return;
    };
    if (this.preview) {
      this.preview.destroy();
      this.preview = null;
    }
    if (this.parentHighlight) {
      const parent2 = this.state.cell.getParent();
      const pstate = parent2 ? this.graph.view.getState(parent2) : null;
      if (pstate && pstate.parentHighlight === this.parentHighlight) {
        pstate.parentHighlight = null;
      }
      this.parentHighlight.destroy();
      this.parentHighlight = null;
    }
    if (this.ghostPreview) {
      this.ghostPreview.destroy();
      this.ghostPreview = null;
    }
    if (this.selectionBorder) {
      this.selectionBorder.destroy();
    }
    this.labelShape = null;
    this.removeHint();
    for (let i2 = 0; i2 < this.sizers.length; i2 += 1) {
      this.sizers[i2].destroy();
    }
    this.sizers = [];
    for (let i2 = 0; i2 < this.customHandles.length; i2 += 1) {
      this.customHandles[i2].destroy();
    }
    this.customHandles = [];
  }
};
var VertexHandler_default = VertexHandler;

// node_modules/@maxgraph/core/lib/util/Translations.js
var Translations = class {
};
Translations.resources = {};
Translations.extension = ".txt";
Translations.resourcesEncoded = false;
Translations.loadDefaultBundle = true;
Translations.loadSpecialBundle = true;
Translations.isLanguageSupported = (lan) => {
  if (Client_default.languages != null) {
    return Client_default.languages.indexOf(lan) >= 0;
  }
  return true;
};
Translations.getDefaultBundle = (basename, lan) => {
  if (Translations.loadDefaultBundle || !Translations.isLanguageSupported(lan)) {
    return basename + Translations.extension;
  }
  return null;
};
Translations.getSpecialBundle = (basename, lan) => {
  if (Client_default.languages == null || !Translations.isLanguageSupported(lan)) {
    const dash = lan.indexOf("-");
    if (dash > 0) {
      lan = lan.substring(0, dash);
    }
  }
  if (Translations.loadSpecialBundle && Translations.isLanguageSupported(lan) && lan != Client_default.defaultLanguage) {
    return `${basename}_${lan}${Translations.extension}`;
  }
  return null;
};
Translations.add = (basename, lan = null, callback = null) => {
  lan = lan != null ? lan : Client_default.language != null ? Client_default.language.toLowerCase() : NONE;
  if (lan !== NONE) {
    const defaultBundle = Translations.getDefaultBundle(basename, lan);
    const specialBundle = Translations.getSpecialBundle(basename, lan);
    const loadSpecialBundle = () => {
      if (specialBundle != null) {
        if (callback) {
          get(specialBundle, (req) => {
            Translations.parse(req.getText());
            callback();
          }, () => {
            callback();
          });
        } else {
          try {
            const req = load(specialBundle);
            if (req.isReady()) {
              Translations.parse(req.getText());
            }
          } catch (e) {
          }
        }
      } else if (callback != null) {
        callback();
      }
    };
    if (defaultBundle != null) {
      if (callback) {
        get(defaultBundle, (req) => {
          Translations.parse(req.getText());
          loadSpecialBundle();
        }, () => {
          loadSpecialBundle();
        });
      } else {
        try {
          const req = load(defaultBundle);
          if (req.isReady()) {
            Translations.parse(req.getText());
          }
          loadSpecialBundle();
        } catch (e) {
        }
      }
    } else {
      loadSpecialBundle();
    }
  }
};
Translations.parse = (text2) => {
  if (text2 != null) {
    const lines = text2.split("\n");
    for (let i2 = 0; i2 < lines.length; i2 += 1) {
      if (lines[i2].charAt(0) !== "#") {
        const index = lines[i2].indexOf("=");
        if (index > 0) {
          const key2 = lines[i2].substring(0, index);
          let idx = lines[i2].length;
          if (lines[i2].charCodeAt(idx - 1) === 13) {
            idx--;
          }
          let value2 = lines[i2].substring(index + 1, idx);
          if (Translations.resourcesEncoded) {
            value2 = value2.replace(/\\(?=u[a-fA-F\d]{4})/g, "%");
            Translations.resources[key2] = unescape(value2);
          } else {
            Translations.resources[key2] = value2;
          }
        }
      }
    }
  }
};
Translations.get = (key2, params = null, defaultValue = null) => {
  let value2 = Translations.resources[key2];
  if (value2 == null) {
    value2 = defaultValue;
  }
  if (value2 != null && params != null) {
    value2 = Translations.replacePlaceholders(value2, params);
  }
  return value2;
};
Translations.replacePlaceholders = (value2, params) => {
  const result2 = [];
  let index = null;
  for (let i2 = 0; i2 < value2.length; i2 += 1) {
    const c = value2.charAt(i2);
    if (c === "{") {
      index = "";
    } else if (index != null && c === "}") {
      index = parseInt(index) - 1;
      if (index >= 0 && index < params.length) {
        result2.push(params[index]);
      }
      index = null;
    } else if (index != null) {
      index += c;
    } else {
      result2.push(c);
    }
  }
  return result2.join("");
};
Translations.loadResources = (callback) => {
  Translations.add(`${Client_default.basePath}/resources/editor`, null, () => {
    Translations.add(`${Client_default.basePath}/resources/graph`, null, callback);
  });
};
var Translations_default = Translations;

// node_modules/@maxgraph/core/lib/view/handler/ElbowEdgeHandler.js
var ElbowEdgeHandler = class extends EdgeHandler_default {
  constructor(state2) {
    super(state2);
    this.flipEnabled = true;
    this.doubleClickOrientationResource = Client_default.language !== "none" ? "doubleClickOrientation" : "";
  }
  /**
   * Overrides {@link EdgeHandler#createBends} to create custom bends.
   */
  createBends() {
    const bends = [];
    let bend = this.createHandleShape(0);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    bends.push(this.createVirtualBend((evt2) => {
      if (!isConsumed(evt2) && this.flipEnabled) {
        this.graph.flipEdge(this.state.cell);
        InternalEvent_default.consume(evt2);
      }
    }));
    this.points.push(new Point_default(0, 0));
    bend = this.createHandleShape(2);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    return bends;
  }
  /**
   * Creates a virtual bend that supports double clicking and calls
   * {@link Graph#flipEdge}.
   */
  createVirtualBend(dblClickHandler) {
    const bend = this.createHandleShape();
    this.initBend(bend, dblClickHandler);
    bend.setCursor(this.getCursorForBend());
    if (!this.graph.isCellBendable(this.state.cell)) {
      bend.node.style.display = "none";
    }
    return bend;
  }
  /**
   * Returns the cursor to be used for the bend.
   */
  getCursorForBend() {
    return this.state.style.edgeStyle === EDGESTYLE.TOPTOBOTTOM || this.state.style.edgeStyle === EDGESTYLE.ELBOW && this.state.style.elbow === ELBOW.VERTICAL ? "row-resize" : "col-resize";
  }
  /**
   * Returns the tooltip for the given node.
   */
  getTooltipForNode(node2) {
    let tip = null;
    if (this.bends != null && this.bends[1] != null && (node2 === this.bends[1].node || node2.parentNode === this.bends[1].node)) {
      tip = this.doubleClickOrientationResource;
      tip = Translations_default.get(tip) || tip;
    }
    return tip;
  }
  /**
   * Converts the given point in-place from screen to unscaled, untranslated
   * graph coordinates and applies the grid.
   *
   * @param point {@link Point} to be converted.
   * @param gridEnabled Boolean that specifies if the grid should be applied.
   */
  convertPoint(point, gridEnabled) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    const { origin } = this.state;
    if (gridEnabled) {
      point.x = this.graph.snap(point.x);
      point.y = this.graph.snap(point.y);
    }
    point.x = Math.round(point.x / scale - tr.x - origin.x);
    point.y = Math.round(point.y / scale - tr.y - origin.y);
    return point;
  }
  /**
   * Updates and redraws the inner bends.
   *
   * @param p0 {@link Point} that represents the location of the first point.
   * @param pe {@link Point} that represents the location of the last point.
   */
  redrawInnerBends(p0, pe) {
    const g = this.state.cell.getGeometry();
    const pts = this.state.absolutePoints;
    let pt = null;
    if (pts.length > 1) {
      p0 = pts[1];
      pe = pts[pts.length - 2];
    } else if (g.points != null && g.points.length > 0) {
      pt = pts[0];
    }
    if (pt == null) {
      pt = new Point_default(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
    } else {
      pt = new Point_default(this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));
    }
    const b = this.bends[1].bounds;
    let w = b.width;
    let h = b.height;
    let bounds = new Rectangle_default(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);
    if (this.manageLabelHandle) {
      this.checkLabelHandle(bounds);
    } else if (this.handleImage == null && this.labelShape.visible && this.labelShape.bounds && intersects2(bounds, this.labelShape.bounds)) {
      w = HANDLE_SIZE + 3;
      h = HANDLE_SIZE + 3;
      bounds = new Rectangle_default(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);
    }
    this.bends[1].bounds = bounds;
    this.bends[1].redraw();
    if (this.manageLabelHandle) {
      this.checkLabelHandle(this.bends[1].bounds);
    }
  }
};
var ElbowEdgeHandler_default = ElbowEdgeHandler;

// node_modules/@maxgraph/core/lib/view/handler/EdgeSegmentHandler.js
var EdgeSegmentHandler = class extends ElbowEdgeHandler_default {
  constructor(state2) {
    super(state2);
    this.points = [];
  }
  /**
   * Returns the current absolute points.
   */
  getCurrentPoints() {
    let pts = this.state.absolutePoints;
    const tol = Math.max(1, this.graph.view.scale);
    if (pts.length === 2 && pts[0] && pts[1] || pts.length === 3 && pts[0] && pts[1] && pts[2] && (Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol || Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)) {
      const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
      const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
      pts = [pts[0], new Point_default(cx, cy), new Point_default(cx, cy), pts[pts.length - 1]];
    }
    return pts;
  }
  /**
   * Updates the given preview state taking into account the state of the constraint handler.
   */
  getPreviewPoints(point) {
    if (this.isSource || this.isTarget) {
      return super.getPreviewPoints(point);
    }
    const pts = this.getCurrentPoints();
    let last = this.convertPoint(pts[0].clone(), false);
    point = this.convertPoint(point.clone(), false);
    let result2 = [];
    for (let i2 = 1; i2 < pts.length; i2 += 1) {
      const pt = this.convertPoint(pts[i2].clone(), false);
      if (i2 === this.index) {
        if (Math.round(last.x - pt.x) === 0) {
          last.x = point.x;
          pt.x = point.x;
        }
        if (Math.round(last.y - pt.y) === 0) {
          last.y = point.y;
          pt.y = point.y;
        }
      }
      if (i2 < pts.length - 1) {
        result2.push(pt);
      }
      last = pt;
    }
    if (result2.length === 1) {
      const source2 = this.state.getVisibleTerminalState(true);
      const target2 = this.state.getVisibleTerminalState(false);
      const scale = this.state.view.getScale();
      const tr = this.state.view.getTranslate();
      const x = result2[0].x * scale + tr.x;
      const y = result2[0].y * scale + tr.y;
      if (source2 != null && contains(source2, x, y) || target2 != null && contains(target2, x, y)) {
        result2 = [point, point];
      }
    }
    return result2;
  }
  /**
   * Overridden to perform optimization of the edge style result.
   */
  updatePreviewState(edge2, point, terminalState, me) {
    super.updatePreviewState(edge2, point, terminalState, me);
    if (!this.isSource && !this.isTarget) {
      point = this.convertPoint(point.clone(), false);
      const pts = edge2.absolutePoints;
      let pt0 = pts[0];
      let pt1 = pts[1];
      let result2 = [];
      for (let i2 = 2; i2 < pts.length; i2 += 1) {
        const pt2 = pts[i2];
        if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
          result2.push(this.convertPoint(pt1.clone(), false));
        }
        pt0 = pt1;
        pt1 = pt2;
      }
      const source2 = this.state.getVisibleTerminalState(true);
      const target2 = this.state.getVisibleTerminalState(false);
      const rpts = this.state.absolutePoints;
      const end = pts[pts.length - 1];
      if (result2.length === 0 && pts[0] && end && (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {
        result2 = [point, point];
      } else if (pts.length === 5 && result2.length === 2 && source2 != null && target2 != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {
        const view = this.graph.getView();
        const scale = view.getScale();
        const tr = view.getTranslate();
        let y0 = view.getRoutingCenterY(source2) / scale - tr.y;
        const sc = this.graph.getConnectionConstraint(edge2, source2, true);
        if (sc != null) {
          const pt = this.graph.getConnectionPoint(source2, sc);
          if (pt != null) {
            this.convertPoint(pt, false);
            y0 = pt.y;
          }
        }
        let ye = view.getRoutingCenterY(target2) / scale - tr.y;
        const tc = this.graph.getConnectionConstraint(edge2, target2, false);
        if (tc) {
          const pt = this.graph.getConnectionPoint(target2, tc);
          if (pt != null) {
            this.convertPoint(pt, false);
            ye = pt.y;
          }
        }
        result2 = [new Point_default(point.x, y0), new Point_default(point.x, ye)];
      }
      this.points = result2;
      edge2.view.updateFixedTerminalPoints(edge2, source2, target2);
      edge2.view.updatePoints(edge2, this.points, source2, target2);
      edge2.view.updateFloatingTerminalPoints(edge2, source2, target2);
    }
  }
  /**
   * Overriden to merge edge segments.
   */
  connect(edge2, terminal, isSource, isClone, me) {
    const model2 = this.graph.getDataModel();
    let geo = edge2.getGeometry();
    let result2 = null;
    if (geo != null && geo.points != null && geo.points.length > 0) {
      const pts = this.abspoints;
      let pt0 = pts[0];
      let pt1 = pts[1];
      result2 = [];
      for (let i2 = 2; i2 < pts.length; i2 += 1) {
        const pt2 = pts[i2];
        if (pt0 && pt1 && pt2 && (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) && (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {
          result2.push(this.convertPoint(pt1.clone(), false));
        }
        pt0 = pt1;
        pt1 = pt2;
      }
    }
    this.graph.batchUpdate(() => {
      if (result2 != null) {
        geo = edge2.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.points = result2;
          model2.setGeometry(edge2, geo);
        }
      }
      edge2 = super.connect(edge2, terminal, isSource, isClone, me);
    });
    return edge2;
  }
  /**
   * Returns no tooltips.
   */
  getTooltipForNode(node2) {
    return null;
  }
  /**
   * Adds custom bends for the center of each segment.
   */
  start(x, y, index) {
    super.start(x, y, index);
    if (this.bends != null && this.bends[index] != null && !this.isSource && !this.isTarget) {
      setOpacity(this.bends[index].node, 100);
    }
  }
  /**
   * Adds custom bends for the center of each segment.
   */
  createBends() {
    const bends = [];
    let bend = this.createHandleShape(0);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    const pts = this.getCurrentPoints();
    if (this.graph.isCellBendable(this.state.cell)) {
      if (this.points == null) {
        this.points = [];
      }
      for (let i2 = 0; i2 < pts.length - 1; i2 += 1) {
        bend = this.createVirtualBend();
        bends.push(bend);
        let horizontal = Math.round(pts[i2].x - pts[i2 + 1].x) === 0;
        if (Math.round(pts[i2].y - pts[i2 + 1].y) === 0 && i2 < pts.length - 2) {
          horizontal = Math.round(pts[i2].x - pts[i2 + 2].x) === 0;
        }
        bend.setCursor(horizontal ? "col-resize" : "row-resize");
        this.points.push(new Point_default(0, 0));
      }
    }
    bend = this.createHandleShape(pts.length);
    this.initBend(bend);
    bend.setCursor(CURSOR.TERMINAL_HANDLE);
    bends.push(bend);
    return bends;
  }
  /**
   * Overridden to invoke <refresh> before the redraw.
   */
  redraw() {
    this.refresh();
    super.redraw();
  }
  /**
   * Updates the position of the custom bends.
   */
  redrawInnerBends(p0, pe) {
    if (this.graph.isCellBendable(this.state.cell)) {
      const pts = this.getCurrentPoints();
      if (pts != null && pts.length > 1) {
        let straight = false;
        if (pts.length === 4 && pts[0] && pts[1] && pts[2] && pts[3] && Math.round(pts[1].x - pts[2].x) === 0 && Math.round(pts[1].y - pts[2].y) === 0) {
          straight = true;
          if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {
            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;
            pts[1] = new Point_default(cx, pts[1].y);
            pts[2] = new Point_default(cx, pts[2].y);
          } else {
            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;
            pts[1] = new Point_default(pts[1].x, cy);
            pts[2] = new Point_default(pts[2].x, cy);
          }
        }
        for (let i2 = 0; i2 < pts.length - 1; i2 += 1) {
          if (this.bends[i2 + 1] != null) {
            p0 = pts[i2];
            pe = pts[i2 + 1];
            const pt = new Point_default(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);
            const b = this.bends[i2 + 1].bounds;
            this.bends[i2 + 1].bounds = new Rectangle_default(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);
            this.bends[i2 + 1].redraw();
            if (this.manageLabelHandle) {
              this.checkLabelHandle(this.bends[i2 + 1].bounds);
            }
          }
        }
        if (straight) {
          setOpacity(this.bends[1].node, this.virtualBendOpacity);
          setOpacity(this.bends[3].node, this.virtualBendOpacity);
        }
      }
    }
  }
};
var EdgeSegmentHandler_default = EdgeSegmentHandler;

// node_modules/@maxgraph/core/lib/view/undoable_changes/SelectionChange.js
var SelectionChange = class {
  constructor(graph, added = [], removed = []) {
    this.graph = graph;
    this.added = added.slice();
    this.removed = removed.slice();
  }
  /**
   * Changes the current root of the view.
   */
  execute() {
    const selectionModel = this.graph.getSelectionModel();
    for (const removed of this.removed) {
      selectionModel.cellRemoved(removed);
    }
    for (const added of this.added) {
      selectionModel.cellAdded(added);
    }
    [this.added, this.removed] = [this.removed, this.added];
    selectionModel.fireEvent(new EventObject_default(InternalEvent_default.CHANGE, { added: this.added, removed: this.removed }));
  }
};
var SelectionChange_default = SelectionChange;

// node_modules/@maxgraph/core/lib/view/GraphSelectionModel.js
var GraphSelectionModel = class extends EventSource_default {
  constructor(graph) {
    super();
    this.doneResource = Client_default.language !== "none" ? "done" : "";
    this.updatingSelectionResource = Client_default.language !== "none" ? "updatingSelection" : "";
    this.singleSelection = false;
    this.graph = graph;
    this.cells = [];
  }
  /**
   * Returns {@link singleSelection} as a boolean.
   */
  isSingleSelection() {
    return this.singleSelection;
  }
  /**
   * Sets the {@link singleSelection} flag.
   *
   * @param {boolean} singleSelection Boolean that specifies the new value for
   * {@link singleSelection}.
   */
  setSingleSelection(singleSelection) {
    this.singleSelection = singleSelection;
  }
  /**
   * Returns true if the given {@link Cell} is selected.
   */
  isSelected(cell2) {
    return this.cells.indexOf(cell2) >= 0;
  }
  /**
   * Returns true if no cells are currently selected.
   */
  isEmpty() {
    return this.cells.length === 0;
  }
  /**
   * Clears the selection and fires a {@link change} event if the selection was not
   * empty.
   */
  clear() {
    this.changeSelection(null, this.cells);
  }
  /**
   * Selects the specified {@link Cell} using {@link setCells}.
   *
   * @param cell {@link mxCell} to be selected.
   */
  setCell(cell2) {
    this.setCells(cell2 ? [cell2] : []);
  }
  /**
   * Selects the given array of {@link Cell} and fires a {@link change} event.
   *
   * @param cells Array of {@link Cell} to be selected.
   */
  setCells(cells) {
    if (this.singleSelection) {
      cells = [this.getFirstSelectableCell(cells)];
    }
    const tmp2 = [];
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (this.graph.isCellSelectable(cells[i2])) {
        tmp2.push(cells[i2]);
      }
    }
    this.changeSelection(tmp2, this.cells);
  }
  /**
   * Returns the first selectable cell in the given array of cells.
   */
  getFirstSelectableCell(cells) {
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (this.graph.isCellSelectable(cells[i2])) {
        return cells[i2];
      }
    }
    return null;
  }
  /**
   * Adds the given {@link Cell} to the selection and fires a {@link select} event.
   *
   * @param cell {@link mxCell} to add to the selection.
   */
  addCell(cell2) {
    this.addCells([cell2]);
  }
  /**
   * Adds the given array of {@link Cell} to the selection and fires a {@link select}
   * event.
   *
   * @param cells Array of {@link Cell} to add to the selection.
   */
  addCells(cells) {
    let remove2 = null;
    if (this.singleSelection) {
      remove2 = this.cells;
      const selectableCell = this.getFirstSelectableCell(cells);
      cells = selectableCell ? [selectableCell] : [];
    }
    const tmp2 = [];
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (!this.isSelected(cells[i2]) && this.graph.isCellSelectable(cells[i2])) {
        tmp2.push(cells[i2]);
      }
    }
    this.changeSelection(tmp2, remove2);
  }
  /**
   * Removes the specified {@link Cell} from the selection and fires a {@link select}
   * event for the remaining cells.
   *
   * @param cell {@link mxCell} to remove from the selection.
   */
  removeCell(cell2) {
    this.removeCells([cell2]);
  }
  /**
   * Removes the specified {@link Cell} from the selection and fires a {@link select}
   * event for the remaining cells.
   *
   * @param cells {@link mxCell}s to remove from the selection.
   */
  removeCells(cells) {
    const tmp2 = [];
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (this.isSelected(cells[i2])) {
        tmp2.push(cells[i2]);
      }
    }
    this.changeSelection(null, tmp2);
  }
  /**
   * Adds/removes the specified arrays of {@link Cell} to/from the selection.
   *
   * @param added Array of {@link Cell} to add to the selection.
   * @param remove Array of {@link Cell} to remove from the selection.
   */
  changeSelection(added = null, removed = null) {
    if (added && added.length > 0 && added[0] || removed && removed.length > 0 && removed[0]) {
      const change = new SelectionChange_default(this.graph, added || [], removed || []);
      change.execute();
      const edit = new UndoableEdit_default(this.graph, false);
      edit.add(change);
      this.fireEvent(new EventObject_default(InternalEvent_default.UNDO, { edit }));
    }
  }
  /**
   * Inner callback to add the specified {@link Cell} to the selection. No event
   * is fired in this implementation.
   *
   * Paramters:
   *
   * @param cell {@link mxCell} to add to the selection.
   */
  cellAdded(cell2) {
    if (!this.isSelected(cell2)) {
      this.cells.push(cell2);
    }
  }
  /**
   * Inner callback to remove the specified {@link Cell} from the selection. No
   * event is fired in this implementation.
   *
   * @param cell {@link mxCell} to remove from the selection.
   */
  cellRemoved(cell2) {
    const index = this.cells.indexOf(cell2);
    if (index >= 0) {
      this.cells.splice(index, 1);
    }
  }
};
var GraphSelectionModel_default = GraphSelectionModel;

// node_modules/@maxgraph/core/lib/view/geometry/node/RhombusShape.js
var RhombusShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokewidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokewidth;
  }
  /**
   * Adds roundable support.
   */
  // isRoundable(): boolean;
  isRoundable() {
    return true;
  }
  /**
   * Generic painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintVertexShape(c, x, y, w, h) {
    var _a2;
    const hw = w / 2;
    const hh = h / 2;
    const arcSize = (((_a2 = this.style) == null ? void 0 : _a2.arcSize) ?? LINE_ARCSIZE) / 2;
    c.begin();
    this.addPoints(c, [
      new Point_default(x + hw, y),
      new Point_default(x + w, y + hh),
      new Point_default(x + hw, y + h),
      new Point_default(x, y + hh)
    ], this.isRounded, arcSize, true);
    c.fillAndStroke();
  }
};
var RhombusShape_default = RhombusShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/CylinderShape.js
var CylinderShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.maxHeight = 40;
    this.svgStrokeTolerance = 0;
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  paintVertexShape(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    this.redrawPath(c, x, y, w, h, false);
    c.fillAndStroke();
    if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {
      c.setShadow(false);
      c.begin();
      this.redrawPath(c, x, y, w, h, true);
      c.stroke();
    }
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  getCylinderSize(x, y, w, h) {
    return Math.min(this.maxHeight, Math.round(h / 5));
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h, isForeground = false) {
    const dy = this.getCylinderSize(x, y, w, h);
    if (isForeground && this.fill !== NONE || !isForeground && this.fill === NONE) {
      c.moveTo(0, dy);
      c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);
      if (!isForeground) {
        c.stroke();
        c.begin();
      }
    }
    if (!isForeground) {
      c.moveTo(0, dy);
      c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);
      c.lineTo(w, h - dy);
      c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);
      c.close();
    }
  }
};
var CylinderShape_default = CylinderShape;

// node_modules/@maxgraph/core/lib/view/geometry/ActorShape.js
var ActorShape = class extends Shape_default {
  constructor(bounds = null, fill = NONE, stroke = NONE, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   */
  paintVertexShape(c, x, y, w, h) {
    c.translate(x, y);
    c.begin();
    this.redrawPath(c, x, y, w, h);
    c.fillAndStroke();
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    const width = w / 3;
    c.moveTo(0, h);
    c.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);
    c.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);
    c.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);
    c.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);
    c.close();
  }
};
var ActorShape_default = ActorShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/TriangleShape.js
var TriangleShape = class extends ActorShape_default {
  constructor() {
    super();
  }
  /**
   * Adds roundable support.
   * @returns {boolean}
   */
  isRoundable() {
    return true;
  }
  /**
   * Draws the path for this shape.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  redrawPath(c, x, y, w, h) {
    var _a2;
    const arcSize = (((_a2 = this.style) == null ? void 0 : _a2.arcSize) ?? LINE_ARCSIZE) / 2;
    this.addPoints(c, [new Point_default(0, 0), new Point_default(w, 0.5 * h), new Point_default(0, h)], this.isRounded, arcSize, true);
  }
};
var TriangleShape_default = TriangleShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/HexagonShape.js
var HexagonShape = class extends ActorShape_default {
  constructor() {
    super();
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    var _a2;
    const arcSize = (((_a2 = this.style) == null ? void 0 : _a2.arcSize) ?? LINE_ARCSIZE) / 2;
    this.addPoints(c, [
      new Point_default(0.25 * w, 0),
      new Point_default(0.75 * w, 0),
      new Point_default(w, 0.5 * h),
      new Point_default(0.75 * w, h),
      new Point_default(0.25 * w, h),
      new Point_default(0, 0.5 * h)
    ], this.isRounded, arcSize, true);
  }
};
var HexagonShape_default = HexagonShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/CloudShape.js
var CloudShape = class extends ActorShape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Draws the path for this shape.
   */
  redrawPath(c, x, y, w, h) {
    c.moveTo(0.25 * w, 0.25 * h);
    c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);
    c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);
    c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);
    c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);
    c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);
    c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);
    c.close();
  }
};
var CloudShape_default = CloudShape;

// node_modules/@maxgraph/core/lib/view/geometry/edge/LineShape.js
var LineShape = class extends Shape_default {
  constructor(bounds, stroke, strokeWidth = 1, vertical = false) {
    super();
    this.bounds = bounds;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.vertical = vertical;
  }
  /**
   * Redirects to redrawPath for subclasses to work.
   * @param {AbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintVertexShape(c, x, y, w, h) {
    c.begin();
    if (this.vertical) {
      const mid = x + w / 2;
      c.moveTo(mid, y);
      c.lineTo(mid, y + h);
    } else {
      const mid = y + h / 2;
      c.moveTo(x, mid);
      c.lineTo(x + w, mid);
    }
    c.stroke();
  }
};
var LineShape_default = LineShape;

// node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowShape.js
var ArrowShape = class extends Shape_default {
  constructor(points2, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE) {
    super();
    this.points = points2;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.arrowWidth = arrowWidth;
    this.spacing = spacing;
    this.endSize = endSize;
  }
  /**
   * Augments the bounding box with the edge width and markers.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    const w = Math.max(this.arrowWidth, this.endSize);
    bbox.grow((w / 2 + this.strokeWidth) * this.scale);
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    const spacing = ARROW_SPACING;
    const width = ARROW_WIDTH;
    const arrow = ARROW_SIZE;
    const p0 = pts[0];
    const pe = pts[pts.length - 1];
    const dx = pe.x - p0.x;
    const dy = pe.y - p0.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const length = dist - 2 * spacing - arrow;
    const nx = dx / dist;
    const ny = dy / dist;
    const basex = length * nx;
    const basey = length * ny;
    const floorx = width * ny / 3;
    const floory = -width * nx / 3;
    const p0x = p0.x - floorx / 2 + spacing * nx;
    const p0y = p0.y - floory / 2 + spacing * ny;
    const p1x = p0x + floorx;
    const p1y = p0y + floory;
    const p2x = p1x + basex;
    const p2y = p1y + basey;
    const p3x = p2x + floorx;
    const p3y = p2y + floory;
    const p5x = p3x - 3 * floorx;
    const p5y = p3y - 3 * floory;
    c.begin();
    c.moveTo(p0x, p0y);
    c.lineTo(p1x, p1y);
    c.lineTo(p2x, p2y);
    c.lineTo(p3x, p3y);
    c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);
    c.lineTo(p5x, p5y);
    c.lineTo(p5x + floorx, p5y + floory);
    c.close();
    c.fillAndStroke();
  }
};
var ArrowShape_default = ArrowShape;

// node_modules/@maxgraph/core/lib/view/geometry/edge/ArrowConnectorShape.js
var ArrowConnectorShape = class extends Shape_default {
  constructor(points2, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {
    super();
    this.useSvgBoundingBox = true;
    this.points = points2;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
    this.arrowWidth = arrowWidth;
    this.arrowSpacing = spacing;
    this.startSize = ARROW_SIZE / 5;
    this.endSize = endSize;
  }
  /**
   * Hook for subclassers.
   */
  isRoundable() {
    return true;
  }
  /**
   * Overrides mxShape to reset spacing.
   */
  resetStyles() {
    super.resetStyles();
    this.arrowSpacing = ARROW_SPACING;
  }
  /**
   * Overrides apply to get smooth transition from default start- and endsize.
   */
  apply(state2) {
    super.apply(state2);
    if (this.style && this.style.startSize != null && this.style.endSize != null) {
      this.startSize = this.style.startSize * 3;
      this.endSize = this.style.endSize * 3;
    }
  }
  /**
   * Augments the bounding box with the edge width and markers.
   */
  augmentBoundingBox(bbox) {
    super.augmentBoundingBox(bbox);
    let w = this.getEdgeWidth();
    if (this.isMarkerStart()) {
      w = Math.max(w, this.getStartArrowWidth());
    }
    if (this.isMarkerEnd()) {
      w = Math.max(w, this.getEndArrowWidth());
    }
    bbox.grow((w / 2 + this.strokeWidth) * this.scale);
  }
  /**
   * Paints the line shape.
   */
  paintEdgeShape(c, pts) {
    var _a2;
    let strokeWidth = this.strokeWidth;
    if (this.outline) {
      strokeWidth = Math.max(1, ((_a2 = this.style) == null ? void 0 : _a2.strokeWidth) ?? 0);
    }
    const startWidth = this.getStartArrowWidth() + strokeWidth;
    const endWidth = this.getEndArrowWidth() + strokeWidth;
    const edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();
    const openEnded = this.isOpenEnded();
    const markerStart = this.isMarkerStart();
    const markerEnd = this.isMarkerEnd();
    const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;
    const startSize = this.startSize + strokeWidth;
    const endSize = this.endSize + strokeWidth;
    const isRounded = this.isArrowRounded();
    const pe = pts[pts.length - 1];
    let i0 = 1;
    while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {
      i0++;
    }
    const dx = pts[i0].x - pts[0].x;
    const dy = pts[i0].y - pts[0].y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist === 0) {
      return;
    }
    let nx = dx / dist;
    let nx2;
    let nx1 = nx;
    let ny = dy / dist;
    let ny2;
    let ny1 = ny;
    let orthx = edgeWidth * ny;
    let orthy = -edgeWidth * nx;
    const fns = [];
    if (isRounded) {
      c.setLineJoin("round");
    } else if (pts.length > 2) {
      c.setMiterLimit(1.42);
    }
    c.begin();
    const startNx = nx;
    const startNy = ny;
    if (markerStart && !openEnded) {
      this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);
    } else {
      const outStartX = pts[0].x + orthx / 2 + spacing * nx;
      const outStartY = pts[0].y + orthy / 2 + spacing * ny;
      const inEndX = pts[0].x - orthx / 2 + spacing * nx;
      const inEndY = pts[0].y - orthy / 2 + spacing * ny;
      if (openEnded) {
        c.moveTo(outStartX, outStartY);
        fns.push(() => {
          c.lineTo(inEndX, inEndY);
        });
      } else {
        c.moveTo(inEndX, inEndY);
        c.lineTo(outStartX, outStartY);
      }
    }
    let dx1 = 0;
    let dy1 = 0;
    let dist1 = 0;
    for (let i2 = 0; i2 < pts.length - 2; i2 += 1) {
      const pos = relativeCcw(pts[i2].x, pts[i2].y, pts[i2 + 1].x, pts[i2 + 1].y, pts[i2 + 2].x, pts[i2 + 2].y);
      dx1 = pts[i2 + 2].x - pts[i2 + 1].x;
      dy1 = pts[i2 + 2].y - pts[i2 + 1].y;
      dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      if (dist1 !== 0) {
        nx1 = dx1 / dist1;
        ny1 = dy1 / dist1;
        const tmp1 = nx * nx1 + ny * ny1;
        const tmp2 = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);
        nx2 = nx + nx1;
        ny2 = ny + ny1;
        const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);
        if (dist2 !== 0) {
          nx2 /= dist2;
          ny2 /= dist2;
          const strokeWidthFactor = Math.max(tmp2, Math.min(this.strokeWidth / 200 + 0.04, 0.35));
          const angleFactor = pos !== 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp2, 0.06);
          const outX = pts[i2 + 1].x + ny2 * edgeWidth / 2 / angleFactor;
          const outY = pts[i2 + 1].y - nx2 * edgeWidth / 2 / angleFactor;
          const inX = pts[i2 + 1].x - ny2 * edgeWidth / 2 / angleFactor;
          const inY = pts[i2 + 1].y + nx2 * edgeWidth / 2 / angleFactor;
          if (pos === 0 || !isRounded) {
            c.lineTo(outX, outY);
            ((x, y) => {
              fns.push(() => {
                c.lineTo(x, y);
              });
            })(inX, inY);
          } else if (pos === -1) {
            const c1x = inX + ny * edgeWidth;
            const c1y = inY - nx * edgeWidth;
            const c2x = inX + ny1 * edgeWidth;
            const c2y = inY - nx1 * edgeWidth;
            c.lineTo(c1x, c1y);
            c.quadTo(outX, outY, c2x, c2y);
            ((x, y) => {
              fns.push(() => {
                c.lineTo(x, y);
              });
            })(inX, inY);
          } else {
            c.lineTo(outX, outY);
            ((x, y) => {
              const c1x = outX - ny * edgeWidth;
              const c1y = outY + nx * edgeWidth;
              const c2x = outX - ny1 * edgeWidth;
              const c2y = outY + nx1 * edgeWidth;
              fns.push(() => {
                c.quadTo(x, y, c1x, c1y);
              });
              fns.push(() => {
                c.lineTo(c2x, c2y);
              });
            })(inX, inY);
          }
          nx = nx1;
          ny = ny1;
        }
      }
    }
    orthx = edgeWidth * ny1;
    orthy = -edgeWidth * nx1;
    if (markerEnd && !openEnded) {
      this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);
    } else {
      c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);
      const inStartX = pe.x - spacing * nx1 - orthx / 2;
      const inStartY = pe.y - spacing * ny1 - orthy / 2;
      if (!openEnded) {
        c.lineTo(inStartX, inStartY);
      } else {
        c.moveTo(inStartX, inStartY);
        fns.splice(0, 0, () => {
          c.moveTo(inStartX, inStartY);
        });
      }
    }
    for (let i2 = fns.length - 1; i2 >= 0; i2--) {
      fns[i2]();
    }
    if (openEnded) {
      c.end();
      c.stroke();
    } else {
      c.close();
      c.fillAndStroke();
    }
    c.setShadow(false);
    c.setMiterLimit(4);
    if (isRounded) {
      c.setLineJoin("flat");
    }
    if (pts.length > 2) {
      c.setMiterLimit(4);
      if (markerStart && !openEnded) {
        c.begin();
        this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);
        c.stroke();
        c.end();
      }
      if (markerEnd && !openEnded) {
        c.begin();
        this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);
        c.stroke();
        c.end();
      }
    }
  }
  /**
   * Paints the marker.
   */
  paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {
    const widthArrowRatio = edgeWidth / arrowWidth;
    const orthx = edgeWidth * ny / 2;
    const orthy = -edgeWidth * nx / 2;
    const spaceX = (spacing + size) * nx;
    const spaceY = (spacing + size) * ny;
    if (initialMove) {
      c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
    } else {
      c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);
    }
    c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);
    c.lineTo(ptX + spacing * nx, ptY + spacing * ny);
    c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);
    c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);
  }
  /**
   * @returns whether the arrow is rounded
   */
  isArrowRounded() {
    return this.isRounded;
  }
  /**
   * @returns the width of the start arrow
   */
  getStartArrowWidth() {
    return ARROW_WIDTH;
  }
  /**
   * @returns the width of the end arrow
   */
  getEndArrowWidth() {
    return ARROW_WIDTH;
  }
  /**
   * @returns the width of the body of the edge
   */
  getEdgeWidth() {
    return ARROW_WIDTH / 3;
  }
  /**
   * @returns whether the ends of the shape are drawn
   */
  isOpenEnded() {
    return false;
  }
  /**
   * @returns whether the start marker is drawn
   */
  isMarkerStart() {
    var _a2;
    return (((_a2 = this.style) == null ? void 0 : _a2.startArrow) ?? NONE) !== NONE;
  }
  /**
   * @returns whether the end marker is drawn
   */
  isMarkerEnd() {
    var _a2;
    return (((_a2 = this.style) == null ? void 0 : _a2.endArrow) ?? NONE) !== NONE;
  }
};
var ArrowConnectorShape_default = ArrowConnectorShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/DoubleEllipseShape.js
var DoubleEllipseShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Paints the background.
   */
  paintBackground(c, x, y, w, h) {
    c.ellipse(x, y, w, h);
    c.fillAndStroke();
  }
  /**
   * Paints the foreground.
   */
  paintForeground(c, x, y, w, h) {
    var _a2;
    if (!this.outline) {
      const margin = ((_a2 = this.style) == null ? void 0 : _a2.margin) ?? Math.min(3 + this.strokeWidth, Math.min(w / 5, h / 5));
      x += margin;
      y += margin;
      w -= 2 * margin;
      h -= 2 * margin;
      if (w > 0 && h > 0) {
        c.ellipse(x, y, w, h);
      }
      c.stroke();
    }
  }
  /**
   * @returns the bounds for the label.
   */
  getLabelBounds(rect) {
    var _a2;
    const margin = ((_a2 = this.style) == null ? void 0 : _a2.margin) ?? Math.min(3 + this.strokeWidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)) * this.scale;
    return new Rectangle_default(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);
  }
};
var DoubleEllipseShape_default = DoubleEllipseShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/SwimlaneShape.js
var SwimlaneShape = class extends Shape_default {
  constructor(bounds, fill, stroke, strokeWidth = 1) {
    super();
    this.imageSize = 16;
    this.imageSrc = null;
    this.bounds = bounds;
    this.fill = fill;
    this.stroke = stroke;
    this.strokeWidth = strokeWidth;
  }
  /**
   * Adds roundable support.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @returns {boolean}
   */
  isRoundable(c, x, y, w, h) {
    return true;
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getTitleSize() {
    var _a2;
    return Math.max(0, ((_a2 = this.style) == null ? void 0 : _a2.startSize) ?? DEFAULT_STARTSIZE);
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getLabelBounds(rect) {
    var _a2, _b;
    const start = this.getTitleSize();
    const bounds = new Rectangle_default(rect.x, rect.y, rect.width, rect.height);
    const horizontal = this.isHorizontal();
    const flipH = ((_a2 = this.style) == null ? void 0 : _a2.flipH) ?? false;
    const flipV = ((_b = this.style) == null ? void 0 : _b.flipV) ?? false;
    const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;
    const realHorizontal = horizontal == !shapeVertical;
    const realFlipH = !realHorizontal && flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);
    const realFlipV = realHorizontal && flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);
    if (!shapeVertical) {
      const tmp2 = Math.min(bounds.height, start * this.scale);
      if (realFlipH || realFlipV) {
        bounds.y += bounds.height - tmp2;
      }
      bounds.height = tmp2;
    } else {
      const tmp2 = Math.min(bounds.width, start * this.scale);
      if (realFlipH || realFlipV) {
        bounds.x += bounds.width - tmp2;
      }
      bounds.width = tmp2;
    }
    return bounds;
  }
  /**
   * Returns the bounding box for the gradient box for this shape.
   */
  getGradientBounds(c, x, y, w, h) {
    let start = this.getTitleSize();
    if (this.isHorizontal()) {
      start = Math.min(start, h);
      return new Rectangle_default(x, y, w, start);
    }
    start = Math.min(start, w);
    return new Rectangle_default(x, y, start, h);
  }
  /**
   * Returns the arcsize for the swimlane.
   */
  getSwimlaneArcSize(w, h, start) {
    var _a2, _b, _c;
    if (((_a2 = this.style) == null ? void 0 : _a2.absoluteArcSize) ?? false) {
      return Math.min(w / 2, Math.min(h / 2, ((_b = this.style) == null ? void 0 : _b.arcSize) ?? LINE_ARCSIZE / 2));
    }
    const f = (((_c = this.style) == null ? void 0 : _c.arcSize) ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;
    return start * f * 3;
  }
  /**
   * Paints the swimlane vertex shape.
   */
  isHorizontal() {
    var _a2;
    return ((_a2 = this.style) == null ? void 0 : _a2.horizontal) ?? true;
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintVertexShape(c, x, y, w, h) {
    var _a2, _b, _c;
    let start = this.getTitleSize();
    const fill = ((_a2 = this.style) == null ? void 0 : _a2.swimlaneFillColor) ?? NONE;
    const swimlaneLine = ((_b = this.style) == null ? void 0 : _b.swimlaneLine) ?? true;
    let r = 0;
    if (this.isHorizontal()) {
      start = Math.min(start, h);
    } else {
      start = Math.min(start, w);
    }
    c.translate(x, y);
    if (!this.isRounded) {
      this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);
    } else {
      r = this.getSwimlaneArcSize(w, h, start);
      r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));
      this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);
    }
    const sep = ((_c = this.style) == null ? void 0 : _c.separatorColor) ?? NONE;
    this.paintSeparator(c, x, y, w, h, start, sep);
    if (this.imageSrc) {
      const bounds = this.getImageBounds(x, y, w, h);
      c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);
    }
    if (this.glass) {
      c.setShadow(false);
      this.paintGlassEffect(c, 0, 0, w, start, r);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {
    c.begin();
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (!events && this.fill === NONE) {
      c.pointerEvents = false;
    }
    if (this.isHorizontal()) {
      c.moveTo(0, start);
      c.lineTo(0, 0);
      c.lineTo(w, 0);
      c.lineTo(w, start);
      c.fillAndStroke();
      if (start < h) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(0, start);
        c.lineTo(0, h);
        c.lineTo(w, h);
        c.lineTo(w, start);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    } else {
      c.moveTo(start, 0);
      c.lineTo(0, 0);
      c.lineTo(0, h);
      c.lineTo(start, h);
      c.fillAndStroke();
      if (start < w) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(start, 0);
        c.lineTo(w, 0);
        c.lineTo(w, h);
        c.lineTo(start, h);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    }
    if (swimlaneLine) {
      this.paintDivider(c, x, y, w, h, start, fill === NONE);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {
    c.begin();
    let events = true;
    if (this.style && this.style.pointerEvents != null) {
      events = this.style.pointerEvents;
    }
    if (!events && this.fill === NONE) {
      c.pointerEvents = false;
    }
    if (this.isHorizontal()) {
      c.moveTo(w, start);
      c.lineTo(w, r);
      c.quadTo(w, 0, w - Math.min(w / 2, r), 0);
      c.lineTo(Math.min(w / 2, r), 0);
      c.quadTo(0, 0, 0, r);
      c.lineTo(0, start);
      c.fillAndStroke();
      if (start < h) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(0, start);
        c.lineTo(0, h - r);
        c.quadTo(0, h, Math.min(w / 2, r), h);
        c.lineTo(w - Math.min(w / 2, r), h);
        c.quadTo(w, h, w, h - r);
        c.lineTo(w, start);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    } else {
      c.moveTo(start, 0);
      c.lineTo(r, 0);
      c.quadTo(0, 0, 0, Math.min(h / 2, r));
      c.lineTo(0, h - Math.min(h / 2, r));
      c.quadTo(0, h, r, h);
      c.lineTo(start, h);
      c.fillAndStroke();
      if (start < w) {
        if (fill === NONE || !events) {
          c.pointerEvents = false;
        }
        if (fill !== NONE) {
          c.setFillColor(fill);
        }
        c.begin();
        c.moveTo(start, h);
        c.lineTo(w - r, h);
        c.quadTo(w, h, w, h - Math.min(h / 2, r));
        c.lineTo(w, Math.min(h / 2, r));
        c.quadTo(w, 0, w - r, 0);
        c.lineTo(start, 0);
        if (fill === NONE) {
          c.stroke();
        } else {
          c.fillAndStroke();
        }
      }
    }
    if (swimlaneLine) {
      this.paintDivider(c, x, y, w, h, start, fill === NONE);
    }
  }
  /**
   * Paints the divider between swimlane title and content area.
   */
  paintDivider(c, x, y, w, h, start, shadow) {
    if (!shadow) {
      c.setShadow(false);
    }
    c.begin();
    if (this.isHorizontal()) {
      c.moveTo(0, start);
      c.lineTo(w, start);
    } else {
      c.moveTo(start, 0);
      c.lineTo(start, h);
    }
    c.stroke();
  }
  /**
   * Paints the vertical or horizontal separator line between swimlanes.
   */
  paintSeparator(c, x, y, w, h, start, color) {
    if (color !== NONE) {
      c.setStrokeColor(color);
      c.setDashed(true);
      c.begin();
      if (this.isHorizontal()) {
        c.moveTo(w, start);
        c.lineTo(w, h);
      } else {
        c.moveTo(start, 0);
        c.lineTo(w, 0);
      }
      c.stroke();
      c.setDashed(false);
    }
  }
  /**
   * Paints the swimlane vertex shape.
   */
  getImageBounds(x, y, w, h) {
    if (this.isHorizontal()) {
      return new Rectangle_default(x + w - this.imageSize, y, this.imageSize, this.imageSize);
    }
    return new Rectangle_default(x, y, this.imageSize, this.imageSize);
  }
};
var SwimlaneShape_default = SwimlaneShape;

// node_modules/@maxgraph/core/lib/view/geometry/node/LabelShape.js
var LabelShape = class extends RectangleShape_default {
  /**
   * Constructs a new label shape.
   *
   * @param bounds {@link Rectangle} that defines the bounds. This is stored in {@link bounds}.
   * @param fill String that defines the fill color. This is stored in {@link fill}.
   * @param stroke String that defines the stroke color. This is stored in {@link stroke}.
   * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link strokeWidth}.
   */
  constructor(bounds, fill, stroke, strokeWidth) {
    super(bounds, fill, stroke, strokeWidth);
    this.imageSize = DEFAULT_IMAGESIZE;
    this.imageSrc = null;
    this.spacing = 2;
    this.indicatorSize = 10;
    this.indicatorSpacing = 2;
    this.indicatorImageSrc = null;
  }
  /**
   * Initializes the shape and the <indicator>.
   */
  init(container) {
    super.init(container);
    if (this.indicatorShape) {
      this.indicator = new this.indicatorShape();
      this.indicator.dialect = this.dialect;
      this.indicator.init(this.node);
    }
  }
  /**
   * Reconfigures this shape. This will update the colors of the indicator
   * and reconfigure it if required.
   */
  redraw() {
    if (this.indicator) {
      this.indicator.fill = this.indicatorColor;
      this.indicator.stroke = this.indicatorStrokeColor;
      this.indicator.gradient = this.indicatorGradientColor;
      this.indicator.direction = this.indicatorDirection;
      this.indicator.redraw();
    }
    super.redraw();
  }
  /**
   * Returns true for non-rounded, non-rotated shapes with no glass gradient and
   * no indicator shape.
   */
  isHtmlAllowed() {
    return super.isHtmlAllowed() && this.indicatorColor === NONE && !!this.indicatorShape;
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintForeground(c, x, y, w, h) {
    this.paintImage(c, x, y, w, h);
    this.paintIndicator(c, x, y, w, h);
    super.paintForeground(c, x, y, w, h);
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintImage(c, x, y, w, h) {
    if (this.imageSrc) {
      const bounds = this.getImageBounds(x, y, w, h);
      c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.imageSrc, false, false, false);
    }
  }
  /**
   * Generic background painting implementation.
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  getImageBounds(x, y, w, h) {
    var _a2, _b, _c, _d, _e;
    const align = ((_a2 = this.style) == null ? void 0 : _a2.imageAlign) ?? ALIGN.LEFT;
    const valign = ((_b = this.style) == null ? void 0 : _b.verticalAlign) ?? ALIGN.MIDDLE;
    const width = ((_c = this.style) == null ? void 0 : _c.imageWidth) ?? DEFAULT_IMAGESIZE;
    const height = ((_d = this.style) == null ? void 0 : _d.imageHeight) ?? DEFAULT_IMAGESIZE;
    const spacing = ((_e = this.style) == null ? void 0 : _e.spacing) ?? this.spacing + 5;
    if (align === ALIGN.CENTER) {
      x += (w - width) / 2;
    } else if (align === ALIGN.RIGHT) {
      x += w - width - spacing;
    } else {
      x += spacing;
    }
    if (valign === ALIGN.TOP) {
      y += spacing;
    } else if (valign === ALIGN.BOTTOM) {
      y += h - height - spacing;
    } else {
      y += (h - height) / 2;
    }
    return new Rectangle_default(x, y, width, height);
  }
  /**
   * Generic background painting implementation.
   * @param {mxAbstractCanvas2D} c
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   */
  paintIndicator(c, x, y, w, h) {
    if (this.indicator) {
      this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);
      this.indicator.paint(c);
    } else if (this.indicatorImageSrc) {
      const bounds = this.getIndicatorBounds(x, y, w, h);
      c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImageSrc, false, false, false);
    }
  }
  /**
   * Generic background painting implementation.
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @returns {Rectangle}
   */
  getIndicatorBounds(x, y, w, h) {
    var _a2, _b, _c, _d;
    const align = ((_a2 = this.style) == null ? void 0 : _a2.imageAlign) ?? ALIGN.LEFT;
    const valign = ((_b = this.style) == null ? void 0 : _b.verticalAlign) ?? ALIGN.MIDDLE;
    const width = ((_c = this.style) == null ? void 0 : _c.indicatorWidth) ?? this.indicatorSize;
    const height = ((_d = this.style) == null ? void 0 : _d.indicatorHeight) ?? this.indicatorSize;
    const spacing = this.spacing + 5;
    if (align === ALIGN.RIGHT) {
      x += w - width - spacing;
    } else if (align === ALIGN.CENTER) {
      x += (w - width) / 2;
    } else {
      x += spacing;
    }
    if (valign === ALIGN.BOTTOM) {
      y += h - height - spacing;
    } else if (valign === ALIGN.TOP) {
      y += spacing;
    } else {
      y += (h - height) / 2;
    }
    return new Rectangle_default(x, y, width, height);
  }
  /**
   * Generic background painting implementation.
   */
  redrawHtmlShape() {
    super.redrawHtmlShape();
    while (this.node.hasChildNodes()) {
      this.node.removeChild(this.node.lastChild);
    }
    if (this.imageSrc && this.bounds) {
      const node2 = document.createElement("img");
      node2.style.position = "relative";
      node2.setAttribute("border", "0");
      const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
      bounds.x -= this.bounds.x;
      bounds.y -= this.bounds.y;
      node2.style.left = `${Math.round(bounds.x)}px`;
      node2.style.top = `${Math.round(bounds.y)}px`;
      node2.style.width = `${Math.round(bounds.width)}px`;
      node2.style.height = `${Math.round(bounds.height)}px`;
      node2.src = this.imageSrc;
      this.node.appendChild(node2);
    }
  }
};
var LabelShape_default = LabelShape;

// node_modules/@maxgraph/core/lib/view/cell/register-shapes.js
var isDefaultElementsRegistered = false;
function registerDefaultShapes() {
  if (!isDefaultElementsRegistered) {
    const shapesToRegister = [
      [SHAPE.ACTOR, ActorShape_default],
      [SHAPE.ARROW, ArrowShape_default],
      [SHAPE.ARROW_CONNECTOR, ArrowConnectorShape_default],
      [SHAPE.CONNECTOR, ConnectorShape_default],
      [SHAPE.CLOUD, CloudShape_default],
      [SHAPE.CYLINDER, CylinderShape_default],
      [SHAPE.DOUBLE_ELLIPSE, DoubleEllipseShape_default],
      [SHAPE.ELLIPSE, EllipseShape_default],
      [SHAPE.HEXAGON, HexagonShape_default],
      [SHAPE.IMAGE, ImageShape_default],
      [SHAPE.LABEL, LabelShape_default],
      [SHAPE.LINE, LineShape_default],
      [SHAPE.RECTANGLE, RectangleShape_default],
      [SHAPE.RHOMBUS, RhombusShape_default],
      [SHAPE.SWIMLANE, SwimlaneShape_default],
      [SHAPE.TRIANGLE, TriangleShape_default]
    ];
    for (const [shapeName, shapeClass] of shapesToRegister) {
      CellRenderer_default.registerShape(shapeName, shapeClass);
    }
    isDefaultElementsRegistered = true;
  }
}

// node_modules/@maxgraph/core/lib/view/style/perimeter/EllipsePerimeter.js
var EllipsePerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const { x } = bounds;
  const { y } = bounds;
  const a = bounds.width / 2;
  const b = bounds.height / 2;
  const cx = x + a;
  const cy = y + b;
  const px = next.x;
  const py = next.y;
  const dx = parseInt(String(px - cx));
  const dy = parseInt(String(py - cy));
  if (dx === 0 && dy !== 0) {
    return new Point_default(cx, cy + b * dy / Math.abs(dy));
  }
  if (dx === 0 && dy === 0) {
    return new Point_default(px, py);
  }
  if (orthogonal) {
    if (py >= y && py <= y + bounds.height) {
      const ty = py - cy;
      let tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;
      if (px <= x) {
        tx = -tx;
      }
      return new Point_default(cx + tx, py);
    }
    if (px >= x && px <= x + bounds.width) {
      const tx = px - cx;
      let ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;
      if (py <= y) {
        ty = -ty;
      }
      return new Point_default(px, cy + ty);
    }
  }
  const d = dy / dx;
  const h = cy - d * cx;
  const e = a * a * d * d + b * b;
  const f = -2 * cx * e;
  const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;
  const det = Math.sqrt(f * f - 4 * e * g);
  const xout1 = (-f + det) / (2 * e);
  const xout2 = (-f - det) / (2 * e);
  const yout1 = d * xout1 + h;
  const yout2 = d * xout2 + h;
  const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));
  const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));
  let xout = 0;
  let yout = 0;
  if (dist1 < dist2) {
    xout = xout1;
    yout = yout1;
  } else {
    xout = xout2;
    yout = yout2;
  }
  return new Point_default(xout, yout);
};

// node_modules/@maxgraph/core/lib/view/style/perimeter/HexagonPerimeter.js
var HexagonPerimeter = (bounds, vertex, next, orthogonal = false) => {
  var _a2;
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  const cx = bounds.getCenterX();
  const cy = bounds.getCenterY();
  const px = next.x;
  const py = next.y;
  const dx = px - cx;
  const dy = py - cy;
  const alpha = -Math.atan2(dy, dx);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  let result2 = new Point_default(cx, cy);
  const direction = ((_a2 = vertex == null ? void 0 : vertex.style) == null ? void 0 : _a2.direction) ?? DIRECTION.EAST;
  const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
  let a = new Point_default();
  let b = new Point_default();
  if (px < x && py < y || px < x && py > y + h || px > x + w && py < y || px > x + w && py > y + h) {
    orthogonal = false;
  }
  if (orthogonal) {
    if (vertical) {
      if (px === cx) {
        if (py <= y) {
          return new Point_default(cx, y);
        }
        if (py >= y + h) {
          return new Point_default(cx, y + h);
        }
      } else if (px < x) {
        if (py === y + h / 4) {
          return new Point_default(x, y + h / 4);
        }
        if (py === y + 3 * h / 4) {
          return new Point_default(x, y + 3 * h / 4);
        }
      } else if (px > x + w) {
        if (py === y + h / 4) {
          return new Point_default(x + w, y + h / 4);
        }
        if (py === y + 3 * h / 4) {
          return new Point_default(x + w, y + 3 * h / 4);
        }
      } else if (px === x) {
        if (py < cy) {
          return new Point_default(x, y + h / 4);
        }
        if (py > cy) {
          return new Point_default(x, y + 3 * h / 4);
        }
      } else if (px === x + w) {
        if (py < cy) {
          return new Point_default(x + w, y + h / 4);
        }
        if (py > cy) {
          return new Point_default(x + w, y + 3 * h / 4);
        }
      }
      if (py === y) {
        return new Point_default(cx, y);
      }
      if (py === y + h) {
        return new Point_default(cx, y + h);
      }
      if (px < cx) {
        if (py > y + h / 4 && py < y + 3 * h / 4) {
          a = new Point_default(x, y);
          b = new Point_default(x, y + h);
        } else if (py < y + h / 4) {
          a = new Point_default(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
          b = new Point_default(x + w, y - Math.floor(0.25 * h));
        } else if (py > y + 3 * h / 4) {
          a = new Point_default(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
          b = new Point_default(x + w, y + Math.floor(1.25 * h));
        }
      } else if (px > cx) {
        if (py > y + h / 4 && py < y + 3 * h / 4) {
          a = new Point_default(x + w, y);
          b = new Point_default(x + w, y + h);
        } else if (py < y + h / 4) {
          a = new Point_default(x, y - Math.floor(0.25 * h));
          b = new Point_default(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
        } else if (py > y + 3 * h / 4) {
          a = new Point_default(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
          b = new Point_default(x, y + Math.floor(1.25 * h));
        }
      }
    } else {
      if (py === cy) {
        if (px <= x) {
          return new Point_default(x, y + h / 2);
        }
        if (px >= x + w) {
          return new Point_default(x + w, y + h / 2);
        }
      } else if (py < y) {
        if (px === x + w / 4) {
          return new Point_default(x + w / 4, y);
        }
        if (px === x + 3 * w / 4) {
          return new Point_default(x + 3 * w / 4, y);
        }
      } else if (py > y + h) {
        if (px === x + w / 4) {
          return new Point_default(x + w / 4, y + h);
        }
        if (px === x + 3 * w / 4) {
          return new Point_default(x + 3 * w / 4, y + h);
        }
      } else if (py === y) {
        if (px < cx) {
          return new Point_default(x + w / 4, y);
        }
        if (px > cx) {
          return new Point_default(x + 3 * w / 4, y);
        }
      } else if (py === y + h) {
        if (px < cx) {
          return new Point_default(x + w / 4, y + h);
        }
        if (py > cy) {
          return new Point_default(x + 3 * w / 4, y + h);
        }
      }
      if (px === x) {
        return new Point_default(x, cy);
      }
      if (px === x + w) {
        return new Point_default(x + w, cy);
      }
      if (py < cy) {
        if (px > x + w / 4 && px < x + 3 * w / 4) {
          a = new Point_default(x, y);
          b = new Point_default(x + w, y);
        } else if (px < x + w / 4) {
          a = new Point_default(x - Math.floor(0.25 * w), y + h);
          b = new Point_default(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
        } else if (px > x + 3 * w / 4) {
          a = new Point_default(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
          b = new Point_default(x + Math.floor(1.25 * w), y + h);
        }
      } else if (py > cy) {
        if (px > x + w / 4 && px < x + 3 * w / 4) {
          a = new Point_default(x, y + h);
          b = new Point_default(x + w, y + h);
        } else if (px < x + w / 4) {
          a = new Point_default(x - Math.floor(0.25 * w), y);
          b = new Point_default(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
        } else if (px > x + 3 * w / 4) {
          a = new Point_default(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
          b = new Point_default(x + Math.floor(1.25 * w), y);
        }
      }
    }
    let tx = cx;
    let ty = cy;
    if (px >= x && px <= x + w) {
      tx = px;
      if (py < cy) {
        ty = y + h;
      } else {
        ty = y;
      }
    } else if (py >= y && py <= y + h) {
      ty = py;
      if (px < cx) {
        tx = x + w;
      } else {
        tx = x;
      }
    }
    result2 = intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);
  } else {
    if (vertical) {
      const beta = Math.atan2(h / 4, w / 2);
      if (alpha === beta) {
        return new Point_default(x + w, y + Math.floor(0.25 * h));
      }
      if (alpha === pi2) {
        return new Point_default(x + Math.floor(0.5 * w), y);
      }
      if (alpha === pi - beta) {
        return new Point_default(x, y + Math.floor(0.25 * h));
      }
      if (alpha === -beta) {
        return new Point_default(x + w, y + Math.floor(0.75 * h));
      }
      if (alpha === -pi2) {
        return new Point_default(x + Math.floor(0.5 * w), y + h);
      }
      if (alpha === -pi + beta) {
        return new Point_default(x, y + Math.floor(0.75 * h));
      }
      if (alpha < beta && alpha > -beta) {
        a = new Point_default(x + w, y);
        b = new Point_default(x + w, y + h);
      } else if (alpha > beta && alpha < pi2) {
        a = new Point_default(x, y - Math.floor(0.25 * h));
        b = new Point_default(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
      } else if (alpha > pi2 && alpha < pi - beta) {
        a = new Point_default(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
        b = new Point_default(x + w, y - Math.floor(0.25 * h));
      } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {
        a = new Point_default(x, y);
        b = new Point_default(x, y + h);
      } else if (alpha < -beta && alpha > -pi2) {
        a = new Point_default(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));
        b = new Point_default(x, y + Math.floor(1.25 * h));
      } else if (alpha < -pi2 && alpha > -pi + beta) {
        a = new Point_default(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));
        b = new Point_default(x + w, y + Math.floor(1.25 * h));
      }
    } else {
      const beta = Math.atan2(h / 2, w / 4);
      if (alpha === beta) {
        return new Point_default(x + Math.floor(0.75 * w), y);
      }
      if (alpha === pi - beta) {
        return new Point_default(x + Math.floor(0.25 * w), y);
      }
      if (alpha === pi || alpha === -pi) {
        return new Point_default(x, y + Math.floor(0.5 * h));
      }
      if (alpha === 0) {
        return new Point_default(x + w, y + Math.floor(0.5 * h));
      }
      if (alpha === -beta) {
        return new Point_default(x + Math.floor(0.75 * w), y + h);
      }
      if (alpha === -pi + beta) {
        return new Point_default(x + Math.floor(0.25 * w), y + h);
      }
      if (alpha > 0 && alpha < beta) {
        a = new Point_default(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
        b = new Point_default(x + Math.floor(1.25 * w), y + h);
      } else if (alpha > beta && alpha < pi - beta) {
        a = new Point_default(x, y);
        b = new Point_default(x + w, y);
      } else if (alpha > pi - beta && alpha < pi) {
        a = new Point_default(x - Math.floor(0.25 * w), y + h);
        b = new Point_default(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));
      } else if (alpha < 0 && alpha > -beta) {
        a = new Point_default(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
        b = new Point_default(x + Math.floor(1.25 * w), y);
      } else if (alpha < -beta && alpha > -pi + beta) {
        a = new Point_default(x, y + h);
        b = new Point_default(x + w, y + h);
      } else if (alpha < -pi + beta && alpha > -pi) {
        a = new Point_default(x - Math.floor(0.25 * w), y);
        b = new Point_default(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));
      }
    }
    result2 = intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);
  }
  if (result2 == null) {
    return new Point_default(cx, cy);
  }
  return result2;
};

// node_modules/@maxgraph/core/lib/view/style/perimeter/RectanglePerimeter.js
var RectanglePerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const cx = bounds.getCenterX();
  const cy = bounds.getCenterY();
  const dx = next.x - cx;
  const dy = next.y - cy;
  const alpha = Math.atan2(dy, dx);
  const p = new Point_default(0, 0);
  const pi = Math.PI;
  const pi2 = Math.PI / 2;
  const beta = pi2 - alpha;
  const t = Math.atan2(bounds.height, bounds.width);
  if (alpha < -pi + t || alpha > pi - t) {
    p.x = bounds.x;
    p.y = cy - bounds.width * Math.tan(alpha) / 2;
  } else if (alpha < -t) {
    p.y = bounds.y;
    p.x = cx - bounds.height * Math.tan(beta) / 2;
  } else if (alpha < t) {
    p.x = bounds.x + bounds.width;
    p.y = cy + bounds.width * Math.tan(alpha) / 2;
  } else {
    p.y = bounds.y + bounds.height;
    p.x = cx + bounds.height * Math.tan(beta) / 2;
  }
  if (orthogonal) {
    if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
      p.x = next.x;
    } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
      p.y = next.y;
    }
    if (next.x < bounds.x) {
      p.x = bounds.x;
    } else if (next.x > bounds.x + bounds.width) {
      p.x = bounds.x + bounds.width;
    }
    if (next.y < bounds.y) {
      p.y = bounds.y;
    } else if (next.y > bounds.y + bounds.height) {
      p.y = bounds.y + bounds.height;
    }
  }
  return p;
};

// node_modules/@maxgraph/core/lib/view/style/perimeter/RhombusPerimeter.js
var RhombusPerimeter = (bounds, _vertex, next, orthogonal = false) => {
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  const cx = x + w / 2;
  const cy = y + h / 2;
  const px = next.x;
  const py = next.y;
  if (cx === px) {
    if (cy > py) {
      return new Point_default(cx, y);
    }
    return new Point_default(cx, y + h);
  }
  if (cy === py) {
    if (cx > px) {
      return new Point_default(x, cy);
    }
    return new Point_default(x + w, cy);
  }
  let tx = cx;
  let ty = cy;
  if (orthogonal) {
    if (px >= x && px <= x + w) {
      tx = px;
    } else if (py >= y && py <= y + h) {
      ty = py;
    }
  }
  if (px < cx) {
    if (py < cy) {
      return intersection(px, py, tx, ty, cx, y, x, cy);
    }
    return intersection(px, py, tx, ty, cx, y + h, x, cy);
  }
  if (py < cy) {
    return intersection(px, py, tx, ty, cx, y, x + w, cy);
  }
  return intersection(px, py, tx, ty, cx, y + h, x + w, cy);
};

// node_modules/@maxgraph/core/lib/view/style/perimeter/TrianglePerimeter.js
var TrianglePerimeter = (bounds, vertex, next, orthogonal = false) => {
  const direction = vertex != null ? vertex.style.direction : null;
  const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
  const { x } = bounds;
  const { y } = bounds;
  const w = bounds.width;
  const h = bounds.height;
  let cx = x + w / 2;
  let cy = y + h / 2;
  let start = new Point_default(x, y);
  let corner = new Point_default(x + w, cy);
  let end = new Point_default(x, y + h);
  if (direction === DIRECTION.NORTH) {
    start = end;
    corner = new Point_default(cx, y);
    end = new Point_default(x + w, y + h);
  } else if (direction === DIRECTION.SOUTH) {
    corner = new Point_default(cx, y + h);
    end = new Point_default(x + w, y);
  } else if (direction === DIRECTION.WEST) {
    start = new Point_default(x + w, y);
    corner = new Point_default(x, cy);
    end = new Point_default(x + w, y + h);
  }
  let dx = next.x - cx;
  let dy = next.y - cy;
  const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);
  const t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);
  let base = false;
  if (direction === DIRECTION.NORTH || direction === DIRECTION.WEST) {
    base = alpha > -t && alpha < t;
  } else {
    base = alpha < -Math.PI + t || alpha > Math.PI - t;
  }
  let result2 = null;
  if (base) {
    if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {
      if (vertical) {
        result2 = new Point_default(next.x, start.y);
      } else {
        result2 = new Point_default(start.x, next.y);
      }
    } else if (direction === DIRECTION.NORTH) {
      result2 = new Point_default(x + w / 2 + h * Math.tan(alpha) / 2, y + h);
    } else if (direction === DIRECTION.SOUTH) {
      result2 = new Point_default(x + w / 2 - h * Math.tan(alpha) / 2, y);
    } else if (direction === DIRECTION.WEST) {
      result2 = new Point_default(x + w, y + h / 2 + w * Math.tan(alpha) / 2);
    } else {
      result2 = new Point_default(x, y + h / 2 - w * Math.tan(alpha) / 2);
    }
  } else {
    if (orthogonal) {
      const pt = new Point_default(cx, cy);
      if (next.y >= y && next.y <= y + h) {
        pt.x = vertical ? cx : direction === DIRECTION.WEST ? x + w : x;
        pt.y = next.y;
      } else if (next.x >= x && next.x <= x + w) {
        pt.x = next.x;
        pt.y = !vertical ? cy : direction === DIRECTION.NORTH ? y + h : y;
      }
      dx = next.x - pt.x;
      dy = next.y - pt.y;
      cx = pt.x;
      cy = pt.y;
    }
    if (vertical && next.x <= x + w / 2 || !vertical && next.y <= y + h / 2) {
      result2 = intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);
    } else {
      result2 = intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);
    }
  }
  if (result2 == null) {
    result2 = new Point_default(cx, cy);
  }
  return result2;
};

// node_modules/@maxgraph/core/lib/view/style/Perimeter.js
var Perimeter = {
  /**
   * Describes a rectangular perimeter.
   */
  RectanglePerimeter,
  /**
   * Describes an elliptic perimeter.
   */
  EllipsePerimeter,
  /**
   * Describes a rhombus (aka diamond) perimeter.
   */
  RhombusPerimeter,
  /**
   * Describes a triangle perimeter.
   */
  TrianglePerimeter,
  /**
   * Describes a hexagon perimeter.
   */
  HexagonPerimeter
};
var Perimeter_default = Perimeter;

// node_modules/@maxgraph/core/lib/view/style/register.js
var isDefaultsRegistered = false;
var registerDefaultStyleElements = () => {
  if (!isDefaultsRegistered) {
    StyleRegistry_default.putValue(EDGESTYLE.ELBOW, EdgeStyle_default.ElbowConnector);
    StyleRegistry_default.putValue(EDGESTYLE.ENTITY_RELATION, EdgeStyle_default.EntityRelation);
    StyleRegistry_default.putValue(EDGESTYLE.LOOP, EdgeStyle_default.Loop);
    StyleRegistry_default.putValue(EDGESTYLE.MANHATTAN, EdgeStyle_default.ManhattanConnector);
    StyleRegistry_default.putValue(EDGESTYLE.ORTHOGONAL, EdgeStyle_default.OrthConnector);
    StyleRegistry_default.putValue(EDGESTYLE.SEGMENT, EdgeStyle_default.SegmentConnector);
    StyleRegistry_default.putValue(EDGESTYLE.SIDETOSIDE, EdgeStyle_default.SideToSide);
    StyleRegistry_default.putValue(EDGESTYLE.TOPTOBOTTOM, EdgeStyle_default.TopToBottom);
    StyleRegistry_default.putValue(PERIMETER.ELLIPSE, Perimeter_default.EllipsePerimeter);
    StyleRegistry_default.putValue(PERIMETER.HEXAGON, Perimeter_default.HexagonPerimeter);
    StyleRegistry_default.putValue(PERIMETER.RECTANGLE, Perimeter_default.RectanglePerimeter);
    StyleRegistry_default.putValue(PERIMETER.RHOMBUS, Perimeter_default.RhombusPerimeter);
    StyleRegistry_default.putValue(PERIMETER.TRIANGLE, Perimeter_default.TrianglePerimeter);
    isDefaultsRegistered = true;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/CellsMixin.js
var CellsMixin = {
  cellsResizable: true,
  cellsBendable: true,
  cellsSelectable: true,
  cellsDisconnectable: true,
  autoSizeCells: false,
  autoSizeCellsOnAdd: false,
  cellsLocked: false,
  cellsCloneable: true,
  cellsDeletable: true,
  cellsMovable: true,
  extendParents: true,
  extendParentsOnAdd: true,
  extendParentsOnMove: false,
  getBoundingBox(cells) {
    let result2 = null;
    if (cells.length > 0) {
      for (const cell2 of cells) {
        if (cell2.isVertex() || cell2.isEdge()) {
          const bbox = this.getView().getBoundingBox(this.getView().getState(cell2), true);
          if (bbox) {
            if (!result2) {
              result2 = Rectangle_default.fromRectangle(bbox);
            } else {
              result2.add(bbox);
            }
          }
        }
      }
    }
    return result2;
  },
  removeStateForCell(cell2) {
    for (const child2 of cell2.getChildren()) {
      this.removeStateForCell(child2);
    }
    this.getView().invalidate(cell2, false, true);
    this.getView().removeState(cell2);
  },
  /*****************************************************************************
   * Group: Cell styles
   *****************************************************************************/
  getCurrentCellStyle(cell2, ignoreState = false) {
    const state2 = ignoreState ? null : this.getView().getState(cell2);
    return state2 ? state2.style : this.getCellStyle(cell2);
  },
  getCellStyle(cell2) {
    const cellStyle = cell2.getStyle();
    const stylesheet = this.getStylesheet();
    const defaultStyle = cell2.isEdge() ? stylesheet.getDefaultEdgeStyle() : stylesheet.getDefaultVertexStyle();
    const style2 = this.postProcessCellStyle(stylesheet.getCellStyle(cellStyle, defaultStyle ?? {}));
    return style2;
  },
  postProcessCellStyle(style2) {
    if (!style2.image) {
      return style2;
    }
    const key2 = style2.image;
    let image = this.getImageFromBundles(key2);
    if (image) {
      style2.image = image;
    } else {
      image = key2;
    }
    if (image && image.substring(0, 11) === "data:image/") {
      if (image.substring(0, 20) === "data:image/svg+xml,<") {
        image = image.substring(0, 19) + encodeURIComponent(image.substring(19));
      } else if (image.substring(0, 22) !== "data:image/svg+xml,%3C") {
        const comma = image.indexOf(",");
        if (comma > 0 && image.substring(comma - 7, comma + 1) !== ";base64,") {
          image = `${image.substring(0, comma)};base64,${image.substring(comma + 1)}`;
        }
      }
      style2.image = image;
    }
    return style2;
  },
  setCellStyle(style2, cells) {
    cells = cells ?? this.getSelectionCells();
    this.batchUpdate(() => {
      for (const cell2 of cells) {
        this.getDataModel().setStyle(cell2, style2);
      }
    });
  },
  toggleCellStyle(key2, defaultValue = false, cell2) {
    cell2 = cell2 ?? this.getSelectionCell();
    return this.toggleCellStyles(key2, defaultValue, [cell2]);
  },
  toggleCellStyles(key2, defaultValue = false, cells) {
    let value2 = false;
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 0) {
      const style2 = this.getCurrentCellStyle(cells[0]);
      value2 = style2[key2] ?? defaultValue ? false : true;
      this.setCellStyles(key2, value2, cells);
    }
    return value2;
  },
  setCellStyles(key2, value2, cells) {
    cells = cells ?? this.getSelectionCells();
    setCellStyles(this.getDataModel(), cells, key2, value2);
  },
  toggleCellStyleFlags(key2, flag, cells) {
    cells = cells ?? this.getSelectionCells();
    this.setCellStyleFlags(key2, flag, null, cells);
  },
  setCellStyleFlags(key2, flag, value2 = null, cells) {
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 0) {
      if (value2 === null) {
        const style2 = this.getCurrentCellStyle(cells[0]);
        const current = style2[key2] || 0;
        value2 = !((current & flag) === flag);
      }
      setCellStyleFlags(this.getDataModel(), cells, key2, flag, value2);
    }
  },
  /*****************************************************************************
   * Group: Cell alignment and orientation
   *****************************************************************************/
  alignCells(align, cells, param = null) {
    cells = cells ?? this.getSelectionCells();
    if (cells.length > 1) {
      if (param === null) {
        for (const cell2 of cells) {
          const state2 = this.getView().getState(cell2);
          if (state2 && !cell2.isEdge()) {
            if (param === null) {
              if (align === ALIGN.CENTER) {
                param = state2.x + state2.width / 2;
                break;
              } else if (align === ALIGN.RIGHT) {
                param = state2.x + state2.width;
              } else if (align === ALIGN.TOP) {
                param = state2.y;
              } else if (align === ALIGN.MIDDLE) {
                param = state2.y + state2.height / 2;
                break;
              } else if (align === ALIGN.BOTTOM) {
                param = state2.y + state2.height;
              } else {
                param = state2.x;
              }
            } else if (align === ALIGN.RIGHT) {
              param = Math.max(param, state2.x + state2.width);
            } else if (align === ALIGN.TOP) {
              param = Math.min(param, state2.y);
            } else if (align === ALIGN.BOTTOM) {
              param = Math.max(param, state2.y + state2.height);
            } else {
              param = Math.min(param, state2.x);
            }
          }
        }
      }
      if (param !== null) {
        const s = this.getView().scale;
        this.batchUpdate(() => {
          const p = param;
          for (const cell2 of cells) {
            const state2 = this.getView().getState(cell2);
            if (state2 != null) {
              let geo = cell2.getGeometry();
              if (geo != null && !cell2.isEdge()) {
                geo = geo.clone();
                if (align === ALIGN.CENTER) {
                  geo.x += (p - state2.x - state2.width / 2) / s;
                } else if (align === ALIGN.RIGHT) {
                  geo.x += (p - state2.x - state2.width) / s;
                } else if (align === ALIGN.TOP) {
                  geo.y += (p - state2.y) / s;
                } else if (align === ALIGN.MIDDLE) {
                  geo.y += (p - state2.y - state2.height / 2) / s;
                } else if (align === ALIGN.BOTTOM) {
                  geo.y += (p - state2.y - state2.height) / s;
                } else {
                  geo.x += (p - state2.x) / s;
                }
                this.resizeCell(cell2, geo);
              }
            }
          }
          this.fireEvent(new EventObject_default(InternalEvent_default.ALIGN_CELLS, { align, cells }));
        });
      }
    }
    return cells;
  },
  /*****************************************************************************
   * Group: Cell cloning, insertion and removal
   *****************************************************************************/
  cloneCell(cell2, allowInvalidEdges = false, mapping = {}, keepPosition = false) {
    return this.cloneCells([cell2], allowInvalidEdges, mapping, keepPosition)[0];
  },
  cloneCells(cells, allowInvalidEdges = true, mapping = {}, keepPosition = false) {
    let clones;
    const dict = new Dictionary_default();
    const tmp2 = [];
    for (const cell2 of cells) {
      dict.put(cell2, true);
      tmp2.push(cell2);
    }
    if (tmp2.length > 0) {
      const { scale } = this.getView();
      const trans = this.getView().translate;
      const out = [];
      clones = cloneCells(cells, true, mapping);
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const cell2 = cells[i2];
        const clone2 = clones[i2];
        if (!allowInvalidEdges && clone2.isEdge() && this.getEdgeValidationError(clone2, clone2.getTerminal(true), clone2.getTerminal(false)) !== null) {
        } else {
          out.push(clone2);
          const g = clone2.getGeometry();
          if (g) {
            const state2 = this.getView().getState(cell2);
            const parent2 = cell2.getParent();
            const pstate = parent2 ? this.getView().getState(parent2) : null;
            if (state2 && pstate) {
              const dx = keepPosition ? 0 : pstate.origin.x;
              const dy = keepPosition ? 0 : pstate.origin.y;
              if (clone2.isEdge()) {
                const pts = state2.absolutePoints;
                let src = cell2.getTerminal(true);
                while (src && !dict.get(src)) {
                  src = src.getParent();
                }
                if (!src && pts[0]) {
                  g.setTerminalPoint(new Point_default(pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);
                }
                let trg = cell2.getTerminal(false);
                while (trg && !dict.get(trg)) {
                  trg = trg.getParent();
                }
                const n = pts.length - 1;
                const p = pts[n];
                if (!trg && p) {
                  g.setTerminalPoint(new Point_default(p.x / scale - trans.x, p.y / scale - trans.y), false);
                }
                const { points: points2 } = g;
                if (points2) {
                  for (const point of points2) {
                    point.x += dx;
                    point.y += dy;
                  }
                }
              } else {
                g.translate(dx, dy);
              }
            }
          }
        }
      }
      clones = out;
    } else {
      clones = [];
    }
    return clones;
  },
  addCell(cell2, parent2 = null, index = null, source2 = null, target2 = null) {
    return this.addCells([cell2], parent2, index, source2, target2)[0];
  },
  addCells(cells, parent2 = null, index = null, source2 = null, target2 = null, absolute = false) {
    const p = parent2 ?? this.getDefaultParent();
    const i2 = index ?? p.getChildCount();
    this.batchUpdate(() => {
      this.cellsAdded(cells, p, i2, source2, target2, absolute, true);
      this.fireEvent(new EventObject_default(InternalEvent_default.ADD_CELLS, { cells, p, i: i2, source: source2, target: target2 }));
    });
    return cells;
  },
  cellsAdded(cells, parent2, index, source2 = null, target2 = null, absolute = false, constrain = false, extend2 = true) {
    this.batchUpdate(() => {
      const parentState = absolute ? this.getView().getState(parent2) : null;
      const o1 = parentState ? parentState.origin : null;
      const zero = new Point_default(0, 0);
      cells.forEach((cell2, i2) => {
        const previous = cell2.getParent();
        if (o1 && cell2 !== parent2 && parent2 !== previous) {
          const oldState = previous ? this.getView().getState(previous) : null;
          const o2 = oldState ? oldState.origin : zero;
          let geo = cell2.getGeometry();
          if (geo) {
            const dx = o2.x - o1.x;
            const dy = o2.y - o1.y;
            geo = geo.clone();
            geo.translate(dx, dy);
            if (!geo.relative && cell2.isVertex() && !this.isAllowNegativeCoordinates()) {
              geo.x = Math.max(0, geo.x);
              geo.y = Math.max(0, geo.y);
            }
            this.getDataModel().setGeometry(cell2, geo);
          }
        }
        if (parent2 === previous && index + i2 > parent2.getChildCount()) {
          index--;
        }
        this.getDataModel().add(parent2, cell2, index + i2);
        if (this.autoSizeCellsOnAdd) {
          this.autoSizeCell(cell2, true);
        }
        if ((!extend2 || extend2) && this.isExtendParentsOnAdd(cell2) && this.isExtendParent(cell2)) {
          this.extendParent(cell2);
        }
        if (!constrain || constrain) {
          this.constrainChild(cell2);
        }
        if (source2) {
          this.cellConnected(cell2, source2, true);
        }
        if (target2) {
          this.cellConnected(cell2, target2, false);
        }
      });
      this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_ADDED, {
        cells,
        parent: parent2,
        index,
        source: source2,
        target: target2,
        absolute
      }));
    });
  },
  autoSizeCell(cell2, recurse = true) {
    if (recurse) {
      for (const child2 of cell2.getChildren()) {
        this.autoSizeCell(child2);
      }
    }
    if (cell2.isVertex() && this.isAutoSizeCell(cell2)) {
      this.updateCellSize(cell2);
    }
  },
  removeCells(cells = null, includeEdges = true) {
    if (!cells) {
      cells = this.getDeletableCells(this.getSelectionCells());
    }
    if (includeEdges) {
      cells = this.getDeletableCells(this.addAllEdges(cells));
    } else {
      cells = cells.slice();
      const edges = this.getDeletableCells(this.getAllEdges(cells));
      const dict = new Dictionary_default();
      for (const cell2 of cells) {
        dict.put(cell2, true);
      }
      for (const edge2 of edges) {
        if (!this.getView().getState(edge2) && !dict.get(edge2)) {
          dict.put(edge2, true);
          cells.push(edge2);
        }
      }
    }
    this.batchUpdate(() => {
      this.cellsRemoved(cells);
      this.fireEvent(new EventObject_default(InternalEvent_default.REMOVE_CELLS, { cells, includeEdges }));
    });
    return cells ?? [];
  },
  cellsRemoved(cells) {
    if (cells.length > 0) {
      const { scale } = this.getView();
      const tr = this.getView().translate;
      this.batchUpdate(() => {
        const dict = new Dictionary_default();
        for (const cell2 of cells) {
          dict.put(cell2, true);
        }
        for (const cell2 of cells) {
          const edges = this.getAllEdges([cell2]);
          const disconnectTerminal = (edge2, source2) => {
            let geo = edge2.getGeometry();
            if (geo) {
              const terminal = edge2.getTerminal(source2);
              let connected = false;
              let tmp2 = terminal;
              while (tmp2) {
                if (cell2 === tmp2) {
                  connected = true;
                  break;
                }
                tmp2 = tmp2.getParent();
              }
              if (connected) {
                geo = geo.clone();
                const state2 = this.getView().getState(edge2);
                if (state2) {
                  const pts = state2.absolutePoints;
                  const n = source2 ? 0 : pts.length - 1;
                  const p = pts[n];
                  geo.setTerminalPoint(new Point_default(p.x / scale - tr.x - state2.origin.x, p.y / scale - tr.y - state2.origin.y), source2);
                } else if (terminal) {
                  const tstate = this.getView().getState(terminal);
                  if (tstate) {
                    geo.setTerminalPoint(new Point_default(tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source2);
                  }
                }
                this.getDataModel().setGeometry(edge2, geo);
                this.getDataModel().setTerminal(edge2, null, source2);
              }
            }
          };
          for (const edge2 of edges) {
            if (!dict.get(edge2)) {
              dict.put(edge2, true);
              disconnectTerminal(edge2, true);
              disconnectTerminal(edge2, false);
            }
          }
          this.getDataModel().remove(cell2);
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_REMOVED, { cells }));
      });
    }
  },
  /*****************************************************************************
   * Group: Cell visibility
   *****************************************************************************/
  toggleCells(show2 = false, cells, includeEdges = true) {
    cells = cells ?? this.getSelectionCells();
    if (includeEdges) {
      cells = this.addAllEdges(cells);
    }
    this.batchUpdate(() => {
      this.cellsToggled(cells, show2);
      this.fireEvent(new EventObject_default(InternalEvent_default.TOGGLE_CELLS, { show: show2, cells, includeEdges }));
    });
    return cells;
  },
  cellsToggled(cells, show2 = false) {
    if (cells.length > 0) {
      this.batchUpdate(() => {
        for (const cell2 of cells) {
          this.getDataModel().setVisible(cell2, show2);
        }
      });
    }
  },
  /*****************************************************************************
   * Group: Cell sizing
   *****************************************************************************/
  updateCellSize(cell2, ignoreChildren = false) {
    this.batchUpdate(() => {
      this.cellSizeUpdated(cell2, ignoreChildren);
      this.fireEvent(new EventObject_default(InternalEvent_default.UPDATE_CELL_SIZE, { cell: cell2, ignoreChildren }));
    });
    return cell2;
  },
  cellSizeUpdated(cell2, ignoreChildren = false) {
    this.batchUpdate(() => {
      const size = this.getPreferredSizeForCell(cell2);
      let geo = cell2.getGeometry();
      if (size && geo) {
        const collapsed = cell2.isCollapsed();
        geo = geo.clone();
        if (this.isSwimlane(cell2)) {
          const style2 = this.getCellStyle(cell2);
          const cellStyle = cell2.getStyle();
          if (style2.horizontal ?? true) {
            cellStyle.startSize = size.height + 8;
            if (collapsed) {
              geo.height = size.height + 8;
            }
            geo.width = size.width;
          } else {
            cellStyle.startSize = size.width + 8;
            if (collapsed) {
              geo.width = size.width + 8;
            }
            geo.height = size.height;
          }
          this.getDataModel().setStyle(cell2, cellStyle);
        } else {
          const state2 = this.getView().createState(cell2);
          const align = state2.style.align ?? ALIGN.CENTER;
          if (align === ALIGN.RIGHT) {
            geo.x += geo.width - size.width;
          } else if (align === ALIGN.CENTER) {
            geo.x += Math.round((geo.width - size.width) / 2);
          }
          const valign = state2.getVerticalAlign();
          if (valign === ALIGN.BOTTOM) {
            geo.y += geo.height - size.height;
          } else if (valign === ALIGN.MIDDLE) {
            geo.y += Math.round((geo.height - size.height) / 2);
          }
          geo.width = size.width;
          geo.height = size.height;
        }
        if (!ignoreChildren && !collapsed) {
          const bounds = this.getView().getBounds(cell2.getChildren());
          if (bounds != null) {
            const tr = this.getView().translate;
            const { scale } = this.getView();
            const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;
            const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;
            geo.width = Math.max(geo.width, width);
            geo.height = Math.max(geo.height, height);
          }
        }
        this.cellsResized([cell2], [geo], false);
      }
    });
  },
  getPreferredSizeForCell(cell2, textWidth = null) {
    let result2 = null;
    const state2 = this.getView().createState(cell2);
    const { style: style2 } = state2;
    if (!cell2.isEdge()) {
      const fontSize = style2.fontSize || DEFAULT_FONTSIZE;
      let dx = 0;
      let dy = 0;
      if (state2.getImageSrc() || style2.image) {
        if (style2.shape === SHAPE.LABEL) {
          if (style2.verticalAlign === ALIGN.MIDDLE) {
            dx += style2.imageWidth || DEFAULT_IMAGESIZE;
          }
          if (style2.align !== ALIGN.CENTER) {
            dy += style2.imageHeight || DEFAULT_IMAGESIZE;
          }
        }
      }
      dx += 2 * (style2.spacing || 0);
      dx += style2.spacingLeft || 0;
      dx += style2.spacingRight || 0;
      dy += 2 * (style2.spacing || 0);
      dy += style2.spacingTop || 0;
      dy += style2.spacingBottom || 0;
      const image = this.getFoldingImage(state2);
      if (image) {
        dx += image.width + 8;
      }
      let value2 = this.getCellRenderer().getLabelValue(state2);
      if (value2 && value2.length > 0) {
        if (!this.isHtmlLabel(state2.cell)) {
          value2 = htmlEntities(value2, false);
        }
        value2 = value2.replace(/\n/g, "<br>");
        const size = getSizeForString(value2, fontSize, style2.fontFamily, textWidth, style2.fontStyle);
        let width = size.width + dx;
        let height = size.height + dy;
        if (!(style2.horizontal ?? true)) {
          const tmp2 = height;
          height = width;
          width = tmp2;
        }
        if (this.isGridEnabled()) {
          width = this.snap(width + this.getGridSize() / 2);
          height = this.snap(height + this.getGridSize() / 2);
        }
        result2 = new Rectangle_default(0, 0, width, height);
      } else {
        const gs2 = 4 * this.getGridSize();
        result2 = new Rectangle_default(0, 0, gs2, gs2);
      }
    }
    return result2;
  },
  resizeCell(cell2, bounds, recurse = false) {
    return this.resizeCells([cell2], [bounds], recurse)[0];
  },
  resizeCells(cells, bounds, recurse) {
    recurse = recurse ?? this.isRecursiveResize();
    this.batchUpdate(() => {
      const prev = this.cellsResized(cells, bounds, recurse);
      this.fireEvent(new EventObject_default(InternalEvent_default.RESIZE_CELLS, { cells, bounds, prev }));
    });
    return cells;
  },
  cellsResized(cells, bounds, recurse = false) {
    const prev = [];
    if (cells.length === bounds.length) {
      this.batchUpdate(() => {
        cells.forEach((cell2, i2) => {
          prev.push(this.cellResized(cell2, bounds[i2], false, recurse));
          if (this.isExtendParent(cell2)) {
            this.extendParent(cell2);
          }
          this.constrainChild(cell2);
        });
        if (this.isResetEdgesOnResize()) {
          this.resetEdges(cells);
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_RESIZED, { cells, bounds, prev }));
      });
    }
    return prev;
  },
  cellResized(cell2, bounds, ignoreRelative = false, recurse = false) {
    const prev = cell2.getGeometry();
    if (prev && (prev.x !== bounds.x || prev.y !== bounds.y || prev.width !== bounds.width || prev.height !== bounds.height)) {
      const geo = prev.clone();
      if (!ignoreRelative && geo.relative) {
        const { offset } = geo;
        if (offset) {
          offset.x += bounds.x - geo.x;
          offset.y += bounds.y - geo.y;
        }
      } else {
        geo.x = bounds.x;
        geo.y = bounds.y;
      }
      geo.width = bounds.width;
      geo.height = bounds.height;
      if (!geo.relative && cell2.isVertex() && !this.isAllowNegativeCoordinates()) {
        geo.x = Math.max(0, geo.x);
        geo.y = Math.max(0, geo.y);
      }
      this.batchUpdate(() => {
        if (recurse) {
          this.resizeChildCells(cell2, geo);
        }
        this.getDataModel().setGeometry(cell2, geo);
        this.constrainChildCells(cell2);
      });
    }
    return prev;
  },
  resizeChildCells(cell2, newGeo) {
    const geo = cell2.getGeometry();
    if (geo) {
      const dx = geo.width !== 0 ? newGeo.width / geo.width : 1;
      const dy = geo.height !== 0 ? newGeo.height / geo.height : 1;
      for (const child2 of cell2.getChildren()) {
        this.scaleCell(child2, dx, dy, true);
      }
    }
  },
  constrainChildCells(cell2) {
    for (const child2 of cell2.getChildren()) {
      this.constrainChild(child2);
    }
  },
  scaleCell(cell2, dx, dy, recurse = false) {
    let geo = cell2.getGeometry();
    if (geo) {
      const style2 = this.getCurrentCellStyle(cell2);
      geo = geo.clone();
      const { x } = geo;
      const { y } = geo;
      const w = geo.width;
      const h = geo.height;
      geo.scale(dx, dy, style2.aspect === "fixed");
      if (style2.resizeWidth) {
        geo.width = w * dx;
      } else if (!style2.resizeWidth) {
        geo.width = w;
      }
      if (style2.resizeHeight) {
        geo.height = h * dy;
      } else if (!style2.resizeHeight) {
        geo.height = h;
      }
      if (!this.isCellMovable(cell2)) {
        geo.x = x;
        geo.y = y;
      }
      if (!this.isCellResizable(cell2)) {
        geo.width = w;
        geo.height = h;
      }
      if (cell2.isVertex()) {
        this.cellResized(cell2, geo, true, recurse);
      } else {
        this.getDataModel().setGeometry(cell2, geo);
      }
    }
  },
  extendParent(cell2) {
    const parent2 = cell2.getParent();
    let p = parent2 ? parent2.getGeometry() : null;
    if (parent2 && p && !parent2.isCollapsed()) {
      const geo = cell2.getGeometry();
      if (geo && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {
        p = p.clone();
        p.width = Math.max(p.width, geo.x + geo.width);
        p.height = Math.max(p.height, geo.y + geo.height);
        this.cellsResized([parent2], [p], false);
      }
    }
  },
  // *************************************************************************************
  // Group: Cell moving
  // *************************************************************************************
  importCells(cells, dx, dy, target2 = null, evt2 = null, mapping = {}) {
    return this.moveCells(cells, dx, dy, true, target2, evt2, mapping);
  },
  moveCells(cells, dx = 0, dy = 0, clone2 = false, target2 = null, evt2 = null, mapping = {}) {
    if (dx !== 0 || dy !== 0 || clone2 || target2) {
      cells = getTopmostCells(cells);
      const origCells = cells;
      this.batchUpdate(() => {
        const dict = new Dictionary_default();
        for (const cell2 of cells) {
          dict.put(cell2, true);
        }
        const isSelected = (cell2) => {
          while (cell2) {
            if (dict.get(cell2)) {
              return true;
            }
            cell2 = cell2.getParent();
          }
          return false;
        };
        const checked = [];
        for (const cell2 of cells) {
          const geo = cell2.getGeometry();
          const parent2 = cell2.getParent();
          if (!geo || !geo.relative || parent2 && !parent2.isEdge() || parent2 && !isSelected(parent2.getTerminal(true)) && !isSelected(parent2.getTerminal(false))) {
            checked.push(cell2);
          }
        }
        cells = checked;
        if (clone2) {
          cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);
          if (!target2) {
            target2 = this.getDefaultParent();
          }
        }
        const previous = this.isAllowNegativeCoordinates();
        if (target2) {
          this.setAllowNegativeCoordinates(true);
        }
        this.cellsMoved(cells, dx, dy, !clone2 && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), !target2, this.isExtendParentsOnMove() && !target2);
        this.setAllowNegativeCoordinates(previous);
        if (target2) {
          const index = target2.getChildCount();
          this.cellsAdded(cells, target2, index, null, null, true);
          if (clone2) {
            cells.forEach((cell2, i2) => {
              const geo = cell2.getGeometry();
              const parent2 = origCells[i2].getParent();
              if (geo && geo.relative && parent2 && parent2.isEdge() && this.getDataModel().contains(parent2)) {
                this.getDataModel().add(parent2, cell2);
              }
            });
          }
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.MOVE_CELLS, {
          cells,
          dx,
          dy,
          clone: clone2,
          target: target2,
          event: evt2
        }));
      });
    }
    return cells;
  },
  cellsMoved(cells, dx, dy, disconnect = false, constrain = false, extend2 = false) {
    if (dx !== 0 || dy !== 0) {
      this.batchUpdate(() => {
        if (disconnect) {
          this.disconnectGraph(cells);
        }
        for (const cell2 of cells) {
          this.translateCell(cell2, dx, dy);
          if (extend2 && this.isExtendParent(cell2)) {
            this.extendParent(cell2);
          } else if (constrain) {
            this.constrainChild(cell2);
          }
        }
        if (this.isResetEdgesOnMove()) {
          this.resetEdges(cells);
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_MOVED, { cells, dx, dy, disconnect }));
      });
    }
  },
  translateCell(cell2, dx, dy) {
    let geometry = cell2.getGeometry();
    if (geometry) {
      geometry = geometry.clone();
      geometry.translate(dx, dy);
      if (!geometry.relative && cell2.isVertex() && !this.isAllowNegativeCoordinates()) {
        geometry.x = Math.max(0, geometry.x);
        geometry.y = Math.max(0, geometry.y);
      }
      if (geometry.relative && !cell2.isEdge()) {
        const parent2 = cell2.getParent();
        let angle = 0;
        if (parent2.isVertex()) {
          const style2 = this.getCurrentCellStyle(parent2);
          angle = style2.rotation ?? 0;
        }
        if (angle !== 0) {
          const rad = toRadians(-angle);
          const cos = Math.cos(rad);
          const sin = Math.sin(rad);
          const pt = getRotatedPoint(new Point_default(dx, dy), cos, sin, new Point_default(0, 0));
          dx = pt.x;
          dy = pt.y;
        }
        if (!geometry.offset) {
          geometry.offset = new Point_default(dx, dy);
        } else {
          geometry.offset.x = geometry.offset.x + dx;
          geometry.offset.y = geometry.offset.y + dy;
        }
      }
      this.getDataModel().setGeometry(cell2, geometry);
    }
  },
  getCellContainmentArea(cell2) {
    if (!cell2.isEdge()) {
      const parent2 = cell2.getParent();
      if (parent2 && parent2 !== this.getDefaultParent()) {
        const g = parent2.getGeometry();
        if (g) {
          let x = 0;
          let y = 0;
          let w = g.width;
          let h = g.height;
          if (this.isSwimlane(parent2)) {
            const size = this.getStartSize(parent2);
            const style2 = this.getCurrentCellStyle(parent2);
            const dir = style2.direction ?? DIRECTION.EAST;
            const flipH = style2.flipH ?? false;
            const flipV = style2.flipV ?? false;
            if (dir === DIRECTION.SOUTH || dir === DIRECTION.NORTH) {
              const tmp2 = size.width;
              size.width = size.height;
              size.height = tmp2;
            }
            if (dir === DIRECTION.EAST && !flipV || dir === DIRECTION.NORTH && !flipH || dir === DIRECTION.WEST && flipV || dir === DIRECTION.SOUTH && flipH) {
              x = size.width;
              y = size.height;
            }
            w -= size.width;
            h -= size.height;
          }
          return new Rectangle_default(x, y, w, h);
        }
      }
    }
    return null;
  },
  constrainChild(cell2, sizeFirst = true) {
    let geo = cell2.getGeometry();
    if (geo && (this.isConstrainRelativeChildren() || !geo.relative)) {
      const parent2 = cell2.getParent();
      let max = this.getMaximumGraphBounds();
      if (max && parent2) {
        const off = this.getBoundingBoxFromGeometry([parent2], false);
        if (off) {
          max = Rectangle_default.fromRectangle(max);
          max.x -= off.x;
          max.y -= off.y;
        }
      }
      if (this.isConstrainChild(cell2)) {
        let tmp2 = this.getCellContainmentArea(cell2);
        if (tmp2) {
          const overlap = this.getOverlap(cell2);
          if (overlap > 0) {
            tmp2 = Rectangle_default.fromRectangle(tmp2);
            tmp2.x -= tmp2.width * overlap;
            tmp2.y -= tmp2.height * overlap;
            tmp2.width += 2 * tmp2.width * overlap;
            tmp2.height += 2 * tmp2.height * overlap;
          }
          if (!max) {
            max = tmp2;
          } else {
            max = Rectangle_default.fromRectangle(max);
            max.intersect(tmp2);
          }
        }
      }
      if (max) {
        const cells = [cell2];
        if (!cell2.isCollapsed()) {
          const desc = cell2.getDescendants();
          for (const descItem of desc) {
            if (descItem.isVisible()) {
              cells.push(descItem);
            }
          }
        }
        const bbox = this.getBoundingBoxFromGeometry(cells, false);
        if (bbox) {
          geo = geo.clone();
          let dx = 0;
          if (geo.width > max.width) {
            dx = geo.width - max.width;
            geo.width -= dx;
          }
          if (bbox.x + bbox.width > max.x + max.width) {
            dx -= bbox.x + bbox.width - max.x - max.width - dx;
          }
          let dy = 0;
          if (geo.height > max.height) {
            dy = geo.height - max.height;
            geo.height -= dy;
          }
          if (bbox.y + bbox.height > max.y + max.height) {
            dy -= bbox.y + bbox.height - max.y - max.height - dy;
          }
          if (bbox.x < max.x) {
            dx -= bbox.x - max.x;
          }
          if (bbox.y < max.y) {
            dy -= bbox.y - max.y;
          }
          if (dx !== 0 || dy !== 0) {
            if (geo.relative) {
              if (!geo.offset) {
                geo.offset = new Point_default();
              }
              geo.offset.x += dx;
              geo.offset.y += dy;
            } else {
              geo.x += dx;
              geo.y += dy;
            }
          }
          this.getDataModel().setGeometry(cell2, geo);
        }
      }
    }
  },
  /*****************************************************************************
   * Group: Cell retrieval
   *****************************************************************************/
  getChildCells(parent2, vertices = false, edges = false) {
    parent2 = parent2 ?? this.getDefaultParent();
    const cells = parent2.getChildCells(vertices, edges);
    const result2 = [];
    for (const cell2 of cells) {
      if (cell2.isVisible()) {
        result2.push(cell2);
      }
    }
    return result2;
  },
  getCellAt(x, y, parent2 = null, vertices = true, edges = true, ignoreFn = null) {
    if (!parent2) {
      parent2 = this.getCurrentRoot();
      if (!parent2) {
        parent2 = this.getDataModel().getRoot();
      }
    }
    if (parent2) {
      const childCount2 = parent2.getChildCount();
      for (let i2 = childCount2 - 1; i2 >= 0; i2--) {
        const cell2 = parent2.getChildAt(i2);
        const result2 = this.getCellAt(x, y, cell2, vertices, edges, ignoreFn);
        if (result2) {
          return result2;
        }
        if (cell2.isVisible() && (edges && cell2.isEdge() || vertices && cell2.isVertex())) {
          const state2 = this.getView().getState(cell2);
          if (state2 && (!ignoreFn || !ignoreFn(state2, x, y)) && this.intersects(state2, x, y)) {
            return cell2;
          }
        }
      }
    }
    return null;
  },
  getCells(x, y, width, height, parent2 = null, result2 = [], intersection2 = null, ignoreFn = null, includeDescendants = false) {
    if (width > 0 || height > 0 || intersection2) {
      const model2 = this.getDataModel();
      const right = x + width;
      const bottom = y + height;
      if (!parent2) {
        parent2 = this.getCurrentRoot();
        if (!parent2) {
          parent2 = model2.getRoot();
        }
      }
      if (parent2) {
        for (const cell2 of parent2.getChildren()) {
          const state2 = this.getView().getState(cell2);
          if (state2 && cell2.isVisible() && (!ignoreFn || !ignoreFn(state2))) {
            const deg = state2.style.rotation ?? 0;
            let box = state2;
            if (deg !== 0) {
              box = getBoundingBox(box, deg);
            }
            const hit = intersection2 && cell2.isVertex() && intersects2(intersection2, box) || !intersection2 && (cell2.isEdge() || cell2.isVertex()) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right;
            if (hit) {
              result2.push(cell2);
            }
            if (!hit || includeDescendants) {
              this.getCells(x, y, width, height, cell2, result2, intersection2, ignoreFn, includeDescendants);
            }
          }
        }
      }
    }
    return result2;
  },
  getCellsBeyond(x0, y0, parent2 = null, rightHalfpane = false, bottomHalfpane = false) {
    const result2 = [];
    if (rightHalfpane || bottomHalfpane) {
      if (!parent2) {
        parent2 = this.getDefaultParent();
      }
      if (parent2) {
        for (const child2 of parent2.getChildren()) {
          const state2 = this.getView().getState(child2);
          if (child2.isVisible() && state2) {
            if ((!rightHalfpane || state2.x >= x0) && (!bottomHalfpane || state2.y >= y0)) {
              result2.push(child2);
            }
          }
        }
      }
    }
    return result2;
  },
  intersects(state2, x, y) {
    const pts = state2.absolutePoints;
    if (pts.length > 0) {
      const t2 = this.getEventTolerance() * this.getEventTolerance();
      let pt = pts[0];
      for (let i2 = 1; i2 < pts.length; i2 += 1) {
        const next = pts[i2];
        if (pt && next) {
          const dist = ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);
          if (dist <= t2) {
            return true;
          }
        }
        pt = next;
      }
    } else {
      const alpha = toRadians(state2.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        const cx = new Point_default(state2.getCenterX(), state2.getCenterY());
        const pt = getRotatedPoint(new Point_default(x, y), cos, sin, cx);
        x = pt.x;
        y = pt.y;
      }
      if (contains(state2, x, y)) {
        return true;
      }
    }
    return false;
  },
  isValidAncestor(cell2, parent2, recurse = false) {
    return recurse ? parent2.isAncestor(cell2) : cell2.getParent() === parent2;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isCellLocked(cell2) {
    const geometry = cell2.getGeometry();
    return this.isCellsLocked() || !!geometry && cell2.isVertex() && geometry.relative;
  },
  isCellsLocked() {
    return this.cellsLocked;
  },
  setCellsLocked(value2) {
    this.cellsLocked = value2;
  },
  getCloneableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.isCellCloneable(cell2);
    });
  },
  isCellCloneable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    const cloneable = style2.cloneable == null ? true : style2.cloneable;
    return this.isCellsCloneable() && cloneable;
  },
  isCellsCloneable() {
    return this.cellsCloneable;
  },
  setCellsCloneable(value2) {
    this.cellsCloneable = value2;
  },
  getExportableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.canExportCell(cell2);
    });
  },
  canExportCell(_cell = null) {
    return this.isExportEnabled();
  },
  getImportableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.canImportCell(cell2);
    });
  },
  canImportCell(cell2 = null) {
    return this.isImportEnabled();
  },
  isCellSelectable(_cell) {
    return this.isCellsSelectable();
  },
  isCellsSelectable() {
    return this.cellsSelectable;
  },
  setCellsSelectable(value2) {
    this.cellsSelectable = value2;
  },
  getDeletableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.isCellDeletable(cell2);
    });
  },
  isCellDeletable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    const deletable = style2.deletable == null ? true : style2.deletable;
    return this.isCellsDeletable() && deletable;
  },
  isCellsDeletable() {
    return this.cellsDeletable;
  },
  setCellsDeletable(value2) {
    this.cellsDeletable = value2;
  },
  isCellRotatable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return style2.rotatable == null ? true : style2.rotatable;
  },
  getMovableCells(cells) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.isCellMovable(cell2);
    });
  },
  isCellMovable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return this.isCellsMovable() && !this.isCellLocked(cell2) && (style2.movable ?? true);
  },
  isCellsMovable() {
    return this.cellsMovable;
  },
  setCellsMovable(value2) {
    this.cellsMovable = value2;
  },
  isCellResizable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return this.isCellsResizable() && !this.isCellLocked(cell2) && (style2.resizable ?? true);
  },
  isCellsResizable() {
    return this.cellsResizable;
  },
  setCellsResizable(value2) {
    this.cellsResizable = value2;
  },
  isCellBendable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return this.isCellsBendable() && !this.isCellLocked(cell2) && style2.bendable != false;
  },
  isCellsBendable() {
    return this.cellsBendable;
  },
  setCellsBendable(value2) {
    this.cellsBendable = value2;
  },
  isAutoSizeCell(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return this.isAutoSizeCells() || (style2.autoSize ?? false);
  },
  isAutoSizeCells() {
    return this.autoSizeCells;
  },
  setAutoSizeCells(value2) {
    this.autoSizeCells = value2;
  },
  isExtendParent(cell2) {
    return !cell2.isEdge() && this.isExtendParents();
  },
  isExtendParents() {
    return this.extendParents;
  },
  setExtendParents(value2) {
    this.extendParents = value2;
  },
  isExtendParentsOnAdd(cell2) {
    return this.extendParentsOnAdd;
  },
  setExtendParentsOnAdd(value2) {
    this.extendParentsOnAdd = value2;
  },
  isExtendParentsOnMove() {
    return this.extendParentsOnMove;
  },
  setExtendParentsOnMove(value2) {
    this.extendParentsOnMove = value2;
  },
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  getCursorForCell(_cell) {
    return null;
  },
  /*****************************************************************************
   * Group: Graph display
   *****************************************************************************/
  getCellBounds(cell2, includeEdges = false, includeDescendants = false) {
    let cells = [cell2];
    if (includeEdges) {
      cells = cells.concat(cell2.getEdges());
    }
    let result2 = this.getView().getBounds(cells);
    if (includeDescendants) {
      for (const child2 of cell2.getChildren()) {
        const tmp2 = this.getCellBounds(child2, includeEdges, true);
        if (result2 && tmp2) {
          result2.add(tmp2);
        } else {
          result2 = tmp2;
        }
      }
    }
    return result2;
  },
  getBoundingBoxFromGeometry(cells, includeEdges = false) {
    let result2 = null;
    let tmp2 = null;
    for (const cell2 of cells) {
      if (includeEdges || cell2.isVertex()) {
        const geo = cell2.getGeometry();
        if (geo) {
          let bbox = null;
          if (cell2.isEdge()) {
            const addPoint = (pt) => {
              if (pt) {
                if (!tmp2) {
                  tmp2 = new Rectangle_default(pt.x, pt.y, 0, 0);
                } else {
                  tmp2.add(new Rectangle_default(pt.x, pt.y, 0, 0));
                }
              }
            };
            if (!cell2.getTerminal(true)) {
              addPoint(geo.getTerminalPoint(true));
            }
            if (!cell2.getTerminal(false)) {
              addPoint(geo.getTerminalPoint(false));
            }
            const pts = geo.points;
            if (pts && pts.length > 0) {
              tmp2 = new Rectangle_default(pts[0].x, pts[0].y, 0, 0);
              for (let j = 1; j < pts.length; j++) {
                addPoint(pts[j]);
              }
            }
            bbox = tmp2;
          } else {
            const parent2 = cell2.getParent();
            if (geo.relative && parent2) {
              if (parent2.isVertex() && parent2 !== this.getView().currentRoot) {
                tmp2 = this.getBoundingBoxFromGeometry([parent2], false);
                if (tmp2) {
                  bbox = new Rectangle_default(geo.x * tmp2.width, geo.y * tmp2.height, geo.width, geo.height);
                  if (cells.indexOf(parent2) >= 0) {
                    bbox.x += tmp2.x;
                    bbox.y += tmp2.y;
                  }
                }
              }
            } else {
              bbox = Rectangle_default.fromRectangle(geo);
              if (parent2 && parent2.isVertex() && cells.indexOf(parent2) >= 0) {
                tmp2 = this.getBoundingBoxFromGeometry([parent2], false);
                if (tmp2) {
                  bbox.x += tmp2.x;
                  bbox.y += tmp2.y;
                }
              }
            }
            if (bbox && geo.offset) {
              bbox.x += geo.offset.x;
              bbox.y += geo.offset.y;
            }
            const style2 = this.getCurrentCellStyle(cell2);
            if (bbox) {
              const angle = style2.rotation ?? 0;
              if (angle !== 0) {
                bbox = getBoundingBox(bbox, angle);
              }
            }
          }
          if (bbox) {
            if (!result2) {
              result2 = Rectangle_default.fromRectangle(bbox);
            } else {
              result2.add(bbox);
            }
          }
        }
      }
    }
    return result2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/ConnectionsMixin.js
var ConnectionsMixin = {
  /*****************************************************************************
   * Group: Cell connecting and connection constraints
   *****************************************************************************/
  constrainChildren: true,
  constrainRelativeChildren: false,
  disconnectOnMove: true,
  cellsDisconnectable: true,
  getOutlineConstraint(point, terminalState, me) {
    if (terminalState.shape) {
      const bounds = this.getView().getPerimeterBounds(terminalState);
      const direction = terminalState.style.direction;
      if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
        bounds.x += bounds.width / 2 - bounds.height / 2;
        bounds.y += bounds.height / 2 - bounds.width / 2;
        const tmp2 = bounds.width;
        bounds.width = bounds.height;
        bounds.height = tmp2;
      }
      const alpha = toRadians(terminalState.shape.getShapeRotation());
      if (alpha !== 0) {
        const cos = Math.cos(-alpha);
        const sin = Math.sin(-alpha);
        const ct = new Point_default(bounds.getCenterX(), bounds.getCenterY());
        point = getRotatedPoint(point, cos, sin, ct);
      }
      let sx = 1;
      let sy = 1;
      let dx = 0;
      let dy = 0;
      if (terminalState.cell.isVertex()) {
        let flipH = terminalState.style.flipH;
        let flipV = terminalState.style.flipV;
        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
          const tmp2 = flipH;
          flipH = flipV;
          flipV = tmp2;
        }
        if (flipH) {
          sx = -1;
          dx = -bounds.width;
        }
        if (flipV) {
          sy = -1;
          dy = -bounds.height;
        }
      }
      point = new Point_default((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);
      const x = bounds.width === 0 ? 0 : Math.round((point.x - bounds.x) * 1e3 / bounds.width) / 1e3;
      const y = bounds.height === 0 ? 0 : Math.round((point.y - bounds.y) * 1e3 / bounds.height) / 1e3;
      return new ConnectionConstraint_default(new Point_default(x, y), false);
    }
    return null;
  },
  getAllConnectionConstraints(terminal, source2) {
    var _a2, _b;
    return ((_b = (_a2 = terminal == null ? void 0 : terminal.shape) == null ? void 0 : _a2.stencil) == null ? void 0 : _b.constraints) ?? null;
  },
  getConnectionConstraint(edge2, terminal, source2 = false) {
    let point = null;
    const x = edge2.style[source2 ? "exitX" : "entryX"];
    if (x !== void 0) {
      const y = edge2.style[source2 ? "exitY" : "entryY"];
      if (y !== void 0) {
        point = new Point_default(x, y);
      }
    }
    let perimeter2 = false;
    let dx = 0;
    let dy = 0;
    if (point) {
      perimeter2 = edge2.style[source2 ? "exitPerimeter" : "entryPerimeter"] || false;
      dx = edge2.style[source2 ? "exitDx" : "entryDx"];
      dy = edge2.style[source2 ? "exitDy" : "entryDy"];
      dx = Number.isFinite(dx) ? dx : 0;
      dy = Number.isFinite(dy) ? dy : 0;
    }
    return new ConnectionConstraint_default(point, perimeter2, null, dx, dy);
  },
  setConnectionConstraint(edge2, terminal, source2 = false, constraint = null) {
    if (constraint) {
      this.batchUpdate(() => {
        if (!constraint || !constraint.point) {
          this.setCellStyles(source2 ? "exitX" : "entryX", null, [edge2]);
          this.setCellStyles(source2 ? "exitY" : "entryY", null, [edge2]);
          this.setCellStyles(source2 ? "exitDx" : "entryDx", null, [edge2]);
          this.setCellStyles(source2 ? "exitDy" : "entryDy", null, [edge2]);
          this.setCellStyles(source2 ? "exitPerimeter" : "entryPerimeter", null, [edge2]);
        } else if (constraint.point) {
          this.setCellStyles(source2 ? "exitX" : "entryX", constraint.point.x, [edge2]);
          this.setCellStyles(source2 ? "exitY" : "entryY", constraint.point.y, [edge2]);
          this.setCellStyles(source2 ? "exitDx" : "entryDx", constraint.dx, [edge2]);
          this.setCellStyles(source2 ? "exitDy" : "entryDy", constraint.dy, [edge2]);
          if (!constraint.perimeter) {
            this.setCellStyles(source2 ? "exitPerimeter" : "entryPerimeter", "0", [edge2]);
          } else {
            this.setCellStyles(source2 ? "exitPerimeter" : "entryPerimeter", null, [edge2]);
          }
        }
      });
    }
  },
  getConnectionPoint(vertex, constraint, round = true) {
    let point = null;
    if (constraint.point) {
      const bounds = this.getView().getPerimeterBounds(vertex);
      const cx = new Point_default(bounds.getCenterX(), bounds.getCenterY());
      const direction = vertex.style.direction;
      let r1 = 0;
      if (vertex.style.anchorPointDirection) {
        if (direction === DIRECTION.NORTH) {
          r1 += 270;
        } else if (direction === DIRECTION.WEST) {
          r1 += 180;
        } else if (direction === DIRECTION.SOUTH) {
          r1 += 90;
        }
        if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
          bounds.rotate90();
        }
      }
      const { scale } = this.getView();
      point = new Point_default(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);
      let r2 = vertex.style.rotation || 0;
      if (constraint.perimeter) {
        if (r1 !== 0) {
          let cos = 0;
          let sin = 0;
          if (r1 === 90) {
            sin = 1;
          } else if (r1 === 180) {
            cos = -1;
          } else if (r1 === 270) {
            sin = -1;
          }
          point = getRotatedPoint(point, cos, sin, cx);
        }
        point = this.getView().getPerimeterPoint(vertex, point, false);
      } else {
        r2 += r1;
        if (vertex.cell.isVertex()) {
          let flipH = vertex.style.flipH;
          let flipV = vertex.style.flipV;
          if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {
            const temp = flipH;
            flipH = flipV;
            flipV = temp;
          }
          if (flipH) {
            point.x = 2 * bounds.getCenterX() - point.x;
          }
          if (flipV) {
            point.y = 2 * bounds.getCenterY() - point.y;
          }
        }
      }
      if (r2 !== 0 && point) {
        const rad = toRadians(r2);
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        point = getRotatedPoint(point, cos, sin, cx);
      }
    }
    if (round && point) {
      point.x = Math.round(point.x);
      point.y = Math.round(point.y);
    }
    return point;
  },
  connectCell(edge2, terminal = null, source2 = false, constraint = null) {
    this.batchUpdate(() => {
      const previous = edge2.getTerminal(source2);
      this.cellConnected(edge2, terminal, source2, constraint);
      this.fireEvent(new EventObject_default(InternalEvent_default.CONNECT_CELL, "edge", edge2, "terminal", terminal, "source", source2, "previous", previous));
    });
    return edge2;
  },
  cellConnected(edge2, terminal, source2 = false, constraint = null) {
    this.batchUpdate(() => {
      const previous = edge2.getTerminal(source2);
      this.setConnectionConstraint(edge2, terminal, source2, constraint);
      if (this.isPortsEnabled()) {
        let id2 = null;
        if (terminal && this.isPort(terminal)) {
          id2 = terminal.getId();
          terminal = this.getTerminalForPort(terminal, source2);
        }
        const key2 = source2 ? "sourcePort" : "targetPort";
        this.setCellStyles(key2, id2, [edge2]);
      }
      this.getDataModel().setTerminal(edge2, terminal, source2);
      if (this.isResetEdgesOnConnect()) {
        this.resetEdge(edge2);
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.CELL_CONNECTED, "edge", edge2, "terminal", terminal, "source", source2, "previous", previous));
    });
  },
  disconnectGraph(cells) {
    this.batchUpdate(() => {
      const { scale, translate: tr } = this.getView();
      const dict = new Dictionary_default();
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        dict.put(cells[i2], true);
      }
      for (const cell2 of cells) {
        if (cell2.isEdge()) {
          let geo = cell2.getGeometry();
          if (geo) {
            const state2 = this.getView().getState(cell2);
            const parent2 = cell2.getParent();
            const pstate = parent2 ? this.getView().getState(parent2) : null;
            if (state2 && pstate) {
              geo = geo.clone();
              const dx = -pstate.origin.x;
              const dy = -pstate.origin.y;
              const pts = state2.absolutePoints;
              let src = cell2.getTerminal(true);
              if (src && this.isCellDisconnectable(cell2, src, true)) {
                while (src && !dict.get(src)) {
                  src = src.getParent();
                }
                if (!src && pts[0]) {
                  geo.setTerminalPoint(new Point_default(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);
                  this.getDataModel().setTerminal(cell2, null, true);
                }
              }
              let trg = cell2.getTerminal(false);
              if (trg && this.isCellDisconnectable(cell2, trg, false)) {
                while (trg && !dict.get(trg)) {
                  trg = trg.getParent();
                }
                if (!trg) {
                  const n = pts.length - 1;
                  const p = pts[n];
                  if (p) {
                    geo.setTerminalPoint(new Point_default(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);
                    this.getDataModel().setTerminal(cell2, null, false);
                  }
                }
              }
              this.getDataModel().setGeometry(cell2, geo);
            }
          }
        }
      }
    });
  },
  getConnections(cell2, parent2 = null) {
    return this.getEdges(cell2, parent2, true, true, false);
  },
  isConstrainChild(cell2) {
    return this.isConstrainChildren() && !!cell2.getParent() && !cell2.getParent().isEdge();
  },
  isConstrainChildren() {
    return this.constrainChildren;
  },
  setConstrainChildren(value2) {
    this.constrainChildren = value2;
  },
  isConstrainRelativeChildren() {
    return this.constrainRelativeChildren;
  },
  setConstrainRelativeChildren(value2) {
    this.constrainRelativeChildren = value2;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isDisconnectOnMove() {
    return this.disconnectOnMove;
  },
  setDisconnectOnMove(value2) {
    this.disconnectOnMove = value2;
  },
  isCellDisconnectable(cell2, terminal = null, source2 = false) {
    return this.isCellsDisconnectable() && !this.isCellLocked(cell2);
  },
  isCellsDisconnectable() {
    return this.cellsDisconnectable;
  },
  setCellsDisconnectable(value2) {
    this.cellsDisconnectable = value2;
  },
  isValidSource(cell2) {
    return cell2 == null && this.isAllowDanglingEdges() || cell2 != null && (!cell2.isEdge() || this.isConnectableEdges()) && cell2.isConnectable();
  },
  isValidTarget(cell2) {
    return this.isValidSource(cell2);
  },
  isValidConnection(source2, target2) {
    return this.isValidSource(source2) && this.isValidTarget(target2);
  },
  setConnectable(connectable) {
    const connectionHandler = this.getPlugin("ConnectionHandler");
    connectionHandler == null ? void 0 : connectionHandler.setEnabled(connectable);
  },
  isConnectable() {
    const connectionHandler = this.getPlugin("ConnectionHandler");
    return (connectionHandler == null ? void 0 : connectionHandler.isEnabled()) ?? false;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/DragDropMixin.js
var DragDropMixin = {
  dropEnabled: false,
  splitEnabled: true,
  autoScroll: true,
  isAutoScroll() {
    return this.autoScroll;
  },
  autoExtend: true,
  isAutoExtend() {
    return this.autoExtend;
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isDropEnabled() {
    return this.dropEnabled;
  },
  setDropEnabled(value2) {
    this.dropEnabled = value2;
  },
  /*****************************************************************************
   * Group: Split behaviour
   *****************************************************************************/
  isSplitEnabled() {
    return this.splitEnabled;
  },
  setSplitEnabled(value2) {
    this.splitEnabled = value2;
  },
  isSplitTarget(target2, cells = [], evt2) {
    if (target2.isEdge() && cells.length === 1 && cells[0].isConnectable() && !this.getEdgeValidationError(target2, target2.getTerminal(true), cells[0])) {
      const src = target2.getTerminal(true);
      const trg = target2.getTerminal(false);
      return !cells[0].isAncestor(src) && !cells[0].isAncestor(trg);
    }
    return false;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/EdgeMixin.js
var EdgeMixin = {
  resetEdgesOnResize: false,
  isResetEdgesOnResize() {
    return this.resetEdgesOnResize;
  },
  resetEdgesOnMove: false,
  isResetEdgesOnMove() {
    return this.resetEdgesOnMove;
  },
  resetEdgesOnConnect: true,
  isResetEdgesOnConnect() {
    return this.resetEdgesOnConnect;
  },
  connectableEdges: false,
  allowDanglingEdges: true,
  cloneInvalidEdges: false,
  alternateEdgeStyle: {},
  edgeLabelsMovable: true,
  // ***************************************************************************
  // Group: Graph Behaviour
  // ***************************************************************************
  isEdgeLabelsMovable() {
    return this.edgeLabelsMovable;
  },
  setEdgeLabelsMovable(value2) {
    this.edgeLabelsMovable = value2;
  },
  setAllowDanglingEdges(value2) {
    this.allowDanglingEdges = value2;
  },
  isAllowDanglingEdges() {
    return this.allowDanglingEdges;
  },
  setConnectableEdges(value2) {
    this.connectableEdges = value2;
  },
  isConnectableEdges() {
    return this.connectableEdges;
  },
  setCloneInvalidEdges(value2) {
    this.cloneInvalidEdges = value2;
  },
  isCloneInvalidEdges() {
    return this.cloneInvalidEdges;
  },
  // ***************************************************************************
  // Group: Cell alignment and orientation
  // ***************************************************************************
  flipEdge(edge2) {
    if (this.alternateEdgeStyle) {
      this.batchUpdate(() => {
        const style2 = edge2.getStyle();
        if (Object.keys(style2).length) {
          this.getDataModel().setStyle(edge2, this.alternateEdgeStyle);
        } else {
          this.getDataModel().setStyle(edge2, {});
        }
        this.resetEdge(edge2);
        this.fireEvent(new EventObject_default(InternalEvent_default.FLIP_EDGE, { edge: edge2 }));
      });
    }
    return edge2;
  },
  splitEdge(edge2, cells, newEdge, dx = 0, dy = 0, x, y, parent2 = null) {
    parent2 = parent2 ?? edge2.getParent();
    const source2 = edge2.getTerminal(true);
    this.batchUpdate(() => {
      if (!newEdge) {
        newEdge = this.cloneCell(edge2);
        const state2 = this.getView().getState(edge2);
        let geo = newEdge.getGeometry();
        if (geo && state2) {
          const t = this.getView().translate;
          const s = this.getView().scale;
          const idx = findNearestSegment(state2, (dx + t.x) * s, (dy + t.y) * s);
          geo.points = geo.points.slice(0, idx);
          geo = edge2.getGeometry();
          if (geo) {
            geo = geo.clone();
            geo.points = geo.points.slice(idx);
            this.getDataModel().setGeometry(edge2, geo);
          }
        }
      }
      this.cellsMoved(cells, dx, dy, false, false);
      this.cellsAdded(cells, parent2, parent2 ? parent2.getChildCount() : 0, null, null, true);
      this.cellsAdded([newEdge], parent2, parent2 ? parent2.getChildCount() : 0, source2, cells[0], false);
      this.cellConnected(edge2, cells[0], true);
      this.fireEvent(new EventObject_default(InternalEvent_default.SPLIT_EDGE, { edge: edge2, cells, newEdge, dx, dy }));
    });
    return newEdge;
  },
  insertEdge(...args) {
    let parent2;
    let id2;
    let value2;
    let source2;
    let target2;
    let style2;
    if (args.length === 1 && typeof args[0] === "object") {
      const params = args[0];
      parent2 = params.parent;
      id2 = params.id;
      value2 = params.value;
      source2 = params.source;
      target2 = params.target;
      style2 = params.style;
    } else {
      [parent2, id2, value2, source2, target2, style2] = args;
    }
    const edge2 = this.createEdge(parent2, id2, value2, source2, target2, style2);
    return this.addEdge(edge2, parent2, source2, target2);
  },
  createEdge(parent2 = null, id2, value2, source2 = null, target2 = null, style2 = {}) {
    const edge2 = new Cell_default(value2, new Geometry_default(), style2);
    edge2.setId(id2);
    edge2.setEdge(true);
    edge2.geometry.relative = true;
    return edge2;
  },
  addEdge(edge2, parent2 = null, source2 = null, target2 = null, index = null) {
    return this.addCell(edge2, parent2, index, source2, target2);
  },
  // ***************************************************************************
  // Group: Folding
  // ***************************************************************************
  addAllEdges(cells) {
    const allCells = cells.slice();
    return removeDuplicates(allCells.concat(this.getAllEdges(cells)));
  },
  getAllEdges(cells) {
    let edges = [];
    if (cells) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const edgeCount = cells[i2].getEdgeCount();
        for (let j = 0; j < edgeCount; j++) {
          edges.push(cells[i2].getEdgeAt(j));
        }
        const children = cells[i2].getChildren();
        edges = edges.concat(this.getAllEdges(children));
      }
    }
    return edges;
  },
  getIncomingEdges(cell2, parent2 = null) {
    return this.getEdges(cell2, parent2, true, false, false);
  },
  getOutgoingEdges(cell2, parent2 = null) {
    return this.getEdges(cell2, parent2, false, true, false);
  },
  getEdges(cell2, parent2 = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {
    let edges = [];
    const isCollapsed = cell2.isCollapsed();
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      if (isCollapsed || !child2.isVisible()) {
        edges = edges.concat(child2.getEdges(incoming, outgoing));
      }
    }
    edges = edges.concat(cell2.getEdges(incoming, outgoing));
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const state2 = this.getView().getState(edges[i2]);
      const source2 = state2 ? state2.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i2], true);
      const target2 = state2 ? state2.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i2], false);
      if (includeLoops && source2 === target2 || source2 !== target2 && (incoming && target2 === cell2 && (!parent2 || this.isValidAncestor(source2, parent2, recurse)) || outgoing && source2 === cell2 && (!parent2 || this.isValidAncestor(target2, parent2, recurse)))) {
        result2.push(edges[i2]);
      }
    }
    return result2;
  },
  // ***************************************************************************
  // Group: Cell retrieval
  // ***************************************************************************
  getChildEdges(parent2) {
    return this.getChildCells(parent2, false, true);
  },
  getEdgesBetween(source2, target2, directed = false) {
    const edges = this.getEdges(source2);
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const state2 = this.getView().getState(edges[i2]);
      const src = state2 ? state2.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i2], true);
      const trg = state2 ? state2.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i2], false);
      if (src === source2 && trg === target2 || !directed && src === target2 && trg === source2) {
        result2.push(edges[i2]);
      }
    }
    return result2;
  },
  // ***************************************************************************
  // Group: Cell moving
  // ***************************************************************************
  resetEdges(cells) {
    const dict = new Dictionary_default();
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      dict.put(cells[i2], true);
    }
    this.batchUpdate(() => {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const edges = cells[i2].getEdges();
        for (let j = 0; j < edges.length; j++) {
          const state2 = this.getView().getState(edges[j]);
          const source2 = state2 ? state2.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[j], true);
          const target2 = state2 ? state2.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[j], false);
          if (!dict.get(source2) || !dict.get(target2)) {
            this.resetEdge(edges[j]);
          }
        }
        this.resetEdges(cells[i2].getChildren());
      }
    });
  },
  resetEdge(edge2) {
    let geo = edge2.getGeometry();
    if (geo && geo.points && geo.points.length > 0) {
      geo = geo.clone();
      geo.points = [];
      this.getDataModel().setGeometry(edge2, geo);
    }
    return edge2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/EditingMixin.js
var EditingMixin = {
  cellsEditable: true,
  /*****************************************************************************
   * Group: Cell in-place editing
   *****************************************************************************/
  startEditing(evt2) {
    this.startEditingAtCell(null, evt2);
  },
  startEditingAtCell(cell2 = null, evt2) {
    if (!evt2 || !isMultiTouchEvent(evt2)) {
      if (!cell2) {
        cell2 = this.getSelectionCell();
        if (cell2 && !this.isCellEditable(cell2)) {
          cell2 = null;
        }
      } else {
        this.fireEvent(new EventObject_default(InternalEvent_default.START_EDITING, { cell: cell2, event: evt2 }));
        const cellEditorHandler = this.getPlugin("CellEditorHandler");
        cellEditorHandler == null ? void 0 : cellEditorHandler.startEditing(cell2, evt2);
        this.fireEvent(new EventObject_default(InternalEvent_default.EDITING_STARTED, { cell: cell2, event: evt2 }));
      }
    }
  },
  getEditingValue(cell2, evt2) {
    return this.convertValueToString(cell2);
  },
  stopEditing(cancel = false) {
    const cellEditorHandler = this.getPlugin("CellEditorHandler");
    cellEditorHandler == null ? void 0 : cellEditorHandler.stopEditing(cancel);
    this.fireEvent(new EventObject_default(InternalEvent_default.EDITING_STOPPED, { cancel }));
  },
  labelChanged(cell2, value2, evt2) {
    this.batchUpdate(() => {
      const old = cell2.value;
      this.cellLabelChanged(cell2, value2, this.isAutoSizeCell(cell2));
      this.fireEvent(new EventObject_default(InternalEvent_default.LABEL_CHANGED, {
        cell: cell2,
        value: value2,
        old,
        event: evt2
      }));
    });
    return cell2;
  },
  cellLabelChanged(cell2, value2, autoSize = false) {
    this.batchUpdate(() => {
      this.getDataModel().setValue(cell2, value2);
      if (autoSize) {
        this.cellSizeUpdated(cell2, false);
      }
    });
  },
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  isEditing(cell2 = null) {
    const cellEditorHandler = this.getPlugin("CellEditorHandler");
    const editingCell = cellEditorHandler == null ? void 0 : cellEditorHandler.getEditingCell();
    return !cell2 ? !!editingCell : cell2 === editingCell;
  },
  isCellEditable(cell2) {
    const style2 = this.getCurrentCellStyle(cell2);
    return this.isCellsEditable() && !this.isCellLocked(cell2) && (style2.editable || false);
  },
  isCellsEditable() {
    return this.cellsEditable;
  },
  setCellsEditable(value2) {
    this.cellsEditable = value2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/EventsMixin.js
var EventsMixin = {
  // TODO: Document me!
  lastTouchEvent: null,
  doubleClickCounter: 0,
  lastTouchCell: null,
  fireDoubleClick: null,
  tapAndHoldThread: null,
  lastMouseX: null,
  lastMouseY: null,
  isMouseTrigger: null,
  ignoreMouseEvents: null,
  mouseMoveRedirect: null,
  mouseUpRedirect: null,
  lastEvent: null,
  // FIXME: Check if this can be more specific - DOM events or mxEventObjects!
  escapeEnabled: true,
  invokesStopCellEditing: true,
  enterStopsCellEditing: false,
  isMouseDown: false,
  nativeDblClickEnabled: true,
  doubleTapEnabled: true,
  doubleTapTimeout: 500,
  doubleTapTolerance: 25,
  lastTouchX: 0,
  lastTouchY: 0,
  lastTouchTime: 0,
  tapAndHoldEnabled: true,
  tapAndHoldDelay: 500,
  tapAndHoldInProgress: false,
  tapAndHoldValid: false,
  initialTouchX: 0,
  initialTouchY: 0,
  tolerance: 4,
  isNativeDblClickEnabled() {
    return this.nativeDblClickEnabled;
  },
  getEventTolerance() {
    return this.tolerance;
  },
  setEventTolerance(tolerance) {
    this.tolerance = tolerance;
  },
  escape(evt2) {
    this.fireEvent(new EventObject_default(InternalEvent_default.ESCAPE, { event: evt2 }));
  },
  click(me) {
    const evt2 = me.getEvent();
    let cell2 = me.getCell();
    const mxe = new EventObject_default(InternalEvent_default.CLICK, { event: evt2, cell: cell2 });
    if (me.isConsumed()) {
      mxe.consume();
    }
    this.fireEvent(mxe);
    if (this.isEnabled() && !isConsumed(evt2) && !mxe.isConsumed()) {
      if (cell2) {
        if (this.isTransparentClickEvent(evt2)) {
          let active = false;
          const tmp2 = this.getCellAt(me.graphX, me.graphY, null, false, false, (state2) => {
            const selected = this.isCellSelected(state2.cell);
            active = active || selected;
            return !active || selected || state2.cell !== cell2 && state2.cell.isAncestor(cell2);
          });
          if (tmp2) {
            cell2 = tmp2;
          }
        }
      } else if (this.isSwimlaneSelectionEnabled()) {
        cell2 = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());
        if (cell2 != null && (!this.isToggleEvent(evt2) || !isAltDown(evt2))) {
          let temp = cell2;
          let swimlanes = [];
          while (temp != null) {
            temp = temp.getParent();
            const state2 = this.getView().getState(temp);
            if (this.isSwimlane(temp) && state2 != null) {
              swimlanes.push(temp);
            }
          }
          if (swimlanes.length > 0) {
            swimlanes = swimlanes.reverse();
            swimlanes.splice(0, 0, cell2);
            swimlanes.push(cell2);
            for (let i2 = 0; i2 < swimlanes.length - 1; i2 += 1) {
              if (this.isCellSelected(swimlanes[i2])) {
                cell2 = swimlanes[this.isToggleEvent(evt2) ? i2 : i2 + 1];
              }
            }
          }
        }
      }
      if (cell2) {
        this.selectCellForEvent(cell2, evt2);
      } else if (!this.isToggleEvent(evt2)) {
        this.clearSelection();
      }
    }
    return false;
  },
  dblClick(evt2, cell2 = null) {
    const mxe = new EventObject_default(InternalEvent_default.DOUBLE_CLICK, { event: evt2, cell: cell2 });
    this.fireEvent(mxe);
    if (this.isEnabled() && !isConsumed(evt2) && !mxe.isConsumed() && cell2 && this.isCellEditable(cell2) && !this.isEditing(cell2)) {
      this.startEditingAtCell(cell2, evt2);
      InternalEvent_default.consume(evt2);
    }
  },
  tapAndHold(me) {
    const evt2 = me.getEvent();
    const mxe = new EventObject_default(InternalEvent_default.TAP_AND_HOLD, {
      event: evt2,
      cell: me.getCell()
    });
    const panningHandler = this.getPlugin("PanningHandler");
    const connectionHandler = this.getPlugin("ConnectionHandler");
    this.fireEvent(mxe);
    if (mxe.isConsumed()) {
      panningHandler && (panningHandler.panningTrigger = false);
    }
    if (this.isEnabled() && !isConsumed(evt2) && !mxe.isConsumed() && connectionHandler && connectionHandler.isEnabled()) {
      const cell2 = connectionHandler.marker.getCell(me);
      if (cell2) {
        const state2 = this.getView().getState(cell2);
        if (state2) {
          connectionHandler.marker.currentColor = connectionHandler.marker.validColor;
          connectionHandler.marker.markedState = state2;
          connectionHandler.marker.mark();
          connectionHandler.first = new Point_default(me.getGraphX(), me.getGraphY());
          connectionHandler.edgeState = connectionHandler.createEdgeState(me);
          connectionHandler.previous = state2;
          connectionHandler.fireEvent(new EventObject_default(InternalEvent_default.START, { state: connectionHandler.previous }));
        }
      }
    }
  },
  addMouseListener(listener) {
    this.mouseListeners.push(listener);
  },
  removeMouseListener(listener) {
    for (let i2 = 0; i2 < this.mouseListeners.length; i2 += 1) {
      if (this.mouseListeners[i2] === listener) {
        this.mouseListeners.splice(i2, 1);
        break;
      }
    }
  },
  updateMouseEvent(me, evtName) {
    const pt = convertPoint(this.getContainer(), me.getX(), me.getY());
    me.graphX = pt.x - this.getPanDx();
    me.graphY = pt.y - this.getPanDy();
    if (!me.getCell() && this.isMouseDown && evtName === InternalEvent_default.MOUSE_MOVE) {
      const cell2 = this.getCellAt(pt.x, pt.y, null, true, true, (state2) => {
        return !state2.shape || state2.shape.paintBackground !== this.paintBackground || state2.style.pointerEvents || state2.shape.fill !== NONE;
      });
      me.state = cell2 ? this.getView().getState(cell2) : null;
    }
    return me;
  },
  getStateForTouchEvent(evt2) {
    const x = getClientX(evt2);
    const y = getClientY(evt2);
    const pt = convertPoint(this.getContainer(), x, y);
    const cell2 = this.getCellAt(pt.x, pt.y);
    return cell2 ? this.getView().getState(cell2) : null;
  },
  isEventIgnored(evtName, me, sender) {
    const mouseEvent = isMouseEvent(me.getEvent());
    let result2 = false;
    if (me.getEvent() === this.lastEvent) {
      result2 = true;
    } else {
      this.lastEvent = me.getEvent();
    }
    const eventSource = this.getEventSource();
    if (eventSource && evtName !== InternalEvent_default.MOUSE_MOVE) {
      InternalEvent_default.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
      this.mouseMoveRedirect = null;
      this.mouseUpRedirect = null;
      this.setEventSource(null);
    } else if (!Client_default.IS_GC && eventSource && me.getSource() !== eventSource) {
      result2 = true;
    } else if (eventSource && Client_default.IS_TOUCH && evtName === InternalEvent_default.MOUSE_DOWN && !mouseEvent && !isPenEvent(me.getEvent())) {
      this.setEventSource(me.getSource());
      this.mouseMoveRedirect = (evt2) => {
        this.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt2, this.getStateForTouchEvent(evt2)));
      }, this.mouseUpRedirect = (evt2) => {
        this.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt2, this.getStateForTouchEvent(evt2)));
      }, InternalEvent_default.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);
    }
    if (this.isSyntheticEventIgnored(evtName, me, sender)) {
      result2 = true;
    }
    if (!isPopupTrigger(this.lastEvent) && evtName !== InternalEvent_default.MOUSE_MOVE && this.lastEvent.detail === 2) {
      return true;
    }
    if (evtName === InternalEvent_default.MOUSE_UP && this.isMouseDown) {
      this.isMouseDown = false;
    } else if (evtName === InternalEvent_default.MOUSE_DOWN && !this.isMouseDown) {
      this.isMouseDown = true;
      this.isMouseTrigger = mouseEvent;
    } else if (!result2 && ((!Client_default.IS_FF || evtName !== InternalEvent_default.MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger !== mouseEvent || evtName === InternalEvent_default.MOUSE_DOWN && this.isMouseDown || evtName === InternalEvent_default.MOUSE_UP && !this.isMouseDown)) {
      result2 = true;
    }
    if (!result2 && evtName === InternalEvent_default.MOUSE_DOWN) {
      this.lastMouseX = me.getX();
      this.lastMouseY = me.getY();
    }
    return result2;
  },
  isSyntheticEventIgnored(evtName, me, sender) {
    let result2 = false;
    const mouseEvent = isMouseEvent(me.getEvent());
    if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent_default.MOUSE_MOVE) {
      this.ignoreMouseEvents = evtName !== InternalEvent_default.MOUSE_UP;
      result2 = true;
    } else if (Client_default.IS_FF && !mouseEvent && evtName === InternalEvent_default.MOUSE_UP) {
      this.ignoreMouseEvents = true;
    }
    return result2;
  },
  isEventSourceIgnored(evtName, me) {
    const source2 = me.getSource();
    if (!source2)
      return true;
    const name2 = source2.nodeName ? source2.nodeName.toLowerCase() : "";
    const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());
    return evtName === InternalEvent_default.MOUSE_DOWN && candidate && (name2 === "select" || name2 === "option" || name2 === "input" && // @ts-ignore type could exist
    source2.type !== "checkbox" && // @ts-ignore type could exist
    source2.type !== "radio" && // @ts-ignore type could exist
    source2.type !== "button" && // @ts-ignore type could exist
    source2.type !== "submit" && // @ts-ignore type could exist
    source2.type !== "file");
  },
  getEventState(state2) {
    return state2;
  },
  fireMouseEvent(evtName, me, sender) {
    sender = sender ?? this;
    if (this.isEventSourceIgnored(evtName, me)) {
      const tooltipHandler = this.getPlugin("TooltipHandler");
      if (tooltipHandler) {
        tooltipHandler.hide();
      }
      return;
    }
    me = this.updateMouseEvent(me, evtName);
    if (!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && Client_default.IS_TOUCH && (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent()))) {
      const currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (evtName === InternalEvent_default.MOUSE_DOWN) {
        if (this.lastTouchEvent && this.lastTouchEvent !== me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {
          this.doubleClickCounter += 1;
          let doubleClickFired = false;
          if (evtName === InternalEvent_default.MOUSE_UP) {
            if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {
              this.lastTouchTime = 0;
              const cell2 = this.lastTouchCell;
              this.lastTouchCell = null;
              this.dblClick(me.getEvent(), cell2);
              doubleClickFired = true;
            }
          } else {
            this.fireDoubleClick = true;
            this.lastTouchTime = 0;
          }
          if (doubleClickFired) {
            InternalEvent_default.consume(me.getEvent());
            return;
          }
        } else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {
          this.lastTouchCell = me.getCell();
          this.lastTouchX = me.getX();
          this.lastTouchY = me.getY();
          this.lastTouchTime = currentTime;
          this.lastTouchEvent = me.getEvent();
          this.doubleClickCounter = 0;
        }
      } else if ((this.isMouseDown || evtName === InternalEvent_default.MOUSE_UP) && this.fireDoubleClick) {
        this.fireDoubleClick = false;
        const cell2 = this.lastTouchCell;
        this.lastTouchCell = null;
        this.isMouseDown = false;
        const valid = cell2 || (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && (Client_default.IS_GC || Client_default.IS_SF);
        if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {
          this.dblClick(me.getEvent(), cell2);
        } else {
          InternalEvent_default.consume(me.getEvent());
        }
        return;
      }
    }
    if (!this.isEventIgnored(evtName, me, sender)) {
      const state2 = me.getState();
      me.state = state2 ? this.getEventState(state2) : null;
      this.fireEvent(new EventObject_default(InternalEvent_default.FIRE_MOUSE_EVENT, { eventName: evtName, event: me }));
      if (Client_default.IS_SF || Client_default.IS_GC || me.getEvent().target !== this.getContainer()) {
        const container = this.getContainer();
        if (evtName === InternalEvent_default.MOUSE_MOVE && this.isMouseDown && this.isAutoScroll() && !isMultiTouchEvent(me.getEvent())) {
          this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());
        } else if (evtName === InternalEvent_default.MOUSE_UP && this.isIgnoreScrollbars() && this.isTranslateToScrollPosition() && (container.scrollLeft !== 0 || container.scrollTop !== 0)) {
          const s = this.getView().scale;
          const tr = this.getView().translate;
          this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);
          container.scrollLeft = 0;
          container.scrollTop = 0;
        }
        const mouseListeners = this.mouseListeners;
        if (!me.getEvent().preventDefault) {
          me.getEvent().returnValue = true;
        }
        for (const l of mouseListeners) {
          if (evtName === InternalEvent_default.MOUSE_DOWN) {
            l.mouseDown(sender, me);
          } else if (evtName === InternalEvent_default.MOUSE_MOVE) {
            l.mouseMove(sender, me);
          } else if (evtName === InternalEvent_default.MOUSE_UP) {
            l.mouseUp(sender, me);
          }
        }
        if (evtName === InternalEvent_default.MOUSE_UP) {
          this.click(me);
        }
      }
      if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) && evtName === InternalEvent_default.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {
        this.tapAndHoldInProgress = true;
        this.initialTouchX = me.getGraphX();
        this.initialTouchY = me.getGraphY();
        const handler = () => {
          if (this.tapAndHoldValid) {
            this.tapAndHold(me);
          }
          this.tapAndHoldInProgress = false;
          this.tapAndHoldValid = false;
        };
        if (this.tapAndHoldThread) {
          window.clearTimeout(this.tapAndHoldThread);
        }
        this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);
        this.tapAndHoldValid = true;
      } else if (evtName === InternalEvent_default.MOUSE_UP) {
        this.tapAndHoldInProgress = false;
        this.tapAndHoldValid = false;
      } else if (this.tapAndHoldValid) {
        this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;
      }
      const cellEditorHandler = this.getPlugin("CellEditorHandler");
      if (evtName === InternalEvent_default.MOUSE_DOWN && this.isEditing() && !(cellEditorHandler == null ? void 0 : cellEditorHandler.isEventSource(me.getEvent()))) {
        this.stopEditing(!this.isInvokesStopCellEditing());
      }
      this.consumeMouseEvent(evtName, me, sender);
    }
  },
  consumeMouseEvent(evtName, me, sender) {
    sender = sender ?? this;
    if (evtName === InternalEvent_default.MOUSE_DOWN && isTouchEvent(me.getEvent())) {
      me.consume(false);
    }
  },
  fireGestureEvent(evt2, cell2 = null) {
    this.lastTouchTime = 0;
    this.fireEvent(new EventObject_default(InternalEvent_default.GESTURE, { event: evt2, cell: cell2 }));
  },
  sizeDidChange() {
    const bounds = this.getGraphBounds();
    const border = this.getBorder();
    let width = Math.max(0, bounds.x) + bounds.width + 2 * border;
    let height = Math.max(0, bounds.y) + bounds.height + 2 * border;
    const minimumContainerSize = this.getMinimumContainerSize();
    if (minimumContainerSize) {
      width = Math.max(width, minimumContainerSize.width);
      height = Math.max(height, minimumContainerSize.height);
    }
    if (this.isResizeContainer()) {
      this.doResizeContainer(width, height);
    }
    if (this.isPreferPageSize() || this.isPageVisible()) {
      const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));
      width = size.width * this.getView().scale;
      height = size.height * this.getView().scale;
    }
    const minimumGraphSize = this.getMinimumGraphSize();
    if (minimumGraphSize) {
      width = Math.max(width, minimumGraphSize.width * this.getView().scale);
      height = Math.max(height, minimumGraphSize.height * this.getView().scale);
    }
    width = Math.ceil(width);
    height = Math.ceil(height);
    const root = this.getView().getDrawPane().ownerSVGElement;
    if (root) {
      root.style.minWidth = `${Math.max(1, width)}px`;
      root.style.minHeight = `${Math.max(1, height)}px`;
      root.style.width = "100%";
      root.style.height = "100%";
    }
    this.updatePageBreaks(this.isPageBreaksVisible(), width, height);
    this.fireEvent(new EventObject_default(InternalEvent_default.SIZE, { bounds }));
  },
  isCloneEvent(evt2) {
    return isControlDown(evt2);
  },
  isTransparentClickEvent(evt2) {
    return false;
  },
  isToggleEvent(evt2) {
    return Client_default.IS_MAC ? isMetaDown(evt2) : isControlDown(evt2);
  },
  isGridEnabledEvent(evt2) {
    return !isAltDown(evt2);
  },
  isConstrainedEvent(evt2) {
    return isShiftDown(evt2);
  },
  isIgnoreTerminalEvent(_evt) {
    return false;
  },
  getPointForEvent(evt2, addOffset = true) {
    const p = convertPoint(this.getContainer(), getClientX(evt2), getClientY(evt2));
    const s = this.getView().scale;
    const tr = this.getView().translate;
    const off = addOffset ? this.getGridSize() / 2 : 0;
    p.x = this.snap(p.x / s - tr.x - off);
    p.y = this.snap(p.y / s - tr.y - off);
    return p;
  },
  isEscapeEnabled() {
    return this.escapeEnabled;
  },
  setEscapeEnabled(value2) {
    this.escapeEnabled = value2;
  },
  isInvokesStopCellEditing() {
    return this.invokesStopCellEditing;
  },
  setInvokesStopCellEditing(value2) {
    this.invokesStopCellEditing = value2;
  },
  isEnterStopsCellEditing() {
    return this.enterStopsCellEditing;
  },
  setEnterStopsCellEditing(value2) {
    this.enterStopsCellEditing = value2;
  },
  getCursorForMouseEvent(me) {
    const cell2 = me.getCell();
    return cell2 ? this.getCursorForCell(cell2) : null;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/FoldingMixin.js
var FoldingMixin = {
  options: {
    foldingEnabled: true,
    collapsedImage: new ImageBox_default(`${Client_default.imageBasePath}/collapsed.gif`, 9, 9),
    expandedImage: new ImageBox_default(`${Client_default.imageBasePath}/expanded.gif`, 9, 9),
    collapseToPreferredSize: true
  },
  collapseExpandResource: Client_default.language != "none" ? "collapse-expand" : "",
  getCollapseExpandResource() {
    return this.collapseExpandResource;
  },
  isFoldingEnabled() {
    return this.options.foldingEnabled;
  },
  getFoldableCells(cells, collapse = false) {
    return this.getDataModel().filterCells(cells, (cell2) => {
      return this.isCellFoldable(cell2, collapse);
    });
  },
  isCellFoldable(cell2, collapse) {
    const style2 = this.getCurrentCellStyle(cell2);
    return cell2.getChildCount() > 0 && (style2.foldable ?? true);
  },
  getFoldingImage(state2) {
    if (state2 != null && this.isFoldingEnabled() && !state2.cell.isEdge()) {
      const tmp2 = state2.cell.isCollapsed();
      if (this.isCellFoldable(state2.cell, !tmp2)) {
        return tmp2 ? this.options.collapsedImage : this.options.expandedImage;
      }
    }
    return null;
  },
  foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, _evt = null) {
    if (cells == null) {
      cells = this.getFoldableCells(this.getSelectionCells(), collapse);
    }
    this.stopEditing(false);
    this.batchUpdate(() => {
      this.cellsFolded(cells, collapse, recurse, checkFoldable);
      this.fireEvent(new EventObject_default(InternalEvent_default.FOLD_CELLS, "collapse", collapse, "recurse", recurse, "cells", cells));
    });
    return cells;
  },
  cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {
    if (cells != null && cells.length > 0) {
      this.batchUpdate(() => {
        for (let i2 = 0; i2 < cells.length; i2 += 1) {
          if ((!checkFoldable || this.isCellFoldable(cells[i2], collapse)) && collapse !== cells[i2].isCollapsed()) {
            this.getDataModel().setCollapsed(cells[i2], collapse);
            this.swapBounds(cells[i2], collapse);
            if (this.isExtendParent(cells[i2])) {
              this.extendParent(cells[i2]);
            }
            if (recurse) {
              const children = cells[i2].getChildren();
              this.cellsFolded(children, collapse, recurse);
            }
            this.constrainChild(cells[i2]);
          }
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_FOLDED, { cells, collapse, recurse }));
      });
    }
  },
  swapBounds(cell2, willCollapse = false) {
    let geo = cell2.getGeometry();
    if (geo != null) {
      geo = geo.clone();
      this.updateAlternateBounds(cell2, geo, willCollapse);
      geo.swap();
      this.getDataModel().setGeometry(cell2, geo);
    }
  },
  updateAlternateBounds(cell2 = null, geo = null, willCollapse = false) {
    if (cell2 != null && geo != null) {
      const style2 = this.getCurrentCellStyle(cell2);
      if (geo.alternateBounds == null) {
        let bounds = geo;
        if (this.options.collapseToPreferredSize) {
          const tmp2 = this.getPreferredSizeForCell(cell2);
          if (tmp2 != null) {
            bounds = tmp2;
            const startSize = getValue(style2, "startSize");
            if (startSize > 0) {
              bounds.height = Math.max(bounds.height, startSize);
            }
          }
        }
        geo.alternateBounds = new Rectangle_default(0, 0, bounds.width, bounds.height);
      }
      if (geo.alternateBounds != null) {
        geo.alternateBounds.x = geo.x;
        geo.alternateBounds.y = geo.y;
        const alpha = toRadians(style2.rotation || 0);
        if (alpha !== 0) {
          const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();
          const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();
          const cos = Math.cos(alpha);
          const sin = Math.sin(alpha);
          const dx2 = cos * dx - sin * dy;
          const dy2 = sin * dx + cos * dy;
          geo.alternateBounds.x += dx2 - dx;
          geo.alternateBounds.y += dy2 - dy;
        }
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/GroupingMixin.js
var GroupingMixin = {
  groupCells(group, border = 0, cells) {
    if (!cells)
      cells = sortCells(this.getSelectionCells(), true);
    if (!cells)
      cells = this.getCellsForGroup(cells);
    if (group == null) {
      group = this.createGroupCell(cells);
    }
    const bounds = this.getBoundsForGroup(group, cells, border);
    if (cells.length > 1 && bounds != null) {
      let parent2 = group.getParent();
      if (parent2 == null) {
        parent2 = cells[0].getParent();
      }
      this.batchUpdate(() => {
        if (group.getGeometry() == null) {
          this.getDataModel().setGeometry(group, new Geometry_default());
        }
        let index = parent2.getChildCount();
        this.cellsAdded([group], parent2, index, null, null, false, false, false);
        index = group.getChildCount();
        this.cellsAdded(cells, group, index, null, null, false, false, false);
        this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);
        this.cellsResized([group], [bounds], false);
        this.fireEvent(new EventObject_default(InternalEvent_default.GROUP_CELLS, { group, border, cells }));
      });
    }
    return group;
  },
  getCellsForGroup(cells) {
    const result2 = [];
    if (cells != null && cells.length > 0) {
      const parent2 = cells[0].getParent();
      result2.push(cells[0]);
      for (let i2 = 1; i2 < cells.length; i2 += 1) {
        if (cells[i2].getParent() === parent2) {
          result2.push(cells[i2]);
        }
      }
    }
    return result2;
  },
  getBoundsForGroup(group, children, border) {
    const result2 = this.getBoundingBoxFromGeometry(children, true);
    if (result2 != null) {
      if (this.isSwimlane(group)) {
        const size = this.getStartSize(group);
        result2.x -= size.width;
        result2.y -= size.height;
        result2.width += size.width;
        result2.height += size.height;
      }
      if (border != null) {
        result2.x -= border;
        result2.y -= border;
        result2.width += 2 * border;
        result2.height += 2 * border;
      }
    }
    return result2;
  },
  createGroupCell(cells) {
    const group = new Cell_default("");
    group.setVertex(true);
    group.setConnectable(false);
    return group;
  },
  ungroupCells(cells) {
    let result2 = [];
    if (cells == null) {
      cells = this.getCellsForUngroup();
    }
    if (cells != null && cells.length > 0) {
      this.batchUpdate(() => {
        const _cells = cells;
        for (let i2 = 0; i2 < _cells.length; i2 += 1) {
          let children = _cells[i2].getChildren();
          if (children != null && children.length > 0) {
            children = children.slice();
            const parent2 = _cells[i2].getParent();
            const index = parent2.getChildCount();
            this.cellsAdded(children, parent2, index, null, null, true);
            result2 = result2.concat(children);
            for (const child2 of children) {
              const state2 = this.getView().getState(child2);
              let geo = child2.getGeometry();
              if (state2 != null && geo != null && geo.relative) {
                geo = geo.clone();
                geo.x = state2.origin.x;
                geo.y = state2.origin.y;
                geo.relative = false;
                this.getDataModel().setGeometry(child2, geo);
              }
            }
          }
        }
        this.removeCellsAfterUngroup(_cells);
        this.fireEvent(new EventObject_default(InternalEvent_default.UNGROUP_CELLS, { cells }));
      });
    }
    return result2;
  },
  getCellsForUngroup() {
    const cells = this.getSelectionCells();
    const tmp2 = [];
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (cells[i2].isVertex() && cells[i2].getChildCount() > 0) {
        tmp2.push(cells[i2]);
      }
    }
    return tmp2;
  },
  removeCellsAfterUngroup(cells) {
    this.cellsRemoved(this.addAllEdges(cells));
  },
  removeCellsFromParent(cells) {
    if (cells == null) {
      cells = this.getSelectionCells();
    }
    this.batchUpdate(() => {
      const parent2 = this.getDefaultParent();
      const index = parent2.getChildCount();
      this.cellsAdded(cells, parent2, index, null, null, true);
      this.fireEvent(new EventObject_default(InternalEvent_default.REMOVE_CELLS_FROM_PARENT, { cells }));
    });
    return cells;
  },
  updateGroupBounds(cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {
    if (cells == null) {
      cells = this.getSelectionCells();
    }
    border = border != null ? border : 0;
    moveGroup = moveGroup != null ? moveGroup : false;
    topBorder = topBorder != null ? topBorder : 0;
    rightBorder = rightBorder != null ? rightBorder : 0;
    bottomBorder = bottomBorder != null ? bottomBorder : 0;
    leftBorder = leftBorder != null ? leftBorder : 0;
    this.batchUpdate(() => {
      for (let i2 = cells.length - 1; i2 >= 0; i2--) {
        let geo = cells[i2].getGeometry();
        if (geo == null) {
          continue;
        }
        const children = this.getChildCells(cells[i2]);
        if (children != null && children.length > 0) {
          const bounds = this.getBoundingBoxFromGeometry(children, true);
          if (bounds != null && bounds.width > 0 && bounds.height > 0) {
            const size = this.isSwimlane(cells[i2]) ? this.getActualStartSize(cells[i2], true) : new Rectangle_default();
            geo = geo.clone();
            if (moveGroup) {
              geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);
              geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);
            }
            geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);
            geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);
            this.getDataModel().setGeometry(cells[i2], geo);
            this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);
          }
        }
      }
    });
    return cells;
  },
  /*****************************************************************************
   * Group: Drilldown
   *****************************************************************************/
  enterGroup(cell2) {
    cell2 = cell2 || this.getSelectionCell();
    if (cell2 != null && this.isValidRoot(cell2)) {
      this.getView().setCurrentRoot(cell2);
      this.clearSelection();
    }
  },
  exitGroup() {
    const root = this.getDataModel().getRoot();
    const current = this.getCurrentRoot();
    if (current != null) {
      let next = current.getParent();
      while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {
        next = next.getParent();
      }
      if (next === root || next.getParent() === root) {
        this.getView().setCurrentRoot(null);
      } else {
        this.getView().setCurrentRoot(next);
      }
      const state2 = this.getView().getState(current);
      if (state2 != null) {
        this.setSelectionCell(current);
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/ImageMixin.js
var ImageMixin = {
  addImageBundle(bundle) {
    this.imageBundles.push(bundle);
  },
  removeImageBundle(bundle) {
    const tmp2 = [];
    for (let i2 = 0; i2 < this.imageBundles.length; i2 += 1) {
      if (this.imageBundles[i2] !== bundle) {
        tmp2.push(this.imageBundles[i2]);
      }
    }
    this.imageBundles = tmp2;
  },
  getImageFromBundles(key2) {
    if (key2) {
      for (let i2 = 0; i2 < this.imageBundles.length; i2 += 1) {
        const image = this.imageBundles[i2].getImage(key2);
        if (image) {
          return image;
        }
      }
    }
    return null;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/LabelMixin.js
var LabelMixin = {
  getLabel(cell2) {
    let result2 = "";
    if (this.isLabelsVisible() && cell2 != null) {
      const style2 = this.getCurrentCellStyle(cell2);
      if (!(style2.noLabel ?? false)) {
        result2 = this.convertValueToString(cell2);
      }
    }
    return result2;
  },
  isHtmlLabel(_cell) {
    return this.isHtmlLabels();
  },
  labelsVisible: true,
  isLabelsVisible() {
    return this.labelsVisible;
  },
  htmlLabels: false,
  isHtmlLabels() {
    return this.htmlLabels;
  },
  setHtmlLabels(value2) {
    this.htmlLabels = value2;
  },
  isWrapping(cell2) {
    return this.getCurrentCellStyle(cell2).whiteSpace === "wrap";
  },
  isLabelClipped(cell2) {
    return this.getCurrentCellStyle(cell2).overflow === "hidden";
  },
  isLabelMovable(cell2) {
    return !this.isCellLocked(cell2) && (cell2.isEdge() && this.isEdgeLabelsMovable() || cell2.isVertex() && this.isVertexLabelsMovable());
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/OrderMixin.js
var OrderMixin = {
  orderCells(back = false, cells) {
    if (!cells)
      cells = this.getSelectionCells();
    if (!cells) {
      cells = sortCells(this.getSelectionCells(), true);
    }
    this.batchUpdate(() => {
      this.cellsOrdered(cells, back);
      const event = new EventObject_default(InternalEvent_default.ORDER_CELLS, "back", back, "cells", cells);
      this.fireEvent(event);
    });
    return cells;
  },
  cellsOrdered(cells, back = false) {
    this.batchUpdate(() => {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const parent2 = cells[i2].getParent();
        if (back) {
          this.getDataModel().add(parent2, cells[i2], i2);
        } else {
          this.getDataModel().add(parent2, cells[i2], parent2 ? parent2.getChildCount() - 1 : 0);
        }
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.CELLS_ORDERED, { back, cells }));
    });
  }
};

// node_modules/@maxgraph/core/lib/view/cell/CellOverlay.js
var CellOverlay = class extends EventSource_default {
  constructor(image, tooltip = null, align = "right", verticalAlign = "bottom", offset = new Point_default(), cursor = "help") {
    super();
    this.align = "right";
    this.verticalAlign = "bottom";
    this.offset = new Point_default();
    this.cursor = "help";
    this.defaultOverlap = 0.5;
    this.image = image;
    this.tooltip = tooltip;
    this.align = align;
    this.verticalAlign = verticalAlign;
    this.offset = offset;
    this.cursor = cursor;
  }
  /**
   * Returns the bounds of the overlay for the given <CellState> as an
   * {@link Rectangle}. This should be overridden when using multiple overlays
   * per cell so that the overlays do not overlap.
   *
   * The following example will place the overlay along an edge (where
   * x=[-1..1] from the start to the end of the edge and y is the
   * orthogonal offset in px).
   *
   * ```javascript
   * overlay.getBounds = function(state)
   * {
   *   var bounds = getBounds.apply(this, arguments);
   *
   *   if (state.view.graph.getDataModel().isEdge(state.cell))
   *   {
   *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});
   *
   *     bounds.x = pt.x - bounds.width / 2;
   *     bounds.y = pt.y - bounds.height / 2;
   *   }
   *
   *   return bounds;
   * };
   * ```
   *
   * @param state <CellState> that represents the current state of the
   * associated cell.
   */
  getBounds(state2) {
    const isEdge = state2.cell.isEdge();
    const s = state2.view.scale;
    let pt = null;
    const image = this.image;
    const w = image.width;
    const h = image.height;
    if (isEdge) {
      const pts = state2.absolutePoints;
      if (pts.length % 2 === 1) {
        pt = pts[Math.floor(pts.length / 2)];
      } else {
        const idx = pts.length / 2;
        const p0 = pts[idx - 1];
        const p1 = pts[idx];
        pt = new Point_default(p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);
      }
    } else {
      pt = new Point_default();
      if (this.align === "left") {
        pt.x = state2.x;
      } else if (this.align === "center") {
        pt.x = state2.x + state2.width / 2;
      } else if (this.align === "right") {
        pt.x = state2.x + state2.width;
      } else {
        throw new Error();
      }
      if (this.verticalAlign === "top") {
        pt.y = state2.y;
      } else if (this.verticalAlign === "middle") {
        pt.y = state2.y + state2.height / 2;
      } else if (this.verticalAlign === "bottom") {
        pt.y = state2.y + state2.height;
      } else {
        throw new Error();
      }
    }
    return new Rectangle_default(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);
  }
  /**
   * Returns the textual representation of the overlay to be used as the
   * tooltip. This implementation returns <tooltip>.
   */
  toString() {
    return this.tooltip;
  }
};
var CellOverlay_default = CellOverlay;

// node_modules/@maxgraph/core/lib/view/mixins/OverlaysMixin.js
var OverlaysMixin = {
  addCellOverlay(cell2, overlay) {
    cell2.overlays.push(overlay);
    const state2 = this.getView().getState(cell2);
    if (state2) {
      this.getCellRenderer().redraw(state2);
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.ADD_OVERLAY, { cell: cell2, overlay }));
    return overlay;
  },
  getCellOverlays(cell2) {
    return cell2.overlays;
  },
  removeCellOverlay(cell2, overlay = null) {
    if (!overlay) {
      this.removeCellOverlays(cell2);
    } else {
      const index = cell2.overlays.indexOf(overlay);
      if (index >= 0) {
        cell2.overlays.splice(index, 1);
        const state2 = this.getView().getState(cell2);
        if (state2) {
          this.getCellRenderer().redraw(state2);
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.REMOVE_OVERLAY, { cell: cell2, overlay }));
      } else {
        overlay = null;
      }
    }
    return overlay;
  },
  removeCellOverlays(cell2) {
    const { overlays } = cell2;
    cell2.overlays = [];
    const state2 = this.getView().getState(cell2);
    if (state2) {
      this.getCellRenderer().redraw(state2);
    }
    for (let i2 = 0; i2 < overlays.length; i2 += 1) {
      this.fireEvent(new EventObject_default(InternalEvent_default.REMOVE_OVERLAY, "cell", cell2, "overlay", overlays[i2]));
    }
    return overlays;
  },
  clearCellOverlays(cell2 = null) {
    cell2 = cell2 ?? this.getDataModel().getRoot();
    if (!cell2)
      return;
    this.removeCellOverlays(cell2);
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      this.clearCellOverlays(child2);
    }
  },
  setCellWarning(cell2, warning = null, img, isSelect = false) {
    img = img ?? this.getWarningImage();
    if (warning && warning.length > 0) {
      const overlay = new CellOverlay_default(img, `<font color=red>${warning}</font>`);
      if (isSelect) {
        overlay.addListener(InternalEvent_default.CLICK, (sender, evt2) => {
          if (this.isEnabled()) {
            this.setSelectionCell(cell2);
          }
        });
      }
      return this.addCellOverlay(cell2, overlay);
    }
    this.removeCellOverlays(cell2);
    return null;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/PageBreaksMixin.js
var PageBreaksMixin = {
  horizontalPageBreaks: null,
  verticalPageBreaks: null,
  updatePageBreaks(visible, _width, _height) {
    const { scale, translate: tr } = this.getView();
    const fmt = this.getPageFormat();
    const ps = scale * this.getPageScale();
    const bounds = new Rectangle_default(0, 0, fmt.width * ps, fmt.height * ps);
    const gb = Rectangle_default.fromRectangle(this.getGraphBounds());
    gb.width = Math.max(1, gb.width);
    gb.height = Math.max(1, gb.height);
    bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;
    bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;
    gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;
    gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;
    visible = visible && Math.min(bounds.width, bounds.height) > this.getMinPageBreakDist();
    const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;
    const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;
    const right = (verticalCount - 1) * bounds.width;
    const bottom = (horizontalCount - 1) * bounds.height;
    if (this.horizontalPageBreaks == null && horizontalCount > 0) {
      this.horizontalPageBreaks = [];
    }
    if (this.verticalPageBreaks == null && verticalCount > 0) {
      this.verticalPageBreaks = [];
    }
    const drawPageBreaks = (breaks) => {
      if (breaks != null) {
        const count = breaks === this.horizontalPageBreaks ? horizontalCount : verticalCount;
        for (let i2 = 0; i2 <= count; i2 += 1) {
          const pts = breaks === this.horizontalPageBreaks ? [
            new Point_default(Math.round(bounds.x), Math.round(bounds.y + i2 * bounds.height)),
            new Point_default(Math.round(bounds.x + right), Math.round(bounds.y + i2 * bounds.height))
          ] : [
            new Point_default(Math.round(bounds.x + i2 * bounds.width), Math.round(bounds.y)),
            new Point_default(Math.round(bounds.x + i2 * bounds.width), Math.round(bounds.y + bottom))
          ];
          if (breaks[i2] != null) {
            breaks[i2].points = pts;
            breaks[i2].redraw();
          } else {
            const pageBreak = new PolylineShape_default(pts, this.getPageBreakColor());
            pageBreak.dialect = this.getDialect();
            pageBreak.pointerEvents = false;
            pageBreak.isDashed = this.isPageBreakDashed();
            pageBreak.init(this.getView().backgroundPane);
            pageBreak.redraw();
            breaks[i2] = pageBreak;
          }
        }
        for (let i2 = count; i2 < breaks.length; i2 += 1) {
          breaks[i2].destroy();
        }
        breaks.splice(count, breaks.length - count);
      }
    };
    drawPageBreaks(this.horizontalPageBreaks);
    drawPageBreaks(this.verticalPageBreaks);
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/PanningMixin.js
var PanningMixin = {
  shiftPreview1: null,
  shiftPreview2: null,
  useScrollbarsForPanning: true,
  isUseScrollbarsForPanning() {
    return this.useScrollbarsForPanning;
  },
  timerAutoScroll: false,
  isTimerAutoScroll() {
    return this.timerAutoScroll;
  },
  allowAutoPanning: false,
  isAllowAutoPanning() {
    return this.allowAutoPanning;
  },
  panDx: 0,
  getPanDx() {
    return this.panDx;
  },
  setPanDx(dx) {
    this.panDx = dx;
  },
  panDy: 0,
  getPanDy() {
    return this.panDy;
  },
  setPanDy(dy) {
    this.panDy = dy;
  },
  panGraph(dx, dy) {
    const container = this.getContainer();
    if (this.useScrollbarsForPanning && hasScrollbars(container)) {
      container.scrollLeft = -dx;
      container.scrollTop = -dy;
    } else {
      const canvas = this.getView().getCanvas();
      if (dx === 0 && dy === 0) {
        canvas.removeAttribute("transform");
        if (this.shiftPreview1) {
          let child2 = this.shiftPreview1.firstChild;
          while (child2) {
            const next = child2.nextSibling;
            container.appendChild(child2);
            child2 = next;
          }
          if (this.shiftPreview1.parentNode) {
            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);
          }
          this.shiftPreview1 = null;
          container.appendChild(canvas.parentNode);
          const shiftPreview2 = this.shiftPreview2;
          child2 = shiftPreview2.firstChild;
          while (child2) {
            const next = child2.nextSibling;
            container.appendChild(child2);
            child2 = next;
          }
          if (shiftPreview2.parentNode) {
            shiftPreview2.parentNode.removeChild(shiftPreview2);
          }
          this.shiftPreview2 = null;
        }
      } else {
        canvas.setAttribute("transform", `translate(${dx},${dy})`);
        if (!this.shiftPreview1) {
          this.shiftPreview1 = document.createElement("div");
          this.shiftPreview1.style.position = "absolute";
          this.shiftPreview1.style.overflow = "visible";
          this.shiftPreview2 = document.createElement("div");
          this.shiftPreview2.style.position = "absolute";
          this.shiftPreview2.style.overflow = "visible";
          let current = this.shiftPreview1;
          let child2 = container.firstChild;
          while (child2) {
            const next = child2.nextSibling;
            if (child2 !== canvas.parentNode) {
              current.appendChild(child2);
            } else {
              current = this.shiftPreview2;
            }
            child2 = next;
          }
          if (this.shiftPreview1.firstChild) {
            container.insertBefore(this.shiftPreview1, canvas.parentNode);
          }
          if (this.shiftPreview2.firstChild) {
            container.appendChild(this.shiftPreview2);
          }
        }
        this.shiftPreview1.style.left = `${dx}px`;
        this.shiftPreview1.style.top = `${dy}px`;
        if (this.shiftPreview2) {
          this.shiftPreview2.style.left = `${dx}px`;
          this.shiftPreview2.style.top = `${dy}px`;
        }
      }
      this.panDx = dx;
      this.panDy = dy;
      this.fireEvent(new EventObject_default(InternalEvent_default.PAN));
    }
  },
  scrollCellToVisible(cell2, center = false) {
    const x = -this.getView().translate.x;
    const y = -this.getView().translate.y;
    const state2 = this.getView().getState(cell2);
    if (state2) {
      const bounds = new Rectangle_default(x + state2.x, y + state2.y, state2.width, state2.height);
      if (center && this.getContainer()) {
        const w = this.getContainer().clientWidth;
        const h = this.getContainer().clientHeight;
        bounds.x = bounds.getCenterX() - w / 2;
        bounds.width = w;
        bounds.y = bounds.getCenterY() - h / 2;
        bounds.height = h;
      }
      const tr = new Point_default(this.getView().translate.x, this.getView().translate.y);
      if (this.scrollRectToVisible(bounds)) {
        const tr2 = new Point_default(this.getView().translate.x, this.getView().translate.y);
        this.getView().translate.x = tr.x;
        this.getView().translate.y = tr.y;
        this.getView().setTranslate(tr2.x, tr2.y);
      }
    }
  },
  scrollRectToVisible(rect) {
    let isChanged = false;
    const container = this.getContainer();
    const w = container.offsetWidth;
    const h = container.offsetHeight;
    const widthLimit = Math.min(w, rect.width);
    const heightLimit = Math.min(h, rect.height);
    if (hasScrollbars(container)) {
      rect.x += this.getView().translate.x;
      rect.y += this.getView().translate.y;
      let dx = container.scrollLeft - rect.x;
      const ddx = Math.max(dx - container.scrollLeft, 0);
      if (dx > 0) {
        container.scrollLeft -= dx + 2;
      } else {
        dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;
        if (dx > 0) {
          container.scrollLeft += dx + 2;
        }
      }
      let dy = container.scrollTop - rect.y;
      const ddy = Math.max(0, dy - container.scrollTop);
      if (dy > 0) {
        container.scrollTop -= dy + 2;
      } else {
        dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;
        if (dy > 0) {
          container.scrollTop += dy + 2;
        }
      }
      if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {
        this.getView().setTranslate(ddx, ddy);
      }
    } else {
      const x = -this.getView().translate.x;
      const y = -this.getView().translate.y;
      const s = this.getView().scale;
      if (rect.x + widthLimit > x + w) {
        this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;
        isChanged = true;
      }
      if (rect.y + heightLimit > y + h) {
        this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;
        isChanged = true;
      }
      if (rect.x < x) {
        this.getView().translate.x += (x - rect.x) / s;
        isChanged = true;
      }
      if (rect.y < y) {
        this.getView().translate.y += (y - rect.y) / s;
        isChanged = true;
      }
      if (isChanged) {
        this.getView().refresh();
        const selectionCellsHandler = this.getPlugin("SelectionCellsHandler");
        if (selectionCellsHandler) {
          selectionCellsHandler.refresh();
        }
      }
    }
    return isChanged;
  },
  setPanning(enabled2) {
    const panningHandler = this.getPlugin("PanningHandler");
    panningHandler && (panningHandler.panningEnabled = enabled2);
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/PortsMixin.js
var PortsMixin = {
  portsEnabled: true,
  isPort(cell2) {
    return false;
  },
  getTerminalForPort(cell2, _source = false) {
    return cell2.getParent();
  },
  isPortsEnabled() {
    return this.portsEnabled;
  },
  setPortsEnabled(value2) {
    this.portsEnabled = value2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/SelectionMixin.js
var SelectionMixin = {
  selectionModel: null,
  getSelectionModel() {
    return this.selectionModel;
  },
  setSelectionModel(selectionModel) {
    this.selectionModel = selectionModel;
  },
  /*****************************************************************************
   * Selection
   *****************************************************************************/
  isCellSelected(cell2) {
    return this.selectionModel.isSelected(cell2);
  },
  isSelectionEmpty() {
    return this.selectionModel.isEmpty();
  },
  clearSelection() {
    this.selectionModel.clear();
  },
  getSelectionCount() {
    return this.selectionModel.cells.length;
  },
  getSelectionCell() {
    return this.selectionModel.cells[0];
  },
  getSelectionCells() {
    return this.selectionModel.cells.slice();
  },
  setSelectionCell(cell2) {
    this.selectionModel.setCell(cell2);
  },
  setSelectionCells(cells) {
    this.selectionModel.setCells(cells);
  },
  addSelectionCell(cell2) {
    this.selectionModel.addCell(cell2);
  },
  addSelectionCells(cells) {
    this.selectionModel.addCells(cells);
  },
  removeSelectionCell(cell2) {
    this.selectionModel.removeCell(cell2);
  },
  removeSelectionCells(cells) {
    this.selectionModel.removeCells(cells);
  },
  selectRegion(rect, evt2) {
    const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);
    this.selectCellsForEvent(cells, evt2);
    return cells;
  },
  selectNextCell() {
    this.selectCell(true);
  },
  selectPreviousCell() {
    this.selectCell();
  },
  selectParentCell() {
    this.selectCell(false, true);
  },
  selectChildCell() {
    this.selectCell(false, false, true);
  },
  selectCell(isNext = false, isParent = false, isChild = false) {
    const cell2 = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;
    if (this.selectionModel.cells.length > 1) {
      this.selectionModel.clear();
    }
    const parent2 = cell2 ? cell2.getParent() : this.getDefaultParent();
    const childCount2 = parent2.getChildCount();
    if (!cell2 && childCount2 > 0) {
      const child2 = parent2.getChildAt(0);
      this.setSelectionCell(child2);
    } else if (parent2 && (!cell2 || isParent) && this.getView().getState(parent2) && parent2.getGeometry()) {
      if (this.getCurrentRoot() !== parent2) {
        this.setSelectionCell(parent2);
      }
    } else if (cell2 && isChild) {
      const tmp2 = cell2.getChildCount();
      if (tmp2 > 0) {
        const child2 = cell2.getChildAt(0);
        this.setSelectionCell(child2);
      }
    } else if (childCount2 > 0) {
      let i2 = parent2.getIndex(cell2);
      if (isNext) {
        i2++;
        const child2 = parent2.getChildAt(i2 % childCount2);
        this.setSelectionCell(child2);
      } else {
        i2--;
        const index = i2 < 0 ? childCount2 - 1 : i2;
        const child2 = parent2.getChildAt(index);
        this.setSelectionCell(child2);
      }
    }
  },
  selectAll(parent2, descendants = false) {
    parent2 = parent2 ?? this.getDefaultParent();
    const cells = descendants ? parent2.filterDescendants((cell2) => {
      return cell2 !== parent2 && !!this.getView().getState(cell2);
    }) : parent2.getChildren();
    this.setSelectionCells(cells);
  },
  selectVertices(parent2, selectGroups = false) {
    this.selectCells(true, false, parent2, selectGroups);
  },
  selectEdges(parent2) {
    this.selectCells(false, true, parent2);
  },
  selectCells(vertices = false, edges = false, parent2, selectGroups = false) {
    parent2 = parent2 ?? this.getDefaultParent();
    const filter = (cell2) => {
      const p = cell2.getParent();
      return !!this.getView().getState(cell2) && ((selectGroups || cell2.getChildCount() === 0) && cell2.isVertex() && vertices && p && !p.isEdge() || cell2.isEdge() && edges);
    };
    const cells = parent2.filterDescendants(filter);
    this.setSelectionCells(cells);
  },
  selectCellForEvent(cell2, evt2) {
    const isSelected = this.isCellSelected(cell2);
    if (this.isToggleEvent(evt2)) {
      if (isSelected) {
        this.removeSelectionCell(cell2);
      } else {
        this.addSelectionCell(cell2);
      }
    } else if (!isSelected || this.getSelectionCount() !== 1) {
      this.setSelectionCell(cell2);
    }
  },
  selectCellsForEvent(cells, evt2) {
    if (this.isToggleEvent(evt2)) {
      this.addSelectionCells(cells);
    } else {
      this.setSelectionCells(cells);
    }
  },
  isSiblingSelected(cell2) {
    const parent2 = cell2.getParent();
    const childCount2 = parent2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = parent2.getChildAt(i2);
      if (cell2 !== child2 && this.isCellSelected(child2)) {
        return true;
      }
    }
    return false;
  },
  /*****************************************************************************
   * Selection state
   *****************************************************************************/
  getSelectionCellsForChanges(changes, ignoreFn = null) {
    const dict = new Dictionary_default();
    const cells = [];
    const addCell = (cell2) => {
      if (!dict.get(cell2) && this.getDataModel().contains(cell2)) {
        if (cell2.isEdge() || cell2.isVertex()) {
          dict.put(cell2, true);
          cells.push(cell2);
        } else {
          const childCount2 = cell2.getChildCount();
          for (let i2 = 0; i2 < childCount2; i2 += 1) {
            addCell(cell2.getChildAt(i2));
          }
        }
      }
    };
    for (let i2 = 0; i2 < changes.length; i2 += 1) {
      const change = changes[i2];
      if (change.constructor !== RootChange_default && (!ignoreFn || !ignoreFn(change))) {
        let cell2 = null;
        if (change instanceof ChildChange_default) {
          cell2 = change.child;
        } else if (change.cell && change.cell instanceof Cell_default) {
          cell2 = change.cell;
        }
        if (cell2) {
          addCell(cell2);
        }
      }
    }
    return cells;
  },
  updateSelection() {
    const cells = this.getSelectionCells();
    const removed = [];
    for (const cell2 of cells) {
      if (!this.getDataModel().contains(cell2) || !cell2.isVisible()) {
        removed.push(cell2);
      } else {
        let par = cell2.getParent();
        while (par && par !== this.getView().currentRoot) {
          if (par.isCollapsed() || !par.isVisible()) {
            removed.push(cell2);
            break;
          }
          par = par.getParent();
        }
      }
    }
    this.removeSelectionCells(removed);
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/SnapMixin.js
var SnapMixin = {
  snapTolerance: 0,
  getSnapTolerance() {
    return this.snapTolerance;
  },
  gridSize: 10,
  gridEnabled: true,
  snap(value2) {
    if (this.gridEnabled) {
      value2 = Math.round(value2 / this.gridSize) * this.gridSize;
    }
    return value2;
  },
  snapDelta(delta, bounds, ignoreGrid = false, ignoreHorizontal = false, ignoreVertical = false) {
    const t = this.getView().translate;
    const s = this.getView().scale;
    if (!ignoreGrid && this.gridEnabled) {
      const tol = this.gridSize * s * 0.5;
      if (!ignoreHorizontal) {
        const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;
        if (Math.abs(delta.x - tx) < tol) {
          delta.x = 0;
        } else {
          delta.x = this.snap(delta.x / s) * s - tx;
        }
      }
      if (!ignoreVertical) {
        const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;
        if (Math.abs(delta.y - ty) < tol) {
          delta.y = 0;
        } else {
          delta.y = this.snap(delta.y / s) * s - ty;
        }
      }
    } else {
      const tol = 0.5 * s;
      if (!ignoreHorizontal) {
        const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;
        if (Math.abs(delta.x - tx) < tol) {
          delta.x = 0;
        } else {
          delta.x = Math.round(delta.x / s) * s - tx;
        }
      }
      if (!ignoreVertical) {
        const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;
        if (Math.abs(delta.y - ty) < tol) {
          delta.y = 0;
        } else {
          delta.y = Math.round(delta.y / s) * s - ty;
        }
      }
    }
    return delta;
  },
  isGridEnabled() {
    return this.gridEnabled;
  },
  setGridEnabled(value2) {
    this.gridEnabled = value2;
  },
  getGridSize() {
    return this.gridSize;
  },
  setGridSize(value2) {
    this.gridSize = value2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/SwimlaneMixin.js
var SwimlaneMixin = {
  swimlaneSelectionEnabled: true,
  swimlaneNesting: true,
  swimlaneIndicatorColorAttribute: "fillColor",
  getSwimlane(cell2 = null) {
    while (cell2 && !this.isSwimlane(cell2)) {
      cell2 = cell2.getParent();
    }
    return cell2;
  },
  getSwimlaneAt(x, y, parent2) {
    if (!parent2) {
      parent2 = this.getCurrentRoot();
      if (!parent2) {
        parent2 = this.getDataModel().getRoot();
      }
    }
    if (parent2) {
      const childCount2 = parent2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = parent2.getChildAt(i2);
        if (child2) {
          const result2 = this.getSwimlaneAt(x, y, child2);
          if (result2 != null) {
            return result2;
          }
          if (child2.isVisible() && this.isSwimlane(child2)) {
            const state2 = this.getView().getState(child2);
            if (state2 && this.intersects(state2, x, y)) {
              return child2;
            }
          }
        }
      }
    }
    return null;
  },
  hitsSwimlaneContent(swimlane, x, y) {
    const state2 = this.getView().getState(swimlane);
    const size = this.getStartSize(swimlane);
    if (state2) {
      const scale = this.getView().getScale();
      x -= state2.x;
      y -= state2.y;
      if (size.width > 0 && x > 0 && x > size.width * scale) {
        return true;
      }
      if (size.height > 0 && y > 0 && y > size.height * scale) {
        return true;
      }
    }
    return false;
  },
  getStartSize(swimlane, ignoreState = false) {
    const result2 = new Rectangle_default();
    const style2 = this.getCurrentCellStyle(swimlane, ignoreState);
    const size = style2.startSize ?? DEFAULT_STARTSIZE;
    if (style2.horizontal ?? true) {
      result2.height = size;
    } else {
      result2.width = size;
    }
    return result2;
  },
  getSwimlaneDirection(style2) {
    const dir = style2.direction ?? DIRECTION.EAST;
    const flipH = style2.flipH;
    const flipV = style2.flipV;
    const h = style2.horizontal ?? true;
    let n = h ? 0 : 3;
    if (dir === DIRECTION.NORTH) {
      n--;
    } else if (dir === DIRECTION.WEST) {
      n += 2;
    } else if (dir === DIRECTION.SOUTH) {
      n += 1;
    }
    const _mod = mod(n, 2);
    if (flipH && _mod === 1) {
      n += 2;
    }
    if (flipV && _mod === 0) {
      n += 2;
    }
    return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];
  },
  getActualStartSize(swimlane, ignoreState = false) {
    const result2 = new Rectangle_default();
    if (this.isSwimlane(swimlane, ignoreState)) {
      const style2 = this.getCurrentCellStyle(swimlane, ignoreState);
      const size = style2.startSize ?? DEFAULT_STARTSIZE;
      const dir = this.getSwimlaneDirection(style2);
      if (dir === DIRECTION.NORTH) {
        result2.y = size;
      } else if (dir === DIRECTION.WEST) {
        result2.x = size;
      } else if (dir === DIRECTION.SOUTH) {
        result2.height = size;
      } else {
        result2.width = size;
      }
    }
    return result2;
  },
  isSwimlane(cell2, ignoreState = false) {
    if (cell2 && cell2.getParent() !== this.getDataModel().getRoot() && !cell2.isEdge()) {
      return this.getCurrentCellStyle(cell2, ignoreState).shape === SHAPE.SWIMLANE;
    }
    return false;
  },
  isValidDropTarget(cell2, cells, evt2) {
    return cell2 && (this.isSplitEnabled() && this.isSplitTarget(cell2, cells, evt2) || !cell2.isEdge() && (this.isSwimlane(cell2) || cell2.getChildCount() > 0 && !cell2.isCollapsed()));
  },
  getDropTarget(cells, evt2, cell2 = null, clone2 = false) {
    if (!this.isSwimlaneNesting()) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        if (this.isSwimlane(cells[i2])) {
          return null;
        }
      }
    }
    const pt = convertPoint(this.getContainer(), getClientX(evt2), getClientY(evt2));
    pt.x -= this.getPanDx();
    pt.y -= this.getPanDy();
    const swimlane = this.getSwimlaneAt(pt.x, pt.y);
    if (!cell2) {
      cell2 = swimlane;
    } else if (swimlane) {
      let tmp2 = swimlane.getParent();
      while (tmp2 && this.isSwimlane(tmp2) && tmp2 !== cell2) {
        tmp2 = tmp2.getParent();
      }
      if (tmp2 === cell2) {
        cell2 = swimlane;
      }
    }
    while (cell2 && !this.isValidDropTarget(cell2, cells, evt2) && !this.getDataModel().isLayer(cell2)) {
      cell2 = cell2.getParent();
    }
    let parentCell = cell2;
    if (!clone2) {
      while (parentCell && cells.indexOf(parentCell) < 0) {
        parentCell = parentCell.getParent();
      }
    }
    return !this.getDataModel().isLayer(cell2) && !parentCell ? cell2 : null;
  },
  isSwimlaneNesting() {
    return this.swimlaneNesting;
  },
  setSwimlaneNesting(value2) {
    this.swimlaneNesting = value2;
  },
  isSwimlaneSelectionEnabled() {
    return this.swimlaneSelectionEnabled;
  },
  setSwimlaneSelectionEnabled(value2) {
    this.swimlaneSelectionEnabled = value2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/TerminalMixin.js
var TerminalMixin = {
  isTerminalPointMovable(cell2, source2) {
    return true;
  },
  getOpposites(edges, terminal = null, includeSources = true, includeTargets = true) {
    const terminals = [];
    const dict = new Dictionary_default();
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const state2 = this.getView().getState(edges[i2]);
      const source2 = state2 ? state2.getVisibleTerminal(true) : this.getView().getVisibleTerminal(edges[i2], true);
      const target2 = state2 ? state2.getVisibleTerminal(false) : this.getView().getVisibleTerminal(edges[i2], false);
      if (source2 === terminal && target2 && target2 !== terminal && includeTargets) {
        if (!dict.get(target2)) {
          dict.put(target2, true);
          terminals.push(target2);
        }
      } else if (target2 === terminal && source2 && source2 !== terminal && includeSources) {
        if (!dict.get(source2)) {
          dict.put(source2, true);
          terminals.push(source2);
        }
      }
    }
    return terminals;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/TooltipMixin.js
var TooltipMixin = {
  getTooltip(state2, node2, x, y) {
    let tip = null;
    if (state2.control && (node2 === state2.control.node || node2.parentNode === state2.control.node)) {
      tip = this.getCollapseExpandResource();
      tip = htmlEntities(Translations_default.get(tip) || tip, true).replace(/\\n/g, "<br>");
    }
    if (!tip && state2.overlays) {
      state2.overlays.visit((id2, shape2) => {
        if (!tip && (node2 === shape2.node || node2.parentNode === shape2.node)) {
          tip = shape2.overlay ? shape2.overlay.toString() ?? null : null;
        }
      });
    }
    if (!tip) {
      const selectionCellsHandler = this.getPlugin("SelectionCellsHandler");
      const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(state2.cell);
      if (handler && "getTooltipForNode" in handler && typeof handler.getTooltipForNode === "function") {
        tip = handler.getTooltipForNode(node2);
      }
    }
    if (!tip) {
      tip = this.getTooltipForCell(state2.cell);
    }
    return tip;
  },
  getTooltipForCell(cell2) {
    let tip = null;
    if (cell2 && "getTooltip" in cell2) {
      tip = cell2.getTooltip();
    } else {
      tip = this.convertValueToString(cell2);
    }
    return tip;
  },
  setTooltips(enabled2) {
    const tooltipHandler = this.getPlugin("TooltipHandler");
    tooltipHandler == null ? void 0 : tooltipHandler.setEnabled(enabled2);
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/ValidationMixin.js
var ValidationMixin = {
  validationAlert(message) {
    alert(message);
  },
  isEdgeValid(edge2, source2, target2) {
    return !this.getEdgeValidationError(edge2, source2, target2);
  },
  getEdgeValidationError(edge2 = null, source2 = null, target2 = null) {
    if (edge2 && !this.isAllowDanglingEdges() && (!source2 || !target2)) {
      return "";
    }
    if (edge2 && !edge2.getTerminal(true) && !edge2.getTerminal(false)) {
      return null;
    }
    if (!this.isAllowLoops() && source2 === target2 && source2) {
      return "";
    }
    if (!this.isValidConnection(source2, target2)) {
      return "";
    }
    if (source2 && target2) {
      let error2 = "";
      if (!this.isMultigraph()) {
        const tmp2 = this.getDataModel().getEdgesBetween(source2, target2, true);
        if (tmp2.length > 1 || tmp2.length === 1 && tmp2[0] !== edge2) {
          error2 += `${Translations_default.get(this.getAlreadyConnectedResource()) || this.getAlreadyConnectedResource()}
`;
        }
      }
      const sourceOut = source2.getDirectedEdgeCount(true, edge2);
      const targetIn = target2.getDirectedEdgeCount(false, edge2);
      for (const multiplicity of this.multiplicities) {
        const err2 = multiplicity.check(
          this,
          // needs to cast to Graph
          edge2,
          source2,
          target2,
          sourceOut,
          targetIn
        );
        if (err2 != null) {
          error2 += err2;
        }
      }
      const err = this.validateEdge(edge2, source2, target2);
      if (err != null) {
        error2 += err;
      }
      return error2.length > 0 ? error2 : null;
    }
    return this.isAllowDanglingEdges() ? null : "";
  },
  validateEdge(edge2 = null, source2 = null, target2 = null) {
    return null;
  },
  validateGraph(cell2 = null, context) {
    cell2 = cell2 ?? this.getDataModel().getRoot();
    if (!cell2) {
      return "The root does not exist!";
    }
    context = context ?? {};
    let isValid = true;
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const tmp2 = cell2.getChildAt(i2);
      let ctx = context;
      if (this.isValidRoot(tmp2)) {
        ctx = {};
      }
      const warn = this.validateGraph(tmp2, ctx);
      if (warn) {
        this.setCellWarning(tmp2, warn.replace(/\n/g, "<br>"));
      } else {
        this.setCellWarning(tmp2, null);
      }
      isValid = isValid && warn == null;
    }
    let warning = "";
    if (cell2 && cell2.isCollapsed() && !isValid) {
      warning += `${Translations_default.get(this.getContainsValidationErrorsResource()) || this.getContainsValidationErrorsResource()}
`;
    }
    if (cell2 && cell2.isEdge()) {
      warning += this.getEdgeValidationError(cell2, cell2.getTerminal(true), cell2.getTerminal(false)) || "";
    } else {
      warning += this.getCellValidationError(cell2) || "";
    }
    const err = this.validateCell(cell2, context);
    if (err != null) {
      warning += err;
    }
    if (cell2.getParent() == null) {
      this.getView().validate();
    }
    return warning.length > 0 || !isValid ? warning : null;
  },
  getCellValidationError(cell2) {
    const outCount = cell2.getDirectedEdgeCount(true);
    const inCount = cell2.getDirectedEdgeCount(false);
    const value2 = cell2.getValue();
    let error2 = "";
    for (let i2 = 0; i2 < this.multiplicities.length; i2 += 1) {
      const rule = this.multiplicities[i2];
      if (rule.source && isNode(value2, rule.type, rule.attr, rule.value) && (outCount > rule.max || outCount < rule.min)) {
        error2 += `${rule.countError}
`;
      } else if (!rule.source && isNode(value2, rule.type, rule.attr, rule.value) && (inCount > rule.max || inCount < rule.min)) {
        error2 += `${rule.countError}
`;
      }
    }
    return error2.length > 0 ? error2 : null;
  },
  validateCell(cell2, context) {
    return null;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/VertexMixin.js
var VertexMixin = {
  vertexLabelsMovable: false,
  allowNegativeCoordinates: true,
  isAllowNegativeCoordinates() {
    return this.allowNegativeCoordinates;
  },
  setAllowNegativeCoordinates(value2) {
    this.allowNegativeCoordinates = value2;
  },
  insertVertex(...args) {
    var _a2, _b, _c, _d;
    let parent2;
    let id2;
    let value2;
    let x;
    let y;
    let width;
    let height;
    let style2;
    let relative;
    let geometryClass;
    if (args.length === 1 && typeof args[0] === "object") {
      const params = args[0];
      parent2 = params.parent;
      id2 = params.id;
      value2 = params.value;
      x = "x" in params ? params.x : (_a2 = params.position) == null ? void 0 : _a2[0];
      y = "y" in params ? params.y : (_b = params.position) == null ? void 0 : _b[1];
      width = "width" in params ? params.width : (_c = params.size) == null ? void 0 : _c[0];
      height = "height" in params ? params.height : (_d = params.size) == null ? void 0 : _d[1];
      style2 = params.style;
      relative = params.relative;
      geometryClass = params.geometryClass;
    } else {
      [parent2, id2, value2, x, y, width, height, style2, relative, geometryClass] = args;
    }
    const vertex = this.createVertex(parent2, id2, value2, x, y, width, height, style2, relative, geometryClass);
    return this.addCell(vertex, parent2);
  },
  createVertex(_parent, id2, value2, x, y, width, height, style2, relative = false, geometryClass = Geometry_default) {
    const geometry = new geometryClass(x, y, width, height);
    geometry.relative = relative;
    const vertex = new Cell_default(value2, geometry, style2);
    vertex.setId(id2);
    vertex.setVertex(true);
    vertex.setConnectable(true);
    return vertex;
  },
  getChildVertices(parent2) {
    return this.getChildCells(parent2, true, false);
  },
  isVertexLabelsMovable() {
    return this.vertexLabelsMovable;
  },
  setVertexLabelsMovable(value2) {
    this.vertexLabelsMovable = value2;
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/ZoomMixin.js
var ZoomMixin = {
  zoomFactor: 1.2,
  keepSelectionVisibleOnZoom: false,
  centerZoom: true,
  zoomIn() {
    this.zoom(this.zoomFactor);
  },
  zoomOut() {
    this.zoom(1 / this.zoomFactor);
  },
  zoomActual() {
    if (this.getView().scale === 1) {
      this.getView().setTranslate(0, 0);
    } else {
      this.getView().translate.x = 0;
      this.getView().translate.y = 0;
      this.getView().setScale(1);
    }
  },
  zoomTo(scale, center = false) {
    this.zoom(scale / this.getView().scale, center);
  },
  zoom(factor, center) {
    center = center ?? this.centerZoom;
    const scale = Math.round(this.getView().scale * factor * 100) / 100;
    const state2 = this.getView().getState(this.getSelectionCell());
    const container = this.getContainer();
    factor = scale / this.getView().scale;
    if (this.keepSelectionVisibleOnZoom && state2 != null) {
      const rect = new Rectangle_default(state2.x * factor, state2.y * factor, state2.width * factor, state2.height * factor);
      this.getView().scale = scale;
      if (!this.scrollRectToVisible(rect)) {
        this.getView().revalidate();
        this.getView().setScale(scale);
      }
    } else {
      const _hasScrollbars = hasScrollbars(this.getContainer());
      if (center && !_hasScrollbars) {
        let dx = container.offsetWidth;
        let dy = container.offsetHeight;
        if (factor > 1) {
          const f = (factor - 1) / (scale * 2);
          dx *= -f;
          dy *= -f;
        } else {
          const f = (1 / factor - 1) / (this.getView().scale * 2);
          dx *= f;
          dy *= f;
        }
        this.getView().scaleAndTranslate(scale, this.getView().translate.x + dx, this.getView().translate.y + dy);
      } else {
        const tx = this.getView().translate.x;
        const ty = this.getView().translate.y;
        const sl = container.scrollLeft;
        const st = container.scrollTop;
        this.getView().setScale(scale);
        if (_hasScrollbars) {
          let dx = 0;
          let dy = 0;
          if (center) {
            dx = container.offsetWidth * (factor - 1) / 2;
            dy = container.offsetHeight * (factor - 1) / 2;
          }
          container.scrollLeft = (this.getView().translate.x - tx) * this.getView().scale + Math.round(sl * factor + dx);
          container.scrollTop = (this.getView().translate.y - ty) * this.getView().scale + Math.round(st * factor + dy);
        }
      }
    }
  },
  zoomToRect(rect) {
    const container = this.getContainer();
    const scaleX = container.clientWidth / rect.width;
    const scaleY = container.clientHeight / rect.height;
    const aspectFactor = scaleX / scaleY;
    rect.x = Math.max(0, rect.x);
    rect.y = Math.max(0, rect.y);
    let rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
    let rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
    rect.width = rectRight - rect.x;
    rect.height = rectBottom - rect.y;
    if (aspectFactor < 1) {
      const newHeight = rect.height / aspectFactor;
      const deltaHeightBuffer = (newHeight - rect.height) / 2;
      rect.height = newHeight;
      const upperBuffer = Math.min(rect.y, deltaHeightBuffer);
      rect.y -= upperBuffer;
      rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);
      rect.height = rectBottom - rect.y;
    } else {
      const newWidth = rect.width * aspectFactor;
      const deltaWidthBuffer = (newWidth - rect.width) / 2;
      rect.width = newWidth;
      const leftBuffer = Math.min(rect.x, deltaWidthBuffer);
      rect.x -= leftBuffer;
      rectRight = Math.min(container.scrollWidth, rect.x + rect.width);
      rect.width = rectRight - rect.x;
    }
    const scale = container.clientWidth / rect.width;
    const newScale = this.getView().scale * scale;
    if (!hasScrollbars(this.getContainer())) {
      this.getView().scaleAndTranslate(newScale, this.getView().translate.x - rect.x / this.getView().scale, this.getView().translate.y - rect.y / this.getView().scale);
    } else {
      this.getView().setScale(newScale);
      container.scrollLeft = Math.round(rect.x * scale);
      container.scrollTop = Math.round(rect.y * scale);
    }
  }
};

// node_modules/@maxgraph/core/lib/view/mixins/_graph-mixins-apply.js
var applyGraphMixins = () => {
  const mixIntoGraph = mixInto(Graph);
  for (const mixin of [
    CellsMixin,
    ConnectionsMixin,
    DragDropMixin,
    EdgeMixin,
    EditingMixin,
    EventsMixin,
    FoldingMixin,
    GroupingMixin,
    ImageMixin,
    LabelMixin,
    OrderMixin,
    PageBreaksMixin,
    OverlaysMixin,
    PanningMixin,
    PortsMixin,
    SelectionMixin,
    SnapMixin,
    SwimlaneMixin,
    TerminalMixin,
    TooltipMixin,
    ValidationMixin,
    VertexMixin,
    ZoomMixin
  ]) {
    mixIntoGraph(mixin);
  }
};

// node_modules/@maxgraph/core/lib/view/handler/CellEditorHandler.js
var CellEditorHandler = class {
  constructor(graph) {
    this.clearOnChange = false;
    this.bounds = null;
    this.resizeThread = null;
    this.textDirection = null;
    this.textarea = null;
    this.editingCell = null;
    this.trigger = null;
    this.modified = false;
    this.autoSize = true;
    this.selectText = true;
    this.emptyLabelText = Client_default.IS_FF ? "<br>" : "";
    this.escapeCancelsEditing = true;
    this.textNode = null;
    this.zIndex = 5;
    this.minResize = new Rectangle_default(0, 20);
    this.wordWrapPadding = 0;
    this.blurEnabled = false;
    this.initialValue = null;
    this.align = null;
    this.graph = graph;
    this.zoomHandler = () => {
      if (this.graph.isEditing()) {
        this.resize();
      }
    };
    this.changeHandler = (sender) => {
      if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {
        this.stopEditing(true);
      }
    };
    this.graph.getView().addListener(InternalEvent_default.SCALE, this.zoomHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.zoomHandler);
    this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.changeHandler);
  }
  /**
   * Creates the <textarea> and installs the event listeners. The key handler
   * updates the {@link odified} state.
   */
  init() {
    this.textarea = document.createElement("div");
    this.textarea.className = "mxCellEditor mxPlainTextEditor";
    this.textarea.contentEditable = String(true);
    if (Client_default.IS_GC) {
      this.textarea.style.minHeight = "1em";
    }
    this.textarea.style.position = "relative";
    this.installListeners(this.textarea);
  }
  /**
   * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.
   */
  // applyValue(state: CellState, value: string): void;
  applyValue(state2, value2) {
    this.graph.labelChanged(state2.cell, value2, this.trigger);
  }
  /**
   * Sets the temporary horizontal alignment for the current editing session.
   */
  setAlign(align) {
    if (this.textarea) {
      this.textarea.style.textAlign = align;
    }
    this.align = align;
    this.resize();
  }
  /**
   * Gets the initial editing value for the given cell.
   */
  getInitialValue(state2, trigger) {
    let result2 = htmlEntities(this.graph.getEditingValue(state2.cell, trigger), false);
    result2 = replaceTrailingNewlines(result2, "<div><br></div>");
    return result2.replace(/\n/g, "<br>");
  }
  /**
   * Returns the current editing value.
   */
  getCurrentValue(state2) {
    if (!this.textarea)
      return null;
    return extractTextWithWhitespace(Array.from(this.textarea.childNodes));
  }
  /**
   * Returns true if <escapeCancelsEditing> is true and shift, control and meta
   * are not pressed.
   */
  // isCancelEditingKeyEvent(evt: Event): boolean;
  isCancelEditingKeyEvent(evt2) {
    return this.escapeCancelsEditing || isShiftDown(evt2) || isControlDown(evt2) || isMetaDown(evt2);
  }
  /**
   * Installs listeners for focus, change and standard key event handling.
   */
  // installListeners(elt: Element): void;
  installListeners(elt2) {
    InternalEvent_default.addListener(elt2, "dragstart", (evt2) => {
      this.graph.stopEditing(false);
      InternalEvent_default.consume(evt2);
    });
    InternalEvent_default.addListener(elt2, "blur", (evt2) => {
      if (this.blurEnabled) {
        this.focusLost();
      }
    });
    InternalEvent_default.addListener(elt2, "keydown", (evt2) => {
      if (!isConsumed(evt2)) {
        if (this.isStopEditingEvent(evt2)) {
          this.graph.stopEditing(false);
          InternalEvent_default.consume(evt2);
        } else if (evt2.keyCode === 27) {
          this.graph.stopEditing(this.isCancelEditingKeyEvent(evt2));
          InternalEvent_default.consume(evt2);
        }
      }
    });
    const keypressHandler = (evt2) => {
      if (this.editingCell != null) {
        if (this.clearOnChange && elt2.innerHTML === this.getEmptyLabelText() && (!Client_default.IS_FF || evt2.keyCode !== 8 && evt2.keyCode !== 46)) {
          this.clearOnChange = false;
          elt2.innerHTML = "";
        }
      }
    };
    InternalEvent_default.addListener(elt2, "keypress", keypressHandler);
    InternalEvent_default.addListener(elt2, "paste", keypressHandler);
    const keyupHandler = (evt2) => {
      if (this.editingCell != null) {
        const textarea = this.textarea;
        if (textarea.innerHTML.length === 0 || textarea.innerHTML === "<br>") {
          textarea.innerHTML = this.getEmptyLabelText();
          this.clearOnChange = textarea.innerHTML.length > 0;
        } else {
          this.clearOnChange = false;
        }
      }
    };
    InternalEvent_default.addListener(elt2, "input", keyupHandler);
    InternalEvent_default.addListener(elt2, "cut", keyupHandler);
    InternalEvent_default.addListener(elt2, "paste", keyupHandler);
    const evtName = "input";
    const resizeHandler = (evt2) => {
      if (this.editingCell != null && this.autoSize && !isConsumed(evt2)) {
        if (this.resizeThread != null) {
          window.clearTimeout(this.resizeThread);
        }
        this.resizeThread = window.setTimeout(() => {
          this.resizeThread = null;
          this.resize();
        }, 0);
      }
    };
    InternalEvent_default.addListener(elt2, evtName, resizeHandler);
    InternalEvent_default.addListener(window, "resize", resizeHandler);
    InternalEvent_default.addListener(elt2, "cut", resizeHandler);
    InternalEvent_default.addListener(elt2, "paste", resizeHandler);
  }
  /**
   * Returns true if the given keydown event should stop cell editing. This
   * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true
   * and enter is pressed without control or shift.
   */
  isStopEditingEvent(evt2) {
    return evt2.keyCode === 113 || this.graph.isEnterStopsCellEditing() && evt2.keyCode === 13 && !isControlDown(evt2) && !isShiftDown(evt2);
  }
  /**
   * Returns true if this editor is the source for the given native event.
   */
  isEventSource(evt2) {
    return getSource(evt2) === this.textarea;
  }
  /**
   * Returns {@link odified}.
   */
  resize() {
    const state2 = this.editingCell ? this.graph.getView().getState(this.editingCell) : null;
    if (!state2) {
      this.stopEditing(true);
    } else if (this.textarea != null) {
      const isEdge = state2.cell.isEdge();
      const { scale } = this.graph.getView();
      let m = null;
      if (!this.autoSize || state2.style.overflow === "fill") {
        this.bounds = this.getEditorBounds(state2);
        this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;
        this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;
        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;
        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;
        if (this.graph.isWrapping(state2.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = "normal";
          if (state2.style.overflow !== "fill") {
            this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          if (state2.style.overflow !== "fill") {
            this.textarea.style.width = "";
          }
        }
      } else {
        const lw = getValue(state2.style, "labelWidth", null);
        m = state2.text != null && this.align == null ? state2.text.margin : null;
        if (m == null) {
          m = getAlignmentAsPoint(this.align || getValue(state2.style, "align", ALIGN.CENTER), getValue(state2.style, "verticalAlign", ALIGN.MIDDLE));
        }
        if (isEdge) {
          this.bounds = new Rectangle_default(state2.absoluteOffset.x, state2.absoluteOffset.y, 0, 0);
          if (lw != null) {
            const tmp2 = (parseFloat(lw) + 2) * scale;
            this.bounds.width = tmp2;
            this.bounds.x += m.x * tmp2;
          }
        } else {
          let bounds = Rectangle_default.fromRectangle(state2);
          let hpos = getValue(state2.style, "labelPosition", ALIGN.CENTER);
          let vpos = getValue(state2.style, "verticalLabelPosition", ALIGN.MIDDLE);
          bounds = state2.shape != null && hpos === "center" && vpos === "middle" ? state2.shape.getLabelBounds(bounds) : bounds;
          if (lw != null) {
            bounds.width = parseFloat(lw) * scale;
          }
          if (!state2.view.graph.cellRenderer.legacySpacing || state2.style.overflow !== "width") {
            const dummy = new TextShape_default();
            const spacing = (state2.style.spacing ?? 2) * scale;
            const spacingTop = ((state2.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
            const spacingRight = ((state2.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
            const spacingBottom = ((state2.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
            const spacingLeft = ((state2.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
            hpos = state2.style.labelPosition != null ? state2.style.labelPosition : "center";
            vpos = state2.style.verticalLabelPosition != null ? state2.style.verticalLabelPosition : "middle";
            bounds = new Rectangle_default(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width - (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));
          }
          this.bounds = new Rectangle_default(bounds.x + state2.absoluteOffset.x, bounds.y + state2.absoluteOffset.y, bounds.width, bounds.height);
        }
        if (this.graph.isWrapping(state2.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML !== this.getEmptyLabelText()) {
          this.textarea.style.wordWrap = WORD_WRAP;
          this.textarea.style.whiteSpace = "normal";
          const tmp2 = Math.round(this.bounds.width / scale) + this.wordWrapPadding;
          if (this.textarea.style.position !== "relative") {
            this.textarea.style.width = `${tmp2}px`;
            if (this.textarea.scrollWidth > tmp2) {
              this.textarea.style.width = `${this.textarea.scrollWidth}px`;
            }
          } else {
            this.textarea.style.maxWidth = `${tmp2}px`;
          }
        } else {
          this.textarea.style.whiteSpace = "nowrap";
          this.textarea.style.width = "";
        }
        const ow = this.textarea.scrollWidth;
        const oh = this.textarea.scrollHeight;
        this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;
        this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;
      }
      setPrefixedStyle(this.textarea.style, "transformOrigin", "0px 0px");
      setPrefixedStyle(this.textarea.style, "transform", `scale(${scale},${scale})${m == null ? "" : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);
    }
  }
  /**
   * Called if the textarea has lost focus.
   */
  focusLost() {
    this.stopEditing(!this.graph.isInvokesStopCellEditing());
  }
  /**
   * Returns the background color for the in-place editor. This implementation
   * always returns NONE.
   */
  getBackgroundColor(state2) {
    return NONE;
  }
  /**
   * Starts the editor for the given cell.
   *
   * @param cell <Cell> to start editing.
   * @param trigger Optional mouse event that triggered the editor.
   */
  startEditing(cell2, trigger = null) {
    this.stopEditing(true);
    this.align = null;
    if (this.textarea == null) {
      this.init();
    }
    const tooltipHandler = this.graph.getPlugin("TooltipHandler");
    tooltipHandler == null ? void 0 : tooltipHandler.hideTooltip();
    const state2 = this.graph.getView().getState(cell2);
    if (state2) {
      const { scale } = this.graph.getView();
      const size = state2.style.fontSize ?? DEFAULT_FONTSIZE;
      const family = state2.style.fontFamily ?? DEFAULT_FONTFAMILY;
      const color = state2.style.fontColor ?? "black";
      const align = state2.style.align ?? ALIGN.LEFT;
      const bold = (state2.style.fontStyle || 0) & FONT.BOLD;
      const italic = (state2.style.fontStyle || 0) & FONT.ITALIC;
      const txtDecor = [];
      if ((state2.style.fontStyle || 0) & FONT.UNDERLINE) {
        txtDecor.push("underline");
      }
      if ((state2.style.fontStyle || 0) & FONT.STRIKETHROUGH) {
        txtDecor.push("line-through");
      }
      const textarea = this.textarea;
      textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT ? `${Math.round(size * LINE_HEIGHT)}px` : String(LINE_HEIGHT);
      textarea.style.backgroundColor = this.getBackgroundColor(state2) || "transparent";
      textarea.style.textDecoration = txtDecor.join(" ");
      textarea.style.fontWeight = bold ? "bold" : "normal";
      textarea.style.fontStyle = italic ? "italic" : "";
      textarea.style.fontSize = `${Math.round(size)}px`;
      textarea.style.zIndex = String(this.zIndex);
      textarea.style.fontFamily = family;
      textarea.style.textAlign = align;
      textarea.style.outline = "none";
      textarea.style.color = color;
      let dir = this.textDirection = state2.style.textDirection ?? DEFAULT_TEXT_DIRECTION;
      if (dir === "auto") {
        if (state2.text !== null && state2.text.dialect !== DIALECT.STRICTHTML && !isNode(state2.text.value)) {
          dir = state2.text.getAutoDirection();
        }
      }
      if (dir === "ltr" || dir === "rtl") {
        textarea.setAttribute("dir", dir);
      } else {
        textarea.removeAttribute("dir");
      }
      textarea.innerHTML = this.getInitialValue(state2, trigger) || "";
      this.initialValue = textarea.innerHTML;
      if (textarea.innerHTML.length === 0 || textarea.innerHTML === "<br>") {
        textarea.innerHTML = this.getEmptyLabelText();
        this.clearOnChange = true;
      } else {
        this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();
      }
      this.graph.container.appendChild(textarea);
      this.editingCell = cell2;
      this.trigger = trigger;
      this.textNode = null;
      if (state2.text !== null && this.isHideLabel(state2)) {
        this.textNode = state2.text.node;
        this.textNode.style.visibility = "hidden";
      }
      if (this.autoSize && (state2.cell.isEdge() || state2.style.overflow !== "fill")) {
        window.setTimeout(() => {
          this.resize();
        }, 0);
      }
      this.resize();
      try {
        textarea.focus();
        if (this.isSelectText() && textarea.innerHTML.length > 0 && (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {
          document.execCommand("selectAll", false);
        }
      } catch (e) {
      }
    }
  }
  /**
   * Returns <selectText>.
   */
  isSelectText() {
    return this.selectText;
  }
  /**
    clearSelection() {
      const selection = window.getSelection();
  
      if (selection) {
        if (selection.empty) {
          selection.empty();
        } else if (selection.removeAllRanges) {
          selection.removeAllRanges();
        }
      }
    }
  
    /**
     * Stops the editor and applies the value if cancel is false.
     */
  stopEditing(cancel = false) {
    if (this.editingCell) {
      if (this.textNode) {
        this.textNode.style.visibility = "visible";
        this.textNode = null;
      }
      const state2 = !cancel ? this.graph.view.getState(this.editingCell) : null;
      const textarea = this.textarea;
      const initial = this.initialValue;
      this.initialValue = null;
      this.editingCell = null;
      this.trigger = null;
      this.bounds = null;
      textarea.blur();
      clearSelection();
      if (textarea.parentNode) {
        textarea.parentNode.removeChild(textarea);
      }
      if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {
        textarea.innerHTML = "";
        this.clearOnChange = false;
      }
      if (state2 && (textarea.innerHTML !== initial || this.align !== null)) {
        this.prepareTextarea();
        const value2 = this.getCurrentValue(state2);
        this.graph.batchUpdate(() => {
          if (value2 !== null) {
            this.applyValue(state2, value2);
          }
          if (this.align !== null) {
            this.graph.setCellStyles("align", this.align, [state2.cell]);
          }
        });
      }
      if (this.textarea)
        InternalEvent_default.release(this.textarea);
      this.textarea = null;
      this.align = null;
    }
  }
  /**
   * Prepares the textarea for getting its value in <stopEditing>.
   * This implementation removes the extra trailing linefeed in Firefox.
   */
  prepareTextarea() {
    const textarea = this.textarea;
    if (textarea.lastChild && textarea.lastChild.nodeName === "BR") {
      textarea.removeChild(textarea.lastChild);
    }
  }
  /**
   * Returns true if the label should be hidden while the cell is being
   * edited.
   */
  isHideLabel(state2 = null) {
    return true;
  }
  /**
   * Returns the minimum width and height for editing the given state.
   */
  getMinimumSize(state2) {
    const { scale } = this.graph.getView();
    const textarea = this.textarea;
    return new Rectangle_default(0, 0, state2.text === null ? 30 : state2.text.size * scale + 20, textarea.style.textAlign === "left" ? 120 : 40);
  }
  /**
   * Returns the {@link Rectangle} that defines the bounds of the editor.
   */
  getEditorBounds(state2) {
    const isEdge = state2.cell.isEdge();
    const { scale } = this.graph.getView();
    const minSize = this.getMinimumSize(state2);
    const minWidth = minSize.width;
    const minHeight = minSize.height;
    let result2 = null;
    if (!isEdge && state2.view.graph.cellRenderer.legacySpacing && state2.style.overflow === "fill") {
      result2 = state2.shape.getLabelBounds(Rectangle_default.fromRectangle(state2));
    } else {
      const dummy = new TextShape_default();
      const spacing = (state2.style.spacing ?? 0) * scale;
      const spacingTop = ((state2.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;
      const spacingRight = ((state2.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;
      const spacingBottom = ((state2.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;
      const spacingLeft = ((state2.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;
      result2 = new Rectangle_default(state2.x, state2.y, Math.max(minWidth, state2.width - spacingLeft - spacingRight), Math.max(minHeight, state2.height - spacingTop - spacingBottom));
      const hpos = state2.style.labelPosition != null ? state2.style.labelPosition : "center";
      const vpos = state2.style.verticalLabelPosition != null ? state2.style.verticalLabelPosition : "middle";
      result2 = state2.shape != null && hpos === "center" && vpos === "middle" ? state2.shape.getLabelBounds(result2) : result2;
      if (isEdge) {
        result2.x = state2.absoluteOffset.x;
        result2.y = state2.absoluteOffset.y;
        if (state2.text != null && state2.text.boundingBox != null) {
          if (state2.text.boundingBox.x > 0) {
            result2.x = state2.text.boundingBox.x;
          }
          if (state2.text.boundingBox.y > 0) {
            result2.y = state2.text.boundingBox.y;
          }
        }
      } else if (state2.text != null && state2.text.boundingBox != null) {
        result2.x = Math.min(result2.x, state2.text.boundingBox.x);
        result2.y = Math.min(result2.y, state2.text.boundingBox.y);
      }
      result2.x += spacingLeft;
      result2.y += spacingTop;
      if (state2.text != null && state2.text.boundingBox != null) {
        if (!isEdge) {
          result2.width = Math.max(result2.width, state2.text.boundingBox.width);
          result2.height = Math.max(result2.height, state2.text.boundingBox.height);
        } else {
          result2.width = Math.max(minWidth, state2.text.boundingBox.width);
          result2.height = Math.max(minHeight, state2.text.boundingBox.height);
        }
      }
      if (state2.cell.isVertex()) {
        const horizontal = getStringValue(state2.style, "labelPosition", ALIGN.CENTER);
        if (horizontal === "left") {
          result2.x -= state2.width;
        } else if (horizontal === "right") {
          result2.x += state2.width;
        }
        const vertical = state2.style.verticalLabelPosition != null ? state2.style.verticalLabelPosition : "middle";
        if (vertical === "top") {
          result2.y -= state2.height;
        } else if (vertical === "bottom") {
          result2.y += state2.height;
        }
      }
    }
    return new Rectangle_default(Math.round(result2.x), Math.round(result2.y), Math.round(result2.width), Math.round(result2.height));
  }
  /**
   * Returns the initial label value to be used of the label of the given
   * cell is empty. This label is displayed and cleared on the first keystroke.
   * This implementation returns <emptyLabelText>.
   *
   * @param cell <Cell> for which a text for an empty editing box should be
   * returned.
   */
  getEmptyLabelText(cell2 = null) {
    return this.emptyLabelText ?? "";
  }
  /**
   * Returns the cell that is currently being edited or null if no cell is
   * being edited.
   */
  getEditingCell() {
    return this.editingCell;
  }
  /**
   * Destroys the editor and removes all associated resources.
   */
  onDestroy() {
    if (this.textarea) {
      InternalEvent_default.release(this.textarea);
      if (this.textarea.parentNode) {
        this.textarea.parentNode.removeChild(this.textarea);
      }
      this.textarea = null;
    }
    this.graph.getDataModel().removeListener(this.changeHandler);
    this.graph.getView().removeListener(this.zoomHandler);
  }
};
CellEditorHandler.pluginId = "CellEditorHandler";
var CellEditorHandler_default = CellEditorHandler;

// node_modules/@maxgraph/core/lib/view/handler/TooltipHandler.js
var TooltipHandler = class {
  /**
   * Constructs an event handler that displays tooltips.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   */
  constructor(graph) {
    this.zIndex = 10005;
    this.delay = 500;
    this.ignoreTouchEvents = true;
    this.hideOnHover = false;
    this.destroyed = false;
    this.lastX = 0;
    this.lastY = 0;
    this.state = null;
    this.stateSource = false;
    this.thread = null;
    this.enabled = false;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.div = document.createElement("div");
    this.div.className = "mxTooltip";
    this.div.style.visibility = "hidden";
    document.body.appendChild(this.div);
    InternalEvent_default.addGestureListeners(this.div, (evt2) => {
      const source2 = getSource(evt2);
      if (source2 && source2.nodeName !== "A") {
        this.hideTooltip();
      }
    });
    InternalEvent_default.addListener(this.graph.getContainer(), "mouseleave", (evt2) => {
      if (this.div !== evt2.relatedTarget) {
        this.hide();
      }
    });
  }
  /**
   * Returns `true` if events are handled.
   *
   * This implementation returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling.
   *
   * This implementation updates {@link enabled}.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns {@link hideOnHover}.
   */
  isHideOnHover() {
    return this.hideOnHover;
  }
  /**
   * Sets <hideOnHover>.
   */
  setHideOnHover(value2) {
    this.hideOnHover = value2;
  }
  /**
   * Returns the <CellState> to be used for showing a tooltip for this event.
   */
  getStateForEvent(me) {
    return me.getState();
  }
  /**
   * Handles the event by initiating a rubberband selection. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender, me) {
    this.reset(me, false);
    this.hideTooltip();
  }
  /**
   * Handles the event by updating the rubberband selection.
   */
  mouseMove(sender, me) {
    if (me.getX() !== this.lastX || me.getY() !== this.lastY) {
      this.reset(me, true);
      const state2 = this.getStateForEvent(me);
      if (this.isHideOnHover() || state2 !== this.state || me.getSource() !== this.node && (!this.stateSource || state2 != null && this.stateSource === (me.isSource(state2.shape) || !me.isSource(state2.text)))) {
        this.hideTooltip();
      }
    }
    this.lastX = me.getX();
    this.lastY = me.getY();
  }
  /**
   * Handles the event by resetting the tooltip timer or hiding the existing
   * tooltip.
   */
  mouseUp(sender, me) {
    this.reset(me, true);
    this.hideTooltip();
  }
  /**
   * Resets the timer.
   */
  resetTimer() {
    if (this.thread) {
      window.clearTimeout(this.thread);
      this.thread = null;
    }
  }
  /**
   * Resets and/or restarts the timer to trigger the display of the tooltip.
   */
  reset(me, restart, state2 = null) {
    if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {
      this.resetTimer();
      state2 = state2 ?? this.getStateForEvent(me);
      if (restart && this.isEnabled() && state2 && this.div.style.visibility === "hidden") {
        const node2 = me.getSource();
        const x = me.getX();
        const y = me.getY();
        const stateSource = me.isSource(state2.shape) || me.isSource(state2.text);
        const popupMenuHandler = this.graph.getPlugin("PopupMenuHandler");
        this.thread = window.setTimeout(() => {
          if (state2 && node2 && !this.graph.isEditing() && popupMenuHandler && !popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {
            const tip = this.graph.getTooltip(state2, node2, x, y);
            this.show(tip, x, y);
            this.state = state2;
            this.node = node2;
            this.stateSource = stateSource;
          }
        }, this.delay);
      }
    }
  }
  /**
   * Hides the tooltip and resets the timer.
   */
  hide() {
    this.resetTimer();
    this.hideTooltip();
  }
  /**
   * Hides the tooltip.
   */
  hideTooltip() {
    this.div.style.visibility = "hidden";
    this.div.innerHTML = "";
  }
  /**
   * Shows the tooltip for the specified cell and optional index at the
   * specified location (with a vertical offset of 10 pixels).
   */
  show(tip, x, y) {
    if (!this.destroyed && tip && tip !== "") {
      const origin = getScrollOrigin();
      this.div.style.zIndex = String(this.zIndex);
      this.div.style.left = `${x + origin.x}px`;
      this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;
      if (!isNode(tip)) {
        this.div.innerHTML = tip.replace(/\n/g, "<br>");
      } else {
        this.div.innerHTML = "";
        this.div.appendChild(tip);
      }
      this.div.style.visibility = "";
      fit(this.div);
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    if (!this.destroyed) {
      this.graph.removeMouseListener(this);
      InternalEvent_default.release(this.div);
      if (this.div.parentNode) {
        this.div.parentNode.removeChild(this.div);
      }
      this.destroyed = true;
    }
  }
};
TooltipHandler.pluginId = "TooltipHandler";
var TooltipHandler_default = TooltipHandler;

// node_modules/@maxgraph/core/lib/view/handler/SelectionCellsHandler.js
var SelectionCellsHandler = class extends EventSource_default {
  constructor(graph) {
    super();
    this.enabled = true;
    this.maxHandlers = 100;
    this.graph = graph;
    this.handlers = new Dictionary_default();
    this.graph.addMouseListener(this);
    this.refreshHandler = (sender, evt2) => {
      if (this.isEnabled()) {
        this.refresh();
      }
    };
    this.graph.getSelectionModel().addListener(InternalEvent_default.CHANGE, this.refreshHandler);
    this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent_default.TRANSLATE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent_default.DOWN, this.refreshHandler);
    this.graph.getView().addListener(InternalEvent_default.UP, this.refreshHandler);
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns the handler for the given cell.
   */
  getHandler(cell2) {
    return this.handlers.get(cell2);
  }
  /**
   * Returns true if the given cell has a handler.
   */
  isHandled(cell2) {
    return !!this.getHandler(cell2);
  }
  /**
   * Resets all handlers.
   */
  reset() {
    this.handlers.visit((key2, handler) => {
      handler.reset.apply(handler);
    });
  }
  /**
   * Reloads or updates all handlers.
   */
  getHandledSelectionCells() {
    return this.graph.getSelectionCells();
  }
  /**
   * Reloads or updates all handlers.
   */
  refresh() {
    const oldHandlers = this.handlers;
    this.handlers = new Dictionary_default();
    const tmp2 = sortCells(this.getHandledSelectionCells(), false);
    for (let i2 = 0; i2 < tmp2.length; i2 += 1) {
      const state2 = this.graph.view.getState(tmp2[i2]);
      if (state2) {
        let handler = oldHandlers.remove(tmp2[i2]);
        if (handler) {
          if (handler.state !== state2) {
            handler.onDestroy();
            handler = null;
          } else if (!this.isHandlerActive(handler)) {
            if (handler.refresh)
              handler.refresh();
            handler.redraw();
          }
        }
        if (handler) {
          this.handlers.put(tmp2[i2], handler);
        }
      }
    }
    oldHandlers.visit((key2, handler) => {
      this.fireEvent(new EventObject_default(InternalEvent_default.REMOVE, { state: handler.state }));
      handler.onDestroy();
    });
    for (let i2 = 0; i2 < tmp2.length; i2 += 1) {
      const state2 = this.graph.view.getState(tmp2[i2]);
      if (state2) {
        let handler = this.handlers.get(tmp2[i2]);
        if (!handler) {
          handler = this.graph.createHandler(state2);
          this.fireEvent(new EventObject_default(InternalEvent_default.ADD, { state: state2 }));
          this.handlers.put(tmp2[i2], handler);
        } else {
          handler.updateParentHighlight();
        }
      }
    }
  }
  /**
   * Returns true if the given handler is active and should not be redrawn.
   */
  isHandlerActive(handler) {
    return handler.index !== null;
  }
  /**
   * Updates the handler for the given shape if one exists.
   */
  updateHandler(state2) {
    let handler = this.handlers.remove(state2.cell);
    if (handler) {
      const { index } = handler;
      const x = handler.startX;
      const y = handler.startY;
      handler.onDestroy();
      handler = this.graph.createHandler(state2);
      if (handler) {
        this.handlers.put(state2.cell, handler);
        if (index !== null) {
          handler.start(x, y, index);
        }
      }
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseDown(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key2, handler) => {
        handler.mouseDown(sender, me);
      });
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseMove(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key2, handler) => {
        handler.mouseMove(sender, me);
      });
    }
  }
  /**
   * Redirects the given event to the handlers.
   */
  mouseUp(sender, me) {
    if (this.graph.isEnabled() && this.isEnabled()) {
      this.handlers.visit((key2, handler) => {
        handler.mouseUp(sender, me);
      });
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.refreshHandler);
    this.graph.getDataModel().removeListener(this.refreshHandler);
    this.graph.getView().removeListener(this.refreshHandler);
  }
};
SelectionCellsHandler.pluginId = "SelectionCellsHandler";
var SelectionCellsHandler_default = SelectionCellsHandler;

// node_modules/@maxgraph/core/lib/gui/MaxPopupMenu.js
var MaxPopupMenu = class extends EventSource_default {
  constructor(factoryMethod) {
    super();
    this.activeRow = null;
    this.eventReceiver = null;
    this.submenuImage = `${Client_default.imageBasePath}/submenu.gif`;
    this.zIndex = 10006;
    this.useLeftButtonForPopup = false;
    this.enabled = true;
    this.itemCount = 0;
    this.autoExpand = false;
    this.smartSeparators = false;
    this.labels = true;
    this.willAddSeparator = false;
    this.containsItems = false;
    if (factoryMethod) {
      this.factoryMethod = factoryMethod;
    }
    this.table = document.createElement("table");
    this.table.className = "mxPopupMenu";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.div = document.createElement("div");
    this.div.className = "mxPopupMenu";
    this.div.style.display = "inline";
    this.div.style.zIndex = String(this.zIndex);
    this.div.appendChild(this.table);
    InternalEvent_default.disableContextMenu(this.div);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns true if the given event is a popupmenu trigger for the optional
   * given cell.
   *
   * @param me {@link MouseEvent} that represents the mouse event.
   */
  isPopupTrigger(me) {
    return me.isPopupTrigger() || this.useLeftButtonForPopup && isLeftMouseButton(me.getEvent());
  }
  /**
   * Adds the given item to the given parent item. If no parent item is specified
   * then the item is added to the top-level menu. The return value may be used
   * as the parent argument, ie. as a submenu item. The return value is the table
   * row that represents the item.
   *
   * Paramters:
   *
   * title - String that represents the title of the menu item.
   * image - Optional URL for the image icon.
   * funct - Function associated that takes a mouseup or touchend event.
   * parent - Optional item returned by <addItem>.
   * iconCls - Optional string that represents the CSS class for the image icon.
   * IconsCls is ignored if image is given.
   * enabled - Optional boolean indicating if the item is enabled. Default is true.
   * active - Optional boolean indicating if the menu should implement any event handling.
   * Default is true.
   * noHover - Optional boolean to disable hover state.
   */
  addItem(title, image, funct2, parent2 = null, iconCls2 = null, enabled2 = true, active = true, noHover = false) {
    var _a2;
    parent2 = parent2 ?? this;
    this.itemCount++;
    if (parent2.willAddSeparator) {
      if (parent2.containsItems) {
        this.addSeparator(parent2, true);
      }
      parent2.willAddSeparator = false;
    }
    parent2.containsItems = true;
    const tr = document.createElement("tr");
    tr.className = "mxPopupMenuItem";
    const col1 = document.createElement("td");
    col1.className = "mxPopupMenuIcon";
    if (image) {
      const img = document.createElement("img");
      img.src = image;
      col1.appendChild(img);
    } else if (iconCls2) {
      const div = document.createElement("div");
      div.className = iconCls2;
      col1.appendChild(div);
    }
    tr.appendChild(col1);
    if (this.labels) {
      const col2 = document.createElement("td");
      col2.className = `mxPopupMenuItem${!enabled2 ? " mxDisabled" : ""}`;
      write(col2, title);
      col2.align = "left";
      tr.appendChild(col2);
      const col3 = document.createElement("td");
      col3.className = `mxPopupMenuItem${!enabled2 ? " mxDisabled" : ""}`;
      col3.style.paddingRight = "6px";
      col3.style.textAlign = "right";
      tr.appendChild(col3);
      if (parent2.div == null) {
        this.createSubmenu(parent2);
      }
    }
    (_a2 = parent2.tbody) == null ? void 0 : _a2.appendChild(tr);
    if (active && enabled2) {
      InternalEvent_default.addGestureListeners(tr, (evt2) => {
        this.eventReceiver = tr;
        if (parent2 && parent2.activeRow != tr && parent2.activeRow != parent2) {
          if (parent2.activeRow && parent2.activeRow.div.parentNode) {
            this.hideSubmenu(parent2);
          }
          if (tr.div) {
            this.showSubmenu(parent2, tr);
            parent2.activeRow = tr;
          }
        }
        InternalEvent_default.consume(evt2);
      }, (_evt) => {
        if (parent2 && parent2.activeRow != tr && parent2.activeRow != parent2) {
          if (parent2.activeRow && parent2.activeRow.div.parentNode) {
            this.hideSubmenu(parent2);
          }
          if (this.autoExpand && tr.div) {
            this.showSubmenu(parent2, tr);
            parent2.activeRow = tr;
          }
        }
        if (!noHover) {
          tr.className = "mxPopupMenuItemHover";
        }
      }, (evt2) => {
        if (this.eventReceiver == tr) {
          if (parent2 && parent2.activeRow != tr) {
            this.hideMenu();
          }
          funct2 == null ? void 0 : funct2(evt2);
        }
        this.eventReceiver = null;
        InternalEvent_default.consume(evt2);
      });
      if (!noHover) {
        InternalEvent_default.addListener(tr, "mouseout", (_evt) => {
          tr.className = "mxPopupMenuItem";
        });
      }
    }
    return tr;
  }
  /**
   * Adds a checkmark to the given menuitem.
   */
  addCheckmark(item2, img) {
    if (item2.firstChild) {
      const td = item2.firstChild.nextSibling;
      td.style.backgroundImage = `url('${img}')`;
      td.style.backgroundRepeat = "no-repeat";
      td.style.backgroundPosition = "2px 50%";
    }
  }
  /**
   * Creates the nodes required to add submenu items inside the given parent
   * item. This is called in <addItem> if a parent item is used for the first
   * time. This adds various DOM nodes and a <submenuImage> to the parent.
   *
   * @param parent An item returned by <addItem>.
   */
  createSubmenu(parent2) {
    var _a2, _b;
    parent2.table = document.createElement("table");
    parent2.table.className = "mxPopupMenu";
    parent2.tbody = document.createElement("tbody");
    parent2.table.appendChild(parent2.tbody);
    parent2.div = document.createElement("div");
    parent2.div.className = "mxPopupMenu";
    parent2.div.style.position = "absolute";
    parent2.div.style.display = "inline";
    parent2.div.style.zIndex = String(this.zIndex);
    parent2.div.appendChild(parent2.table);
    const img = document.createElement("img");
    img.setAttribute("src", this.submenuImage);
    if ((_b = (_a2 = parent2.firstChild) == null ? void 0 : _a2.nextSibling) == null ? void 0 : _b.nextSibling) {
      const td = parent2.firstChild.nextSibling.nextSibling;
      td.appendChild(img);
    }
  }
  /**
   * Shows the submenu inside the given parent row.
   */
  showSubmenu(parent2, row2) {
    if (row2.div) {
      row2.div.style.left = `${parent2.div.offsetLeft + row2.offsetLeft + row2.offsetWidth - 1}px`;
      row2.div.style.top = `${parent2.div.offsetTop + row2.offsetTop}px`;
      document.body.appendChild(row2.div);
      const left = row2.div.offsetLeft;
      const width = row2.div.offsetWidth;
      const offset = getDocumentScrollOrigin(document);
      const b = document.body;
      const d = document.documentElement;
      const right = offset.x + (b.clientWidth || d.clientWidth);
      if (left + width > right) {
        row2.div.style.left = `${Math.max(0, parent2.div.offsetLeft - width - 6)}px`;
      }
      fit(row2.div);
    }
  }
  /**
   * Adds a horizontal separator in the given parent item or the top-level menu
   * if no parent is specified.
   *
   * @param parent Optional item returned by <addItem>.
   * @param force Optional boolean to ignore <smartSeparators>. Default is false.
   */
  addSeparator(parent2 = null, force = false) {
    parent2 = parent2 || this;
    if (this.smartSeparators && !force) {
      parent2.willAddSeparator = true;
    } else if (parent2.tbody) {
      parent2.willAddSeparator = false;
      const tr = document.createElement("tr");
      const col1 = document.createElement("td");
      col1.className = "mxPopupMenuIcon";
      col1.style.padding = "0 0 0 0px";
      tr.appendChild(col1);
      const col2 = document.createElement("td");
      col2.style.padding = "0 0 0 0px";
      col2.setAttribute("colSpan", "2");
      const hr = document.createElement("hr");
      hr.setAttribute("size", "1");
      col2.appendChild(hr);
      tr.appendChild(col2);
      parent2.tbody.appendChild(tr);
    }
  }
  /**
   * Shows the popup menu for the given event and cell.
   *
   * Example:
   *
   * ```javascript
   * graph.getPlugin('PanningHandler').popup(x, y, cell, evt)
   * {
   *   mxUtils.alert('Hello, World!');
   * }
   * ```
   */
  popup(x, y, cell2, evt2) {
    if (this.div && this.tbody && this.factoryMethod) {
      this.div.style.left = `${x}px`;
      this.div.style.top = `${y}px`;
      while (this.tbody.firstChild) {
        InternalEvent_default.release(this.tbody.firstChild);
        this.tbody.removeChild(this.tbody.firstChild);
      }
      this.itemCount = 0;
      this.factoryMethod(this, cell2, evt2);
      if (this.itemCount > 0) {
        this.showMenu();
        this.fireEvent(new EventObject_default(InternalEvent_default.SHOW));
      }
    }
  }
  /**
   * Returns true if the menu is showing.
   */
  isMenuShowing() {
    return this.div && this.div.parentNode == document.body;
  }
  /**
   * Shows the menu.
   */
  showMenu() {
    document.body.appendChild(this.div);
    fit(this.div);
  }
  /**
   * Removes the menu and all submenus.
   */
  hideMenu() {
    var _a2;
    if (this.div) {
      (_a2 = this.div.parentNode) == null ? void 0 : _a2.removeChild(this.div);
      this.hideSubmenu(this);
      this.containsItems = false;
      this.fireEvent(new EventObject_default(InternalEvent_default.HIDE));
    }
  }
  /**
   * Removes all submenus inside the given parent.
   *
   * @param parent An item returned by <addItem>.
   */
  hideSubmenu(parent2) {
    var _a2;
    if (parent2.activeRow) {
      this.hideSubmenu(parent2.activeRow);
      (_a2 = parent2.activeRow.div.parentNode) == null ? void 0 : _a2.removeChild(parent2.activeRow.div);
      parent2.activeRow = null;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  destroy() {
    var _a2;
    if (this.div) {
      InternalEvent_default.release(this.div);
      (_a2 = this.div.parentNode) == null ? void 0 : _a2.removeChild(this.div);
    }
  }
};
var MaxPopupMenu_default = MaxPopupMenu;

// node_modules/@maxgraph/core/lib/view/handler/PopupMenuHandler.js
var PopupMenuHandler = class extends MaxPopupMenu_default {
  constructor(graph) {
    super();
    this.inTolerance = false;
    this.popupTrigger = false;
    this.selectOnPopup = true;
    this.clearSelectionOnBackground = true;
    this.triggerX = null;
    this.triggerY = null;
    this.screenX = null;
    this.screenY = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.gestureHandler = (sender, eo) => {
      this.inTolerance = false;
    };
    this.graph.addListener(InternalEvent_default.GESTURE, this.gestureHandler);
    this.init();
  }
  /**
   * Initializes the shapes required for this vertex handler.
   */
  init() {
    InternalEvent_default.addGestureListeners(this.div, (evt2) => {
      const tooltipHandler = this.graph.getPlugin("TooltipHandler");
      tooltipHandler == null ? void 0 : tooltipHandler.hide();
    });
  }
  /**
   * Hook for returning if a cell should be selected for a given {@link MouseEvent}.
   * This implementation returns <selectOnPopup>.
   */
  isSelectOnPopup(me) {
    return this.selectOnPopup;
  }
  /**
   * Handles the event by initiating the panning. By consuming the event all
   * subsequent events of the gesture are redirected to this handler.
   */
  mouseDown(sender, me) {
    if (this.isEnabled() && !isMultiTouchEvent(me.getEvent())) {
      this.hideMenu();
      this.triggerX = me.getGraphX();
      this.triggerY = me.getGraphY();
      this.screenX = getMainEvent(me.getEvent()).screenX;
      this.screenY = getMainEvent(me.getEvent()).screenY;
      this.popupTrigger = this.isPopupTrigger(me);
      this.inTolerance = true;
    }
  }
  /**
   * Handles the event by updating the panning on the graph.
   */
  mouseMove(sender, me) {
    if (this.inTolerance && this.screenX != null && this.screenY != null) {
      if (Math.abs(getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.getEventTolerance() || Math.abs(getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.getEventTolerance()) {
        this.inTolerance = false;
      }
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  mouseUp(sender, me) {
    if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {
      const cell2 = this.getCellForPopupEvent(me);
      if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell2 != null && !this.graph.isCellSelected(cell2)) {
        this.graph.setSelectionCell(cell2);
      } else if (this.clearSelectionOnBackground && cell2 == null) {
        this.graph.clearSelection();
      }
      const tooltipHandler = this.graph.getPlugin("TooltipHandler");
      tooltipHandler == null ? void 0 : tooltipHandler.hide();
      const origin = getScrollOrigin();
      this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell2, me.getEvent());
      me.consume();
    }
    this.popupTrigger = false;
    this.inTolerance = false;
  }
  /**
   * Hook to return the cell for the mouse up popup trigger handling.
   */
  getCellForPopupEvent(me) {
    return me.getCell();
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.gestureHandler);
    super.destroy();
  }
};
PopupMenuHandler.pluginId = "PopupMenuHandler";
var PopupMenuHandler_default = PopupMenuHandler;

// node_modules/@maxgraph/core/lib/view/handler/ConnectionHandler.js
var ConnectionHandler = class extends EventSource_default {
  /**
   * Constructs an event handler that connects vertices using the specified
   * factory method to create the new edges.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param factoryMethod Optional function to create the edge. The function takes
   * the source and target {@link Cell} as the first and second argument and an
   * optional cell style from the preview as the third argument. It returns
   * the {@link Cell} that represents the new edge.
   */
  constructor(graph, factoryMethod = null) {
    super();
    this.previous = null;
    this.iconState = null;
    this.icons = [];
    this.cell = null;
    this.currentPoint = null;
    this.sourceConstraint = null;
    this.shape = null;
    this.icon = null;
    this.originalPoint = null;
    this.currentState = null;
    this.selectedIcon = null;
    this.waypoints = [];
    this.factoryMethod = null;
    this.moveIconFront = false;
    this.moveIconBack = false;
    this.connectImage = null;
    this.targetConnectImage = false;
    this.enabled = false;
    this.select = true;
    this.createTarget = false;
    this.error = null;
    this.waypointsEnabled = false;
    this.ignoreMouseDown = false;
    this.first = null;
    this.connectIconOffset = new Point_default(0, TOOLTIP_VERTICAL_OFFSET);
    this.edgeState = null;
    this.mouseDownCounter = 0;
    this.movePreviewAway = false;
    this.outlineConnect = false;
    this.livePreview = false;
    this.cursor = null;
    this.insertBeforeSource = false;
    this.graph = graph;
    this.factoryMethod = factoryMethod;
    this.graph.addMouseListener(this);
    this.marker = this.createMarker();
    this.constraintHandler = new ConstraintHandler_default(this.graph);
    this.changeHandler = (sender) => {
      if (this.iconState) {
        this.iconState = this.graph.getView().getState(this.iconState.cell);
      }
      if (this.iconState) {
        this.redrawIcons(this.icons, this.iconState);
        this.constraintHandler.reset();
      } else if (this.previous && !this.graph.view.getState(this.previous.cell)) {
        this.reset();
      }
    };
    this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent_default.TRANSLATE, this.changeHandler);
    this.graph.getView().addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.changeHandler);
    this.drillHandler = (sender) => {
      this.reset();
    };
    this.graph.addListener(InternalEvent_default.START_EDITING, this.drillHandler);
    this.graph.getView().addListener(InternalEvent_default.DOWN, this.drillHandler);
    this.graph.getView().addListener(InternalEvent_default.UP, this.drillHandler);
    this.escapeHandler = () => {
      this.reset();
    };
    this.graph.addListener(InternalEvent_default.ESCAPE, this.escapeHandler);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns <insertBeforeSource> for non-loops and false for loops.
   *
   * @param edge <Cell> that represents the edge to be inserted.
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget <Cell> that represents the cell under the mouse when it was
   * released.
   */
  isInsertBefore(edge2, source2, target2, evt2, dropTarget) {
    return this.insertBeforeSource && source2 !== target2;
  }
  /**
   * Returns <createTarget>.
   *
   * @param evt Current active native pointer event.
   */
  isCreateTarget(evt2) {
    return this.createTarget;
  }
  /**
   * Sets <createTarget>.
   */
  setCreateTarget(value2) {
    this.createTarget = value2;
  }
  /**
   * Creates the preview shape for new connections.
   */
  createShape() {
    const shape2 = this.livePreview && this.edgeState ? this.graph.cellRenderer.createShape(this.edgeState) : new PolylineShape_default([], INVALID_COLOR);
    if (shape2 && shape2.node) {
      shape2.dialect = DIALECT.SVG;
      shape2.scale = this.graph.view.scale;
      shape2.pointerEvents = false;
      shape2.isDashed = true;
      shape2.init(this.graph.getView().getOverlayPane());
      InternalEvent_default.redirectMouseEvents(shape2.node, this.graph, null);
    }
    return shape2;
  }
  /**
   * Returns true if the given cell is connectable. This is a hook to
   * disable floating connections. This implementation returns true.
   */
  isConnectableCell(cell2) {
    return true;
  }
  /**
   * Creates and returns the {@link CellMarker} used in {@link arker}.
   */
  createMarker() {
    return new ConnectionHandlerCellMarker(this.graph, this);
  }
  /**
   * Starts a new connection for the given state and coordinates.
   */
  start(state2, x, y, edgeState) {
    this.previous = state2;
    this.first = new Point_default(x, y);
    this.edgeState = edgeState ?? this.createEdgeState();
    this.marker.currentColor = this.marker.validColor;
    this.marker.markedState = state2;
    this.marker.mark();
    this.fireEvent(new EventObject_default(InternalEvent_default.START, { state: this.previous }));
  }
  /**
   * Returns true if the source terminal has been clicked and a new
   * connection is currently being previewed.
   */
  isConnecting() {
    return !!this.first && !!this.shape;
  }
  /**
   * Returns {@link Graph#isValidSource} for the given source terminal.
   *
   * @param cell <Cell> that represents the source terminal.
   * @param me {@link MouseEvent} that is associated with this call.
   */
  isValidSource(cell2, me) {
    return this.graph.isValidSource(cell2);
  }
  /**
   * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling
   * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an
   * additional hook for disabling certain targets in this specific handler.
   *
   * @param cell <Cell> that represents the target terminal.
   */
  isValidTarget(cell2) {
    return true;
  }
  /**
   * Returns the error message or an empty string if the connection for the
   * given source target pair is not valid. Otherwise it returns null. This
   * implementation uses {@link Graph#getEdgeValidationError}.
   *
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   */
  validateConnection(source2, target2) {
    if (!this.isValidTarget(target2)) {
      return "";
    }
    return this.graph.getEdgeValidationError(null, source2, target2);
  }
  /**
   * Hook to return the {@link Image} used for the connection icon of the given
   * {@link CellState}. This implementation returns {@link connectImage}.
   *
   * @param state {@link CellState} whose connect image should be returned.
   */
  getConnectImage(state2) {
    return this.connectImage;
  }
  /**
   * Returns true if the state has a HTML label in the graph's container, otherwise
   * it returns {@link oveIconFront}.
   *
   * @param state <CellState> whose connect icons should be returned.
   */
  isMoveIconToFrontForState(state2) {
    if (state2.text && state2.text.node.parentNode === this.graph.container) {
      return true;
    }
    return this.moveIconFront;
  }
  /**
   * Creates the array {@link ImageShape}s that represent the connect icons for
   * the given {@link CellState}.
   *
   * @param state {@link CellState} whose connect icons should be returned.
   */
  createIcons(state2) {
    const image = this.getConnectImage(state2);
    if (image) {
      this.iconState = state2;
      const icons = [];
      const bounds = new Rectangle_default(0, 0, image.width, image.height);
      const icon2 = new ImageShape_default(bounds, image.src, void 0, void 0, 0);
      icon2.preserveImageAspect = false;
      if (this.isMoveIconToFrontForState(state2)) {
        icon2.dialect = DIALECT.STRICTHTML;
        icon2.init(this.graph.container);
      } else {
        icon2.dialect = DIALECT.SVG;
        icon2.init(this.graph.getView().getOverlayPane());
        if (this.moveIconBack && icon2.node.parentNode && icon2.node.previousSibling) {
          icon2.node.parentNode.insertBefore(icon2.node, icon2.node.parentNode.firstChild);
        }
      }
      icon2.node.style.cursor = CURSOR.CONNECT;
      const getState = () => {
        return this.currentState ?? state2;
      };
      const mouseDown = (evt2) => {
        if (!isConsumed(evt2)) {
          this.icon = icon2;
          this.graph.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2, getState()));
        }
      };
      InternalEvent_default.redirectMouseEvents(icon2.node, this.graph, getState, mouseDown);
      icons.push(icon2);
      this.redrawIcons(icons, this.iconState);
      return icons;
    }
    return [];
  }
  /**
   * Redraws the given array of {@link ImageShapes}.
   *
   * @param icons Array of {@link ImageShapes} to be redrawn.
   */
  redrawIcons(icons, state2) {
    if (icons[0] && icons[0].bounds) {
      const pos = this.getIconPosition(icons[0], state2);
      icons[0].bounds.x = pos.x;
      icons[0].bounds.y = pos.y;
      icons[0].redraw();
    }
  }
  // TODO: Document me! ===========================================================================================================
  getIconPosition(icon2, state2) {
    const { scale } = this.graph.getView();
    let cx = state2.getCenterX();
    let cy = state2.getCenterY();
    if (this.graph.isSwimlane(state2.cell)) {
      const size = this.graph.getStartSize(state2.cell);
      cx = size.width !== 0 ? state2.x + size.width * scale / 2 : cx;
      cy = size.height !== 0 ? state2.y + size.height * scale / 2 : cy;
      const alpha = toRadians(state2.style.rotation ?? 0);
      if (alpha !== 0) {
        const cos = Math.cos(alpha);
        const sin = Math.sin(alpha);
        const ct = new Point_default(state2.getCenterX(), state2.getCenterY());
        const pt = getRotatedPoint(new Point_default(cx, cy), cos, sin, ct);
        cx = pt.x;
        cy = pt.y;
      }
    }
    return new Point_default(cx - icon2.bounds.width / 2, cy - icon2.bounds.height / 2);
  }
  /**
   * Destroys the connect icons and resets the respective state.
   */
  destroyIcons() {
    for (let i2 = 0; i2 < this.icons.length; i2 += 1) {
      this.icons[i2].destroy();
    }
    this.icons = [];
    this.icon = null;
    this.selectedIcon = null;
    this.iconState = null;
  }
  /**
   * Returns true if the given mouse down event should start this handler. The
   * This implementation returns true if the event does not force marquee
   * selection, and the currentConstraint and currentFocus of the
   * <constraintHandler> are not null, or <previous> and <error> are not null and
   * <icons> is null or <icons> and <icon> are not null.
   */
  isStartEvent(me) {
    return this.constraintHandler.currentFocus !== null && this.constraintHandler.currentConstraint !== null || this.previous !== null && this.error === null && (this.icons.length === 0 || this.icon !== null);
  }
  /**
   * Handles the event by initiating a new connection.
   */
  mouseDown(sender, me) {
    this.mouseDownCounter += 1;
    if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {
      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
        this.sourceConstraint = this.constraintHandler.currentConstraint;
        this.previous = this.constraintHandler.currentFocus;
        this.first = this.constraintHandler.currentPoint.clone();
      } else {
        this.first = new Point_default(me.getGraphX(), me.getGraphY());
      }
      this.edgeState = this.createEdgeState(me);
      this.mouseDownCounter = 1;
      if (this.waypointsEnabled && !this.shape) {
        this.waypoints = [];
        this.shape = this.createShape();
        if (this.edgeState) {
          this.shape.apply(this.edgeState);
        }
      }
      if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {
        const pt = this.graph.getPointForEvent(me.getEvent());
        this.edgeState.cell.geometry.setTerminalPoint(pt, true);
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.START, { state: this.previous }));
      me.consume();
    }
    this.selectedIcon = this.icon;
    this.icon = null;
  }
  /**
   * Returns true if a tap on the given source state should immediately start
   * connecting. This implementation returns true if the state is not movable
   * in the graph.
   */
  isImmediateConnectSource(state2) {
    return !this.graph.isCellMovable(state2.cell);
  }
  /**
   * Hook to return an <CellState> which may be used during the preview.
   * This implementation returns null.
   *
   * Use the following code to create a preview for an existing edge style:
   *
   * ```javascript
   * graph.getPlugin('ConnectionHandler').createEdgeState(me)
   * {
   *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');
   *
   *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));
   * };
   * ```
   */
  createEdgeState(me) {
    return null;
  }
  /**
   * Returns true if <outlineConnect> is true and the source of the event is the outline shape
   * or shift is pressed.
   */
  isOutlineConnectEvent(me) {
    if (!this.currentPoint)
      return false;
    const offset = getOffset(this.graph.container);
    const evt2 = me.getEvent();
    const clientX = getClientX(evt2);
    const clientY = getClientY(evt2);
    const doc = document.documentElement;
    const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;
    const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;
    return this.outlineConnect && !isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX !== clientX || gridY !== clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));
  }
  /**
   * Updates the current state for a given mouse move event by using
   * the {@link arker}.
   */
  updateCurrentState(me, point) {
    this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);
    if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {
      if (this.marker.highlight && this.marker.highlight.state && this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell && this.marker.highlight.shape) {
        if (this.marker.highlight.shape.stroke !== "transparent") {
          this.marker.highlight.shape.stroke = "transparent";
          this.marker.highlight.repaint();
        }
      } else {
        this.marker.markCell(this.constraintHandler.currentFocus.cell, "transparent");
      }
      if (this.previous) {
        this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);
        if (!this.error) {
          this.currentState = this.constraintHandler.currentFocus;
        }
        if (this.error || this.currentState && !this.isCellEnabled(this.currentState.cell)) {
          this.constraintHandler.reset();
        }
      }
    } else {
      if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {
        this.marker.reset();
        this.currentState = null;
      } else {
        this.marker.process(me);
        this.currentState = this.marker.getValidState();
      }
      if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {
        this.constraintHandler.reset();
        this.marker.reset();
        this.currentState = null;
      }
      const outline = this.isOutlineConnectEvent(me);
      if (this.currentState != null && outline) {
        if (me.isSource(this.marker.highlight.shape)) {
          point = new Point_default(me.getGraphX(), me.getGraphY());
        }
        const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);
        this.constraintHandler.setFocus(me, this.currentState, false);
        this.constraintHandler.currentConstraint = constraint;
        this.constraintHandler.currentPoint = point;
      }
      if (this.outlineConnect) {
        if (this.marker.highlight != null && this.marker.highlight.shape != null) {
          const s = this.graph.view.scale;
          if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {
            this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;
            this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          } else if (this.marker.hasValidState()) {
            const cell2 = me.getCell();
            if (cell2 && cell2.isConnectable() && this.marker.getValidState() !== me.getState()) {
              this.marker.highlight.shape.stroke = "transparent";
              this.currentState = null;
            } else {
              this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;
            }
            this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;
            this.marker.highlight.repaint();
          }
        }
      }
    }
  }
  /**
   * Returns true if the given cell does not allow new connections to be created.
   */
  isCellEnabled(cell2) {
    return true;
  }
  /**
   * Converts the given point from screen coordinates to model coordinates.
   */
  convertWaypoint(point) {
    const scale = this.graph.getView().getScale();
    const tr = this.graph.getView().getTranslate();
    point.x = point.x / scale - tr.x;
    point.y = point.y / scale - tr.y;
  }
  /**
   * Called to snap the given point to the current preview. This snaps to the
   * first point of the preview if alt is not pressed.
   */
  snapToPreview(me, point) {
    if (!isAltDown(me.getEvent()) && this.previous) {
      const tol = this.graph.getGridSize() * this.graph.view.scale / 2;
      const tmp2 = this.sourceConstraint && this.first ? this.first : new Point_default(this.previous.getCenterX(), this.previous.getCenterY());
      if (Math.abs(tmp2.x - me.getGraphX()) < tol) {
        point.x = tmp2.x;
      }
      if (Math.abs(tmp2.y - me.getGraphY()) < tol) {
        point.y = tmp2.y;
      }
    }
  }
  /**
   * Handles the event by updating the preview edge or by highlighting
   * a possible source or target terminal.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {
      if (!this.isEnabled() && this.currentState) {
        this.destroyIcons();
        this.currentState = null;
      }
      const view = this.graph.getView();
      const { scale } = view;
      const tr = view.translate;
      let point = new Point_default(me.getGraphX(), me.getGraphY());
      this.error = null;
      if (this.graph.isGridEnabledEvent(me.getEvent())) {
        point = new Point_default((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);
      }
      this.snapToPreview(me, point);
      this.currentPoint = point;
      if ((this.first || this.isEnabled() && this.graph.isEnabled()) && (this.shape || !this.first || Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() || Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {
        this.updateCurrentState(me, point);
      }
      if (this.first) {
        let constraint = null;
        let current = point;
        if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus && this.constraintHandler.currentPoint) {
          constraint = this.constraintHandler.currentConstraint;
          current = this.constraintHandler.currentPoint.clone();
        } else if (this.previous && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && isShiftDown(me.getEvent())) {
          if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {
            point.x = this.previous.getCenterX();
          } else {
            point.y = this.previous.getCenterY();
          }
        }
        let pt2 = this.first;
        if (this.selectedIcon && this.selectedIcon.bounds) {
          const w = this.selectedIcon.bounds.width;
          const h = this.selectedIcon.bounds.height;
          if (this.currentState && this.targetConnectImage) {
            const pos = this.getIconPosition(this.selectedIcon, this.currentState);
            this.selectedIcon.bounds.x = pos.x;
            this.selectedIcon.bounds.y = pos.y;
          } else {
            const bounds = new Rectangle_default(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);
            this.selectedIcon.bounds = bounds;
          }
          this.selectedIcon.redraw();
        }
        if (this.edgeState) {
          this.updateEdgeState(current, constraint);
          current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];
          pt2 = this.edgeState.absolutePoints[0];
        } else {
          if (this.currentState) {
            if (!this.constraintHandler.currentConstraint) {
              const tmp2 = this.getTargetPerimeterPoint(this.currentState, me);
              if (tmp2 != null) {
                current = tmp2;
              }
            }
          }
          if (!this.sourceConstraint && this.previous) {
            const next = this.waypoints.length > 0 ? this.waypoints[0] : current;
            const tmp2 = this.getSourcePerimeterPoint(this.previous, next, me);
            if (tmp2) {
              pt2 = tmp2;
            }
          }
        }
        if (!this.currentState && this.movePreviewAway && current) {
          let tmp2 = pt2;
          if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {
            const tmp22 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];
            if (tmp22) {
              tmp2 = tmp22;
            }
          }
          if (tmp2) {
            const dx = current.x - tmp2.x;
            const dy = current.y - tmp2.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len === 0) {
              return;
            }
            this.originalPoint = current.clone();
            current.x -= dx * 4 / len;
            current.y -= dy * 4 / len;
          }
        } else {
          this.originalPoint = null;
        }
        if (!this.shape) {
          const dx = Math.abs(me.getGraphX() - this.first.x);
          const dy = Math.abs(me.getGraphY() - this.first.y);
          if (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()) {
            this.shape = this.createShape();
            if (this.edgeState) {
              this.shape.apply(this.edgeState);
            }
            this.updateCurrentState(me, point);
          }
        }
        if (this.shape) {
          if (this.edgeState) {
            this.shape.points = this.edgeState.absolutePoints;
          } else {
            let pts = [pt2];
            if (this.waypoints.length > 0) {
              pts = pts.concat(this.waypoints);
            }
            pts.push(current);
            this.shape.points = pts;
          }
          this.drawPreview();
        }
        if (this.cursor) {
          this.graph.container.style.cursor = this.cursor;
        }
        InternalEvent_default.consume(me.getEvent());
        me.consume();
      } else if (!this.isEnabled() || !this.graph.isEnabled()) {
        this.constraintHandler.reset();
      } else if (this.previous !== this.currentState && !this.edgeState) {
        this.destroyIcons();
        if (this.currentState && !this.error && !this.constraintHandler.currentConstraint) {
          this.icons = this.createIcons(this.currentState);
          if (this.icons.length === 0) {
            this.currentState.setCursor(CURSOR.CONNECT);
            me.consume();
          }
        }
        this.previous = this.currentState;
      } else if (this.previous === this.currentState && this.currentState != null && this.icons.length === 0 && !this.graph.isMouseDown) {
        me.consume();
      }
      if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {
        let hitsIcon = false;
        const target2 = me.getSource();
        for (let i2 = 0; i2 < this.icons.length && !hitsIcon; i2 += 1) {
          hitsIcon = target2 === this.icons[i2].node || // @ts-ignore parentNode should exist.
          !!target2 && target2.parentNode === this.icons[i2].node;
        }
        if (!hitsIcon) {
          this.updateIcons(this.currentState, this.icons, me);
        }
      }
    } else {
      this.constraintHandler.reset();
    }
  }
  /**
   * Updates <edgeState>.
   */
  updateEdgeState(current, constraint) {
    if (!this.edgeState)
      return;
    if (this.sourceConstraint && this.sourceConstraint.point) {
      this.edgeState.style.exitX = this.sourceConstraint.point.x;
      this.edgeState.style.exitY = this.sourceConstraint.point.y;
    }
    if (constraint && constraint.point) {
      this.edgeState.style.entryX = constraint.point.x;
      this.edgeState.style.entryY = constraint.point.y;
    } else {
      this.edgeState.style.entryX = 0;
      this.edgeState.style.entryY = 0;
    }
    this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];
    if (this.sourceConstraint) {
      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);
    }
    if (this.currentState != null) {
      if (constraint == null) {
        constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);
      }
      this.edgeState.setAbsoluteTerminalPoint(null, false);
      this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);
    }
    const realPoints = [];
    for (let i2 = 0; i2 < this.waypoints.length; i2 += 1) {
      const pt = this.waypoints[i2].clone();
      this.convertWaypoint(pt);
      realPoints[i2] = pt;
    }
    this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);
    this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);
  }
  /**
   * Returns the perimeter point for the given target state.
   *
   * @param state <CellState> that represents the target cell state.
   * @param _me {@link MouseEvent} that represents the mouse move.
   */
  getTargetPerimeterPoint(state2, _me) {
    let result2 = null;
    const { view } = state2;
    const targetPerimeter = view.getPerimeterFunction(state2);
    if (targetPerimeter && this.previous && this.edgeState) {
      const next = this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new Point_default(this.previous.getCenterX(), this.previous.getCenterY());
      const tmp2 = targetPerimeter(view.getPerimeterBounds(state2), this.edgeState, next, false);
      if (tmp2) {
        result2 = tmp2;
      }
    } else {
      result2 = new Point_default(state2.getCenterX(), state2.getCenterY());
    }
    return result2;
  }
  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state <CellState> that represents the target cell state.
   * @param next {@link Point} that represents the next point along the previewed edge.
   * @param me {@link MouseEvent} that represents the mouse move.
   */
  getSourcePerimeterPoint(state2, next, me) {
    let result2 = null;
    const { view } = state2;
    const sourcePerimeter = view.getPerimeterFunction(state2);
    const c = new Point_default(state2.getCenterX(), state2.getCenterY());
    if (sourcePerimeter) {
      const theta = state2.style.rotation ?? 0;
      const rad = -theta * (Math.PI / 180);
      if (theta !== 0) {
        next = getRotatedPoint(new Point_default(next.x, next.y), Math.cos(rad), Math.sin(rad), c);
      }
      let tmp2 = sourcePerimeter(view.getPerimeterBounds(state2), state2, next, false);
      if (tmp2) {
        if (theta !== 0) {
          tmp2 = getRotatedPoint(new Point_default(tmp2.x, tmp2.y), Math.cos(-rad), Math.sin(-rad), c);
        }
        result2 = tmp2;
      }
    } else {
      result2 = c;
    }
    return result2;
  }
  /**
   * Hook to update the icon position(s) based on a mouseOver event. This is
   * an empty implementation.
   *
   * @param state <CellState> under the mouse.
   * @param icons Array of currently displayed icons.
   * @param me {@link MouseEvent} that contains the mouse event.
   */
  updateIcons(state2, icons, me) {
  }
  /**
   * Returns true if the given mouse up event should stop this handler. The
   * connection will be created if <error> is null. Note that this is only
   * called if <waypointsEnabled> is true. This implemtation returns true
   * if there is a cell state in the given event.
   */
  isStopEvent(me) {
    return !!me.getState();
  }
  /**
   * Adds the waypoint for the given event to <waypoints>.
   */
  addWaypointForEvent(me) {
    if (!this.first)
      return;
    let point = convertPoint(this.graph.container, me.getX(), me.getY());
    const dx = Math.abs(point.x - this.first.x);
    const dy = Math.abs(point.y - this.first.y);
    const addPoint = this.waypoints.length > 0 || this.mouseDownCounter > 1 && (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance());
    if (addPoint) {
      const { scale } = this.graph.view;
      point = new Point_default(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);
      this.waypoints.push(point);
    }
  }
  /**
   * Returns true if the connection for the given constraints is valid. This
   * implementation returns true if the constraints are not pointing to the
   * same fixed connection point.
   */
  checkConstraints(c1, c2) {
    return !c1 || !c2 || !c1.point || !c2.point || !c1.point.equals(c2.point) || c1.dx !== c2.dx || c1.dy !== c2.dy || c1.perimeter !== c2.perimeter;
  }
  /**
   * Handles the event by inserting the new connection.
   */
  mouseUp(sender, me) {
    if (!me.isConsumed() && this.isConnecting()) {
      if (this.waypointsEnabled && !this.isStopEvent(me)) {
        this.addWaypointForEvent(me);
        me.consume();
        return;
      }
      const c1 = this.sourceConstraint;
      const c2 = this.constraintHandler.currentConstraint;
      const source2 = this.previous ? this.previous.cell : null;
      let target2 = null;
      if (this.constraintHandler.currentConstraint && this.constraintHandler.currentFocus) {
        target2 = this.constraintHandler.currentFocus.cell;
      }
      if (!target2 && this.currentState) {
        target2 = this.currentState.cell;
      }
      if (!this.error && (!source2 || !target2 || source2 !== target2 || this.checkConstraints(c1, c2))) {
        this.connect(source2, target2, me.getEvent(), me.getCell());
      } else {
        if (this.previous != null && this.marker.validState != null && this.previous.cell === this.marker.validState.cell) {
          this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());
        }
        if (this.error != null && this.error.length > 0) {
          this.graph.validationAlert(this.error);
        }
      }
      this.destroyIcons();
      me.consume();
    }
    if (this.first != null) {
      this.reset();
    }
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.shape != null) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.cursor != null && this.graph.container != null) {
      this.graph.container.style.cursor = "";
    }
    this.destroyIcons();
    this.marker.reset();
    this.constraintHandler.reset();
    this.originalPoint = null;
    this.currentPoint = null;
    this.edgeState = null;
    this.previous = null;
    this.error = null;
    this.sourceConstraint = null;
    this.mouseDownCounter = 0;
    this.first = null;
    this.fireEvent(new EventObject_default(InternalEvent_default.RESET));
  }
  /**
   * Redraws the preview edge using the color and width returned by
   * <getEdgeColor> and <getEdgeWidth>.
   */
  drawPreview() {
    this.updatePreview(this.error === null);
    if (this.shape)
      this.shape.redraw();
  }
  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  updatePreview(valid) {
    if (this.shape) {
      this.shape.strokeWidth = this.getEdgeWidth(valid);
      this.shape.stroke = this.getEdgeColor(valid);
    }
  }
  /**
   * Returns the color used to draw the preview edge. This returns green if
   * there is no edge validation error and red otherwise.
   *
   * @param valid Boolean indicating if the color for a valid edge should be
   * returned.
   */
  getEdgeColor(valid) {
    return valid ? VALID_COLOR : INVALID_COLOR;
  }
  /**
   * Returns the width used to draw the preview edge. This returns 3 if
   * there is no edge validation error and 1 otherwise.
   *
   * @param valid Boolean indicating if the width for a valid edge should be
   * returned.
   */
  getEdgeWidth(valid) {
    return valid ? 3 : 1;
  }
  /**
   * Connects the given source and target using a new edge. This
   * implementation uses <createEdge> to create the edge.
   *
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param evt Mousedown event of the connect gesture.
   * @param dropTarget <Cell> that represents the cell under the mouse when it was
   * released.
   */
  connect(source2, target2, evt2, dropTarget = null) {
    var _a2, _b, _c, _d;
    if (target2 || this.isCreateTarget(evt2) || this.graph.isAllowDanglingEdges()) {
      const model2 = this.graph.getDataModel();
      let terminalInserted = false;
      let edge2 = null;
      model2.beginUpdate();
      try {
        if (source2 && !target2 && !this.graph.isIgnoreTerminalEvent(evt2) && this.isCreateTarget(evt2)) {
          target2 = this.createTargetVertex(evt2, source2);
          if (target2) {
            dropTarget = this.graph.getDropTarget([target2], evt2, dropTarget);
            terminalInserted = true;
            if (dropTarget == null || !dropTarget.isEdge()) {
              const pstate = dropTarget ? this.graph.getView().getState(dropTarget) : null;
              if (pstate) {
                const tmp2 = target2.getGeometry();
                if (tmp2) {
                  tmp2.x -= pstate.origin.x;
                  tmp2.y -= pstate.origin.y;
                }
              }
            } else {
              dropTarget = this.graph.getDefaultParent();
            }
            this.graph.addCell(target2, dropTarget);
          }
        }
        let parent2 = this.graph.getDefaultParent();
        if (source2 && target2 && source2.getParent() === target2.getParent() && ((_a2 = source2.getParent()) == null ? void 0 : _a2.getParent()) !== model2.getRoot()) {
          parent2 = source2.getParent();
          if (source2.geometry && source2.geometry.relative && target2.geometry && target2.geometry.relative) {
            parent2 = parent2.getParent();
          }
        }
        let value2 = null;
        let style2 = {};
        if ((_b = this.edgeState) == null ? void 0 : _b.cell) {
          value2 = this.edgeState.cell.value;
          style2 = this.edgeState.cell.style ?? {};
        }
        edge2 = this.insertEdge(parent2, "", value2, source2, target2, style2);
        if (edge2 && source2) {
          this.graph.setConnectionConstraint(edge2, source2, true, this.sourceConstraint);
          this.graph.setConnectionConstraint(edge2, target2, false, this.constraintHandler.currentConstraint);
          if ((_d = (_c = this.edgeState) == null ? void 0 : _c.cell) == null ? void 0 : _d.geometry) {
            model2.setGeometry(edge2, this.edgeState.cell.geometry);
          }
          parent2 = source2.getParent();
          if (this.isInsertBefore(edge2, source2, target2, evt2, dropTarget)) {
            const index = null;
            let tmp2 = source2;
            while (tmp2 && tmp2.parent != null && tmp2.geometry != null && tmp2.geometry.relative && tmp2.parent !== edge2.parent) {
              tmp2 = tmp2.getParent();
            }
            if (tmp2 != null && tmp2.parent != null && tmp2.parent === edge2.parent) {
              model2.add(parent2, edge2, tmp2.parent.getIndex(tmp2));
            }
          }
          let geo = edge2.getGeometry();
          if (geo == null) {
            geo = new Geometry_default();
            geo.relative = true;
            model2.setGeometry(edge2, geo);
          }
          if (this.waypoints.length > 0) {
            const s = this.graph.view.scale;
            const tr = this.graph.view.translate;
            geo.points = [];
            for (let i2 = 0; i2 < this.waypoints.length; i2 += 1) {
              const pt = this.waypoints[i2];
              geo.points.push(new Point_default(pt.x / s - tr.x, pt.y / s - tr.y));
            }
          }
          if (!target2 && this.currentPoint) {
            const t = this.graph.view.translate;
            const s = this.graph.view.scale;
            const pt = this.originalPoint != null ? new Point_default(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new Point_default(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
            pt.x -= this.graph.getPanDx() / this.graph.view.scale;
            pt.y -= this.graph.getPanDy() / this.graph.view.scale;
            geo.setTerminalPoint(pt, false);
          }
          this.fireEvent(new EventObject_default(InternalEvent_default.CONNECT, "cell", edge2, "terminal", target2, "event", evt2, "target", dropTarget, "terminalInserted", terminalInserted));
        }
      } catch (e) {
        GlobalConfig.logger.show();
        const errorMessage = `Error in ConnectionHandler: ${e instanceof Error ? e.message + "\n" + e.stack : "unknown cause"}`;
        GlobalConfig.logger.debug(errorMessage);
      } finally {
        model2.endUpdate();
      }
      if (this.select) {
        this.selectCells(edge2, terminalInserted ? target2 : null);
      }
    }
  }
  /**
   * Selects the given edge after adding a new connection. The target argument
   * contains the target vertex if one has been inserted.
   */
  selectCells(edge2, target2) {
    this.graph.setSelectionCell(edge2);
  }
  /**
   * Creates, inserts and returns the new edge for the given parameters. This
   * implementation does only use <createEdge> if <factoryMethod> is defined,
   * otherwise {@link Graph#insertEdge} will be used.
   */
  insertEdge(parent2, id2, value2, source2, target2, style2) {
    if (!this.factoryMethod) {
      return this.graph.insertEdge(parent2, id2, value2, source2, target2, style2);
    }
    let edge2 = this.createEdge(value2, source2, target2, style2);
    edge2 = this.graph.addEdge(edge2, parent2, source2, target2);
    return edge2;
  }
  /**
   * Hook method for creating new vertices on the fly if no target was
   * under the mouse. This is only called if <createTarget> is true and
   * returns null.
   *
   * @param evt Mousedown event of the connect gesture.
   * @param source <Cell> that represents the source terminal.
   */
  createTargetVertex(evt2, source2) {
    let geo = source2.getGeometry();
    while (geo && geo.relative) {
      source2 = source2.getParent();
      geo = source2.getGeometry();
    }
    const clone2 = this.graph.cloneCell(source2);
    geo = clone2.getGeometry();
    if (geo && this.currentPoint) {
      const t = this.graph.view.translate;
      const s = this.graph.view.scale;
      const point = new Point_default(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);
      geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);
      geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);
      const tol = this.getAlignmentTolerance();
      if (tol > 0) {
        const sourceState = this.graph.view.getState(source2);
        if (sourceState != null) {
          const x = sourceState.x / s - t.x;
          const y = sourceState.y / s - t.y;
          if (Math.abs(x - geo.x) <= tol) {
            geo.x = Math.round(x);
          }
          if (Math.abs(y - geo.y) <= tol) {
            geo.y = Math.round(y);
          }
        }
      }
    }
    return clone2;
  }
  /**
   * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.
   */
  getAlignmentTolerance(evt2) {
    return this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.graph.getSnapTolerance();
  }
  /**
   * Creates and returns a new edge using <factoryMethod> if one exists. If
   * no factory method is defined, then a new default edge is returned. The
   * source and target arguments are informal, the actual connection is
   * setup later by the caller of this function.
   *
   * @param value Value to be used for creating the edge.
   * @param source <Cell> that represents the source terminal.
   * @param target <Cell> that represents the target terminal.
   * @param style Optional style from the preview edge.
   */
  createEdge(value2, source2, target2, style2 = {}) {
    let edge2 = null;
    if (this.factoryMethod != null) {
      edge2 = this.factoryMethod(source2, target2, style2);
    }
    if (edge2 == null) {
      edge2 = new Cell_default(value2 || "");
      edge2.setEdge(true);
      edge2.setStyle(style2);
      const geo = new Geometry_default();
      geo.relative = true;
      edge2.setGeometry(geo);
    }
    return edge2;
  }
  /**
   * Destroys the handler and all its resources and DOM nodes. This should be
   * called on all instances. It is called automatically for the built-in
   * instance created for each {@link Graph}.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.marker) {
      this.marker.destroy();
      this.marker = null;
    }
    if (this.constraintHandler) {
      this.constraintHandler.onDestroy();
    }
    if (this.changeHandler) {
      this.graph.getDataModel().removeListener(this.changeHandler);
      this.graph.getView().removeListener(this.changeHandler);
    }
    if (this.drillHandler) {
      this.graph.removeListener(this.drillHandler);
      this.graph.getView().removeListener(this.drillHandler);
    }
    if (this.escapeHandler) {
      this.graph.removeListener(this.escapeHandler);
    }
  }
};
ConnectionHandler.pluginId = "ConnectionHandler";
var ConnectionHandlerCellMarker = class extends CellMarker_default {
  constructor(graph, connectionHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {
    super(graph, validColor, invalidColor, hotspot);
    this.hotspotEnabled = true;
    this.connectionHandler = connectionHandler;
  }
  // Overrides to return cell at location only if valid (so that
  // there is no highlight for invalid cells)
  getCell(me) {
    let cell2 = super.getCell(me);
    this.connectionHandler.error = null;
    if (!cell2 && this.connectionHandler.currentPoint) {
      cell2 = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);
    }
    if (cell2 && !cell2.isConnectable() && this.connectionHandler.cell) {
      const parent2 = this.connectionHandler.cell.getParent();
      if (parent2 && parent2.isVertex() && parent2.isConnectable()) {
        cell2 = parent2;
      }
    }
    if (cell2) {
      if (this.connectionHandler.graph.isSwimlane(cell2) && this.connectionHandler.currentPoint != null && this.connectionHandler.graph.hitsSwimlaneContent(cell2, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y) || !this.connectionHandler.isConnectableCell(cell2)) {
        cell2 = null;
      }
    }
    if (cell2) {
      if (this.connectionHandler.isConnecting()) {
        if (this.connectionHandler.previous) {
          this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell2);
          if (this.connectionHandler.error !== null && this.connectionHandler.error.length === 0) {
            cell2 = null;
            if (this.connectionHandler.isCreateTarget(me.getEvent())) {
              this.connectionHandler.error = null;
            }
          }
        }
      } else if (!this.connectionHandler.isValidSource(cell2, me)) {
        cell2 = null;
      }
    } else if (this.connectionHandler.isConnecting() && !this.connectionHandler.isCreateTarget(me.getEvent()) && !this.connectionHandler.graph.isAllowDanglingEdges()) {
      this.connectionHandler.error = "";
    }
    return cell2;
  }
  // Sets the highlight color according to validateConnection
  isValidState(state2) {
    if (this.connectionHandler.isConnecting()) {
      return !this.connectionHandler.error;
    }
    return super.isValidState(state2);
  }
  // Overrides to use marker color only in highlight mode or for
  // target selection
  getMarkerColor(evt2, state2, isValid) {
    return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting() ? super.getMarkerColor(evt2, state2, isValid) : NONE;
  }
  // Overrides to use hotspot only for source selection otherwise
  // intersects always returns true when over a cell
  intersects(state2, evt2) {
    if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {
      return true;
    }
    return super.intersects(state2, evt2);
  }
};
var ConnectionHandler_default = ConnectionHandler;

// node_modules/@maxgraph/core/lib/view/other/Guide.js
var Guide = class {
  constructor(graph, states) {
    this.states = [];
    this.horizontal = true;
    this.vertical = true;
    this.guideX = null;
    this.guideY = null;
    this.rounded = false;
    this.tolerance = 2;
    this.graph = graph;
    this.setStates(states);
  }
  /**
   * Sets the {@link CellState}s that should be used for alignment.
   */
  setStates(states) {
    this.states = states;
  }
  /**
   * Returns true if the guide should be enabled for the given native event. This
   * implementation always returns true.
   */
  isEnabledForEvent(evt2) {
    return true;
  }
  /**
   * Returns the tolerance for the guides. Default value is gridSize / 2.
   */
  getGuideTolerance(gridEnabled = false) {
    return gridEnabled && this.graph.isGridEnabled() ? this.graph.getGridSize() / 2 : this.tolerance;
  }
  /**
   * Returns the mxShape to be used for painting the respective guide. This
   * implementation returns a new, dashed and crisp {@link PolylineShape} using
   * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.
   *
   * @param horizontal Boolean that specifies which guide should be created.
   */
  createGuideShape(horizontal = false) {
    const guide = new PolylineShape_default([], GUIDE_COLOR, GUIDE_STROKEWIDTH);
    guide.isDashed = true;
    return guide;
  }
  /**
   * Returns true if the given state should be ignored.
   * @param state
   */
  isStateIgnored(state2) {
    return false;
  }
  /**
   * Moves the <bounds> by the given {@link Point} and returnt the snapped point.
   */
  move(bounds = null, delta, gridEnabled = false, clone2 = false) {
    if ((this.horizontal || this.vertical) && bounds) {
      const { scale } = this.graph.getView();
      const tt = this.getGuideTolerance(gridEnabled) * scale;
      const b = bounds.clone();
      b.x += delta.x;
      b.y += delta.y;
      let overrideX = false;
      let stateX = null;
      let valueX = null;
      let overrideY = false;
      let stateY = null;
      let valueY = null;
      let ttX = tt;
      let ttY = tt;
      const left = b.x;
      const right = b.x + b.width;
      const center = b.getCenterX();
      const top = b.y;
      const bottom = b.y + b.height;
      const middle = b.getCenterY();
      const snapX = (x, state2, centerAlign) => {
        let override = false;
        if (centerAlign && Math.abs(x - center) < ttX) {
          delta.x = x - bounds.getCenterX();
          ttX = Math.abs(x - center);
          override = true;
        } else if (!centerAlign) {
          if (Math.abs(x - left) < ttX) {
            delta.x = x - bounds.x;
            ttX = Math.abs(x - left);
            override = true;
          } else if (Math.abs(x - right) < ttX) {
            delta.x = x - bounds.x - bounds.width;
            ttX = Math.abs(x - right);
            override = true;
          }
        }
        if (override) {
          stateX = state2;
          valueX = x;
          if (!this.guideX) {
            this.guideX = this.createGuideShape(true);
            this.guideX.dialect = DIALECT.SVG;
            this.guideX.pointerEvents = false;
            this.guideX.init(this.graph.getView().getOverlayPane());
          }
        }
        overrideX = overrideX || override;
      };
      const snapY = (y, state2, centerAlign) => {
        let override = false;
        if (centerAlign && Math.abs(y - middle) < ttY) {
          delta.y = y - bounds.getCenterY();
          ttY = Math.abs(y - middle);
          override = true;
        } else if (!centerAlign) {
          if (Math.abs(y - top) < ttY) {
            delta.y = y - bounds.y;
            ttY = Math.abs(y - top);
            override = true;
          } else if (Math.abs(y - bottom) < ttY) {
            delta.y = y - bounds.y - bounds.height;
            ttY = Math.abs(y - bottom);
            override = true;
          }
        }
        if (override) {
          stateY = state2;
          valueY = y;
          if (!this.guideY) {
            this.guideY = this.createGuideShape(false);
            this.guideY.dialect = DIALECT.SVG;
            this.guideY.pointerEvents = false;
            this.guideY.init(this.graph.getView().getOverlayPane());
          }
        }
        overrideY = overrideY || override;
      };
      for (let i2 = 0; i2 < this.states.length; i2 += 1) {
        const state2 = this.states[i2];
        if (state2 && !this.isStateIgnored(state2)) {
          if (this.horizontal) {
            snapX(state2.getCenterX(), state2, true);
            snapX(state2.x, state2, false);
            snapX(state2.x + state2.width, state2, false);
            if (!state2.cell) {
              snapX(state2.getCenterX(), state2, false);
            }
          }
          if (this.vertical) {
            snapY(state2.getCenterY(), state2, true);
            snapY(state2.y, state2, false);
            snapY(state2.y + state2.height, state2, false);
            if (!state2.cell) {
              snapY(state2.getCenterY(), state2, false);
            }
          }
        }
      }
      this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);
      delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);
      const c = this.graph.container;
      if (!overrideX && this.guideX) {
        this.guideX.node.style.visibility = "hidden";
      } else if (this.guideX) {
        let minY = null;
        let maxY = null;
        if (stateX) {
          minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);
          maxY = Math.max(
            bounds.y + bounds.height + delta.y - this.graph.getPanDy(),
            // @ts-ignore stateX! doesn't work for some reason...
            stateX.y + stateX.height
          );
        }
        if (minY !== null && maxY !== null) {
          this.guideX.points = [new Point_default(valueX, minY), new Point_default(valueX, maxY)];
        } else {
          this.guideX.points = [
            new Point_default(valueX, -this.graph.getPanDy()),
            new Point_default(valueX, c.scrollHeight - 3 - this.graph.getPanDy())
          ];
        }
        this.guideX.stroke = this.getGuideColor(stateX, true);
        this.guideX.node.style.visibility = "visible";
        this.guideX.redraw();
      }
      if (!overrideY && this.guideY != null) {
        this.guideY.node.style.visibility = "hidden";
      } else if (this.guideY != null) {
        let minX = null;
        let maxX = null;
        if (stateY != null && bounds != null) {
          minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);
          maxX = Math.max(
            bounds.x + bounds.width + delta.x - this.graph.getPanDx(),
            // @ts-ignore
            stateY.x + stateY.width
          );
        }
        if (minX != null && maxX != null && valueY !== null) {
          this.guideY.points = [new Point_default(minX, valueY), new Point_default(maxX, valueY)];
        } else if (valueY !== null) {
          this.guideY.points = [
            new Point_default(-this.graph.getPanDx(), valueY),
            new Point_default(c.scrollWidth - 3 - this.graph.getPanDx(), valueY)
          ];
        }
        this.guideY.stroke = this.getGuideColor(stateY, false);
        this.guideY.node.style.visibility = "visible";
        this.guideY.redraw();
      }
    }
    return delta;
  }
  /**
   * Rounds to pixels for virtual states (eg. page guides)
   */
  getDelta(bounds, stateX = null, dx, stateY = null, dy) {
    const s = this.graph.view.scale;
    if (this.rounded || stateX != null && stateX.cell == null) {
      dx = Math.round((bounds.x + dx) / s) * s - bounds.x;
    }
    if (this.rounded || stateY != null && stateY.cell == null) {
      dy = Math.round((bounds.y + dy) / s) * s - bounds.y;
    }
    return new Point_default(dx, dy);
  }
  /**
   * Hides all current guides.
   */
  getGuideColor(state2, horizontal) {
    return GUIDE_COLOR;
  }
  /**
   * Hides all current guides.
   */
  hide() {
    this.setVisible(false);
  }
  /**
   * Shows or hides the current guides.
   */
  setVisible(visible) {
    if (this.guideX) {
      this.guideX.node.style.visibility = visible ? "visible" : "hidden";
    }
    if (this.guideY) {
      this.guideY.node.style.visibility = visible ? "visible" : "hidden";
    }
  }
  /**
   * Destroys all resources that this object uses.
   */
  destroy() {
    if (this.guideX) {
      this.guideX.destroy();
      this.guideX = null;
    }
    if (this.guideY) {
      this.guideY.destroy();
      this.guideY = null;
    }
  }
};
var Guide_default = Guide;

// node_modules/@maxgraph/core/lib/view/handler/SelectionHandler.js
var SelectionHandler = class {
  /**
   * Constructs an event handler that creates handles for the selection cells.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   */
  constructor(graph) {
    this.refreshThread = null;
    this.maxCells = 50;
    this.enabled = true;
    this.highlightEnabled = true;
    this.cloneEnabled = true;
    this.moveEnabled = true;
    this.guidesEnabled = false;
    this.handlesVisible = true;
    this.guide = null;
    this.currentDx = 0;
    this.currentDy = 0;
    this.updateCursor = true;
    this.selectEnabled = true;
    this.removeCellsFromParent = true;
    this.removeEmptyParents = false;
    this.connectOnDrop = false;
    this.scrollOnMove = true;
    this.minimumSize = 6;
    this.previewColor = "black";
    this.htmlPreview = false;
    this.shape = null;
    this.scaleGrid = false;
    this.rotationEnabled = true;
    this.maxLivePreview = 0;
    this.allowLivePreview = Client_default.IS_SVG;
    this.cell = null;
    this.delayedSelection = false;
    this.first = null;
    this.cells = null;
    this.bounds = null;
    this.pBounds = null;
    this.allCells = new Dictionary_default();
    this.cellWasClicked = false;
    this.cloning = false;
    this.cellCount = 0;
    this.target = null;
    this.suspended = false;
    this.livePreviewActive = false;
    this.livePreviewUsed = false;
    this.highlight = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.panHandler = () => {
      if (!this.suspended) {
        this.updatePreview();
        this.updateHint();
      }
    };
    this.graph.addListener(InternalEvent_default.PAN, this.panHandler);
    this.escapeHandler = (sender, evt2) => {
      this.reset();
    };
    this.graph.addListener(InternalEvent_default.ESCAPE, this.escapeHandler);
    this.refreshHandler = (sender, evt2) => {
      if (this.refreshThread) {
        window.clearTimeout(this.refreshThread);
      }
      this.refreshThread = window.setTimeout(() => {
        this.refreshThread = null;
        if (this.first && !this.suspended && this.cells) {
          const dx = this.currentDx;
          const dy = this.currentDy;
          this.currentDx = 0;
          this.currentDy = 0;
          this.updatePreview();
          this.bounds = this.graph.getView().getBounds(this.cells);
          this.pBounds = this.getPreviewBounds(this.cells);
          if (this.pBounds == null && !this.livePreviewUsed) {
            this.reset();
          } else {
            this.currentDx = dx;
            this.currentDy = dy;
            this.updatePreview();
            this.updateHint();
            if (this.livePreviewUsed) {
              const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
              this.setHandlesVisibleForCells((selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandledSelectionCells()) ?? [], false, true);
              this.updatePreview();
            }
          }
        }
      }, 0);
    };
    this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.refreshHandler);
    this.graph.addListener(InternalEvent_default.REFRESH, this.refreshHandler);
    this.keyHandler = (e) => {
      if (this.graph.container != null && this.graph.container.style.visibility !== "hidden" && this.first != null && !this.suspended) {
        const clone2 = this.graph.isCloneEvent(e) && this.graph.isCellsCloneable() && this.isCloneEnabled();
        if (clone2 !== this.cloning) {
          this.cloning = clone2;
          this.checkPreview();
          this.updatePreview();
        }
      }
    };
    if (typeof document !== "undefined") {
      InternalEvent_default.addListener(document, "keydown", this.keyHandler);
      InternalEvent_default.addListener(document, "keyup", this.keyHandler);
    }
  }
  /**
   * Returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets <enabled>.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns <cloneEnabled>.
   */
  isCloneEnabled() {
    return this.cloneEnabled;
  }
  /**
   * Sets <cloneEnabled>.
   *
   * @param value Boolean that specifies the new clone enabled state.
   */
  setCloneEnabled(value2) {
    this.cloneEnabled = value2;
  }
  /**
   * Returns {@link oveEnabled}.
   */
  isMoveEnabled() {
    return this.moveEnabled;
  }
  /**
   * Sets {@link oveEnabled}.
   */
  setMoveEnabled(value2) {
    this.moveEnabled = value2;
  }
  /**
   * Returns <selectEnabled>.
   */
  isSelectEnabled() {
    return this.selectEnabled;
  }
  /**
   * Sets <selectEnabled>.
   */
  setSelectEnabled(value2) {
    this.selectEnabled = value2;
  }
  /**
   * Returns <removeCellsFromParent>.
   */
  isRemoveCellsFromParent() {
    return this.removeCellsFromParent;
  }
  /**
   * Sets <removeCellsFromParent>.
   */
  setRemoveCellsFromParent(value2) {
    this.removeCellsFromParent = value2;
  }
  /**
   * Returns true if the given cell and parent should propagate
   * selection state to the parent.
   */
  isPropagateSelectionCell(cell2, immediate, me) {
    const parent2 = cell2.getParent();
    if (immediate) {
      const geo = cell2.isEdge() ? null : cell2.getGeometry();
      return !this.graph.isSiblingSelected(cell2) && geo && geo.relative || !this.graph.isSwimlane(parent2);
    }
    return (!this.graph.isToggleEvent(me.getEvent()) || !this.graph.isSiblingSelected(cell2) && !this.graph.isCellSelected(cell2) && !this.graph.isSwimlane(parent2) || this.graph.isCellSelected(parent2)) && (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent2));
  }
  /**
   * Hook to return initial cell for the given event.
   */
  getInitialCellForEvent(me) {
    let state2 = me.getState();
    if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) && state2 && !this.graph.isCellSelected(state2.cell)) {
      let parent2 = state2.cell.getParent();
      let next = parent2 ? this.graph.view.getState(parent2) : null;
      while (next && !this.graph.isCellSelected(next.cell) && (next.cell.isVertex() || next.cell.isEdge()) && this.isPropagateSelectionCell(state2.cell, true, me)) {
        state2 = next;
        parent2 = state2.cell.getParent();
        next = parent2 ? this.graph.view.getState(parent2) : null;
      }
    }
    return state2 ? state2.cell : null;
  }
  /**
   * Hook to return true for delayed selections.
   */
  isDelayedSelection(cell2, me) {
    let c = cell2;
    const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
    if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {
      while (c) {
        if (selectionCellsHandler == null ? void 0 : selectionCellsHandler.isHandled(c)) {
          const cellEditorHandler = this.graph.getPlugin("CellEditorHandler");
          return (cellEditorHandler == null ? void 0 : cellEditorHandler.getEditingCell()) !== c;
        }
        c = c.getParent();
      }
    }
    return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());
  }
  /**
   * Implements the delayed selection for the given mouse event.
   */
  selectDelayed(me) {
    const popupMenuHandler = this.graph.getPlugin("PopupMenuHandler");
    if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {
      let cell2 = me.getCell();
      if (cell2 === null) {
        cell2 = this.cell;
      }
      if (cell2)
        this.selectCellForEvent(cell2, me);
    }
  }
  /**
   * Selects the given cell for the given {@link MouseEvent}.
   */
  selectCellForEvent(cell2, me) {
    const state2 = this.graph.view.getState(cell2);
    if (state2) {
      if (me.isSource(state2.control)) {
        this.graph.selectCellForEvent(cell2, me.getEvent());
      } else {
        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {
          let parent2 = cell2.getParent();
          while (parent2 && this.graph.view.getState(parent2) && (parent2.isVertex() || parent2.isEdge()) && this.isPropagateSelectionCell(cell2, false, me)) {
            cell2 = parent2;
            parent2 = cell2.getParent();
          }
        }
        this.graph.selectCellForEvent(cell2, me.getEvent());
      }
    }
    return cell2;
  }
  /**
   * Consumes the given mouse event. NOTE: This may be used to enable click
   * events for links in labels on iOS as follows as consuming the initial
   * touchStart disables firing the subsequent click evnent on the link.
   *
   * <code>
   * consumeMouseEvent(evtName, me)
   * {
   *   var source = mxEvent.getSource(me.getEvent());
   *
   *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')
   *   {
   *     me.consume();
   *   }
   * }
   * </code>
   */
  consumeMouseEvent(evtName, me) {
    me.consume();
  }
  /**
   * Handles the event by selecing the given cell and creating a handle for
   * it. By consuming the event all subsequent events of the gesture are
   * redirected to this handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() && !isMultiTouchEvent(me.getEvent())) {
      const cell2 = this.getInitialCellForEvent(me);
      if (cell2) {
        this.delayedSelection = this.isDelayedSelection(cell2, me);
        this.cell = null;
        if (this.isSelectEnabled() && !this.delayedSelection) {
          this.graph.selectCellForEvent(cell2, me.getEvent());
        }
        if (this.isMoveEnabled()) {
          const geo = cell2.getGeometry();
          if (geo && this.graph.isCellMovable(cell2) && (!cell2.isEdge() || this.graph.getSelectionCount() > 1 || geo.points && geo.points.length > 0 || !cell2.getTerminal(true) || !cell2.getTerminal(false) || this.graph.isAllowDanglingEdges() || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {
            this.start(cell2, me.getX(), me.getY());
          } else if (this.delayedSelection) {
            this.cell = cell2;
          }
          this.cellWasClicked = true;
          this.consumeMouseEvent(InternalEvent_default.MOUSE_DOWN, me);
        }
      }
    }
  }
  /**
   * Creates an array of cell states which should be used as guides.
   */
  getGuideStates() {
    const parent2 = this.graph.getDefaultParent();
    const filter = (cell2) => {
      const geo = cell2.getGeometry();
      return !!this.graph.view.getState(cell2) && cell2.isVertex() && !!geo && !geo.relative;
    };
    return this.graph.view.getCellStates(parent2.filterDescendants(filter));
  }
  /**
   * Returns the cells to be modified by this handler. This implementation
   * returns all selection cells that are movable, or the given initial cell if
   * the given cell is not selected and movable. This handles the case of moving
   * unselectable or unselected cells.
   *
   * @param initialCell <Cell> that triggered this handler.
   */
  getCells(initialCell) {
    if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {
      return [initialCell];
    }
    return this.graph.getMovableCells(this.graph.getSelectionCells());
  }
  /**
   * Returns the {@link Rectangle} used as the preview bounds for
   * moving the given cells.
   */
  getPreviewBounds(cells) {
    const bounds = this.getBoundingBox(cells);
    if (bounds) {
      bounds.width = Math.max(0, bounds.width - 1);
      bounds.height = Math.max(0, bounds.height - 1);
      if (bounds.width < this.minimumSize) {
        const dx = this.minimumSize - bounds.width;
        bounds.x -= dx / 2;
        bounds.width = this.minimumSize;
      } else {
        bounds.x = Math.round(bounds.x);
        bounds.width = Math.ceil(bounds.width);
      }
      if (bounds.height < this.minimumSize) {
        const dy = this.minimumSize - bounds.height;
        bounds.y -= dy / 2;
        bounds.height = this.minimumSize;
      } else {
        bounds.y = Math.round(bounds.y);
        bounds.height = Math.ceil(bounds.height);
      }
    }
    return bounds;
  }
  /**
   * Returns the union of the {@link CellStates} for the given array of {@link Cells}.
   * For vertices, this method uses the bounding box of the corresponding shape
   * if one exists. The bounding box of the corresponding text label and all
   * controls and overlays are ignored. See also: {@link GraphView#getBounds} and
   * {@link Graph#getBoundingBox}.
   *
   * @param cells Array of {@link Cells} whose bounding box should be returned.
   */
  getBoundingBox(cells) {
    let result2 = null;
    if (cells.length > 0) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        if (cells[i2].isVertex() || cells[i2].isEdge()) {
          const state2 = this.graph.view.getState(cells[i2]);
          if (state2) {
            let bbox = null;
            if (cells[i2].isVertex() && state2.shape && state2.shape.boundingBox) {
              bbox = state2.shape.boundingBox;
            }
            if (bbox) {
              if (!result2) {
                result2 = Rectangle_default.fromRectangle(bbox);
              } else {
                result2.add(bbox);
              }
            }
          }
        }
      }
    }
    return result2;
  }
  /**
   * Creates the shape used to draw the preview for the given bounds.
   */
  createPreviewShape(bounds) {
    const shape2 = new RectangleShape_default(bounds, NONE, this.previewColor);
    shape2.isDashed = true;
    if (this.htmlPreview) {
      shape2.dialect = DIALECT.STRICTHTML;
      shape2.init(this.graph.container);
    } else {
      shape2.dialect = DIALECT.SVG;
      shape2.init(this.graph.getView().getOverlayPane());
      shape2.pointerEvents = false;
      if (Client_default.IS_IOS) {
        shape2.getSvgScreenOffset = () => {
          return 0;
        };
      }
    }
    return shape2;
  }
  createGuide() {
    return new Guide_default(this.graph, this.getGuideStates());
  }
  /**
   * Starts the handling of the mouse gesture.
   */
  start(cell2, x, y, cells) {
    this.cell = cell2;
    this.first = convertPoint(this.graph.container, x, y);
    this.cells = cells ? cells : this.getCells(this.cell);
    this.bounds = this.graph.getView().getBounds(this.cells);
    this.pBounds = this.getPreviewBounds(this.cells);
    this.cloning = false;
    this.cellCount = 0;
    for (let i2 = 0; i2 < this.cells.length; i2 += 1) {
      this.cellCount += this.addStates(this.cells[i2], this.allCells);
    }
    if (this.guidesEnabled) {
      this.guide = this.createGuide();
      const parent2 = cell2.getParent();
      const ignore = parent2.getChildCount() < 2;
      const connected = new Dictionary_default();
      const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);
      for (let i2 = 0; i2 < opps.length; i2 += 1) {
        const state2 = this.graph.view.getState(opps[i2]);
        if (state2 && !connected.get(state2)) {
          connected.put(state2, true);
        }
      }
      this.guide.isStateIgnored = (state2) => {
        const p = state2.cell.getParent();
        return !!state2.cell && (!this.cloning && !!this.isCellMoving(state2.cell) || state2.cell !== (this.target || parent2) && !ignore && !connected.get(state2) && (!this.target || this.target.getChildCount() >= 2) && p !== (this.target || parent2));
      };
    }
  }
  /**
   * Adds the states for the given cell recursively to the given dictionary.
   * @param cell
   * @param dict
   */
  addStates(cell2, dict) {
    const state2 = this.graph.view.getState(cell2);
    let count = 0;
    if (state2 && !dict.get(cell2)) {
      dict.put(cell2, state2);
      count++;
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        count += this.addStates(cell2.getChildAt(i2), dict);
      }
    }
    return count;
  }
  /**
   * Returns true if the given cell is currently being moved.
   */
  isCellMoving(cell2) {
    return this.allCells.get(cell2);
  }
  /**
   * Returns true if the guides should be used for the given {@link MouseEvent}.
   * This implementation returns {@link Guide#isEnabledForEvent}.
   */
  useGuidesForEvent(me) {
    return this.guide ? this.guide.isEnabledForEvent(me.getEvent()) && !this.graph.isConstrainedEvent(me.getEvent()) : true;
  }
  /**
   * Snaps the given vector to the grid and returns the given mxPoint instance.
   */
  snap(vector) {
    const scale = this.scaleGrid ? this.graph.view.scale : 1;
    vector.x = this.graph.snap(vector.x / scale) * scale;
    vector.y = this.graph.snap(vector.y / scale) * scale;
    return vector;
  }
  /**
   * Returns an {@link Point} that represents the vector for moving the cells
   * for the given {@link MouseEvent}.
   */
  getDelta(me) {
    const point = convertPoint(this.graph.container, me.getX(), me.getY());
    if (!this.first)
      return new Point_default();
    return new Point_default(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());
  }
  /**
   * Hook for subclassers do show details while the handler is active.
   */
  updateHint(me) {
    return;
  }
  /**
   * Hooks for subclassers to hide details when the handler gets inactive.
   */
  removeHint() {
    return;
  }
  /**
   * Hook for rounding the unscaled vector. This uses Math.round.
   */
  roundLength(length) {
    return Math.round(length * 100) / 100;
  }
  /**
   * Returns true if the given cell is a valid drop target.
   */
  isValidDropTarget(target2, me) {
    return this.cell ? this.cell.getParent() !== target2 : false;
  }
  /**
   * Updates the preview if cloning state has changed.
   */
  checkPreview() {
    if (this.livePreviewActive && this.cloning) {
      this.resetLivePreview();
      this.livePreviewActive = false;
    } else if (this.maxLivePreview >= this.cellCount && !this.livePreviewActive && this.allowLivePreview) {
      if (!this.cloning || !this.livePreviewActive) {
        this.livePreviewActive = true;
        this.livePreviewUsed = true;
      }
    } else if (!this.livePreviewUsed && !this.shape && this.bounds) {
      this.shape = this.createPreviewShape(this.bounds);
    }
  }
  /**
   * Handles the event by highlighting possible drop targets and updating the
   * preview.
   */
  mouseMove(sender, me) {
    const { graph } = this;
    if (!me.isConsumed() && graph.isMouseDown && this.cell && this.first && this.bounds && !this.suspended) {
      if (isMultiTouchEvent(me.getEvent())) {
        this.reset();
        return;
      }
      let delta = this.getDelta(me);
      const tol = graph.getEventTolerance();
      if (this.shape || this.livePreviewActive || Math.abs(delta.x) > tol || Math.abs(delta.y) > tol) {
        if (!this.highlight) {
          this.highlight = new CellHighlight_default(this.graph, DROP_TARGET_COLOR, 3);
        }
        const clone2 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
        const gridEnabled = graph.isGridEnabledEvent(me.getEvent());
        const cell2 = me.getCell();
        let hideGuide = true;
        let target2 = null;
        this.cloning = clone2;
        if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {
          target2 = graph.getDropTarget(this.cells, me.getEvent(), cell2, clone2);
        }
        let state2 = target2 ? graph.getView().getState(target2) : null;
        let highlight = false;
        if (state2 && (clone2 || target2 && this.isValidDropTarget(target2, me))) {
          if (this.target !== target2) {
            this.target = target2;
            this.setHighlightColor(DROP_TARGET_COLOR);
          }
          highlight = true;
        } else {
          this.target = null;
          if (this.connectOnDrop && cell2 && this.cells && this.cells.length === 1 && cell2.isVertex() && cell2.isConnectable()) {
            state2 = graph.getView().getState(cell2);
            if (state2) {
              const error2 = graph.getEdgeValidationError(null, this.cell, cell2);
              const color = error2 === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;
              this.setHighlightColor(color);
              highlight = true;
            }
          }
        }
        if (state2 && highlight) {
          this.highlight.highlight(state2);
        } else {
          this.highlight.hide();
        }
        if (this.guide && this.useGuidesForEvent(me)) {
          delta = this.guide.move(this.bounds, delta, gridEnabled, clone2);
          hideGuide = false;
        } else {
          delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);
        }
        if (this.guide && hideGuide) {
          this.guide.hide();
        }
        if (graph.isConstrainedEvent(me.getEvent())) {
          if (Math.abs(delta.x) > Math.abs(delta.y)) {
            delta.y = 0;
          } else {
            delta.x = 0;
          }
        }
        this.checkPreview();
        if (this.currentDx !== delta.x || this.currentDy !== delta.y) {
          this.currentDx = delta.x;
          this.currentDy = delta.y;
          this.updatePreview();
        }
      }
      this.updateHint(me);
      this.consumeMouseEvent(InternalEvent_default.MOUSE_MOVE, me);
      InternalEvent_default.consume(me.getEvent());
    } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && (me.getState() || me.sourceState) && !graph.isMouseDown) {
      let cursor = graph.getCursorForMouseEvent(me);
      const cell2 = me.getCell();
      if (!cursor && cell2 && graph.isEnabled() && graph.isCellMovable(cell2)) {
        if (cell2.isEdge()) {
          cursor = CURSOR.MOVABLE_EDGE;
        } else {
          cursor = CURSOR.MOVABLE_VERTEX;
        }
      }
      if (cursor && me.sourceState) {
        me.sourceState.setCursor(cursor);
      }
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updatePreview(remote = false) {
    if (this.livePreviewUsed && !remote) {
      if (this.cells) {
        const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
        this.setHandlesVisibleForCells((selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandledSelectionCells()) ?? [], false);
        this.updateLivePreview(this.currentDx, this.currentDy);
      }
    } else {
      this.updatePreviewShape();
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updatePreviewShape() {
    if (this.shape && this.pBounds) {
      this.shape.bounds = new Rectangle_default(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);
      this.shape.redraw();
    }
  }
  /**
   * Updates the bounds of the preview shape.
   */
  updateLivePreview(dx, dy) {
    if (!this.suspended) {
      const states = [];
      if (this.allCells) {
        this.allCells.visit((key2, state2) => {
          const realState = state2 ? this.graph.view.getState(state2.cell) : null;
          if (realState !== state2 && state2) {
            state2.destroy();
            if (realState) {
              this.allCells.put(state2.cell, realState);
            } else {
              this.allCells.remove(state2.cell);
            }
            state2 = realState;
          }
          if (state2) {
            const tempState = state2.clone();
            states.push([state2, tempState]);
            if (state2.shape) {
              if (state2.shape.originalPointerEvents === null) {
                state2.shape.originalPointerEvents = state2.shape.pointerEvents;
              }
              state2.shape.pointerEvents = false;
              if (state2.text) {
                if (state2.text.originalPointerEvents === null) {
                  state2.text.originalPointerEvents = state2.text.pointerEvents;
                }
                state2.text.pointerEvents = false;
              }
            }
            if (state2.cell.isVertex()) {
              state2.x += dx;
              state2.y += dy;
              if (!this.cloning) {
                state2.view.graph.cellRenderer.redraw(state2, true);
                state2.view.invalidate(state2.cell);
                state2.invalid = false;
                if (state2.control && state2.control.node) {
                  state2.control.node.style.visibility = "hidden";
                }
              } else if (state2.text) {
                state2.text.updateBoundingBox();
                if (state2.text.boundingBox) {
                  state2.text.boundingBox.x += dx;
                  state2.text.boundingBox.y += dy;
                }
                if (state2.text.unrotatedBoundingBox) {
                  state2.text.unrotatedBoundingBox.x += dx;
                  state2.text.unrotatedBoundingBox.y += dy;
                }
              }
            }
          }
        });
      }
      if (states.length === 0) {
        this.reset();
      } else {
        const s = this.graph.view.scale;
        for (let i2 = 0; i2 < states.length; i2 += 1) {
          const state2 = states[i2][0];
          if (state2.cell.isEdge()) {
            const geometry = state2.cell.getGeometry();
            const points2 = [];
            if (geometry && geometry.points) {
              for (let j = 0; j < geometry.points.length; j++) {
                if (geometry.points[j]) {
                  points2.push(new Point_default(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));
                }
              }
            }
            let source2 = state2.visibleSourceState;
            let target2 = state2.visibleTargetState;
            const pts = states[i2][1].absolutePoints;
            if (source2 == null || !this.isCellMoving(source2.cell)) {
              const pt0 = pts[0];
              if (pt0) {
                state2.setAbsoluteTerminalPoint(new Point_default(pt0.x + dx, pt0.y + dy), true);
                source2 = null;
              }
            } else {
              state2.view.updateFixedTerminalPoint(state2, source2, true, this.graph.getConnectionConstraint(state2, source2, true));
            }
            if (target2 == null || !this.isCellMoving(target2.cell)) {
              const ptn = pts[pts.length - 1];
              if (ptn) {
                state2.setAbsoluteTerminalPoint(new Point_default(ptn.x + dx, ptn.y + dy), false);
                target2 = null;
              }
            } else {
              state2.view.updateFixedTerminalPoint(state2, target2, false, this.graph.getConnectionConstraint(state2, target2, false));
            }
            state2.view.updatePoints(state2, points2, source2, target2);
            state2.view.updateFloatingTerminalPoints(state2, source2, target2);
            state2.view.updateEdgeLabelOffset(state2);
            state2.invalid = false;
            if (!this.cloning) {
              state2.view.graph.cellRenderer.redraw(state2, true);
            }
          }
        }
        this.graph.view.validate();
        this.redrawHandles(states);
        this.resetPreviewStates(states);
      }
    }
  }
  /**
   * Redraws the preview shape for the given states array.
   */
  redrawHandles(states) {
    const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
    for (let i2 = 0; i2 < states.length; i2 += 1) {
      const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(states[i2][0].cell);
      handler == null ? void 0 : handler.redraw(true);
    }
  }
  /**
   * Resets the given preview states array.
   */
  resetPreviewStates(states) {
    for (let i2 = 0; i2 < states.length; i2 += 1) {
      states[i2][0].setState(states[i2][1]);
    }
  }
  /**
   * Suspends the livew preview.
   */
  suspend() {
    if (!this.suspended) {
      if (this.livePreviewUsed) {
        this.updateLivePreview(0, 0);
      }
      if (this.shape) {
        this.shape.node.style.visibility = "hidden";
      }
      if (this.guide) {
        this.guide.setVisible(false);
      }
      this.suspended = true;
    }
  }
  /**
   * Suspends the livew preview.
   */
  resume() {
    if (this.suspended) {
      this.suspended = false;
      if (this.livePreviewUsed) {
        this.livePreviewActive = true;
      }
      if (this.shape) {
        this.shape.node.style.visibility = "visible";
      }
      if (this.guide) {
        this.guide.setVisible(true);
      }
    }
  }
  /**
   * Resets the livew preview.
   */
  resetLivePreview() {
    this.allCells.visit((key2, state2) => {
      if (state2.shape && state2.shape.originalPointerEvents !== null) {
        state2.shape.pointerEvents = state2.shape.originalPointerEvents;
        state2.shape.originalPointerEvents = null;
        state2.shape.bounds = null;
        if (state2.text && state2.text.originalPointerEvents !== null) {
          state2.text.pointerEvents = state2.text.originalPointerEvents;
          state2.text.originalPointerEvents = null;
        }
      }
      if (state2.control && state2.control.node && state2.control.node.style.visibility === "hidden") {
        state2.control.node.style.visibility = "";
      }
      if (!this.cloning) {
        if (state2.text) {
          state2.text.updateBoundingBox();
        }
      }
      state2.view.invalidate(state2.cell);
    });
    this.graph.view.validate();
  }
  /**
   * Sets wether the handles attached to the given cells are visible.
   *
   * @param cells Array of {@link Cells}.
   * @param visible Boolean that specifies if the handles should be visible.
   * @param force Forces an update of the handler regardless of the last used value.
   */
  setHandlesVisibleForCells(cells, visible, force = false) {
    if (force || this.handlesVisible !== visible) {
      this.handlesVisible = visible;
      const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const handler = selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandler(cells[i2]);
        if (handler) {
          handler.setHandlesVisible(visible);
          if (visible) {
            handler.redraw();
          }
        }
      }
    }
  }
  /**
   * Sets the color of the rectangle used to highlight drop targets.
   *
   * @param color String that represents the new highlight color.
   */
  setHighlightColor(color) {
    if (this.highlight) {
      this.highlight.setHighlightColor(color);
    }
  }
  /**
   * Handles the event by applying the changes to the selection cells.
   */
  mouseUp(sender, me) {
    if (!me.isConsumed()) {
      if (this.livePreviewUsed) {
        this.resetLivePreview();
      }
      if (this.cell && this.first && (this.shape || this.livePreviewUsed) && isNumeric(this.currentDx) && isNumeric(this.currentDy)) {
        const { graph } = this;
        const cell2 = me.getCell();
        if (this.connectOnDrop && !this.target && cell2 && cell2.isVertex() && cell2.isConnectable() && graph.isEdgeValid(null, this.cell, cell2)) {
          const connectionHandler = graph.getPlugin("ConnectionHandler");
          connectionHandler == null ? void 0 : connectionHandler.connect(this.cell, cell2, me.getEvent());
        } else {
          const clone2 = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();
          const { scale } = graph.getView();
          const dx = this.roundLength(this.currentDx / scale);
          const dy = this.roundLength(this.currentDy / scale);
          const target2 = this.target;
          if (target2 && graph.isSplitEnabled() && this.cells && graph.isSplitTarget(target2, this.cells, me.getEvent())) {
            graph.splitEdge(target2, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());
          } else if (this.cells) {
            this.moveCells(this.cells, dx, dy, clone2, this.target, me.getEvent());
          }
        }
      } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {
        this.selectDelayed(me);
      }
    }
    if (this.cellWasClicked) {
      this.consumeMouseEvent(InternalEvent_default.MOUSE_UP, me);
    }
    this.reset();
  }
  /**
   * Resets the state of this handler.
   */
  reset() {
    if (this.livePreviewUsed) {
      this.resetLivePreview();
      const selectionCellsHandler = this.graph.getPlugin("SelectionCellsHandler");
      this.setHandlesVisibleForCells((selectionCellsHandler == null ? void 0 : selectionCellsHandler.getHandledSelectionCells()) ?? [], true);
    }
    this.destroyShapes();
    this.removeHint();
    this.delayedSelection = false;
    this.livePreviewActive = false;
    this.livePreviewUsed = false;
    this.cellWasClicked = false;
    this.suspended = false;
    this.currentDx = 0;
    this.currentDy = 0;
    this.cellCount = 0;
    this.cloning = false;
    this.allCells.clear();
    this.pBounds = null;
    this.target = null;
    this.first = null;
    this.cells = null;
    this.cell = null;
  }
  /**
   * Returns true if the given cells should be removed from the parent for the specified
   * mousereleased event.
   */
  shouldRemoveCellsFromParent(parent2, cells, evt2) {
    if (parent2.isVertex()) {
      const pState = this.graph.getView().getState(parent2);
      if (pState) {
        let pt = convertPoint(this.graph.container, getClientX(evt2), getClientY(evt2));
        const alpha = toRadians(pState.style.rotation ?? 0);
        if (alpha !== 0) {
          const cos = Math.cos(-alpha);
          const sin = Math.sin(-alpha);
          const cx = new Point_default(pState.getCenterX(), pState.getCenterY());
          pt = getRotatedPoint(pt, cos, sin, cx);
        }
        return !contains(pState, pt.x, pt.y);
      }
    }
    return false;
  }
  /**
   * Moves the given cells by the specified amount.
   */
  moveCells(cells, dx, dy, clone2, target2, evt2) {
    if (!this.cell)
      return;
    if (clone2) {
      cells = this.graph.getCloneableCells(cells);
    }
    const parent2 = this.cell.getParent();
    if (!target2 && parent2 && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(parent2, cells, evt2)) {
      target2 = this.graph.getDefaultParent();
    }
    clone2 = !!clone2 && !this.graph.isCellLocked(target2 || this.graph.getDefaultParent());
    this.graph.batchUpdate(() => {
      const parents = [];
      if (!clone2 && target2 && this.removeEmptyParents) {
        const dict = new Dictionary_default();
        for (let i2 = 0; i2 < cells.length; i2 += 1) {
          dict.put(cells[i2], true);
        }
        for (let i2 = 0; i2 < cells.length; i2 += 1) {
          const par = cells[i2].getParent();
          if (par && !dict.get(par)) {
            dict.put(par, true);
            parents.push(par);
          }
        }
      }
      cells = this.graph.moveCells(cells, dx, dy, clone2, target2, evt2);
      const temp = [];
      for (let i2 = 0; i2 < parents.length; i2 += 1) {
        if (this.shouldRemoveParent(parents[i2])) {
          temp.push(parents[i2]);
        }
      }
      this.graph.removeCells(temp, false);
    });
    if (clone2) {
      this.graph.setSelectionCells(cells);
    }
    if (this.isSelectEnabled() && this.scrollOnMove) {
      this.graph.scrollCellToVisible(cells[0]);
    }
  }
  /**
   * Returns true if the given parent should be removed after removal of child cells.
   */
  shouldRemoveParent(parent2) {
    const state2 = this.graph.view.getState(parent2);
    return state2 != null && (state2.cell.isEdge() || state2.cell.isVertex()) && this.graph.isCellDeletable(state2.cell) && state2.cell.getChildCount() === 0 && state2.isTransparentState();
  }
  /**
   * Destroy the preview and highlight shapes.
   */
  destroyShapes() {
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
    if (this.guide) {
      this.guide.destroy();
      this.guide = null;
    }
    if (this.highlight) {
      this.highlight.destroy();
      this.highlight = null;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.panHandler);
    this.graph.removeListener(this.escapeHandler);
    this.graph.getDataModel().removeListener(this.refreshHandler);
    this.graph.removeListener(this.refreshHandler);
    InternalEvent_default.removeListener(document, "keydown", this.keyHandler);
    InternalEvent_default.removeListener(document, "keyup", this.keyHandler);
    this.destroyShapes();
    this.removeHint();
  }
};
SelectionHandler.pluginId = "SelectionHandler";
var SelectionHandler_default = SelectionHandler;

// node_modules/@maxgraph/core/lib/view/other/PanningManager.js
var PanningManager = class {
  constructor(graph) {
    this.damper = 1 / 6;
    this.delay = 10;
    this.handleMouseOut = true;
    this.border = 0;
    this.thread = null;
    this.active = false;
    this.tdx = 0;
    this.tdy = 0;
    this.t0x = 0;
    this.t0y = 0;
    this.dx = 0;
    this.dy = 0;
    this.scrollbars = false;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.thread = null;
    this.active = false;
    this.tdx = 0;
    this.tdy = 0;
    this.t0x = 0;
    this.t0y = 0;
    this.dx = 0;
    this.dy = 0;
    this.scrollbars = false;
    this.scrollLeft = 0;
    this.scrollTop = 0;
    this.mouseListener = {
      mouseDown: (sender, me) => {
        return;
      },
      mouseMove: (sender, me) => {
        return;
      },
      mouseUp: (sender, me) => {
        if (this.active) {
          this.stop();
        }
      }
    };
    graph.addMouseListener(this.mouseListener);
    this.mouseUpListener = () => {
      if (this.active) {
        this.stop();
      }
    };
    InternalEvent_default.addListener(document, "mouseup", this.mouseUpListener);
    const createThread = () => {
      this.scrollbars = hasScrollbars(graph.container);
      this.scrollLeft = graph.container.scrollLeft;
      this.scrollTop = graph.container.scrollTop;
      return window.setInterval(() => {
        this.tdx -= this.dx;
        this.tdy -= this.dy;
        if (this.scrollbars) {
          const left = -graph.container.scrollLeft - Math.ceil(this.dx);
          const top = -graph.container.scrollTop - Math.ceil(this.dy);
          graph.panGraph(left, top);
          graph.setPanDx(this.scrollLeft - graph.container.scrollLeft);
          graph.setPanDy(this.scrollTop - graph.container.scrollTop);
          graph.fireEvent(new EventObject_default(InternalEvent_default.PAN));
        } else {
          graph.panGraph(this.getDx(), this.getDy());
        }
      }, this.delay);
    };
    this.isActive = () => {
      return this.active;
    };
    this.getDx = () => {
      return Math.round(this.tdx);
    };
    this.getDy = () => {
      return Math.round(this.tdy);
    };
    this.start = () => {
      this.t0x = graph.view.translate.x;
      this.t0y = graph.view.translate.y;
      this.active = true;
    };
    this.panTo = (x, y, w = 0, h = 0) => {
      if (!this.active) {
        this.start();
      }
      this.scrollLeft = graph.container.scrollLeft;
      this.scrollTop = graph.container.scrollTop;
      const c = graph.container;
      this.dx = x + w - c.scrollLeft - c.clientWidth;
      if (this.dx < 0 && Math.abs(this.dx) < this.border) {
        this.dx = this.border + this.dx;
      } else if (this.handleMouseOut) {
        this.dx = Math.max(this.dx, 0);
      } else {
        this.dx = 0;
      }
      if (this.dx == 0) {
        this.dx = x - c.scrollLeft;
        if (this.dx > 0 && this.dx < this.border) {
          this.dx -= this.border;
        } else if (this.handleMouseOut) {
          this.dx = Math.min(0, this.dx);
        } else {
          this.dx = 0;
        }
      }
      this.dy = y + h - c.scrollTop - c.clientHeight;
      if (this.dy < 0 && Math.abs(this.dy) < this.border) {
        this.dy = this.border + this.dy;
      } else if (this.handleMouseOut) {
        this.dy = Math.max(this.dy, 0);
      } else {
        this.dy = 0;
      }
      if (this.dy == 0) {
        this.dy = y - c.scrollTop;
        if (this.dy > 0 && this.dy < this.border) {
          this.dy -= this.border;
        } else if (this.handleMouseOut) {
          this.dy = Math.min(0, this.dy);
        } else {
          this.dy = 0;
        }
      }
      if (this.dx != 0 || this.dy != 0) {
        this.dx *= this.damper;
        this.dy *= this.damper;
        if (this.thread == null) {
          this.thread = createThread();
        }
      } else if (this.thread != null) {
        window.clearInterval(this.thread);
        this.thread = null;
      }
    };
    this.stop = () => {
      if (this.active) {
        this.active = false;
        if (this.thread != null) {
          window.clearInterval(this.thread);
          this.thread = null;
        }
        this.tdx = 0;
        this.tdy = 0;
        if (!this.scrollbars) {
          const px = graph.getPanDx();
          const py = graph.getPanDy();
          if (px != 0 || py != 0) {
            graph.panGraph(0, 0);
            graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);
          }
        } else {
          graph.setPanDx(0);
          graph.setPanDy(0);
          graph.fireEvent(new EventObject_default(InternalEvent_default.PAN));
        }
      }
    };
    this.destroy = () => {
      graph.removeMouseListener(this.mouseListener);
      InternalEvent_default.removeListener(document, "mouseup", this.mouseUpListener);
    };
  }
};
var PanningManager_default = PanningManager;

// node_modules/@maxgraph/core/lib/view/handler/PanningHandler.js
var PanningHandler = class extends EventSource_default {
  constructor(graph) {
    super();
    this.getPanningManager = () => this.panningManager;
    this.useLeftButtonForPanning = false;
    this.usePopupTrigger = true;
    this.ignoreCell = false;
    this.previewEnabled = true;
    this.useGrid = false;
    this.panningEnabled = false;
    this.pinchEnabled = true;
    this.initialScale = 0;
    this.maxScale = 8;
    this.minScale = 0.01;
    this.dx = 0;
    this.dy = 0;
    this.startX = 0;
    this.startY = 0;
    this.dx0 = 0;
    this.dy0 = 0;
    this.panningTrigger = false;
    this.active = false;
    this.mouseDownEvent = null;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forcePanningHandler = (sender, eo) => {
      const evtName = eo.getProperty("eventName");
      const me = eo.getProperty("event");
      if (evtName === InternalEvent_default.MOUSE_DOWN && this.isForcePanningEvent(me)) {
        this.start(me);
        this.active = true;
        this.fireEvent(new EventObject_default(InternalEvent_default.PAN_START, { event: me }));
        me.consume();
      }
    };
    this.graph.addListener(InternalEvent_default.FIRE_MOUSE_EVENT, this.forcePanningHandler);
    this.gestureHandler = (sender, eo) => {
      if (this.isPinchEnabled()) {
        const evt2 = eo.getProperty("event");
        if (!isConsumed(evt2) && evt2.type === "gesturestart") {
          this.initialScale = this.graph.view.scale;
          if (!this.active && this.mouseDownEvent) {
            this.start(this.mouseDownEvent);
            this.mouseDownEvent = null;
          }
        } else if (evt2.type === "gestureend" && this.initialScale !== 0) {
          this.initialScale = 0;
        }
        if (this.initialScale !== 0) {
          this.zoomGraph(evt2);
        }
      }
    };
    this.graph.addListener(InternalEvent_default.GESTURE, this.gestureHandler);
    this.mouseUpListener = () => {
      if (this.active) {
        this.reset();
      }
    };
    InternalEvent_default.addListener(document, "mouseup", this.mouseUpListener);
    this.panningManager = new PanningManager_default(graph);
  }
  /**
   * Returns true if the handler is currently active.
   */
  isActive() {
    return this.active || this.initialScale !== null;
  }
  /**
   * Returns <panningEnabled>.
   */
  isPanningEnabled() {
    return this.panningEnabled;
  }
  /**
   * Sets <panningEnabled>.
   */
  setPanningEnabled(value2) {
    this.panningEnabled = value2;
  }
  /**
   * Returns <pinchEnabled>.
   */
  isPinchEnabled() {
    return this.pinchEnabled;
  }
  /**
   * Sets <pinchEnabled>.
   */
  setPinchEnabled(value2) {
    this.pinchEnabled = value2;
  }
  /**
   * Returns true if the given event is a panning trigger for the optional
   * given cell. This returns true if control-shift is pressed or if
   * <usePopupTrigger> is true and the event is a popup trigger.
   */
  isPanningTrigger(me) {
    const evt2 = me.getEvent();
    return this.useLeftButtonForPanning && !me.getState() && isLeftMouseButton(evt2) || isControlDown(evt2) && isShiftDown(evt2) || this.usePopupTrigger && isPopupTrigger(evt2);
  }
  /**
   * Returns true if the given {@link MouseEvent} should start panning. This
   * implementation always returns true if <ignoreCell> is true or for
   * multi touch events.
   */
  isForcePanningEvent(me) {
    return this.ignoreCell || isMultiTouchEvent(me.getEvent());
  }
  /**
   * Handles the event by initiating the panning. By consuming the event all
   * subsequent events of the gesture are redirected to this handler.
   */
  mouseDown(sender, me) {
    this.mouseDownEvent = me;
    if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {
      this.start(me);
      this.consumePanningTrigger(me);
    }
  }
  /**
   * Starts panning at the given event.
   */
  start(me) {
    this.dx0 = -this.graph.container.scrollLeft;
    this.dy0 = -this.graph.container.scrollTop;
    this.startX = me.getX();
    this.startY = me.getY();
    this.dx = 0;
    this.dy = 0;
    this.panningTrigger = true;
  }
  /**
   * Consumes the given {@link MouseEvent} if it was a panning trigger in
   * {@link ouseDown}. The default is to invoke {@link MouseEvent#consume}. Note that this
   * will block any further event processing. If you haven't disabled built-in
   * context menus and require immediate selection of the cell on mouseDown in
   * Safari and/or on the Mac, then use the following code:
   *
   * ```javascript
   * consumePanningTrigger(me)
   * {
   *   if (me.evt.preventDefault)
   *   {
   *     me.evt.preventDefault();
   *   }
   *
   *   // Stops event processing in IE
   *   me.evt.returnValue = false;
   *
   *   // Sets local consumed state
   *   if (!Client.IS_SF && !Client.IS_MAC)
   *   {
   *     me.consumed = true;
   *   }
   * };
   * ```
   */
  consumePanningTrigger(me) {
    me.consume();
  }
  /**
   * Handles the event by updating the panning on the graph.
   */
  mouseMove(sender, me) {
    this.dx = me.getX() - this.startX;
    this.dy = me.getY() - this.startY;
    if (this.active) {
      if (this.previewEnabled) {
        if (this.useGrid) {
          this.dx = this.graph.snap(this.dx);
          this.dy = this.graph.snap(this.dy);
        }
        this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.PAN, { event: me }));
    } else if (this.panningTrigger) {
      const tmp2 = this.active;
      this.active = Math.abs(this.dx) > this.graph.getSnapTolerance() || Math.abs(this.dy) > this.graph.getSnapTolerance();
      if (!tmp2 && this.active) {
        this.fireEvent(new EventObject_default(InternalEvent_default.PAN_START, { event: me }));
      }
    }
    if (this.active || this.panningTrigger) {
      me.consume();
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  mouseUp(sender, me) {
    if (this.active) {
      if (this.dx !== 0 && this.dy !== 0) {
        if (!this.graph.isUseScrollbarsForPanning() || !hasScrollbars(this.graph.container)) {
          const { scale } = this.graph.getView();
          const t = this.graph.getView().translate;
          this.graph.panGraph(0, 0);
          this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);
        }
        me.consume();
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.PAN_END, { event: me }));
    }
    this.reset();
  }
  /**
   * Zooms the graph to the given value and consumed the event if needed.
   */
  zoomGraph(evt2) {
    let value2 = Math.round(this.initialScale * evt2.scale * 100) / 100;
    value2 = Math.max(this.minScale, value2);
    value2 = Math.min(this.maxScale, value2);
    if (this.graph.view.scale !== value2) {
      this.graph.zoomTo(value2);
      InternalEvent_default.consume(evt2);
    }
  }
  /**
   * Handles the event by setting the translation on the view or showing the
   * popupmenu.
   */
  reset() {
    this.panningTrigger = false;
    this.mouseDownEvent = null;
    this.active = false;
    this.dx = 0;
    this.dy = 0;
  }
  /**
   * Pans <graph> by the given amount.
   */
  panGraph(dx, dy) {
    this.graph.getView().setTranslate(dx, dy);
  }
  /**
   * Destroys the handler and all its resources and DOM nodes.
   */
  onDestroy() {
    this.graph.removeMouseListener(this);
    this.graph.removeListener(this.forcePanningHandler);
    this.graph.removeListener(this.gestureHandler);
    InternalEvent_default.removeListener(document, "mouseup", this.mouseUpListener);
  }
};
PanningHandler.pluginId = "PanningHandler";
var PanningHandler_default = PanningHandler;

// node_modules/@maxgraph/core/lib/view/plugins/index.js
var getDefaultPlugins = () => [
  CellEditorHandler_default,
  TooltipHandler_default,
  SelectionCellsHandler_default,
  PopupMenuHandler_default,
  ConnectionHandler_default,
  SelectionHandler_default,
  PanningHandler_default
];

// node_modules/@maxgraph/core/lib/view/Graph.js
var Graph = class extends EventSource_default {
  // ===================================================================================================================
  // Group: "Create Class Instance" factory functions.
  // These can be overridden in subclasses of Graph to allow the Graph to instantiate user-defined implementations with
  // custom behavior.
  // ===================================================================================================================
  /**
   * Creates a new {@link CellRenderer} to be used in this graph.
   */
  createCellRenderer() {
    return new CellRenderer_default();
  }
  /**
   * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createEdgeHandlerInstance(state2) {
    return new EdgeHandler_default(state2);
  }
  /**
   * Hooks to create a new {@link EdgeSegmentHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createEdgeSegmentHandler(state2) {
    return new EdgeSegmentHandler_default(state2);
  }
  /**
   * Hooks to create a new {@link ElbowEdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createElbowEdgeHandler(state2) {
    return new ElbowEdgeHandler_default(state2);
  }
  /**
   * Creates a new {@link GraphDataModel} to be used in this graph.
   */
  createGraphDataModel() {
    return new GraphDataModel_default();
  }
  /**
   * Creates a new {@link GraphView} to be used in this graph.
   */
  createGraphView() {
    return new GraphView_default(this);
  }
  /**
   * Creates a new {@link GraphSelectionModel} to be used in this graph.
   */
  createSelectionModel() {
    return new GraphSelectionModel_default(this);
  }
  /**
   * Creates a new {@link Stylesheet} to be used in this graph.
   */
  createStylesheet() {
    return new Stylesheet();
  }
  /**
   * Hooks to create a new {@link VertexHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   */
  createVertexHandler(state2) {
    return new VertexHandler_default(state2);
  }
  // ===================================================================================================================
  // Group: Main graph constructor and functions
  // ===================================================================================================================
  registerDefaults() {
    registerDefaultShapes();
    registerDefaultStyleElements();
    registerDefaultEdgeMarkers();
  }
  constructor(container, model2, plugins = getDefaultPlugins(), stylesheet = null) {
    super();
    this.destroyed = false;
    this.graphModelChangeListener = null;
    this.paintBackground = null;
    this.isConstrainedMoving = false;
    this.cells = [];
    this.imageBundles = [];
    this.mouseListeners = [];
    this.multiplicities = [];
    this.plugins = {};
    this.renderHint = null;
    this.dialect = "svg";
    this.defaultOverlap = 0.5;
    this.defaultParent = null;
    this.backgroundImage = null;
    this.pageVisible = false;
    this.pageBreaksVisible = false;
    this.pageBreakColor = "gray";
    this.pageBreakDashed = true;
    this.minPageBreakDist = 20;
    this.preferPageSize = false;
    this.pageFormat = new Rectangle_default(...PAGE_FORMAT_A4_PORTRAIT);
    this.pageScale = 1.5;
    this.enabled = true;
    this.exportEnabled = true;
    this.importEnabled = true;
    this.ignoreScrollbars = false;
    this.translateToScrollPosition = false;
    this.maximumGraphBounds = null;
    this.minimumGraphSize = null;
    this.minimumContainerSize = null;
    this.maximumContainerSize = null;
    this.resizeContainer = false;
    this.border = 0;
    this.keepEdgesInForeground = false;
    this.keepEdgesInBackground = false;
    this.recursiveResize = false;
    this.resetViewOnRootChange = true;
    this.allowLoops = false;
    this.defaultLoopStyle = EdgeStyle_default.Loop;
    this.multigraph = true;
    this.minFitScale = 0.1;
    this.maxFitScale = 8;
    this.warningImage = new ImageBox_default(`${Client_default.imageBasePath}/warning${Client_default.IS_MAC ? ".png" : ".gif"}`, 16, 16);
    this.alreadyConnectedResource = Client_default.language != "none" ? "alreadyConnected" : "";
    this.containsValidationErrorsResource = Client_default.language != "none" ? "containsValidationErrors" : "";
    this.getContainer = () => this.container;
    this.getPlugin = (id2) => this.plugins[id2];
    this.getCellRenderer = () => this.cellRenderer;
    this.getDialect = () => this.dialect;
    this.isPageVisible = () => this.pageVisible;
    this.isPageBreaksVisible = () => this.pageBreaksVisible;
    this.getPageBreakColor = () => this.pageBreakColor;
    this.isPageBreakDashed = () => this.pageBreakDashed;
    this.getMinPageBreakDist = () => this.minPageBreakDist;
    this.isPreferPageSize = () => this.preferPageSize;
    this.getPageFormat = () => this.pageFormat;
    this.getPageScale = () => this.pageScale;
    this.isExportEnabled = () => this.exportEnabled;
    this.isImportEnabled = () => this.importEnabled;
    this.isIgnoreScrollbars = () => this.ignoreScrollbars;
    this.isTranslateToScrollPosition = () => this.translateToScrollPosition;
    this.getMinimumGraphSize = () => this.minimumGraphSize;
    this.setMinimumGraphSize = (size) => this.minimumGraphSize = size;
    this.getMinimumContainerSize = () => this.minimumContainerSize;
    this.setMinimumContainerSize = (size) => this.minimumContainerSize = size;
    this.getAlreadyConnectedResource = () => this.alreadyConnectedResource;
    this.getContainsValidationErrorsResource = () => this.containsValidationErrorsResource;
    this.registerDefaults();
    this.container = container ?? document.createElement("div");
    this.model = model2 ?? this.createGraphDataModel();
    this.cellRenderer = this.createCellRenderer();
    this.setStylesheet(stylesheet ?? this.createStylesheet());
    this.view = this.createGraphView();
    this.graphModelChangeListener = (sender, evt2) => {
      this.graphModelChanged(evt2.getProperty("edit").changes);
    };
    this.getDataModel().addListener(InternalEvent_default.CHANGE, this.graphModelChangeListener);
    this.view.init();
    this.sizeDidChange();
    this.setSelectionModel(this.createSelectionModel());
    plugins.forEach((p) => this.plugins[p.pluginId] = new p(this));
    this.view.revalidate();
  }
  getWarningImage() {
    return this.warningImage;
  }
  /**
   * Updates the model in a transaction.
   *
   * @param fn the update to be performed in the transaction.
   *
   * @see {@link GraphDataModel.batchUpdate}
   */
  batchUpdate(fn) {
    this.getDataModel().batchUpdate(fn);
  }
  /**
   * Returns the {@link GraphDataModel} that contains the cells.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Returns the {@link GraphView} that contains the {@link mxCellStates}.
   */
  getView() {
    return this.view;
  }
  /**
   * Returns the {@link Stylesheet} that defines the style.
   */
  getStylesheet() {
    return this.stylesheet;
  }
  /**
   * Sets the {@link Stylesheet} that defines the style.
   */
  setStylesheet(stylesheet) {
    this.stylesheet = stylesheet;
  }
  /**
   * Called when the graph model changes. Invokes {@link processChange} on each
   * item of the given array to update the view accordingly.
   *
   * @param changes Array that contains the individual changes.
   */
  graphModelChanged(changes) {
    for (const change of changes) {
      this.processChange(change);
    }
    this.updateSelection();
    this.view.validate();
    this.sizeDidChange();
  }
  /**
   * Processes the given change and invalidates the respective cached data
   * in {@link GraphView}. This fires a {@link root} event if the root has changed in the
   * model.
   *
   * @param {(RootChange|ChildChange|TerminalChange|GeometryChange|ValueChange|StyleChange)} change - Object that represents the change on the model.
   */
  processChange(change) {
    if (change instanceof RootChange_default) {
      this.clearSelection();
      this.setDefaultParent(null);
      if (change.previous)
        this.removeStateForCell(change.previous);
      if (this.resetViewOnRootChange) {
        this.view.scale = 1;
        this.view.translate.x = 0;
        this.view.translate.y = 0;
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.ROOT));
    } else if (change instanceof ChildChange_default) {
      const newParent = change.child.getParent();
      this.view.invalidate(change.child, true, true);
      if (!newParent || !this.getDataModel().contains(newParent) || newParent.isCollapsed()) {
        this.view.invalidate(change.child, true, true);
        this.removeStateForCell(change.child);
        if (this.view.currentRoot == change.child) {
          this.home();
        }
      }
      if (newParent != change.previous) {
        if (newParent != null) {
          this.view.invalidate(newParent, false, false);
        }
        if (change.previous != null) {
          this.view.invalidate(change.previous, false, false);
        }
      }
    } else if (change instanceof TerminalChange_default || change instanceof GeometryChange_default) {
      if (change instanceof TerminalChange_default || change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry)) {
        this.view.invalidate(change.cell);
      }
    } else if (change instanceof ValueChange_default) {
      this.view.invalidate(change.cell, false, false);
    } else if (change instanceof StyleChange_default) {
      this.view.invalidate(change.cell, true, true);
      const state2 = this.view.getState(change.cell);
      if (state2 != null) {
        state2.invalidStyle = true;
      }
    } else if (change.cell != null && change.cell instanceof Cell_default) {
      this.removeStateForCell(change.cell);
    }
  }
  /**
   * Scrolls the graph to the given point, extending the graph container if
   * specified.
   */
  scrollPointToVisible(x, y, extend2 = false, border = 20) {
    const panningHandler = this.getPlugin("PanningHandler");
    if (!this.isTimerAutoScroll() && (this.ignoreScrollbars || hasScrollbars(this.container))) {
      const c = this.container;
      if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {
        let dx = c.scrollLeft + c.clientWidth - x;
        if (dx < border) {
          const old = c.scrollLeft;
          c.scrollLeft += border - dx;
          if (extend2 && old === c.scrollLeft) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const width = c.scrollWidth + border - dx;
            root.style.width = `${width}px`;
            c.scrollLeft += border - dx;
          }
        } else {
          dx = x - c.scrollLeft;
          if (dx < border) {
            c.scrollLeft -= border - dx;
          }
        }
        let dy = c.scrollTop + c.clientHeight - y;
        if (dy < border) {
          const old = c.scrollTop;
          c.scrollTop += border - dy;
          if (old == c.scrollTop && extend2) {
            const root = this.view.getDrawPane().ownerSVGElement;
            const height = c.scrollHeight + border - dy;
            root.style.height = `${height}px`;
            c.scrollTop += border - dy;
          }
        } else {
          dy = y - c.scrollTop;
          if (dy < border) {
            c.scrollTop -= border - dy;
          }
        }
      }
    } else if (this.isAllowAutoPanning() && panningHandler && !panningHandler.isActive()) {
      panningHandler.getPanningManager().panTo(x + this.getPanDx(), y + this.getPanDy());
    }
  }
  /**
   * Returns the size of the border and padding on all four sides of the
   * container. The left, top, right and bottom borders are stored in the x, y,
   * width and height of the returned {@link Rectangle}, respectively.
   */
  getBorderSizes() {
    const css = getCurrentStyle(this.container);
    return new Rectangle_default(parseCssNumber(css.paddingLeft) + (css.borderLeftStyle != "none" ? parseCssNumber(css.borderLeftWidth) : 0), parseCssNumber(css.paddingTop) + (css.borderTopStyle != "none" ? parseCssNumber(css.borderTopWidth) : 0), parseCssNumber(css.paddingRight) + (css.borderRightStyle != "none" ? parseCssNumber(css.borderRightWidth) : 0), parseCssNumber(css.paddingBottom) + (css.borderBottomStyle != "none" ? parseCssNumber(css.borderBottomWidth) : 0));
  }
  /**
   * Returns the preferred size of the background page if {@link preferPageSize} is true.
   */
  getPreferredPageSize(bounds, width, height) {
    const tr = this.view.translate;
    const fmt = this.pageFormat;
    const ps = this.pageScale;
    const page = new Rectangle_default(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));
    const hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;
    const vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;
    return new Rectangle_default(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);
  }
  /**
   * Scales the graph such that the complete diagram fits into <container> and
   * returns the current scale in the view. To fit an initial graph prior to
   * rendering, set {@link GraphView#rendering} to false prior to changing the model
   * and execute the following after changing the model.
   *
   * ```javascript
   * graph.fit();
   * graph.view.rendering = true;
   * graph.refresh();
   * ```
   *
   * To fit and center the graph, the following code can be used.
   *
   * ```javascript
   * let margin = 2;
   * let max = 3;
   *
   * let bounds = graph.getGraphBounds();
   * let cw = graph.container.clientWidth - margin;
   * let ch = graph.container.clientHeight - margin;
   * let w = bounds.width / graph.view.scale;
   * let h = bounds.height / graph.view.scale;
   * let s = Math.min(max, Math.min(cw / w, ch / h));
   *
   * graph.view.scaleAndTranslate(s,
   *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,
   *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);
   * ```
   *
   * @param border Optional number that specifies the border. Default is <border>.
   * @param keepOrigin Optional boolean that specifies if the translate should be
   * changed. Default is false.
   * @param margin Optional margin in pixels. Default is 0.
   * @param enabled Optional boolean that specifies if the scale should be set or
   * just returned. Default is true.
   * @param ignoreWidth Optional boolean that specifies if the width should be
   * ignored. Default is false.
   * @param ignoreHeight Optional boolean that specifies if the height should be
   * ignored. Default is false.
   * @param maxHeight Optional maximum height.
   */
  fit(border = this.getBorder(), keepOrigin = false, margin = 0, enabled2 = true, ignoreWidth = false, ignoreHeight = false, maxHeight = null) {
    if (this.container != null) {
      const cssBorder = this.getBorderSizes();
      let w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;
      let h1 = maxHeight != null ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;
      let bounds = this.view.getGraphBounds();
      if (bounds.width > 0 && bounds.height > 0) {
        if (keepOrigin && bounds.x != null && bounds.y != null) {
          bounds = bounds.clone();
          bounds.width += bounds.x;
          bounds.height += bounds.y;
          bounds.x = 0;
          bounds.y = 0;
        }
        const s = this.view.scale;
        let w2 = bounds.width / s;
        let h2 = bounds.height / s;
        if (this.backgroundImage != null) {
          w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);
          h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);
        }
        const b = (keepOrigin ? border : 2 * border) + margin + 1;
        w1 -= b;
        h1 -= b;
        let s2 = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);
        if (this.minFitScale != null) {
          s2 = Math.max(s2, this.minFitScale);
        }
        if (this.maxFitScale != null) {
          s2 = Math.min(s2, this.maxFitScale);
        }
        if (enabled2) {
          if (!keepOrigin) {
            if (!hasScrollbars(this.container)) {
              const x0 = bounds.x != null ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;
              const y0 = bounds.y != null ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;
              this.view.scaleAndTranslate(s2, x0, y0);
            } else {
              this.view.setScale(s2);
              const b2 = this.getGraphBounds();
              if (b2.x != null) {
                this.container.scrollLeft = b2.x;
              }
              if (b2.y != null) {
                this.container.scrollTop = b2.y;
              }
            }
          } else if (this.view.scale != s2) {
            this.view.setScale(s2);
          }
        } else {
          return s2;
        }
      }
    }
    return this.view.scale;
  }
  /**
   * Resizes the container for the given graph width and height.
   */
  doResizeContainer(width, height) {
    if (this.maximumContainerSize != null) {
      width = Math.min(this.maximumContainerSize.width, width);
      height = Math.min(this.maximumContainerSize.height, height);
    }
    const container = this.container;
    container.style.width = `${Math.ceil(width)}px`;
    container.style.height = `${Math.ceil(height)}px`;
  }
  /*****************************************************************************
   * Group: UNCLASSIFIED
   *****************************************************************************/
  /**
   * Creates a new handler for the given cell state. This implementation
   * returns a new {@link EdgeHandler} of the corresponding cell is an edge,
   * otherwise it returns an {@link VertexHandler}.
   *
   * @param state {@link CellState} whose handler should be created.
   */
  createHandler(state2) {
    let result2 = null;
    if (state2.cell.isEdge()) {
      const source2 = state2.getVisibleTerminalState(true);
      const target2 = state2.getVisibleTerminalState(false);
      const geo = state2.cell.getGeometry();
      const edgeStyle2 = this.getView().getEdgeStyle(state2, geo ? geo.points || void 0 : void 0, source2, target2);
      result2 = this.createEdgeHandler(state2, edgeStyle2);
    } else {
      result2 = this.createVertexHandler(state2);
    }
    return result2;
  }
  /**
   * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.
   *
   * @param state {@link CellState} to create the handler for.
   * @param edgeStyle the {@link EdgeStyleFunction} that let choose the actual edge handler.
   */
  createEdgeHandler(state2, edgeStyle2) {
    let result2 = null;
    if (edgeStyle2 == EdgeStyle_default.Loop || edgeStyle2 == EdgeStyle_default.ElbowConnector || edgeStyle2 == EdgeStyle_default.SideToSide || edgeStyle2 == EdgeStyle_default.TopToBottom) {
      result2 = this.createElbowEdgeHandler(state2);
    } else if (edgeStyle2 == EdgeStyle_default.SegmentConnector || edgeStyle2 == EdgeStyle_default.OrthConnector) {
      result2 = this.createEdgeSegmentHandler(state2);
    } else {
      result2 = this.createEdgeHandlerInstance(state2);
    }
    return result2;
  }
  /*****************************************************************************
   * Group: Drilldown
   *****************************************************************************/
  /**
   * Returns the current root of the displayed cell hierarchy. This is a
   * shortcut to {@link GraphView.currentRoot} in {@link GraphView}.
   */
  getCurrentRoot() {
    return this.view.currentRoot;
  }
  /**
   * Returns the translation to be used if the given cell is the root cell as
   * an {@link Point}. This implementation returns null.
   *
   * To keep the children at their absolute position while stepping into groups,
   * this function can be overridden as follows.
   *
   * @example
   * ```javascript
   * var offset = new mxPoint(0, 0);
   *
   * while (cell != null)
   * {
   *   var geo = this.model.getGeometry(cell);
   *
   *   if (geo != null)
   *   {
   *     offset.x -= geo.x;
   *     offset.y -= geo.y;
   *   }
   *
   *   cell = this.model.getParent(cell);
   * }
   *
   * return offset;
   * ```
   *
   * @param cell {@link mxCell} that represents the root.
   */
  getTranslateForRoot(cell2) {
    return null;
  }
  /**
   * Returns the offset to be used for the cells inside the given cell. The
   * root and layer cells may be identified using {@link GraphDataModel.isRoot} and
   * {@link GraphDataModel.isLayer}. For all other current roots, the
   * {@link GraphView.currentRoot} field points to the respective cell, so that
   * the following holds: cell == this.view.currentRoot. This implementation
   * returns null.
   *
   * @param cell {@link mxCell} whose offset should be returned.
   */
  getChildOffsetForCell(cell2) {
    return null;
  }
  /**
   * Uses the root of the model as the root of the displayed cell hierarchy
   * and selects the previous root.
   */
  home() {
    const current = this.getCurrentRoot();
    if (current != null) {
      this.view.setCurrentRoot(null);
      const state2 = this.view.getState(current);
      if (state2 != null) {
        this.setSelectionCell(current);
      }
    }
  }
  /**
   * Returns true if the given cell is a valid root for the cell display
   * hierarchy. This implementation returns true for all non-null values.
   *
   * @param cell {@link mxCell} which should be checked as a possible root.
   */
  isValidRoot(cell2) {
    return !!cell2;
  }
  /*****************************************************************************
   * Group: Graph display
   *****************************************************************************/
  /**
   * Returns the bounds of the visible graph. Shortcut to
   * {@link GraphView.getGraphBounds}. See also: {@link getBoundingBoxFromGeometry}.
   */
  getGraphBounds() {
    return this.view.getGraphBounds();
  }
  /**
   * Returns the bounds inside which the diagram should be kept as an
   * {@link Rectangle}.
   */
  getMaximumGraphBounds() {
    return this.maximumGraphBounds;
  }
  /**
   * Clears all cell states or the states for the hierarchy starting at the
   * given cell and validates the graph. This fires a refresh event as the
   * last step.
   *
   * @param cell Optional {@link Cell} for which the cell states should be cleared.
   */
  refresh(cell2 = null) {
    if (cell2) {
      this.view.clear(cell2, false);
    } else {
      this.view.clear(void 0, true);
    }
    this.view.validate();
    this.sizeDidChange();
    this.fireEvent(new EventObject_default(InternalEvent_default.REFRESH));
  }
  /**
   * Centers the graph in the container.
   *
   * @param horizontal Optional boolean that specifies if the graph should be centered
   * horizontally. Default is `true`.
   * @param vertical Optional boolean that specifies if the graph should be centered
   * vertically. Default is `true`.
   * @param cx Optional float that specifies the horizontal center. Default is `0.5`.
   * @param cy Optional float that specifies the vertical center. Default is `0.5`.
   */
  center(horizontal = true, vertical = true, cx = 0.5, cy = 0.5) {
    const container = this.container;
    const _hasScrollbars = hasScrollbars(this.container);
    const padding = 2 * this.getBorder();
    const cw = container.clientWidth - padding;
    const ch = container.clientHeight - padding;
    const bounds = this.getGraphBounds();
    const t = this.view.translate;
    const s = this.view.scale;
    let dx = horizontal ? cw - bounds.width : 0;
    let dy = vertical ? ch - bounds.height : 0;
    if (!_hasScrollbars) {
      this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x / s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y / s + dy * cy / s) : t.y);
    } else {
      bounds.x -= t.x;
      bounds.y -= t.y;
      const sw = container.scrollWidth;
      const sh = container.scrollHeight;
      if (sw > cw) {
        dx = 0;
      }
      if (sh > ch) {
        dy = 0;
      }
      this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));
      container.scrollLeft = (sw - cw) / 2;
      container.scrollTop = (sh - ch) / 2;
    }
  }
  /**
   * Returns true if perimeter points should be computed such that the
   * resulting edge has only horizontal or vertical segments.
   *
   * @param edge {@link CellState} that represents the edge.
   */
  isOrthogonal(edge2) {
    const orthogonal = edge2.style.orthogonal;
    if (orthogonal != null) {
      return orthogonal;
    }
    const tmp2 = this.view.getEdgeStyle(edge2);
    return tmp2 === EdgeStyle_default.SegmentConnector || tmp2 === EdgeStyle_default.ElbowConnector || tmp2 === EdgeStyle_default.SideToSide || tmp2 === EdgeStyle_default.TopToBottom || tmp2 === EdgeStyle_default.EntityRelation || tmp2 === EdgeStyle_default.OrthConnector;
  }
  /*****************************************************************************
   * Group: Graph appearance
   *****************************************************************************/
  /**
   * Returns the {@link backgroundImage} as an {@link Image}.
   */
  getBackgroundImage() {
    return this.backgroundImage;
  }
  /**
   * Sets the new {@link backgroundImage}.
   *
   * @param image New {@link Image} to be used for the background.
   */
  setBackgroundImage(image) {
    this.backgroundImage = image;
  }
  /**
   * Returns the textual representation for the given cell.
   *
   * This implementation returns the node name or string-representation of the user object.
   *
   *
   * The following returns the label attribute from the cells user object if it is an XML node.
   *
   * @example
   * ```javascript
   * graph.convertValueToString = function(cell)
   * {
   * 	return cell.getAttribute('label');
   * }
   * ```
   *
   * See also: {@link cellLabelChanged}.
   *
   * @param cell {@link Cell} whose textual representation should be returned.
   */
  convertValueToString(cell2) {
    const value2 = cell2.getValue();
    if (value2 != null) {
      if (isNode(value2)) {
        return value2.nodeName;
      }
      if (typeof value2.toString === "function") {
        return value2.toString();
      }
    }
    return "";
  }
  /**
   * Returns the string to be used as the link for the given cell.
   *
   * This implementation returns null.
   *
   * @param cell {@link Cell} whose link should be returned.
   */
  getLinkForCell(cell2) {
    return null;
  }
  /**
   * Returns the value of {@link border}.
   */
  getBorder() {
    return this.border;
  }
  /**
   * Sets the value of {@link border}.
   *
   * @param value Positive integer that represents the border to be used.
   */
  setBorder(value2) {
    this.border = value2;
  }
  /*****************************************************************************
   * Group: Graph behaviour
   *****************************************************************************/
  /**
   * Returns {@link resizeContainer}.
   */
  isResizeContainer() {
    return this.resizeContainer;
  }
  /**
   * Sets {@link resizeContainer}.
   *
   * @param value Boolean indicating if the container should be resized.
   */
  setResizeContainer(value2) {
    this.resizeContainer = value2;
  }
  /**
   * Returns true if the graph is {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Specifies if the graph should allow any interactions. This
   * implementation updates {@link enabled}.
   *
   * @param value Boolean indicating if the graph should be enabled.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns {@link multigraph} as a boolean.
   */
  isMultigraph() {
    return this.multigraph;
  }
  /**
   * Specifies if the graph should allow multiple connections between the
   * same pair of vertices.
   *
   * @param value Boolean indicating if the graph allows multiple connections
   * between the same pair of vertices.
   */
  setMultigraph(value2) {
    this.multigraph = value2;
  }
  /**
   * Returns {@link allowLoops} as a boolean.
   */
  isAllowLoops() {
    return this.allowLoops;
  }
  /**
   * Specifies if loops are allowed.
   *
   * @param value Boolean indicating if loops are allowed.
   */
  setAllowLoops(value2) {
    this.allowLoops = value2;
  }
  /**
   * Returns {@link recursiveResize}.
   *
   * @param state {@link CellState} that is being resized.
   */
  isRecursiveResize(state2 = null) {
    return this.recursiveResize;
  }
  /**
   * Sets {@link recursiveResize}.
   *
   * @param value New boolean value for {@link recursiveResize}.
   */
  setRecursiveResize(value2) {
    this.recursiveResize = value2;
  }
  /**
   * Returns a decimal number representing the amount of the width and height
   * of the given cell that is allowed to overlap its parent. A value of 0
   * means all children must stay inside the parent, 1 means the child is
   * allowed to be placed outside of the parent such that it touches one of
   * the parents sides. If {@link isAllowOverlapParent} returns false for the given
   * cell, then this method returns 0.
   *
   * @param cell {@link mxCell} for which the overlap ratio should be returned.
   */
  getOverlap(cell2) {
    return this.isAllowOverlapParent(cell2) ? this.defaultOverlap : 0;
  }
  /**
   * Returns true if the given cell is allowed to be placed outside of the
   * parents area.
   *
   * @param cell {@link mxCell} that represents the child to be checked.
   */
  isAllowOverlapParent(cell2) {
    return false;
  }
  /*****************************************************************************
   * Group: Cell retrieval
   *****************************************************************************/
  /**
   * Returns {@link defaultParent} or {@link GraphView.currentRoot} or the first child
   * child of {@link GraphDataModel.root} if both are null. The value returned by
   * this function should be used as the parent for new cells (aka default
   * layer).
   */
  getDefaultParent() {
    let parent2 = this.getCurrentRoot();
    if (!parent2) {
      parent2 = this.defaultParent;
      if (!parent2) {
        const root = this.getDataModel().getRoot();
        parent2 = root.getChildAt(0);
      }
    }
    return parent2;
  }
  /**
   * Sets the {@link defaultParent} to the given cell. Set this to null to return
   * the first child of the root in getDefaultParent.
   */
  setDefaultParent(cell2) {
    this.defaultParent = cell2;
  }
  /**
   * Destroys the graph and all its resources.
   */
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      Object.values(this.plugins).forEach((p) => p.onDestroy());
      this.view.destroy();
      if (this.model && this.graphModelChangeListener) {
        this.getDataModel().removeListener(this.graphModelChangeListener);
        this.graphModelChangeListener = null;
      }
    }
  }
};
applyGraphMixins();

// node_modules/@maxgraph/core/lib/view/layout/LayoutManager.js
var LayoutManager = class extends EventSource_default {
  constructor(graph) {
    super();
    this.bubbling = true;
    this.enabled = true;
    this.undoHandler = (sender, evt2) => {
      if (this.isEnabled()) {
        this.beforeUndo(evt2.getProperty("edit"));
      }
    };
    this.moveHandler = (sender, evt2) => {
      if (this.isEnabled()) {
        this.cellsMoved(evt2.getProperty("cells"), evt2.getProperty("event"));
      }
    };
    this.resizeHandler = (sender, evt2) => {
      if (this.isEnabled()) {
        this.cellsResized(evt2.getProperty("cells"), evt2.getProperty("bounds"), evt2.getProperty("previous"));
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns true if a layout should bubble, that is, if the parent layout
   * should be executed whenever a cell layout (layout of the children of
   * a cell) has been executed. This implementation returns {@link bubbling}.
   */
  isBubbling() {
    return this.bubbling;
  }
  /**
   * Sets {@link bubbling}.
   */
  setBubbling(value2) {
    this.bubbling = value2;
  }
  /**
   * Returns the graph that this layout operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Sets the graph that the layouts operate on.
   */
  setGraph(graph) {
    if (this.graph) {
      const model2 = this.graph.getDataModel();
      model2.removeListener(this.undoHandler);
      this.graph.removeListener(this.moveHandler);
      this.graph.removeListener(this.resizeHandler);
    }
    this.graph = graph;
    if (this.graph) {
      const model2 = this.graph.getDataModel();
      model2.addListener(InternalEvent_default.BEFORE_UNDO, this.undoHandler);
      this.graph.addListener(InternalEvent_default.MOVE_CELLS, this.moveHandler);
      this.graph.addListener(InternalEvent_default.RESIZE_CELLS, this.resizeHandler);
    }
  }
  /**
   * Returns true if the given cell has a layout. This implementation invokes
   * <getLayout> with {@link Event#LAYOUT_CELLS} as the eventName. Override this
   * if creating layouts in <getLayout> is expensive and return true if
   * <getLayout> will return a layout for the given cell for
   * {@link Event#BEGIN_UPDATE} or {@link Event#END_UPDATE}.
   */
  hasLayout(cell2) {
    return !!this.getLayout(cell2, InternalEvent_default.LAYOUT_CELLS);
  }
  /**
   * Returns the layout for the given cell and eventName. Possible
   * event names are {@link InternalEvent.MOVE_CELLS} and {@link InternalEvent.RESIZE_CELLS}
   * for callbacks on when cells are moved or resized and
   * {@link InternalEvent.BEGIN_UPDATE} and {@link InternalEvent.END_UPDATE} for the capture
   * and bubble phase of the layout after any changes of the model.
   */
  getLayout(cell2, eventName) {
    return null;
  }
  /**
   * Called from {@link undoHandler}.
   *
   * @param cell Array of {@link Cell} that have been moved.
   * @param evt Mouse event that represents the mousedown.
   *
   * TODO: what is undoableEdit type?
   */
  beforeUndo(undoableEdit) {
    this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));
  }
  /**
   * Called from {@link moveHandler}.
   *
   * @param cell Array of {@link Cell} that have been moved.
   * @param evt Mouse event that represents the mousedown.
   */
  cellsMoved(cells, evt2) {
    if (cells.length > 0 && evt2) {
      const point = convertPoint(this.getGraph().container, getClientX(evt2), getClientY(evt2));
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const layout = this.getLayout(cells[i2].getParent(), InternalEvent_default.MOVE_CELLS);
        if (layout) {
          layout.moveCell(cells[i2], point.x, point.y);
        }
      }
    }
  }
  /**
   * Called from {@link resizeHandler}.
   *
   * @param cell Array of {@link Cell} that have been resized.
   * @param bounds {@link mxRectangle} taht represents the new bounds.
   */
  cellsResized(cells = null, bounds = null, prev = null) {
    if (cells && bounds) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        const layout = this.getLayout(cells[i2].getParent(), InternalEvent_default.RESIZE_CELLS);
        if (layout) {
          layout.resizeCell(cells[i2], bounds[i2], prev == null ? void 0 : prev[i2]);
        }
      }
    }
  }
  /**
   * Returns the cells for which a layout should be executed.
   */
  getCellsForChanges(changes) {
    let result2 = [];
    for (const change of changes) {
      if (change instanceof RootChange_default) {
        return [];
      }
      result2 = result2.concat(this.getCellsForChange(change));
    }
    return result2;
  }
  /**
   * Executes all layouts which have been scheduled during the
   * changes.
   * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...
   */
  getCellsForChange(change) {
    if (change instanceof ChildChange_default) {
      return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));
    }
    if (change instanceof TerminalChange_default || change instanceof GeometryChange_default) {
      return this.addCellsWithLayout(change.cell);
    }
    if (change instanceof VisibleChange_default || change instanceof StyleChange_default) {
      return this.addCellsWithLayout(change.cell);
    }
    return [];
  }
  /**
   * Adds all ancestors of the given cell that have a layout.
   */
  addCellsWithLayout(cell2, result2 = []) {
    return this.addDescendantsWithLayout(cell2, this.addAncestorsWithLayout(cell2, result2));
  }
  /**
   * Adds all ancestors of the given cell that have a layout.
   */
  addAncestorsWithLayout(cell2, result2 = []) {
    if (cell2) {
      const layout = this.hasLayout(cell2);
      if (layout) {
        result2.push(cell2);
      }
      if (this.isBubbling()) {
        this.addAncestorsWithLayout(cell2.getParent(), result2);
      }
    }
    return result2;
  }
  /**
   * Adds all descendants of the given cell that have a layout.
   */
  addDescendantsWithLayout(cell2, result2 = []) {
    if (cell2 && this.hasLayout(cell2)) {
      for (let i2 = 0; i2 < cell2.getChildCount(); i2 += 1) {
        const child2 = cell2.getChildAt(i2);
        if (this.hasLayout(child2)) {
          result2.push(child2);
          this.addDescendantsWithLayout(child2, result2);
        }
      }
    }
    return result2;
  }
  /**
   * Executes the given layout on the given parent.
   */
  executeLayoutForCells(cells) {
    const sorted = sortCells(cells, false);
    this.layoutCells(sorted, true);
    this.layoutCells(sorted.reverse(), false);
  }
  /**
   * Executes all layouts which have been scheduled during the changes.
   */
  layoutCells(cells, bubble = false) {
    if (cells.length > 0) {
      const model2 = this.getGraph().getDataModel();
      model2.batchUpdate(() => {
        let last = null;
        for (const cell2 of cells) {
          if (cell2 !== model2.getRoot() && cell2 !== last) {
            this.executeLayout(cell2, bubble);
            last = cell2;
          }
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.LAYOUT_CELLS, { cells }));
      });
    }
  }
  /**
   * Executes the given layout on the given parent.
   */
  executeLayout(cell2, bubble = false) {
    const layout = this.getLayout(cell2, bubble ? InternalEvent_default.BEGIN_UPDATE : InternalEvent_default.END_UPDATE);
    if (layout) {
      layout.execute(cell2);
    }
  }
  /**
   * Removes all handlers from the {@link graph} and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
};
var LayoutManager_default = LayoutManager;

// node_modules/@maxgraph/core/lib/view/other/Outline.js
var Outline = class {
  constructor(source2, container = null) {
    this.sizer = null;
    this.selectionBorder = null;
    this.updateHandler = null;
    this.refreshHandler = null;
    this.panHandler = null;
    this.active = null;
    this.bounds = null;
    this.zoom = false;
    this.startX = null;
    this.startY = null;
    this.dx0 = null;
    this.dy0 = null;
    this.index = null;
    this.outline = null;
    this.graphRenderHint = "exact";
    this.enabled = true;
    this.showViewport = true;
    this.border = 10;
    this.sizerSize = 8;
    this.labelsVisible = false;
    this.updateOnPan = false;
    this.sizerImage = null;
    this.minScale = 1e-4;
    this.suspended = false;
    this.source = source2;
    if (container != null) {
      this.init(container);
    }
  }
  /**
   * Initializes the outline inside the given container.
   */
  init(container) {
    this.outline = this.createGraph(container);
    const outlineGraphModelChanged = this.outline.graphModelChanged;
    this.outline.graphModelChanged = (changes) => {
      if (!this.suspended && this.outline != null) {
        outlineGraphModelChanged.apply(this.outline, [changes]);
      }
    };
    this.outline.labelsVisible = this.labelsVisible;
    this.outline.setEnabled(false);
    this.updateHandler = (sender, evt2) => {
      if (!this.suspended && !this.active) {
        this.update();
      }
    };
    this.source.getDataModel().addListener(InternalEvent_default.CHANGE, this.updateHandler);
    this.outline.addMouseListener(this);
    const view = this.source.getView();
    view.addListener(InternalEvent_default.SCALE, this.updateHandler);
    view.addListener(InternalEvent_default.TRANSLATE, this.updateHandler);
    view.addListener(InternalEvent_default.SCALE_AND_TRANSLATE, this.updateHandler);
    view.addListener(InternalEvent_default.DOWN, this.updateHandler);
    view.addListener(InternalEvent_default.UP, this.updateHandler);
    InternalEvent_default.addListener(this.source.container, "scroll", this.updateHandler);
    this.panHandler = (sender, evt2) => {
      if (this.updateOnPan) {
        this.updateHandler(sender, evt2);
      }
    };
    this.source.addListener(InternalEvent_default.PAN, this.panHandler);
    this.refreshHandler = (sender) => {
      const outline = this.outline;
      outline.setStylesheet(this.source.getStylesheet());
      outline.refresh();
    };
    this.source.addListener(InternalEvent_default.REFRESH, this.refreshHandler);
    this.bounds = new Rectangle_default(0, 0, 0, 0);
    this.selectionBorder = new RectangleShape_default(this.bounds, NONE, OUTLINE_COLOR, OUTLINE_STROKEWIDTH);
    this.selectionBorder.dialect = this.outline.dialect;
    this.selectionBorder.init(this.outline.getView().getOverlayPane());
    const selectionBorderNode = this.selectionBorder.node;
    const handler = (evt2) => {
      const t = getSource(evt2);
      const redirect = (evt3) => {
        const outline2 = this.outline;
        outline2.fireMouseEvent(InternalEvent_default.MOUSE_MOVE, new InternalMouseEvent_default(evt3));
      };
      const redirect2 = (evt3) => {
        const outline2 = this.outline;
        InternalEvent_default.removeGestureListeners(t, null, redirect, redirect2);
        outline2.fireMouseEvent(InternalEvent_default.MOUSE_UP, new InternalMouseEvent_default(evt3));
      };
      const outline = this.outline;
      InternalEvent_default.addGestureListeners(t, null, redirect, redirect2);
      outline.fireMouseEvent(InternalEvent_default.MOUSE_DOWN, new InternalMouseEvent_default(evt2));
    };
    InternalEvent_default.addGestureListeners(this.selectionBorder.node, handler);
    const sizer = this.sizer = this.createSizer();
    const sizerNode = sizer.node;
    sizer.init(this.outline.getView().getOverlayPane());
    if (this.enabled) {
      sizerNode.style.cursor = "nwse-resize";
    }
    InternalEvent_default.addGestureListeners(this.sizer.node, handler);
    selectionBorderNode.style.display = this.showViewport ? "" : "none";
    sizerNode.style.display = selectionBorderNode.style.display;
    selectionBorderNode.style.cursor = "move";
    this.update(false);
  }
  /**
   * Creates the {@link graph} used in the outline.
   */
  createGraph(container) {
    const graph = new Graph(
      container,
      this.source.getDataModel(),
      // TODO review the list of plugins for the Graph of an Outline
      // we could pass an empty array or a selection of plugins
      // it may be necessary to make the plugins array configurable to allow custom plugins and improve tree-shaking
      getDefaultPlugins(),
      this.source.getStylesheet()
    );
    graph.options.foldingEnabled = false;
    graph.autoScroll = false;
    return graph;
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param value Boolean that specifies the new enabled state.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Enables or disables the zoom handling by showing or hiding the respective
   * handle.
   *
   * @param value Boolean that specifies the new enabled state.
   */
  setZoomEnabled(value2) {
    this.sizer.node.style.visibility = value2 ? "visible" : "hidden";
  }
  /**
   * Invokes {@link update} and revalidate the outline. This method is deprecated.
   */
  refresh() {
    this.update(true);
  }
  /**
   * Creates the shape used as the sizer.
   */
  // createSizer(): mxShape;
  createSizer() {
    const outline = this.outline;
    if (this.sizerImage != null) {
      const sizer2 = new ImageShape_default(new Rectangle_default(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);
      sizer2.dialect = outline.dialect;
      return sizer2;
    }
    const sizer = new RectangleShape_default(new Rectangle_default(0, 0, this.sizerSize, this.sizerSize), OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR);
    sizer.dialect = outline.dialect;
    return sizer;
  }
  /**
   * Returns the size of the source container.
   */
  getSourceContainerSize() {
    return new Rectangle_default(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);
  }
  /**
   * Returns the offset for drawing the outline graph.
   */
  getOutlineOffset(scale) {
    return null;
  }
  /**
   * Returns the offset for drawing the outline graph.
   */
  getSourceGraphBounds() {
    return this.source.getGraphBounds();
  }
  /**
   * Updates the outline.
   */
  update(revalidate = false) {
    if (this.source != null && this.source.container != null && this.outline != null && this.outline.container != null) {
      const sourceScale = this.source.view.scale;
      const scaledGraphBounds = this.getSourceGraphBounds();
      const unscaledGraphBounds = new Rectangle_default(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);
      const unscaledFinderBounds = new Rectangle_default(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);
      const union = unscaledGraphBounds.clone();
      union.add(unscaledFinderBounds);
      const size = this.getSourceContainerSize();
      const completeWidth = Math.max(size.width / sourceScale, union.width);
      const completeHeight = Math.max(size.height / sourceScale, union.height);
      const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);
      const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);
      const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);
      let scale = Number.isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);
      if (scale > 0) {
        if (this.outline.getView().scale !== scale) {
          this.outline.getView().scale = scale;
          revalidate = true;
        }
        const navView = this.outline.getView();
        if (navView.currentRoot !== this.source.getView().currentRoot) {
          navView.setCurrentRoot(this.source.getView().currentRoot);
        }
        const t = this.source.view.translate;
        let tx = t.x + this.source.panDx;
        let ty = t.y + this.source.panDy;
        const off = this.getOutlineOffset(scale);
        if (off != null) {
          tx += off.x;
          ty += off.y;
        }
        if (unscaledGraphBounds.x < 0) {
          tx -= unscaledGraphBounds.x;
        }
        if (unscaledGraphBounds.y < 0) {
          ty -= unscaledGraphBounds.y;
        }
        if (navView.translate.x !== tx || navView.translate.y !== ty) {
          navView.translate.x = tx;
          navView.translate.y = ty;
          revalidate = true;
        }
        const t2 = navView.translate;
        scale = this.source.getView().scale;
        const scale2 = scale / navView.scale;
        const scale3 = 1 / navView.scale;
        const { container } = this.source;
        this.bounds = new Rectangle_default((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);
        this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;
        this.bounds.y += this.source.container.scrollTop * navView.scale / scale;
        const selectionBorder = this.selectionBorder;
        let b = selectionBorder.bounds;
        if (b.x !== this.bounds.x || b.y !== this.bounds.y || b.width !== this.bounds.width || b.height !== this.bounds.height) {
          selectionBorder.bounds = this.bounds;
          selectionBorder.redraw();
        }
        const sizer = this.sizer;
        b = sizer.bounds;
        const b2 = new Rectangle_default(this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);
        if (b.x !== b2.x || b.y !== b2.y || b.width !== b2.width || b.height !== b2.height) {
          sizer.bounds = b2;
          if (sizer.node.style.visibility !== "hidden") {
            sizer.redraw();
          }
        }
        if (revalidate) {
          this.outline.view.revalidate();
        }
      }
    }
  }
  /**
   * Handles the event by starting a translation or zoom.
   */
  mouseDown(sender, me) {
    if (this.enabled && this.showViewport) {
      const tol = !isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;
      const hit = tol > 0 ? new Rectangle_default(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;
      this.zoom = me.isSource(this.sizer) || // @ts-ignore
      hit != null && intersects(this.sizer.bounds, hit);
      this.startX = me.getX();
      this.startY = me.getY();
      this.active = true;
      const sourceContainer = this.source.container;
      if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {
        this.dx0 = sourceContainer.scrollLeft;
        this.dy0 = sourceContainer.scrollTop;
      } else {
        this.dx0 = 0;
        this.dy0 = 0;
      }
    }
    me.consume();
  }
  /**
   * Handles the event by previewing the viewrect in {@link graph} and updating the
   * rectangle that represents the viewrect in the outline.
   */
  mouseMove(sender, me) {
    if (this.active) {
      const myBounds = this.bounds;
      const sizer = this.sizer;
      const sizerNode = sizer.node;
      const selectionBorder = this.selectionBorder;
      const selectionBorderNode = selectionBorder.node;
      const source2 = this.source;
      const outline = this.outline;
      selectionBorderNode.style.display = this.showViewport ? "" : "none";
      sizerNode.style.display = selectionBorderNode.style.display;
      const delta = this.getTranslateForEvent(me);
      let dx = delta.x;
      let dy = delta.y;
      let bounds = null;
      if (!this.zoom) {
        const { scale } = outline.getView();
        bounds = new Rectangle_default(myBounds.x + dx, myBounds.y + dy, myBounds.width, myBounds.height);
        selectionBorder.bounds = bounds;
        selectionBorder.redraw();
        dx /= scale;
        dx *= source2.getView().scale;
        dy /= scale;
        dy *= source2.getView().scale;
        source2.panGraph(-dx - this.dx0, -dy - this.dy0);
      } else {
        const { container } = this.source;
        const viewRatio = container.clientWidth / container.clientHeight;
        dy = dx / viewRatio;
        bounds = new Rectangle_default(myBounds.x, myBounds.y, Math.max(1, myBounds.width + dx), Math.max(1, myBounds.height + dy));
        selectionBorder.bounds = bounds;
        selectionBorder.redraw();
      }
      const b = sizer.bounds;
      sizer.bounds = new Rectangle_default(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);
      if (sizerNode.style.visibility !== "hidden") {
        sizer.redraw();
      }
      me.consume();
    }
  }
  /**
   * Gets the translate for the given mouse event. Here is an example to limit
   * the outline to stay within positive coordinates:
   *
   * @example
   * ```javascript
   * outline.getTranslateForEvent(me)
   * {
   *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);
   *
   *   if (!this.zoom)
   *   {
   *     var tr = this.source.view.translate;
   *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);
   *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);
   *   }
   *
   *   return pt;
   * };
   * ```
   */
  getTranslateForEvent(me) {
    return new Point_default(me.getX() - this.startX, me.getY() - this.startY);
  }
  /**
   * Handles the event by applying the translation or zoom to {@link graph}.
   */
  mouseUp(sender, me) {
    if (this.active) {
      const delta = this.getTranslateForEvent(me);
      let dx = delta.x;
      let dy = delta.y;
      const source2 = this.source;
      const outline = this.outline;
      const selectionBorder = this.selectionBorder;
      if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {
        if (!this.zoom) {
          if (!source2.useScrollbarsForPanning || !hasScrollbars(source2.container)) {
            source2.panGraph(0, 0);
            dx /= outline.getView().scale;
            dy /= outline.getView().scale;
            const t = source2.getView().translate;
            source2.getView().setTranslate(t.x - dx, t.y - dy);
          }
        } else {
          const w = selectionBorder.bounds.width;
          const { scale } = source2.getView();
          source2.zoomTo(Math.max(this.minScale, scale - dx * scale / w), false);
        }
        this.update();
        me.consume();
      }
      this.index = null;
      this.active = false;
    }
  }
  /**
   * Destroy this outline and removes all listeners from {@link source}.
   */
  destroy() {
    if (this.source != null) {
      this.source.removeListener(this.panHandler);
      this.source.removeListener(this.refreshHandler);
      this.source.getDataModel().removeListener(this.updateHandler);
      this.source.getView().removeListener(this.updateHandler);
      InternalEvent_default.removeListener(this.source.container, "scroll", this.updateHandler);
      this.source = null;
    }
    if (this.outline != null) {
      this.outline.removeMouseListener(this);
      this.outline.destroy();
      this.outline = null;
    }
    if (this.selectionBorder != null) {
      this.selectionBorder.destroy();
      this.selectionBorder = null;
    }
    if (this.sizer != null) {
      this.sizer.destroy();
      this.sizer = null;
    }
  }
};
var Outline_default = Outline;

// node_modules/@maxgraph/core/lib/view/other/PrintPreview.js
var PrintPreview = class {
  constructor(graph, scale = null, pageFormat = null, border = null, x0 = 0, y0 = 0, borderColor = null, title = "Printer-friendly version", pageSelector = null) {
    this.border = 0;
    this.marginTop = 0;
    this.marginBottom = 0;
    this.x0 = 0;
    this.y0 = 0;
    this.autoOrigin = true;
    this.printOverlays = false;
    this.printControls = false;
    this.printBackgroundImage = false;
    this.backgroundColor = "#ffffff";
    this.wnd = null;
    this.targetWindow = null;
    this.pageCount = 0;
    this.clipping = true;
    this.graph = graph;
    this.scale = scale != null ? scale : 1 / graph.pageScale;
    this.border = border != null ? border : 0;
    this.pageFormat = Rectangle_default.fromRectangle(pageFormat != null ? pageFormat : graph.pageFormat);
    this.title = title;
    this.x0 = x0;
    this.y0 = y0;
    this.borderColor = borderColor;
    this.pageSelector = pageSelector != null ? pageSelector : true;
  }
  /**
   * Returns {@link wnd}.
   */
  getWindow() {
    return this.wnd;
  }
  /**
   * Returns the string that should go before the HTML tag in the print preview
   * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,
   * IE8 in IE8 standards mode and edge in IE9 standards mode.
   */
  getDoctype() {
    const dt = "";
    return dt;
  }
  /**
   * Adds the given graph to the existing print preview.
   *
   * @param css Optional CSS string to be used in the head section.
   * @param targetWindow Optional window that should be used for rendering. If
   * this is specified then no HEAD tag, CSS and BODY tag will be written.
   */
  appendGraph(graph, scale, x0, y0, forcePageBreaks, keepOpen) {
    this.graph = graph;
    this.scale = scale != null ? scale : 1 / graph.pageScale;
    this.x0 = x0;
    this.y0 = y0;
    this.open(null, null, forcePageBreaks, keepOpen);
  }
  /**
   * Shows the print preview window. The window is created here if it does
   * not exist.
   *
   * @param css Optional CSS string to be used in the head section.
   * @param targetWindow Optional window that should be used for rendering. If
   * this is specified then no HEAD tag, CSS and BODY tag will be written.
   */
  open(css = null, targetWindow = null, forcePageBreaks = false, keepOpen = false) {
    const previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;
    let div = null;
    try {
      if (this.printOverlays) {
        this.graph.cellRenderer.initializeOverlay = (state2, overlay) => {
          overlay.init(state2.view.getDrawPane());
        };
      }
      if (this.printControls) {
        this.graph.cellRenderer.initControl = (state2, control, handleEvents, clickHandler) => {
          control.dialect = state2.view.graph.dialect;
          control.init(state2.view.getDrawPane());
          return null;
        };
      }
      this.wnd = targetWindow != null ? targetWindow : this.wnd;
      let isNewWindow = false;
      if (this.wnd == null) {
        isNewWindow = true;
        this.wnd = window.open();
      }
      if (!this.wnd) {
        throw new Error("Create new window not allowed");
      }
      const doc = this.wnd.document;
      if (isNewWindow) {
        const dt = this.getDoctype();
        if (dt != null && dt.length > 0) {
          doc.writeln(dt);
        }
        if (document.compatMode === "CSS1Compat") {
          doc.writeln("<!DOCTYPE html>");
        }
        doc.writeln("<html>");
        doc.writeln("<head>");
        this.writeHead(doc, css);
        doc.writeln("</head>");
        doc.writeln('<body class="mxPage">');
      }
      const bounds = this.graph.getGraphBounds().clone();
      const currentScale = this.graph.getView().getScale();
      const sc = currentScale / this.scale;
      const tr = this.graph.getView().getTranslate();
      if (!this.autoOrigin) {
        this.x0 -= tr.x * this.scale;
        this.y0 -= tr.y * this.scale;
        bounds.width += bounds.x;
        bounds.height += bounds.y;
        bounds.x = 0;
        bounds.y = 0;
        this.border = 0;
      }
      const availableWidth = this.pageFormat.width - this.border * 2;
      const availableHeight = this.pageFormat.height - this.border * 2;
      this.pageFormat.height += this.marginTop + this.marginBottom;
      bounds.width /= sc;
      bounds.height /= sc;
      const hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));
      const vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));
      this.pageCount = hpages * vpages;
      const writePageSelector = () => {
        if (this.pageSelector && (vpages > 1 || hpages > 1)) {
          const table = this.createPageSelector(vpages, hpages);
          doc.body.appendChild(table);
        }
      };
      const addPage = (div2, addBreak) => {
        if (this.borderColor != null) {
          div2.style.borderColor = this.borderColor;
          div2.style.borderStyle = "solid";
          div2.style.borderWidth = "1px";
        }
        div2.style.background = this.backgroundColor;
        if (forcePageBreaks || addBreak) {
          div2.style.pageBreakAfter = "always";
        }
        if (isNewWindow && Client_default.IS_EDGE) {
          doc.writeln(div2.outerHTML);
          div2.parentNode.removeChild(div2);
        } else if (Client_default.IS_EDGE) {
          let clone2 = doc.createElement("div");
          clone2.innerHTML = div2.outerHTML;
          clone2 = clone2.getElementsByTagName("div")[0];
          doc.body.appendChild(clone2);
          div2.parentNode.removeChild(div2);
        } else {
          div2.parentNode.removeChild(div2);
          doc.body.appendChild(div2);
        }
        if (forcePageBreaks || addBreak) {
          this.addPageBreak(doc);
        }
      };
      const cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);
      if (cov) {
        for (const page of cov) {
          addPage(page, true);
        }
      }
      const apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);
      for (let i2 = 0; i2 < vpages; i2 += 1) {
        const dy = i2 * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;
        for (let j = 0; j < hpages; j++) {
          if (this.wnd == null) {
            return null;
          }
          const dx = j * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;
          const pageNum = i2 * hpages + j + 1;
          const clip = new Rectangle_default(dx, dy, availableWidth, availableHeight);
          div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, (div2) => {
            this.addGraphFragment(-dx, -dy, this.scale, pageNum, div2, clip);
            if (this.printBackgroundImage) {
              this.insertBackgroundImage(div2, -dx, -dy);
            }
          }, pageNum);
          div.setAttribute("id", `mxPage-${pageNum}`);
          addPage(div, apx != null || i2 < vpages - 1 || j < hpages - 1);
        }
      }
      if (apx) {
        for (const [index, page] of apx.entries()) {
          addPage(page, index < apx.length - 1);
        }
      }
      if (isNewWindow && !keepOpen) {
        this.closeDocument();
        writePageSelector();
      }
      this.wnd.focus();
    } catch (e) {
      if (div != null && div.parentNode != null) {
        div.parentNode.removeChild(div);
      }
    } finally {
      this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;
    }
    return this.wnd;
  }
  /**
   * Adds a page break to the given document.
   */
  addPageBreak(doc) {
    const hr = doc.createElement("hr");
    hr.className = "mxPageBreak";
    doc.body.appendChild(hr);
  }
  /**
   * Writes the closing tags for body and page after calling {@link writePostfix}.
   */
  closeDocument() {
    try {
      if (this.wnd != null && this.wnd.document != null) {
        const doc = this.wnd.document;
        this.writePostfix(doc);
        doc.writeln("</body>");
        doc.writeln("</html>");
        doc.close();
        InternalEvent_default.release(doc.body);
      }
    } catch (e) {
    }
  }
  /**
   * Writes the HEAD section into the given document, without the opening and closing HEAD tags.
   */
  writeHead(doc, css) {
    if (this.title != null) {
      doc.writeln(`<title>${this.title}</title>`);
    }
    addLinkToHead("stylesheet", `${Client_default.basePath}/css/common.css`, doc);
    doc.writeln('<style type="text/css">');
    doc.writeln("@media print {");
    doc.writeln("  * { -webkit-print-color-adjust: exact; }");
    doc.writeln("  table.mxPageSelector { display: none; }");
    doc.writeln("  hr.mxPageBreak { display: none; }");
    doc.writeln("}");
    doc.writeln("@media screen {");
    doc.writeln("  table.mxPageSelector { position: fixed; right: 10px; top: 10px;font-family: Arial; font-size:10pt; border: solid 1px darkgray;background: white; border-collapse:collapse; }");
    doc.writeln("  table.mxPageSelector td { border: solid 1px gray; padding:4px; }");
    doc.writeln("  body.mxPage { background: gray; }");
    doc.writeln("}");
    if (css != null) {
      doc.writeln(css);
    }
    doc.writeln("</style>");
  }
  /**
   * Called before closing the body of the page. This implementation is empty.
   */
  writePostfix(doc) {
  }
  /**
   * Creates the page selector table.
   */
  createPageSelector(vpages, hpages) {
    if (!this.wnd) {
      throw new Error("Popup window not created");
    }
    const doc = this.wnd.document;
    const table = doc.createElement("table");
    table.className = "mxPageSelector";
    table.setAttribute("border", "0");
    const tbody = doc.createElement("tbody");
    for (let i2 = 0; i2 < vpages; i2 += 1) {
      const row2 = doc.createElement("tr");
      for (let j = 0; j < hpages; j++) {
        const pageNum = i2 * hpages + j + 1;
        const cell2 = doc.createElement("td");
        const a = doc.createElement("a");
        a.setAttribute("href", `#mxPage-${pageNum}`);
        if (Client_default.IS_NS && !Client_default.IS_SF && !Client_default.IS_GC) {
          const js = `let page = document.getElementById('mxPage-${pageNum}');page.scrollIntoView(true);event.preventDefault();`;
          a.setAttribute("onclick", js);
        }
        write(a, String(pageNum));
        cell2.appendChild(a);
        row2.appendChild(cell2);
      }
      tbody.appendChild(row2);
    }
    table.appendChild(tbody);
    return table;
  }
  /**
   * Creates a DIV that prints a single page of the given
   * graph using the given scale and returns the DIV that
   * represents the page.
   *
   * @param w Width of the page in pixels.
   * @param h Height of the page in pixels.
   * @param dx Optional horizontal page offset in pixels (used internally).
   * @param dy Optional vertical page offset in pixels (used internally).
   * @param content Callback that adds the HTML content to the inner div of a page.
   * Takes the inner div as the argument.
   * @param pageNumber Integer representing the page number.
   */
  renderPage(w, h, dx, dy, content, pageNumber) {
    let div = document.createElement("div");
    let arg = null;
    try {
      if (dx !== 0 || dy !== 0) {
        div.style.position = "relative";
        div.style.width = `${w}px`;
        div.style.height = `${h}px`;
        div.style.pageBreakInside = "avoid";
        const innerDiv = document.createElement("div");
        innerDiv.style.position = "relative";
        innerDiv.style.top = `${this.border}px`;
        innerDiv.style.left = `${this.border}px`;
        innerDiv.style.width = `${w - 2 * this.border}px`;
        innerDiv.style.height = `${h - 2 * this.border}px`;
        innerDiv.style.overflow = "hidden";
        const viewport = document.createElement("div");
        viewport.style.position = "relative";
        viewport.style.marginLeft = `${dx}px`;
        viewport.style.marginTop = `${dy}px`;
        innerDiv.appendChild(viewport);
        div.appendChild(innerDiv);
        document.body.appendChild(div);
        arg = viewport;
      } else {
        div.style.width = `${w}px`;
        div.style.height = `${h}px`;
        div.style.overflow = "hidden";
        div.style.pageBreakInside = "avoid";
        const innerDiv = document.createElement("div");
        innerDiv.style.width = `${w - 2 * this.border}px`;
        innerDiv.style.height = `${h - 2 * this.border}px`;
        innerDiv.style.overflow = "hidden";
        innerDiv.style.top = `${this.border}px`;
        innerDiv.style.left = `${this.border}px`;
        div.appendChild(innerDiv);
        document.body.appendChild(div);
        arg = innerDiv;
      }
    } catch (e) {
      if (div && div.parentNode) {
        div.parentNode.removeChild(div);
      }
      div = null;
      throw e;
    }
    content(arg);
    return div;
  }
  /**
   * Returns the root cell for painting the graph.
   */
  getRoot() {
    let root = this.graph.view.currentRoot;
    if (root == null) {
      root = this.graph.getDataModel().getRoot();
    }
    return root;
  }
  /**
   * Returns true if CSS transforms should be used for scaling content.
   * This returns true if foreignObject is supported and we're not in Safari
   * as it has clipping bugs for transformed CSS content with foreignObjects.
   */
  useCssTransforms() {
    return !Client_default.NO_FO && !Client_default.IS_SF;
  }
  /**
   * Adds a graph fragment to the given div.
   *
   * @param dx Horizontal translation for the diagram.
   * @param dy Vertical translation for the diagram.
   * @param scale Scale for the diagram.
   * @param pageNumber Number of the page to be rendered.
   * @param div Div that contains the output.
   * @param clip Contains the clipping rectangle as an {@link Rectangle}.
   */
  addGraphFragment(dx, dy, scale, pageNumber, div, clip) {
    const view = this.graph.getView();
    const previousContainer = this.graph.container;
    this.graph.container = div;
    const canvas = view.getCanvas();
    const backgroundPane = view.getBackgroundPane();
    const drawPane = view.getDrawPane();
    const overlayPane = view.getOverlayPane();
    const realScale = scale;
    if (this.graph.dialect === DIALECT.SVG) {
      view.createSvg();
      if (this.useCssTransforms()) {
        const g = view.getDrawPane().parentNode;
        const prev = g.getAttribute("transform");
        g.setAttribute("transformOrigin", "0 0");
        g.setAttribute("transform", `scale(${scale},${scale})translate(${dx},${dy})`);
        scale = 1;
        dx = 0;
        dy = 0;
      }
    } else {
      view.createHtml();
    }
    const eventsEnabled = view.isEventsEnabled();
    view.setEventsEnabled(false);
    const graphEnabled = this.graph.isEnabled();
    this.graph.setEnabled(false);
    const translate = view.getTranslate();
    view.translate = new Point_default(dx, dy);
    const { redraw } = this.graph.cellRenderer;
    const { states } = view;
    const s = view.scale;
    if (this.clipping) {
      const tempClip = new Rectangle_default((clip.x + translate.x) * s, (clip.y + translate.y) * s, clip.width * s / realScale, clip.height * s / realScale);
      this.graph.cellRenderer.redraw = (state2, force, rendering) => {
        if (state2 != null) {
          const orig = states.get(state2.cell);
          if (orig != null) {
            const bbox = view.getBoundingBox(orig, false);
            if (bbox != null && bbox.width > 0 && bbox.height > 0 && !intersects2(tempClip, bbox)) {
              return;
            }
          }
        }
        redraw.apply(this.graph.cellRenderer, [state2, force, rendering]);
      };
    }
    let temp = null;
    try {
      const cells = [this.getRoot()];
      temp = new TemporaryCellStates_default(view, scale, cells, null, (state2) => {
        return this.getLinkForCellState(state2);
      });
    } catch (e) {
      GlobalConfig.logger.error("PrintPreview unable to generate the preview", e);
    } finally {
      let tmp2 = div.firstChild;
      while (tmp2 != null) {
        const next = tmp2.nextSibling;
        const name2 = tmp2.nodeName.toLowerCase();
        if (name2 === "svg") {
          tmp2.style.overflow = "hidden";
          tmp2.style.position = "relative";
          tmp2.style.top = `${this.marginTop}px`;
          tmp2.setAttribute("width", String(clip.width));
          tmp2.setAttribute("height", String(clip.height));
          tmp2.style.width = "";
          tmp2.style.height = "";
        } else if (tmp2.style.cursor !== "default" && name2 !== "div") {
          tmp2.parentNode.removeChild(tmp2);
        }
        tmp2 = next;
      }
      if (this.printBackgroundImage) {
        const svgs = div.getElementsByTagName("svg");
        if (svgs.length > 0) {
          svgs[0].style.position = "absolute";
        }
      }
      view.overlayPane.parentNode.removeChild(view.overlayPane);
      this.graph.setEnabled(graphEnabled);
      this.graph.container = previousContainer;
      this.graph.cellRenderer.redraw = redraw;
      view.canvas = canvas;
      view.backgroundPane = backgroundPane;
      view.drawPane = drawPane;
      view.overlayPane = overlayPane;
      view.translate = translate;
      if (temp) {
        temp.destroy();
      }
      view.setEventsEnabled(eventsEnabled);
    }
  }
  /**
   * Returns the link for the given cell state. This returns null.
   */
  getLinkForCellState(state2) {
    return this.graph.getLinkForCell(state2.cell);
  }
  /**
   * Inserts the background image into the given div.
   */
  insertBackgroundImage(div, dx, dy) {
    const bg = this.graph.backgroundImage;
    if (bg != null) {
      const img = document.createElement("img");
      img.style.position = "absolute";
      img.style.marginLeft = `${Math.round(dx * this.scale)}px`;
      img.style.marginTop = `${Math.round(dy * this.scale)}px`;
      img.setAttribute("width", String(Math.round(this.scale * bg.width)));
      img.setAttribute("height", String(Math.round(this.scale * bg.height)));
      img.src = bg.src;
      div.insertBefore(img, div.firstChild);
    }
  }
  /**
   * Returns the pages to be added before the print output. This returns `null`.
   */
  getCoverPages(_width, _height) {
    return null;
  }
  /**
   * Returns the pages to be added after the print output. This returns `null`.
   */
  getAppendices(_width, _height) {
    return null;
  }
  /**
   * Opens the print preview and shows the print dialog.
   *
   * @param css Optional CSS string to be used in the head section.
   */
  print(css) {
    const wnd = this.open(css);
    if (wnd != null) {
      wnd.print();
    }
  }
  /**
   * Closes the print preview window.
   */
  close() {
    if (this.wnd != null) {
      this.wnd.close();
      this.wnd = null;
    }
  }
};
var PrintPreview_default = PrintPreview;

// node_modules/@maxgraph/core/lib/view/layout/SwimlaneManager.js
var SwimlaneManager = class extends EventSource_default {
  constructor(graph, horizontal = true, addEnabled = true, resizeEnabled = true) {
    super();
    this.enabled = true;
    this.horizontal = true;
    this.addEnabled = true;
    this.resizeEnabled = true;
    this.horizontal = horizontal;
    this.addEnabled = addEnabled;
    this.resizeEnabled = resizeEnabled;
    this.addHandler = (sender, evt2) => {
      if (this.isEnabled() && this.isAddEnabled()) {
        this.cellsAdded(evt2.getProperty("cells"));
      }
    };
    this.resizeHandler = (sender, evt2) => {
      if (this.isEnabled() && this.isResizeEnabled()) {
        this.cellsResized(evt2.getProperty("cells"));
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates {@link enabled}.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns {@link horizontal}.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Sets {@link horizontal}.
   */
  setHorizontal(value2) {
    this.horizontal = value2;
  }
  /**
   * Returns {@link addEnabled}.
   */
  isAddEnabled() {
    return this.addEnabled;
  }
  /**
   * Sets {@link addEnabled}.
   */
  setAddEnabled(value2) {
    this.addEnabled = value2;
  }
  /**
   * Returns {@link resizeEnabled}.
   */
  isResizeEnabled() {
    return this.resizeEnabled;
  }
  /**
   * Sets {@link resizeEnabled}.
   */
  setResizeEnabled(value2) {
    this.resizeEnabled = value2;
  }
  /**
   * Returns the graph that this manager operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Sets the graph that the manager operates on.
   */
  setGraph(graph) {
    if (this.graph) {
      this.graph.removeListener(this.addHandler);
      this.graph.removeListener(this.resizeHandler);
    }
    this.graph = graph;
    if (this.graph) {
      this.graph.addListener(InternalEvent_default.ADD_CELLS, this.addHandler);
      this.graph.addListener(InternalEvent_default.CELLS_RESIZED, this.resizeHandler);
    }
  }
  /**
   * Returns true if the given swimlane should be ignored.
   */
  isSwimlaneIgnored(swimlane) {
    return !this.getGraph().isSwimlane(swimlane);
  }
  /**
   * Returns true if the given cell is horizontal. If the given cell is not a
   * swimlane, then the global orientation is returned.
   */
  isCellHorizontal(cell2) {
    if (this.graph.isSwimlane(cell2)) {
      const style2 = this.graph.getCellStyle(cell2);
      return style2.horizontal ?? true;
    }
    return !this.isHorizontal();
  }
  /**
   * Called if any cells have been added.
   *
   * @param cell Array of {@link Cell} that have been added.
   */
  cellsAdded(cells) {
    if (cells.length > 0) {
      this.graph.batchUpdate(() => {
        for (const cell2 of cells) {
          if (!this.isSwimlaneIgnored(cell2)) {
            this.swimlaneAdded(cell2);
          }
        }
      });
    }
  }
  /**
   * Updates the size of the given swimlane to match that of any existing
   * siblings swimlanes.
   *
   * @param swimlane {@link mxCell} that represents the new swimlane.
   */
  swimlaneAdded(swimlane) {
    const parent2 = swimlane.getParent();
    const childCount2 = parent2.getChildCount();
    let geo = null;
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = parent2.getChildAt(i2);
      if (child2 !== swimlane && !this.isSwimlaneIgnored(child2)) {
        geo = child2.getGeometry();
        if (geo) {
          break;
        }
      }
    }
    if (geo) {
      const parentHorizontal = parent2 ? this.isCellHorizontal(parent2) : this.horizontal;
      this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);
    }
  }
  /**
   * Called if any cells have been resizes. Calls {@link swimlaneResized} for all
   * swimlanes where {@link isSwimlaneIgnored} returns false.
   *
   * @param cells Array of {@link Cell} whose size was changed.
   */
  cellsResized(cells) {
    if (cells.length > 0) {
      this.graph.batchUpdate(() => {
        for (const cell2 of cells) {
          if (!this.isSwimlaneIgnored(cell2)) {
            const geo = cell2.getGeometry();
            if (geo) {
              const size = new Rectangle_default(0, 0, geo.width, geo.height);
              let top = cell2;
              let current = top;
              while (current) {
                top = current;
                current = current.getParent();
                const tmp2 = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new Rectangle_default();
                size.width += tmp2.width;
                size.height += tmp2.height;
              }
              const parentHorizontal = current ? this.isCellHorizontal(current) : this.horizontal;
              this.resizeSwimlane(top, size.width, size.height, parentHorizontal);
            }
          }
        }
      });
    }
  }
  /**
   * Called from {@link cellsResized} for all swimlanes that are not ignored to update
   * the size of the siblings and the size of the parent swimlanes, recursively,
   * if {@link bubbling} is true.
   *
   * @param swimlane {@link mxCell} whose size has changed.
   */
  resizeSwimlane(swimlane, w, h, parentHorizontal) {
    const model2 = this.graph.getDataModel();
    model2.batchUpdate(() => {
      const horizontal = this.isCellHorizontal(swimlane);
      if (!this.isSwimlaneIgnored(swimlane)) {
        let geo = swimlane.getGeometry();
        if (geo) {
          if (parentHorizontal && geo.height !== h || !parentHorizontal && geo.width !== w) {
            geo = geo.clone();
            if (parentHorizontal) {
              geo.height = h;
            } else {
              geo.width = w;
            }
            model2.setGeometry(swimlane, geo);
          }
        }
      }
      const tmp2 = this.graph.isSwimlane(swimlane) ? this.graph.getStartSize(swimlane) : new Rectangle_default();
      w -= tmp2.width;
      h -= tmp2.height;
      const childCount2 = swimlane.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = swimlane.getChildAt(i2);
        this.resizeSwimlane(child2, w, h, horizontal);
      }
    });
  }
  /**
   * Removes all handlers from the {@link graph} and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
};
var SwimlaneManager_default = SwimlaneManager;

// node_modules/@maxgraph/core/lib/view/undoable_changes/CellAttributeChange.js
var CellAttributeChange = class {
  constructor(cell2, attribute2, value2) {
    this.cell = cell2;
    this.attribute = attribute2;
    this.value = value2;
    this.previous = value2;
  }
  /**
   * Changes the attribute of the cell's user object by
   * using {@link Cell#setAttribute}.
   */
  execute() {
    const tmp2 = this.cell.getAttribute(this.attribute);
    if (isNullish(this.previous)) {
      this.cell.value.removeAttribute(this.attribute);
    } else {
      this.cell.setAttribute(this.attribute, this.previous);
    }
    this.previous = tmp2;
  }
};
var CellAttributeChange_default = CellAttributeChange;

// node_modules/@maxgraph/core/lib/view/handler/KeyHandler.js
var KeyHandler = class {
  constructor(graph, target2 = null) {
    this.keydownHandler = null;
    this.graph = null;
    this.target = null;
    this.normalKeys = {};
    this.shiftKeys = {};
    this.controlKeys = {};
    this.controlShiftKeys = {};
    this.enabled = true;
    if (graph != null) {
      this.graph = graph;
      this.target = target2 || document.documentElement;
      this.keydownHandler = (evt2) => {
        this.keyDown(evt2);
      };
      InternalEvent_default.addListener(this.target, "keydown", this.keydownHandler);
    }
  }
  /**
   * Returns true if events are handled. This implementation returns
   * <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling by updating <enabled>.
   *
   * @param enabled Boolean that specifies the new enabled state.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control key is not pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindKey(code, funct2) {
    this.normalKeys[code] = funct2;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the shift key is pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindShiftKey(code, funct2) {
    this.shiftKeys[code] = funct2;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control key is pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindControlKey(code, funct2) {
    this.controlKeys[code] = funct2;
  }
  /**
   * Binds the specified keycode to the given function. This binding is used
   * if the control and shift key are pressed.
   *
   * @param code Integer that specifies the keycode.
   * @param funct JavaScript function that takes the key event as an argument.
   */
  bindControlShiftKey(code, funct2) {
    this.controlShiftKeys[code] = funct2;
  }
  /**
   * Returns true if the control key is pressed. This uses {@link Event#isControlDown}.
   *
   * @param evt Key event whose control key pressed state should be returned.
   */
  isControlDown(evt2) {
    return isControlDown(evt2);
  }
  /**
   * Returns the function associated with the given key event or null if no
   * function is associated with the given event.
   *
   * @param evt Key event whose associated function should be returned.
   */
  getFunction(evt2) {
    if (evt2 != null && !isAltDown(evt2)) {
      if (this.isControlDown(evt2)) {
        if (isShiftDown(evt2)) {
          return this.controlShiftKeys[evt2.keyCode];
        }
        return this.controlKeys[evt2.keyCode];
      }
      if (isShiftDown(evt2)) {
        return this.shiftKeys[evt2.keyCode];
      }
      return this.normalKeys[evt2.keyCode];
    }
    return null;
  }
  /**
   * Returns true if the event should be processed by this handler, that is,
   * if the event source is either the target, one of its direct children, a
   * descendant of the {@link Graph#container}, or the {@link Graph#cellEditor} of the
   * <graph>.
   *
   * @param evt Key event that represents the keystroke.
   */
  isGraphEvent(evt2) {
    var _a2;
    const source2 = getSource(evt2);
    const cellEditorHandler = (_a2 = this.graph) == null ? void 0 : _a2.getPlugin("CellEditorHandler");
    if (source2 === this.target || source2.parentNode === this.target || cellEditorHandler && cellEditorHandler.isEventSource(evt2)) {
      return true;
    }
    return isAncestorNode(this.graph.container, source2);
  }
  /**
   * Handles the event by invoking the function bound to the respective keystroke
   * if <isEnabledForEvent> returns true for the given event and if
   * <isEventIgnored> returns false, except for escape for which
   * <isEventIgnored> is not invoked.
   *
   * @param evt Key event that represents the keystroke.
   */
  keyDown(evt2) {
    if (this.isEnabledForEvent(evt2)) {
      if (evt2.keyCode === 27) {
        this.escape(evt2);
      } else if (!this.isEventIgnored(evt2)) {
        const boundFunction = this.getFunction(evt2);
        if (boundFunction != null) {
          boundFunction(evt2);
          InternalEvent_default.consume(evt2);
        }
      }
    }
  }
  /**
   * Returns true if the given event should be handled. <isEventIgnored> is
   * called later if the event is not an escape key stroke, in which case
   * <escape> is called. This implementation returns true if <isEnabled>
   * returns true for both, this handler and <graph>, if the event is not
   * consumed and if <isGraphEvent> returns true.
   *
   * @param evt Key event that represents the keystroke.
   */
  isEnabledForEvent(evt2) {
    return this.graph.isEnabled() && !isConsumed(evt2) && this.isGraphEvent(evt2) && this.isEnabled();
  }
  /**
   * Returns true if the given keystroke should be ignored. This returns
   * graph.isEditing().
   *
   * @param evt Key event that represents the keystroke.
   */
  isEventIgnored(evt2) {
    return this.graph.isEditing();
  }
  /**
   * Hook to process ESCAPE keystrokes. This implementation invokes
   * {@link Graph#stopEditing} to cancel the current editing, connecting
   * and/or other ongoing modifications.
   *
   * @param evt Key event that represents the keystroke. Possible keycode in this
   * case is 27 (ESCAPE).
   */
  escape(evt2) {
    if (this.graph.isEscapeEnabled()) {
      this.graph.escape(evt2);
    }
  }
  /**
   * Destroys the handler and all its references into the DOM. This does
   * normally not need to be called, it is called automatically when the
   * window unloads (in IE).
   */
  onDestroy() {
    if (this.target != null && this.keydownHandler != null) {
      InternalEvent_default.removeListener(this.target, "keydown", this.keydownHandler);
      this.keydownHandler = null;
    }
    this.target = null;
  }
};
var KeyHandler_default = KeyHandler;

// node_modules/@maxgraph/core/lib/editor/EditorKeyHandler.js
var EditorKeyHandler = class {
  constructor(editor2 = null) {
    this.editor = null;
    this.handler = null;
    if (editor2 != null) {
      this.editor = editor2;
      const handler = this.handler = new KeyHandler_default(editor2.graph);
      const old = this.handler.escape;
      this.handler.escape = (evt2) => {
        old.apply(handler, [evt2]);
        editor2.hideProperties();
        editor2.fireEvent(new EventObject_default(InternalEvent_default.ESCAPE, { event: evt2 }));
      };
    }
  }
  /**
   * Binds the specified keycode to the given action in {@link editor}.  The optional control flag specifies if the control key must be pressed to trigger the action.
   *
   * @param code      Integer that specifies the keycode.
   * @param action    Name of the action to execute in {@link editor}.
   * @param control   Optional boolean that specifies if control must be pressed.  Default is false.
   */
  bindAction(code, action2, control) {
    const keyHandler = () => {
      this.editor.execute(action2);
    };
    if (control) {
      this.handler.bindControlKey(code, keyHandler);
    } else {
      this.handler.bindKey(code, keyHandler);
    }
  }
  /**
   * Destroys the {@link handler} associated with this object.  This does normally not need to be called, the {@link handler} is destroyed automatically when the window unloads (in IE) by {@link Editor}.
   */
  destroy() {
    this.handler.onDestroy();
    this.handler = null;
  }
};
var EditorKeyHandler_default = EditorKeyHandler;

// node_modules/@maxgraph/core/lib/editor/EditorPopupMenu.js
var EditorPopupMenu = class {
  constructor(config = null) {
    this.imageBasePath = null;
    this.config = config;
  }
  /**
   * This function is called from {@link Editor} to add items to the
   * given menu based on {@link config}. The config is a sequence of
   * the following nodes and attributes.
   *
   * @ChildNodes:
   *
   * add - Adds a new menu item. See below for attributes.
   * separator - Adds a separator. No attributes.
   * condition - Adds a custom condition. Name attribute.
   *
   * The add-node may have a child node that defines a function to be invoked
   * before the action is executed (or instead of an action to be executed).
   *
   * @Attributes:
   *
   * as - Resource key for the label (needs entry in property file).
   * action - Name of the action to execute in enclosing editor.
   * icon - Optional icon (relative/absolute URL).
   * iconCls - Optional CSS class for the icon.
   * if - Optional name of condition that must be true (see below).
   * enabled-if - Optional name of condition that specifies if the menu item
   * should be enabled.
   * name - Name of custom condition. Only for condition nodes.
   *
   * @Conditions:
   *
   * nocell - No cell under the mouse.
   * ncells - More than one cell selected.
   * notRoot - Drilling position is other than home.
   * cell - Cell under the mouse.
   * notEmpty - Exactly one cell with children under mouse.
   * expandable - Exactly one expandable cell under mouse.
   * collapsable - Exactly one collapsable cell under mouse.
   * validRoot - Exactly one cell which is a possible root under mouse.
   * swimlane - Exactly one cell which is a swimlane under mouse.
   *
   * @Example:
   *
   * To add a new item for a given action to the popupmenu:
   *
   * ```
   * <EditorPopupMenu as="popupHandler">
   *   <add as="delete" action="delete" icon="images/delete.gif" if="cell"/>
   * </EditorPopupMenu>
   * ```
   *
   * To add a new item for a custom function:
   *
   * ```
   * <EditorPopupMenu as="popupHandler">
   *   <add as="action1"><![CDATA[
   *		function (editor, cell, evt)
   *		{
   *			editor.execute('action1', cell, 'myArg');
   *		}
   *   ]]></add>
   * </EditorPopupMenu>
   * ```
   *
   * The above example invokes action1 with an additional third argument via
   * the editor instance. The third argument is passed to the function that
   * defines action1. If the add-node has no action-attribute, then only the
   * function defined in the text content is executed, otherwise first the
   * function and then the action defined in the action-attribute is
   * executed. The function in the text content has 3 arguments, namely the
   * {@link Editor} instance, the {@link mxCell} instance under the mouse, and the
   * native mouse event.
   *
   * Custom Conditions:
   *
   * To add a new condition for popupmenu items:
   *
   * ```
   * <condition name="condition1"><![CDATA[
   *   function (editor, cell, evt)
   *   {
   *     return cell != null;
   *   }
   * ]]></condition>
   * ```
   *
   * The new condition can then be used in any item as follows:
   *
   * ```
   * <add as="action1" action="action1" icon="action1.gif" if="condition1"/>
   * ```
   *
   * The order in which the items and conditions appear is not significant as
   * all conditions are evaluated before any items are created.
   *
   * @param editor - Enclosing {@link Editor} instance.
   * @param menu - {@link mxPopupMenu} that is used for adding items and separators.
   * @param cell - Optional {@link mxCell} which is under the mousepointer.
   * @param evt - Optional mouse event which triggered the menu.
   */
  createMenu(editor2, menu2, cell2 = null, evt2 = null) {
    if (this.config != null) {
      const conditions2 = this.createConditions(editor2, cell2, evt2);
      const item2 = this.config.firstChild;
      this.addItems(editor2, menu2, cell2, evt2, conditions2, item2, null);
    }
  }
  /**
   * Recursively adds the given items and all of its children into the given menu.
   *
   * @param editor Enclosing <Editor> instance.
   * @param menu {@link PopupMenu} that is used for adding items and separators.
   * @param cell Optional <Cell> which is under the mousepointer.
   * @param evt Optional mouse event which triggered the menu.
   * @param conditions Array of names boolean conditions.
   * @param item XML node that represents the current menu item.
   * @param parent DOM node that represents the parent menu item.
   */
  addItems(editor, menu, cell = null, evt = null, conditions, item, parent = null) {
    let addSeparator = false;
    while (item != null) {
      if (item.nodeName === "add") {
        const condition = item.getAttribute("if");
        if (condition == null || conditions[condition]) {
          let as = item.getAttribute("as");
          as = Translations_default.get(as) || as;
          const funct = eval(getTextContent(item));
          const action = item.getAttribute("action");
          let icon = item.getAttribute("icon");
          const iconCls = item.getAttribute("iconCls");
          const enabledCond = item.getAttribute("enabled-if");
          const enabled = enabledCond == null || conditions[enabledCond];
          if (addSeparator) {
            menu.addSeparator(parent);
            addSeparator = false;
          }
          if (icon != null && this.imageBasePath) {
            icon = this.imageBasePath + icon;
          }
          const row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);
          this.addItems(
            editor,
            menu,
            cell,
            evt,
            conditions,
            // @ts-ignore
            item.firstChild,
            row
          );
        }
      } else if (item.nodeName === "separator") {
        addSeparator = true;
      }
      item = item.nextSibling;
    }
  }
  /**
   * Helper method to bind an action to a new menu item.
   *
   * @param menu {@link PopupMenu} that is used for adding items and separators.
   * @param editor Enclosing <Editor> instance.
   * @param lab String that represents the label of the menu item.
   * @param icon Optional URL that represents the icon of the menu item.
   * @param action Optional name of the action to execute in the given editor.
   * @param funct Optional function to execute before the optional action. The
   * function takes an <Editor>, the <Cell> under the mouse and the
   * mouse event that triggered the call.
   * @param cell Optional <Cell> to use as an argument for the action.
   * @param parent DOM node that represents the parent menu item.
   * @param iconCls Optional CSS class for the menu icon.
   * @param enabled Optional boolean that specifies if the menu item is enabled.
   * Default is true.
   */
  addAction(menu2, editor2, lab, icon2 = null, funct2 = null, action2 = null, cell2 = null, parent2 = null, iconCls2 = null, enabled2 = true) {
    const clickHandler = (evt2) => {
      if (typeof funct2 === "function") {
        funct2.call(editor2, editor2, cell2, evt2);
      }
      if (action2 != null) {
        editor2.execute(action2, cell2, evt2);
      }
    };
    return menu2.addItem(lab, icon2 || null, clickHandler, parent2, iconCls2, enabled2);
  }
  /**
   * Evaluates the default conditions for the given context.
   *
   * @param editor
   * @param cell
   * @param evt
   */
  createConditions(editor, cell = null, evt = null) {
    const model = editor.graph.getDataModel();
    const childCount = cell ? cell.getChildCount() : 0;
    const conditions = {};
    conditions.nocell = cell == null;
    conditions.ncells = editor.graph.getSelectionCount() > 1;
    conditions.notRoot = model.getRoot() !== editor.graph.getDefaultParent().getParent();
    conditions.cell = cell != null;
    const isCell = cell != null && editor.graph.getSelectionCount() === 1;
    conditions.nonEmpty = isCell && childCount > 0;
    conditions.expandable = isCell && editor.graph.isCellFoldable(cell, false);
    conditions.collapsable = isCell && editor.graph.isCellFoldable(cell, true);
    conditions.validRoot = isCell && editor.graph.isValidRoot(cell);
    conditions.emptyValidRoot = conditions.validRoot && childCount === 0;
    conditions.swimlane = isCell && editor.graph.isSwimlane(cell);
    const condNodes = this.config.getElementsByTagName("condition");
    for (let i = 0; i < condNodes.length; i += 1) {
      const funct = eval(getTextContent(condNodes[i]));
      const name = condNodes[i].getAttribute("name");
      if (name != null && typeof funct === "function") {
        conditions[name] = funct(editor, cell, evt);
      }
    }
    return conditions;
  }
};
var EditorPopupMenu_default = EditorPopupMenu;

// node_modules/@maxgraph/core/lib/gui/MaxToolbar.js
var MaxToolbar = class extends EventSource_default {
  constructor(container) {
    super();
    this.menu = null;
    this.currentImg = null;
    this.selectedMode = null;
    this.defaultMode = null;
    this.defaultFunction = null;
    this.enabled = true;
    this.noReset = false;
    this.updateDefaultMode = true;
    this.container = container;
  }
  /**
   * Adds the given function as an image with the specified title and icon
   * and returns the new image node.
   *
   * @param title Optional string that is used as the tooltip.
   * @param icon Optional URL of the image to be used. If no URL is given, then a
   * button is created.
   * @param funct Function to execute on a mouse click.
   * @param pressedIcon Optional URL of the pressed image. Default is a gray
   * background.
   * @param style Optional style classname. Default is mxToolbarItem.
   * @param factoryMethod Optional factory method for popup menu, eg.
   * (menu, evt, cell)=> { menu.addItem('Hello, World!'); }
   */
  addItem(title = null, icon2 = null, funct2 = null, pressedIcon2 = null, style2 = null, factoryMethod = null) {
    const img = document.createElement(icon2 != null ? "img" : "button");
    const initialClassName = style2 || (factoryMethod ? "mxToolbarMode" : "mxToolbarItem");
    img.className = initialClassName;
    if (icon2) {
      img.setAttribute("src", icon2);
    }
    if (title != null) {
      if (icon2 != null) {
        img.setAttribute("title", title);
      } else {
        write(img, title);
      }
    }
    this.container.appendChild(img);
    if (funct2 != null) {
      InternalEvent_default.addListener(img, "click", funct2);
      if (Client_default.IS_TOUCH) {
        InternalEvent_default.addListener(img, "touchend", funct2);
      }
    }
    const mouseHandler = (evt2) => {
      if (pressedIcon2 != null) {
        img.setAttribute("src", icon2);
      } else {
        img.style.backgroundColor = "";
      }
    };
    InternalEvent_default.addGestureListeners(img, (evt2) => {
      if (pressedIcon2 != null) {
        img.setAttribute("src", pressedIcon2);
      } else {
        img.style.backgroundColor = "gray";
      }
      if (factoryMethod) {
        if (this.menu == null) {
          this.menu = new MaxPopupMenu_default();
        }
        const last = this.currentImg;
        if (this.menu.isMenuShowing()) {
          this.menu.hideMenu();
        }
        if (last != img) {
          this.currentImg = img;
          this.menu.factoryMethod = factoryMethod;
          const point = new Point_default(img.offsetLeft, img.offsetTop + img.offsetHeight);
          this.menu.popup(point.x, point.y, null, evt2);
          if (this.menu.isMenuShowing()) {
            img.className = `${initialClassName}Selected`;
            const hideMenu = this.menu.hideMenu;
            this.menu.hideMenu = () => {
              hideMenu.apply(this);
              img.className = initialClassName;
              this.currentImg = null;
            };
          }
        }
      }
    }, null, mouseHandler);
    InternalEvent_default.addListener(img, "mouseout", mouseHandler);
    return img;
  }
  /**
   * Adds and returns a new SELECT element using the given style. The element
   * is placed inside a DIV with the mxToolbarComboContainer style classname.
   *
   * @param style - Optional style classname. Default is mxToolbarCombo.
   */
  addCombo(style2) {
    const div = document.createElement("div");
    div.style.display = "inline";
    div.className = "mxToolbarComboContainer";
    const select = document.createElement("select");
    select.className = style2 || "mxToolbarCombo";
    div.appendChild(select);
    this.container.appendChild(div);
    return select;
  }
  /**
   * Adds and returns a new SELECT element using the given title as the
   * default element. The selection is reset to this element after each
   * change.
   *
   * @param title - String that specifies the title of the default element.
   * @param style - Optional style classname. Default is mxToolbarCombo.
   */
  addActionCombo(title, style2) {
    const select = document.createElement("select");
    select.className = style2 || "mxToolbarCombo";
    this.addOption(select, title, null);
    InternalEvent_default.addListener(select, "change", (evt2) => {
      const value2 = select.options[select.selectedIndex];
      select.selectedIndex = 0;
      if (value2.funct != null) {
        value2.funct(evt2);
      }
    });
    this.container.appendChild(select);
    return select;
  }
  /**
   * Adds and returns a new OPTION element inside the given SELECT element.
   * If the given value is a function then it is stored in the option's funct
   * field.
   *
   * @param combo - SELECT element that will contain the new entry.
   * @param title - String that specifies the title of the option.
   * @param value - Specifies the value associated with this option.
   */
  addOption(combo, title, value2 = null) {
    const option = document.createElement("option");
    writeln(option, title);
    if (typeof value2 === "function") {
      option.funct = value2;
    } else {
      option.setAttribute("value", value2);
    }
    combo.appendChild(option);
    return option;
  }
  /**
   * Adds a new selectable item to the toolbar. Only one switch mode item may
   * be selected at a time. The currently selected item is the default item
   * after a reset of the toolbar.
   */
  addSwitchMode(title, icon2, funct2, pressedIcon2 = null, style2 = "mxToolbarMode") {
    const img = document.createElement("img");
    img.initialClassName = style2;
    img.className = img.initialClassName;
    img.setAttribute("src", icon2);
    img.altIcon = pressedIcon2;
    if (title != null) {
      img.setAttribute("title", title);
    }
    InternalEvent_default.addListener(img, "click", (evt2) => {
      const selectedModeImg = this.selectedMode;
      let tmp2 = selectedModeImg.altIcon;
      if (tmp2 != null) {
        selectedModeImg.altIcon = selectedModeImg.getAttribute("src");
        selectedModeImg.setAttribute("src", tmp2);
      } else {
        selectedModeImg.className = selectedModeImg.initialClassName;
      }
      if (this.updateDefaultMode) {
        this.defaultMode = img;
      }
      this.selectedMode = img;
      tmp2 = img.altIcon;
      if (tmp2 != null) {
        img.altIcon = img.getAttribute("src");
        img.setAttribute("src", tmp2);
      } else {
        img.className = `${img.initialClassName}Selected`;
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.SELECT));
      funct2();
    });
    this.container.appendChild(img);
    if (this.defaultMode == null) {
      this.defaultMode = img;
      this.selectMode(img);
      funct2();
    }
    return img;
  }
  /**
   * Adds a new item to the toolbar. The selection is typically reset after
   * the item has been consumed, for example by adding a new vertex to the
   * graph. The reset is not carried out if the item is double clicked.
   *
   * The function argument uses the following signature: funct(evt, cell) where
   * evt is the native mouse event and cell is the cell under the mouse.
   */
  addMode(title = null, icon2 = null, funct2, pressedIcon2, style2 = null, toggle2 = false) {
    toggle2 = toggle2 != null ? toggle2 : true;
    const img = document.createElement(icon2 != null ? "img" : "button");
    img.initialClassName = style2 || "mxToolbarMode";
    img.className = img.initialClassName;
    if (icon2) {
      img.setAttribute("src", icon2);
    }
    img.altIcon = pressedIcon2;
    if (title != null) {
      img.setAttribute("title", title);
    }
    if (this.enabled && toggle2) {
      InternalEvent_default.addListener(img, "click", (evt2) => {
        this.selectMode(img, funct2);
        this.noReset = false;
      });
      InternalEvent_default.addListener(img, "dblclick", (evt2) => {
        this.selectMode(img, funct2);
        this.noReset = true;
      });
      if (this.defaultMode == null) {
        this.defaultMode = img;
        this.defaultFunction = funct2;
        this.selectMode(img, funct2);
      }
    }
    this.container.appendChild(img);
    return img;
  }
  /**
   * Resets the state of the previously selected mode and displays the given
   * DOM node as selected. This function fires a select event with the given
   * function as a parameter.
   */
  selectMode(domNode, funct2 = null) {
    if (this.selectedMode != domNode) {
      if (this.selectedMode != null) {
        const tmp3 = this.selectedMode.altIcon;
        if (tmp3 != null) {
          this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
          this.selectedMode.setAttribute("src", tmp3);
        } else {
          this.selectedMode.className = this.selectedMode.initialClassName;
        }
      }
      this.selectedMode = domNode;
      const tmp2 = this.selectedMode.altIcon;
      if (tmp2 != null) {
        this.selectedMode.altIcon = this.selectedMode.getAttribute("src");
        this.selectedMode.setAttribute("src", tmp2);
      } else {
        this.selectedMode.className = `${this.selectedMode.initialClassName}Selected`;
      }
      this.fireEvent(new EventObject_default(InternalEvent_default.SELECT, { function: funct2 }));
    }
  }
  /**
   * Selects the default mode and resets the state of the previously selected
   * mode.
   */
  resetMode(forced = false) {
    if ((forced || !this.noReset) && this.selectedMode != this.defaultMode) {
      this.selectMode(this.defaultMode, this.defaultFunction);
    }
  }
  /**
   * Adds the specifies image as a separator.
   *
   * @param icon - URL of the separator icon.
   */
  addSeparator(icon2) {
    return this.addItem(null, icon2, null);
  }
  /**
   * Adds a break to the container.
   */
  addBreak() {
    br(this.container);
  }
  /**
   * Adds a horizontal line to the container.
   */
  addLine() {
    const hr = document.createElement("hr");
    hr.style.marginRight = "6px";
    hr.setAttribute("size", "1");
    this.container.appendChild(hr);
  }
  /**
   * Removes the toolbar and all its associated resources.
   */
  destroy() {
    InternalEvent_default.release(this.container);
    this.container = null;
    this.defaultMode = null;
    this.defaultFunction = null;
    this.selectedMode = null;
    if (this.menu != null) {
      this.menu.destroy();
    }
  }
};
var MaxToolbar_default = MaxToolbar;

// node_modules/@maxgraph/core/lib/util/gestureUtils.js
var gestureUtils_exports = {};
__export(gestureUtils_exports, {
  makeDraggable: () => makeDraggable
});

// node_modules/@maxgraph/core/lib/view/other/DragSource.js
var DragSource = class {
  constructor(element, dropHandler) {
    this.dragOffset = null;
    this.dragElement = null;
    this.previewElement = null;
    this.previewOffset = null;
    this.enabled = true;
    this.currentGraph = null;
    this.currentDropTarget = null;
    this.currentPoint = null;
    this.currentGuide = null;
    this.currentHighlight = null;
    this.autoscroll = true;
    this.guidesEnabled = true;
    this.gridEnabled = true;
    this.highlightDropTargets = true;
    this.dragElementZIndex = 100;
    this.dragElementOpacity = 70;
    this.checkEventSource = true;
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
    this.eventSource = null;
    this.element = element;
    this.dropHandler = dropHandler;
    InternalEvent_default.addGestureListeners(element, (evt2) => {
      this.mouseDown(evt2);
    });
    InternalEvent_default.addListener(element, "dragstart", (evt2) => {
      InternalEvent_default.consume(evt2);
    });
    this.eventConsumer = (sender, evt2) => {
      const evtName = evt2.getProperty("eventName");
      const me = evt2.getProperty("event");
      if (evtName !== InternalEvent_default.MOUSE_DOWN) {
        me.consume();
      }
    };
  }
  /**
   * Returns {@link enabled}.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Sets {@link enabled}.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Returns {@link guidesEnabled}.
   */
  isGuidesEnabled() {
    return this.guidesEnabled;
  }
  /**
   * Sets {@link guidesEnabled}.
   */
  setGuidesEnabled(value2) {
    this.guidesEnabled = value2;
  }
  /**
   * Returns {@link gridEnabled}.
   */
  isGridEnabled() {
    return this.gridEnabled;
  }
  /**
   * Sets {@link gridEnabled}.
   */
  setGridEnabled(value2) {
    this.gridEnabled = value2;
  }
  /**
   * Returns the graph for the given mouse event. This implementation returns
   * null.
   */
  getGraphForEvent(evt2) {
    return null;
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   */
  getDropTarget(graph, x, y, evt2) {
    return graph.getCellAt(x, y);
  }
  /**
   * Creates and returns a clone of the {@link dragElementPrototype} or the {@link element}
   * if the former is not defined.
   */
  createDragElement(evt2) {
    return this.element.cloneNode(true);
  }
  /**
   * Creates and returns an element which can be used as a preview in the given
   * graph.
   */
  createPreviewElement(graph) {
    return null;
  }
  /**
   * Returns true if this drag source is active.
   */
  isActive() {
    return !!this.mouseMoveHandler;
  }
  /**
   * Stops and removes everything and restores the state of the object.
   */
  reset() {
    if (this.currentGraph) {
      this.dragExit(this.currentGraph);
      this.currentGraph = null;
    }
    this.removeDragElement();
    this.removeListeners();
    this.stopDrag();
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   *
   * To ignore popup menu events for a drag source, this function can be
   * overridden as follows.
   *
   * @example
   * ```javascript
   * var mouseDown = dragSource.mouseDown;
   *
   * dragSource.mouseDown(evt)
   * {
   *   if (!mxEvent.isPopupTrigger(evt))
   *   {
   *     mouseDown.apply(this, arguments);
   *   }
   * };
   * ```
   */
  mouseDown(evt2) {
    if (this.enabled && !isConsumed(evt2) && this.mouseMoveHandler == null) {
      this.startDrag(evt2);
      this.mouseMoveHandler = this.mouseMove.bind(this);
      this.mouseUpHandler = this.mouseUp.bind(this);
      InternalEvent_default.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
      if (Client_default.IS_TOUCH && !isMouseEvent(evt2)) {
        this.eventSource = getSource(evt2);
        if (this.eventSource) {
          InternalEvent_default.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
        }
      }
    }
  }
  /**
   * Creates the {@link dragElement} using {@link createDragElement}.
   */
  startDrag(evt2) {
    this.dragElement = this.createDragElement(evt2);
    this.dragElement.style.position = "absolute";
    this.dragElement.style.zIndex = String(this.dragElementZIndex);
    setOpacity(this.dragElement, this.dragElementOpacity);
    if (this.checkEventSource && Client_default.IS_SVG) {
      this.dragElement.style.pointerEvents = "none";
    }
  }
  /**
   * Invokes {@link removeDragElement}.
   */
  stopDrag() {
    this.removeDragElement();
  }
  /**
   * Removes and destroys the {@link dragElement}.
   */
  removeDragElement() {
    if (this.dragElement) {
      if (this.dragElement.parentNode) {
        this.dragElement.parentNode.removeChild(this.dragElement);
      }
      this.dragElement = null;
    }
  }
  /**
   * Returns the topmost element under the given event.
   */
  getElementForEvent(evt2) {
    return isTouchEvent(evt2) || isPenEvent(evt2) ? document.elementFromPoint(getClientX(evt2), getClientY(evt2)) : getSource(evt2);
  }
  /**
   * Returns true if the given graph contains the given event.
   */
  graphContainsEvent(graph, evt2) {
    const x = getClientX(evt2);
    const y = getClientY(evt2);
    const offset = getOffset(graph.container);
    const origin = getScrollOrigin();
    let elt2 = this.getElementForEvent(evt2);
    if (this.checkEventSource) {
      while (elt2 && elt2 !== graph.container) {
        elt2 = elt2.parentNode;
      }
    }
    return !!elt2 && x >= offset.x - origin.x && y >= offset.y - origin.y && x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight;
  }
  /**
   * Gets the graph for the given event using {@link getGraphForEvent}, updates the
   * {@link currentGraph}, calling {@link dragEnter} and {@link dragExit} on the new and old graph,
   * respectively, and invokes {@link dragOver} if {@link currentGraph} is not null.
   */
  mouseMove(evt2) {
    let graph = this.getGraphForEvent(evt2);
    if (graph && !this.graphContainsEvent(graph, evt2)) {
      graph = null;
    }
    if (graph !== this.currentGraph) {
      if (this.currentGraph) {
        this.dragExit(this.currentGraph, evt2);
      }
      this.currentGraph = graph;
      if (this.currentGraph) {
        this.dragEnter(this.currentGraph, evt2);
      }
    }
    if (this.currentGraph) {
      this.dragOver(this.currentGraph, evt2);
    }
    if (this.dragElement && (!this.previewElement || this.previewElement.style.visibility !== "visible")) {
      let x = getClientX(evt2);
      let y = getClientY(evt2);
      if (this.dragElement.parentNode == null) {
        document.body.appendChild(this.dragElement);
      }
      this.dragElement.style.visibility = "visible";
      if (this.dragOffset) {
        x += this.dragOffset.x;
        y += this.dragOffset.y;
      }
      const offset = getDocumentScrollOrigin(document);
      this.dragElement.style.left = `${x + offset.x}px`;
      this.dragElement.style.top = `${y + offset.y}px`;
    } else if (this.dragElement) {
      this.dragElement.style.visibility = "hidden";
    }
    InternalEvent_default.consume(evt2);
  }
  /**
   * Processes the mouse up event and invokes {@link drop}, {@link dragExit} and {@link stopDrag}
   * as required.
   */
  mouseUp(evt2) {
    if (this.currentGraph) {
      if (this.currentPoint && (!this.previewElement || this.previewElement.style.visibility !== "hidden")) {
        const { scale } = this.currentGraph.view;
        const tr = this.currentGraph.view.translate;
        const x = this.currentPoint.x / scale - tr.x;
        const y = this.currentPoint.y / scale - tr.y;
        this.drop(this.currentGraph, evt2, this.currentDropTarget, x, y);
      }
      this.dragExit(this.currentGraph);
      this.currentGraph = null;
    }
    this.stopDrag();
    this.removeListeners();
    InternalEvent_default.consume(evt2);
  }
  /**
   * Actives the given graph as a drop target.
   */
  // removeListeners(): void;
  removeListeners() {
    if (this.eventSource) {
      InternalEvent_default.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);
      this.eventSource = null;
    }
    InternalEvent_default.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);
    this.mouseMoveHandler = null;
    this.mouseUpHandler = null;
  }
  /**
   * Actives the given graph as a drop target.
   */
  dragEnter(graph, evt2) {
    graph.isMouseDown = true;
    graph.isMouseTrigger = isMouseEvent(evt2);
    this.previewElement = this.createPreviewElement(graph);
    if (this.previewElement && this.checkEventSource && Client_default.IS_SVG) {
      this.previewElement.style.pointerEvents = "none";
    }
    if (this.isGuidesEnabled() && this.previewElement) {
      const selectionHandler = graph.getPlugin("SelectionHandler");
      this.currentGuide = new Guide_default(graph, selectionHandler == null ? void 0 : selectionHandler.getGuideStates());
    }
    if (this.highlightDropTargets) {
      this.currentHighlight = new CellHighlight_default(graph, DROP_TARGET_COLOR);
    }
    graph.addListener(InternalEvent_default.FIRE_MOUSE_EVENT, this.eventConsumer);
  }
  /**
   * Deactivates the given graph as a drop target.
   */
  dragExit(graph, evt2) {
    this.currentDropTarget = null;
    this.currentPoint = null;
    graph.isMouseDown = false;
    graph.removeListener(this.eventConsumer);
    if (this.previewElement) {
      if (this.previewElement.parentNode) {
        this.previewElement.parentNode.removeChild(this.previewElement);
      }
      this.previewElement = null;
    }
    if (this.currentGuide) {
      this.currentGuide.destroy();
      this.currentGuide = null;
    }
    if (this.currentHighlight) {
      this.currentHighlight.destroy();
      this.currentHighlight = null;
    }
  }
  /**
   * Implements autoscroll, updates the {@link currentPoint}, highlights any drop
   * targets and updates the preview.
   */
  dragOver(graph, evt2) {
    const offset = getOffset(graph.container);
    const origin = getScrollOrigin(graph.container);
    let x = getClientX(evt2) - offset.x + origin.x - graph.getPanDx();
    let y = getClientY(evt2) - offset.y + origin.y - graph.getPanDy();
    if (graph.isAutoScroll() && (!this.autoscroll || this.autoscroll)) {
      graph.scrollPointToVisible(x, y, graph.isAutoExtend());
    }
    if (this.currentHighlight && graph.isDropEnabled()) {
      this.currentDropTarget = this.getDropTarget(graph, x, y, evt2);
      if (this.currentDropTarget) {
        const state2 = graph.getView().getState(this.currentDropTarget);
        this.currentHighlight.highlight(state2);
      }
    }
    if (this.previewElement) {
      if (!this.previewElement.parentNode) {
        graph.container.appendChild(this.previewElement);
        this.previewElement.style.zIndex = "3";
        this.previewElement.style.position = "absolute";
      }
      const gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt2);
      let hideGuide = true;
      if (this.currentGuide && this.currentGuide.isEnabledForEvent(evt2)) {
        const w = parseInt(this.previewElement.style.width);
        const h = parseInt(this.previewElement.style.height);
        const bounds = new Rectangle_default(0, 0, w, h);
        let delta = new Point_default(x, y);
        delta = this.currentGuide.move(bounds, delta, gridEnabled, true);
        hideGuide = false;
        x = delta.x;
        y = delta.y;
      } else if (gridEnabled) {
        const { scale } = graph.view;
        const tr = graph.view.translate;
        const off = graph.getGridSize() / 2;
        x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;
        y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;
      }
      if (this.currentGuide && hideGuide) {
        this.currentGuide.hide();
      }
      if (this.previewOffset) {
        x += this.previewOffset.x;
        y += this.previewOffset.y;
      }
      this.previewElement.style.left = `${Math.round(x)}px`;
      this.previewElement.style.top = `${Math.round(y)}px`;
      this.previewElement.style.visibility = "visible";
    }
    this.currentPoint = new Point_default(x, y);
  }
  /**
   * Returns the drop target for the given graph and coordinates. This
   * implementation uses {@link mxGraph.getCellAt}.
   */
  drop(graph, evt2, dropTarget = null, x, y) {
    this.dropHandler(graph, evt2, dropTarget, x, y);
    if (graph.container.style.visibility !== "hidden") {
      graph.container.focus();
    }
  }
};
var DragSource_default = DragSource;

// node_modules/@maxgraph/core/lib/util/gestureUtils.js
var makeDraggable = (element, graphF, funct2, dragElement = null, dx = null, dy = null, autoscroll = null, scalePreview = false, highlightDropTargets = true, getDropTarget = null) => {
  const dragSource = new DragSource_default(element, funct2);
  dragSource.dragOffset = new Point_default(dx != null ? dx : 0, dy != null ? dy : TOOLTIP_VERTICAL_OFFSET);
  if (autoscroll != null) {
    dragSource.autoscroll = autoscroll;
  }
  dragSource.setGuidesEnabled(false);
  if (highlightDropTargets != null) {
    dragSource.highlightDropTargets = highlightDropTargets;
  }
  if (getDropTarget != null) {
    dragSource.getDropTarget = getDropTarget;
  }
  dragSource.getGraphForEvent = (evt2) => {
    return typeof graphF === "function" ? graphF(evt2) : graphF;
  };
  if (dragElement != null) {
    dragSource.createDragElement = () => {
      return dragElement.cloneNode(true);
    };
    if (scalePreview) {
      dragSource.createPreviewElement = (graph) => {
        const elt2 = dragElement.cloneNode(true);
        const w = parseInt(elt2.style.width);
        const h = parseInt(elt2.style.height);
        elt2.style.width = `${Math.round(w * graph.view.scale)}px`;
        elt2.style.height = `${Math.round(h * graph.view.scale)}px`;
        return elt2;
      };
    }
  }
  return dragSource;
};

// node_modules/@maxgraph/core/lib/editor/EditorToolbar.js
var EditorToolbar = class {
  constructor(container = null, editor2 = null) {
    this.toolbar = null;
    this.resetHandler = null;
    this.spacing = 4;
    this.connectOnDrop = false;
    this.editor = editor2;
    if (container != null && editor2 != null) {
      this.init(container);
    }
  }
  /**
   * Constructs the {@link toolbar} for the given container and installs a listener that updates the {@link Editor.insertFunction} on {@link editor} if an item is selected in the toolbar.  This assumes that {@link editor} is not null.
   */
  init(container) {
    if (container != null) {
      this.toolbar = new MaxToolbar_default(container);
      this.toolbar.addListener(InternalEvent_default.SELECT, (sender, evt2) => {
        const funct2 = evt2.getProperty("function");
        if (funct2 != null) {
          this.editor.insertFunction = () => {
            funct2.apply(this, [container]);
            this.toolbar.resetMode();
          };
        } else {
          this.editor.insertFunction = null;
        }
      });
      this.resetHandler = () => {
        if (this.toolbar != null) {
          this.toolbar.resetMode(true);
        }
      };
      this.editor.graph.addListener(InternalEvent_default.DOUBLE_CLICK, this.resetHandler);
      this.editor.addListener(InternalEvent_default.ESCAPE, this.resetHandler);
    }
  }
  /**
   * Adds a new item that executes the given action in {@link editor}. The title,
   * icon and pressedIcon are used to display the toolbar item.
   *
   * @param title - String that represents the title (tooltip) for the item.
   * @param icon - URL of the icon to be used for displaying the item.
   * @param action - Name of the action to execute when the item is clicked.
   * @param pressed - Optional URL of the icon for the pressed state.
   */
  addItem(title, icon2, action2, pressed) {
    const clickHandler = () => {
      if (action2 != null && action2.length > 0) {
        this.editor.execute(action2);
      }
    };
    return this.toolbar.addItem(title, icon2, clickHandler, pressed);
  }
  /**
   * Adds a vertical separator using the optional icon.
   *
   * @param icon - Optional URL of the icon that represents the vertical separator. Default is {@link Client.imageBasePath} + ‘/separator.gif’.
   */
  addSeparator(icon2) {
    icon2 = icon2 || `${Client_default.imageBasePath}/separator.gif`;
    this.toolbar.addSeparator(icon2);
  }
  /**
   * Helper method to invoke {@link MaxToolbar.addCombo} on toolbar and return the resulting DOM node.
   */
  addCombo() {
    return this.toolbar.addCombo();
  }
  /**
   * Helper method to invoke <MaxToolbar.addActionCombo> on <toolbar> using
   * the given title and return the resulting DOM node.
   *
   * @param title String that represents the title of the combo.
   */
  addActionCombo(title) {
    return this.toolbar.addActionCombo(title);
  }
  /**
   * Binds the given action to a option with the specified label in the given combo.  Combo is an object returned from an earlier call to {@link addCombo} or {@link addActionCombo}.
   *
   * @param combo - DOM node that represents the combo box.
   * @param title - String that represents the title of the combo.
   * @param action - Name of the action to execute in {@link editor}.
   */
  addActionOption(combo, title, action2) {
    const clickHandler = () => {
      this.editor.execute(action2);
    };
    this.addOption(combo, title, clickHandler);
  }
  /**
   * Helper method to invoke {@link MaxToolbar.addOption} on {@link toolbar} and return the resulting DOM node that represents the option.
   *
   * @param combo - DOM node that represents the combo box.
   * @param title - String that represents the title of the combo.
   * @param value - Object that represents the value of the option.
   */
  addOption(combo, title, value2) {
    return this.toolbar.addOption(combo, title, value2);
  }
  /**
   * Creates an item for selecting the given mode in the {@link editor}'s graph.
   * Supported modenames are select, connect and pan.
   *
   * @param title - String that represents the title of the item.
   * @param icon - URL of the icon that represents the item.
   * @param mode - String that represents the mode name to be used in {@link Editor.setMode}.
   * @param pressed - Optional URL of the icon that represents the pressed state.
   * @param funct - Optional JavaScript function that takes the {@link Editor} as the first and only argument that is executed after the mode has been selected.
   */
  addMode(title, icon2, mode2, pressed = null, funct2 = null) {
    const clickHandler = () => {
      this.editor.setMode(mode2);
      if (funct2 != null) {
        funct2(this.editor);
      }
    };
    return this.toolbar.addSwitchMode(title, icon2, clickHandler, pressed);
  }
  /**
   * Creates an item for inserting a clone of the specified prototype cell into
   * the <editor>'s graph. The ptype may either be a cell or a function that
   * returns a cell.
   *
   * @param title String that represents the title of the item.
   * @param icon URL of the icon that represents the item.
   * @param ptype Function or object that represents the prototype cell. If ptype
   * is a function then it is invoked with no arguments to create new
   * instances.
   * @param pressed Optional URL of the icon that represents the pressed state.
   * @param insert Optional JavaScript function that handles an insert of the new
   * cell. This function takes the <Editor>, new cell to be inserted, mouse
   * event and optional <Cell> under the mouse pointer as arguments.
   * @param toggle Optional boolean that specifies if the item can be toggled.
   * Default is true.
   */
  addPrototype(title, icon2, ptype, pressed, insert, toggle2 = true) {
    const factory = () => {
      if (typeof ptype === "function") {
        return ptype();
      }
      if (ptype != null) {
        return this.editor.graph.cloneCell(ptype);
      }
      return null;
    };
    const clickHandler = (evt2, cell2) => {
      if (typeof insert === "function") {
        insert(this.editor, factory(), evt2, cell2);
      } else {
        this.drop(factory(), evt2, cell2);
      }
      this.toolbar.resetMode();
      InternalEvent_default.consume(evt2);
    };
    const img = this.toolbar.addMode(title, icon2, clickHandler, pressed, null, toggle2);
    const dropHandler = (graph, evt2, cell2) => {
      clickHandler(evt2, cell2);
    };
    this.installDropHandler(img, dropHandler);
    return img;
  }
  /**
   * Handles a drop from a toolbar item to the graph. The given vertex
   * represents the new cell to be inserted. This invokes {@link insert} or
   * {@link connect} depending on the given target cell.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param target - Optional {@link Cell} that represents the drop target.
   */
  drop(vertex, evt2, target2 = null) {
    const { graph } = this.editor;
    const model2 = graph.getDataModel();
    if (target2 == null || target2.isEdge() || !this.connectOnDrop || !target2.isConnectable()) {
      while (target2 != null && !graph.isValidDropTarget(target2, [vertex], evt2)) {
        target2 = target2.getParent();
      }
      this.insert(vertex, evt2, target2);
    } else {
      this.connect(vertex, evt2, target2);
    }
  }
  /**
   * Handles a drop by inserting the given vertex into the given parent cell
   * or the default parent if no parent is specified.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param target - Optional {@link Cell} that represents the parent.
   */
  insert(vertex, evt2, target2 = null) {
    const { graph } = this.editor;
    if (graph.canImportCell(vertex)) {
      const x = getClientX(evt2);
      const y = getClientY(evt2);
      const pt = convertPoint(graph.container, x, y);
      if (target2 && graph.isSplitEnabled() && graph.isSplitTarget(target2, [vertex], evt2)) {
        return graph.splitEdge(target2, [vertex], null, pt.x, pt.y);
      }
      return this.editor.addVertex(target2, vertex, pt.x, pt.y);
    }
    return null;
  }
  /**
   * Handles a drop by connecting the given vertex to the given source cell.
   *
   * @param vertex - {@link Cell} to be inserted.
   * @param evt - Mouse event that represents the drop.
   * @param source - Optional {@link Cell} that represents the source terminal.
   */
  connect(vertex, evt2, source2 = null) {
    const { graph } = this.editor;
    const model2 = graph.getDataModel();
    if (source2 != null && vertex.isConnectable() && graph.isEdgeValid(null, source2, vertex)) {
      let edge2 = null;
      model2.beginUpdate();
      try {
        const geo = source2.getGeometry();
        const g = vertex.getGeometry().clone();
        g.x = geo.x + (geo.width - g.width) / 2;
        g.y = geo.y + (geo.height - g.height) / 2;
        const step = this.spacing * graph.gridSize;
        const dist = source2.getDirectedEdgeCount(true) * 20;
        if (this.editor.horizontalFlow) {
          g.x += (g.width + geo.width) / 2 + step + dist;
        } else {
          g.y += (g.height + geo.height) / 2 + step + dist;
        }
        vertex.setGeometry(g);
        const parent2 = source2.getParent();
        graph.addCell(vertex, parent2);
        graph.constrainChild(vertex);
        edge2 = this.editor.createEdge(source2, vertex);
        if (edge2.getGeometry() == null) {
          const edgeGeometry = new Geometry_default();
          edgeGeometry.relative = true;
          model2.setGeometry(edge2, edgeGeometry);
        }
        graph.addEdge(edge2, parent2, source2, vertex);
      } finally {
        model2.endUpdate();
      }
      graph.setSelectionCells([vertex, edge2]);
      graph.scrollCellToVisible(vertex);
    }
  }
  /**
   * Makes the given img draggable using the given function for handling a drop event.
   *
   * @param img - DOM node that represents the image.
   * @param dropHandler - Function that handles a drop of the image.
   */
  installDropHandler(img, dropHandler) {
    const sprite = document.createElement("img");
    sprite.setAttribute("src", img.getAttribute("src"));
    const loader = (evt2) => {
      sprite.style.width = `${2 * img.offsetWidth}px`;
      sprite.style.height = `${2 * img.offsetHeight}px`;
      makeDraggable(img, this.editor.graph, dropHandler, sprite);
      InternalEvent_default.removeListener(sprite, "load", loader);
    };
  }
  /**
   * Destroys the {@link toolbar} associated with this object and removes all installed listeners.
   * This does normally not need to be called, the {@link toolbar} is destroyed automatically when the window unloads (in IE) by {@link Editor}.
   */
  destroy() {
    if (this.resetHandler != null) {
      this.editor.graph.removeListener(this.resetHandler);
      this.editor.removeListener(this.resetHandler);
      this.resetHandler = null;
    }
    if (this.toolbar != null) {
      this.toolbar.destroy();
      this.toolbar = null;
    }
  }
};

// node_modules/@maxgraph/core/lib/view/undoable_changes/UndoManager.js
var UndoManager = class extends EventSource_default {
  constructor(size = 100) {
    super();
    this.size = 100;
    this.history = [];
    this.indexOfNextAdd = 0;
    this.size = size;
    this.clear();
  }
  /**
   * Returns true if the history is empty.
   */
  isEmpty() {
    return this.history.length == 0;
  }
  /**
   * Clears the command history.
   */
  clear() {
    this.history = [];
    this.indexOfNextAdd = 0;
    this.fireEvent(new EventObject_default(InternalEvent_default.CLEAR));
  }
  /**
   * Returns true if an undo is possible.
   */
  canUndo() {
    return this.indexOfNextAdd > 0;
  }
  /**
   * Undoes the last change.
   */
  undo() {
    while (this.indexOfNextAdd > 0) {
      const edit = this.history[--this.indexOfNextAdd];
      edit.undo();
      if (edit.isSignificant()) {
        this.fireEvent(new EventObject_default(InternalEvent_default.UNDO, { edit }));
        break;
      }
    }
  }
  /**
   * Returns true if a redo is possible.
   */
  canRedo() {
    return this.indexOfNextAdd < this.history.length;
  }
  /**
   * Redoes the last change.
   */
  redo() {
    const n = this.history.length;
    while (this.indexOfNextAdd < n) {
      const edit = this.history[this.indexOfNextAdd++];
      edit.redo();
      if (edit.isSignificant()) {
        this.fireEvent(new EventObject_default(InternalEvent_default.REDO, { edit }));
        break;
      }
    }
  }
  /**
   * Method to be called to add new undoable edits to the <history>.
   */
  undoableEditHappened(undoableEdit) {
    this.trim();
    if (this.size > 0 && this.size == this.history.length) {
      this.history.shift();
    }
    this.history.push(undoableEdit);
    this.indexOfNextAdd = this.history.length;
    this.fireEvent(new EventObject_default(InternalEvent_default.ADD, { edit: undoableEdit }));
  }
  /**
   * Removes all pending steps after <indexOfNextAdd> from the history,
   * invoking die on each edit. This is called from <undoableEditHappened>.
   */
  trim() {
    if (this.history.length > this.indexOfNextAdd) {
      const edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);
      for (let i2 = 0; i2 < edits.length; i2 += 1) {
        edits[i2].die();
      }
    }
  }
};
var UndoManager_default = UndoManager;

// node_modules/@maxgraph/core/lib/view/layout/GraphLayout.js
var GraphLayout = class {
  constructor(graph) {
    this.useBoundingBox = true;
    this.parent = null;
    this.graph = graph;
  }
  /**
   * Notified when a cell is being moved in a parent that has automatic
   * layout to update the cell state (eg. index) so that the outcome of the
   * layout will position the vertex as close to the point (x, y) as
   * possible.
   *
   * Empty implementation.
   *
   * @param cell {@link Cell} which has been moved.
   * @param x X-coordinate of the new cell location.
   * @param y Y-coordinate of the new cell location.
   */
  moveCell(cell2, x, y) {
    return;
  }
  /**
   * Notified when a cell is being resized in a parent that has automatic
   * layout to update the other cells in the layout.
   *
   * Empty implementation.
   *
   * @param cell {@link Cell} which has been moved.
   * @param bounds {@link Rectangle} that represents the new cell bounds.
   * @param prev
   */
  resizeCell(cell2, bounds, prev) {
    return;
  }
  /**
   * Executes the layout algorithm for the children of the given parent.
   *
   * @param parent {@link Cell} whose children should be layed out.
   */
  execute(parent2) {
    return;
  }
  /**
   * Returns the graph that this layout operates on.
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Returns the constraint for the given key and cell. The optional edge and
   * source arguments are used to return inbound and outgoing routing-
   * constraints for the given edge and vertex. This implementation always
   * returns the value for the given key in the style of the given cell.
   *
   * @param key Key of the constraint to be returned.
   * @param cell {@link Cell} whose constraint should be returned.
   * @param edge Optional {@link Cell} that represents the connection whose constraint
   * should be returned. Default is null.
   * @param source Optional boolean that specifies if the connection is incoming
   * or outgoing. Default is null.
   */
  getConstraint(key2, cell2, edge2, source2) {
    return this.graph.getCurrentCellStyle(cell2)[key2];
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * Example:
   *
   * ```javascript
   * GlobalConfig.logger.show();
   * const cell = graph.getSelectionCell();
   * graph.traverse(cell, false, function(vertex, edge)
   * {
   *   GlobalConfig.logger.debug(graph.getLabel(vertex));
   * });
   * ```
   *
   * @param vertex {@link Cell} that represents the vertex where the traversal starts.
   * @param directed Optional boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param func Visitor function that takes the current vertex and the incoming
   * edge as arguments. The traversal stops if the function returns false.
   * @param edge Optional {@link Cell} that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param visited Optional {@link Dictionary} of cell paths for the visited cells.
   */
  traverse({ vertex, directed, func, edge: edge2, visited }) {
    if (func != null && vertex != null) {
      directed = directed != null ? directed : true;
      visited = visited || new Dictionary_default();
      if (!visited.get(vertex)) {
        visited.put(vertex, true);
        const result2 = func(vertex, edge2);
        if (result2 == null || result2) {
          const edgeCount = vertex.getEdgeCount();
          if (edgeCount > 0) {
            for (let i2 = 0; i2 < edgeCount; i2 += 1) {
              const e = vertex.getEdgeAt(i2);
              const isSource = e.getTerminal(true) === vertex;
              if (!directed || isSource) {
                const next = this.graph.view.getVisibleTerminal(e, !isSource);
                this.traverse({
                  vertex: next,
                  directed,
                  func,
                  edge: e,
                  visited
                });
              }
            }
          }
        }
      }
    }
  }
  /**
   * Returns true if the given parent is an ancestor of the given child.
   *
   * @param parent {@link Cell} that specifies the parent.
   * @param child {@link Cell} that specifies the child.
   * @param traverseAncestors boolean whether to
   */
  isAncestor(parent2, child2, traverseAncestors) {
    if (!traverseAncestors) {
      return child2.getParent() === parent2;
    }
    if (child2 === parent2) {
      return false;
    }
    while (child2 != null && child2 !== parent2) {
      child2 = child2.getParent();
    }
    return child2 === parent2;
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} is movable or
   * bendable by the algorithm. This implementation returns true if the given
   * cell is movable in the graph.
   *
   * @param cell {@link Cell} whose movable state should be returned.
   */
  isVertexMovable(cell2) {
    return this.graph.isCellMovable(cell2);
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} should be ignored by
   * the algorithm. This implementation returns false for all vertices.
   *
   * @param vertex {@link Cell} whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return !vertex.isVertex() || !vertex.isVisible();
  }
  /**
   * Returns a boolean indicating if the given {@link Cell} should be ignored by
   * the algorithm. This implementation returns false for all vertices.
   *
   * @param edge {@link Cell} whose ignored state should be returned.
   */
  isEdgeIgnored(edge2) {
    return !edge2.isEdge() || !edge2.isVisible() || edge2.getTerminal(true) == null || edge2.getTerminal(false) == null;
  }
  /**
   * Disables or enables the edge style of the given edge.
   */
  setEdgeStyleEnabled(edge2, value2) {
    this.graph.setCellStyles("noEdgeStyle", value2 ? "0" : "1", [edge2]);
  }
  /**
   * Disables or enables orthogonal end segments of the given edge.
   */
  setOrthogonalEdge(edge2, value2) {
    this.graph.setCellStyles("orthogonal", value2 ? "1" : "0", [edge2]);
  }
  /**
   * Determines the offset of the given parent to the parent
   * of the layout
   */
  getParentOffset(parent2) {
    const result2 = new Point_default();
    if (parent2 != null && parent2 !== this.parent) {
      const model2 = this.graph.getDataModel();
      if (this.parent && this.parent.isAncestor(parent2)) {
        let parentGeo = parent2.getGeometry();
        while (parent2 !== this.parent) {
          result2.x += parentGeo.x;
          result2.y += parentGeo.y;
          parent2 = parent2.getParent();
          parentGeo = parent2.getGeometry();
        }
      }
    }
    return result2;
  }
  /**
   * Replaces the array of Point in the geometry of the given edge
   * with the given array of Point.
   */
  setEdgePoints(edge2, points2) {
    if (edge2 != null) {
      const { model: model2 } = this.graph;
      let geometry = edge2.getGeometry();
      if (geometry == null) {
        geometry = new Geometry_default();
        geometry.setRelative(true);
      } else {
        geometry = geometry.clone();
      }
      if (this.parent != null && points2 != null) {
        const parent2 = edge2.getParent();
        const parentOffset = this.getParentOffset(parent2);
        for (let i2 = 0; i2 < points2.length; i2 += 1) {
          points2[i2].x = points2[i2].x - parentOffset.x;
          points2[i2].y = points2[i2].y - parentOffset.y;
        }
      }
      geometry.points = points2;
      model2.setGeometry(edge2, geometry);
    }
  }
  /**
   * Sets the new position of the given cell taking into account the size of
   * the bounding box if {@link useBoundingBox} is true. The change is only carried
   * out if the new location is not equal to the existing location, otherwise
   * the geometry is not replaced with an updated instance. The new or old
   * bounds are returned (including overlapping labels).
   *
   * @param cell {@link Cell} whose geometry is to be set.
   * @param x Integer that defines the x-coordinate of the new location.
   * @param y Integer that defines the y-coordinate of the new location.
   */
  setVertexLocation(cell2, x, y) {
    const model2 = this.graph.getDataModel();
    let geometry = cell2.getGeometry();
    let result2 = null;
    if (geometry != null) {
      result2 = new Rectangle_default(x, y, geometry.width, geometry.height);
      if (this.useBoundingBox) {
        const state2 = this.graph.getView().getState(cell2);
        if (state2 != null && state2.text != null && state2.text.boundingBox != null) {
          const { scale } = this.graph.getView();
          const box = state2.text.boundingBox;
          if (state2.text.boundingBox.x < state2.x) {
            x += (state2.x - box.x) / scale;
            result2.width = box.width;
          }
          if (state2.text.boundingBox.y < state2.y) {
            y += (state2.y - box.y) / scale;
            result2.height = box.height;
          }
        }
      }
      if (this.parent != null) {
        const parent2 = cell2.getParent();
        if (parent2 != null && parent2 !== this.parent) {
          const parentOffset = this.getParentOffset(parent2);
          x -= parentOffset.x;
          y -= parentOffset.y;
        }
      }
      if (geometry.x !== x || geometry.y !== y) {
        geometry = geometry.clone();
        geometry.x = x;
        geometry.y = y;
        model2.setGeometry(cell2, geometry);
      }
    }
    return result2;
  }
  /**
   * Returns an {@link Rectangle} that defines the bounds of the given cell or
   * the bounding box if {@link useBoundingBox} is true.
   */
  getVertexBounds(cell2) {
    let geo = cell2.getGeometry();
    if (this.useBoundingBox) {
      const state2 = this.graph.getView().getState(cell2);
      if (state2 != null && state2.text != null && state2.text.boundingBox != null) {
        const { scale } = this.graph.getView();
        const tmp2 = state2.text.boundingBox;
        const dx0 = Math.max(state2.x - tmp2.x, 0) / scale;
        const dy0 = Math.max(state2.y - tmp2.y, 0) / scale;
        const dx1 = Math.max(tmp2.x + tmp2.width - (state2.x + state2.width), 0) / scale;
        const dy1 = Math.max(tmp2.y + tmp2.height - (state2.y + state2.height), 0) / scale;
        geo = new Rectangle_default(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);
      }
    }
    if (this.parent != null) {
      const parent2 = cell2.getParent();
      geo = geo.clone();
      if (parent2 != null && parent2 !== this.parent) {
        const parentOffset = this.getParentOffset(parent2);
        geo.x += parentOffset.x;
        geo.y += parentOffset.y;
      }
    }
    return new Rectangle_default(geo.x, geo.y, geo.width, geo.height);
  }
  /**
   * Shortcut to {@link Graph#updateGroupBounds} with moveGroup set to true.
   */
  arrangeGroups(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {
    return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);
  }
};
var GraphLayout_default = GraphLayout;

// node_modules/@maxgraph/core/lib/view/layout/util/WeightedCellSorter.js
var WeightedCellSorter = class {
  constructor(cell2, weightedValue = 0) {
    this.weightedValue = 0;
    this.nudge = false;
    this.visited = false;
    this.rankIndex = null;
    this.cell = cell2;
    this.weightedValue = weightedValue;
  }
  /**
   * Compares two WeightedCellSorters.
   */
  static compare(a, b) {
    if (a != null && b != null) {
      if (b.weightedValue > a.weightedValue) {
        return -1;
      }
      if (b.weightedValue < a.weightedValue) {
        return 1;
      }
      if (b.nudge) {
        return -1;
      }
      return 1;
    }
    return 0;
  }
};
var WeightedCellSorter_default = WeightedCellSorter;

// node_modules/@maxgraph/core/lib/util/treeTraversal.js
function findTreeRoots(graph, parent2, isolate = false, invert = false) {
  const roots = [];
  if (parent2 != null) {
    let best = null;
    let maxDiff = 0;
    for (const cell2 of parent2.getChildren()) {
      if (cell2.isVertex() && cell2.isVisible()) {
        const conns = graph.getConnections(cell2, isolate ? parent2 : null);
        let fanOut = 0;
        let fanIn = 0;
        for (let j = 0; j < conns.length; j++) {
          const src = graph.view.getVisibleTerminal(conns[j], true);
          if (src == cell2) {
            fanOut++;
          } else {
            fanIn++;
          }
        }
        if (invert && fanOut == 0 && fanIn > 0 || !invert && fanIn == 0 && fanOut > 0) {
          roots.push(cell2);
        }
        const diff = invert ? fanIn - fanOut : fanOut - fanIn;
        if (diff > maxDiff) {
          maxDiff = diff;
          best = cell2;
        }
      }
    }
    if (roots.length == 0 && best != null) {
      roots.push(best);
    }
  }
  return roots;
}

// node_modules/@maxgraph/core/lib/view/layout/CompactTreeLayout.js
var CompactTreeLayout = class extends GraphLayout_default {
  constructor(graph, horizontal = true, invert = false) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.visited = {};
    this.horizontal = true;
    this.invert = false;
    this.resizeParent = true;
    this.maintainParentLocation = false;
    this.groupPadding = 10;
    this.groupPaddingTop = 0;
    this.groupPaddingRight = 0;
    this.groupPaddingBottom = 0;
    this.groupPaddingLeft = 0;
    this.parentsChanged = null;
    this.moveTree = false;
    this.levelDistance = 10;
    this.nodeDistance = 20;
    this.resetEdges = true;
    this.prefHozEdgeSep = 5;
    this.prefVertEdgeOff = 4;
    this.minEdgeJetty = 8;
    this.channelBuffer = 4;
    this.edgeRouting = true;
    this.sortEdges = false;
    this.alignRanks = false;
    this.maxRankHeight = [];
    this.root = null;
    this.node = null;
    this.horizontal = horizontal;
    this.invert = invert;
  }
  /**
   * Returns a boolean indicating if the given {@link mxCell} should be ignored as a
   * vertex. This returns true if the cell has no connections.
   *
   * @param vertex {@link mxCell} whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || vertex.getConnections().length === 0;
  }
  /**
   * Returns {@link horizontal}.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements {@link GraphLayout.execute}.
   *
   * If the parent has any connected edges, then it is used as the root of
   * the tree. Else, {@link mxGraph.findTreeRoots} will be used to find a suitable
   * root node within the set of children of the given parent.
   *
   * @param parent  {@link mxCell} whose children should be laid out.
   * @param root    Optional {@link mxCell} that will be used as the root of the tree. Overrides {@link root} if specified.
   */
  execute(parent2, root) {
    this.parent = parent2;
    const model2 = this.graph.getDataModel();
    if (root == null) {
      if (this.graph.getEdges(parent2, parent2.getParent(), this.invert, !this.invert, false).length > 0) {
        this.root = parent2;
      } else {
        const roots = findTreeRoots(this.graph, parent2, true, this.invert);
        if (roots.length > 0) {
          for (let i2 = 0; i2 < roots.length; i2 += 1) {
            if (!this.isVertexIgnored(roots[i2]) && this.graph.getEdges(roots[i2], null, this.invert, !this.invert, false).length > 0) {
              this.root = roots[i2];
              break;
            }
          }
        }
      }
    } else {
      this.root = root;
    }
    if (this.root != null) {
      if (this.resizeParent) {
        this.parentsChanged = {};
      } else {
        this.parentsChanged = null;
      }
      this.parentX = null;
      this.parentY = null;
      if (parent2 !== this.root && parent2.isVertex() != null && this.maintainParentLocation) {
        const geo = parent2.getGeometry();
        if (geo != null) {
          this.parentX = geo.x;
          this.parentY = geo.y;
        }
      }
      model2.beginUpdate();
      try {
        this.visited = {};
        this.node = this.dfs(this.root, parent2);
        if (this.alignRanks) {
          this.maxRankHeight = [];
          this.findRankHeights(this.node, 0);
          this.setCellHeights(this.node, 0);
        }
        if (this.node != null) {
          this.layout(this.node);
          let x0 = this.graph.gridSize;
          let y0 = x0;
          if (!this.moveTree) {
            const g = this.getVertexBounds(this.root);
            if (g != null) {
              x0 = g.x;
              y0 = g.y;
            }
          }
          let bounds = null;
          if (this.isHorizontal()) {
            bounds = this.horizontalLayout(this.node, x0, y0);
          } else {
            bounds = this.verticalLayout(this.node, null, x0, y0);
          }
          if (bounds != null) {
            let dx = 0;
            let dy = 0;
            if (bounds.x < 0) {
              dx = Math.abs(x0 - bounds.x);
            }
            if (bounds.y < 0) {
              dy = Math.abs(y0 - bounds.y);
            }
            if (dx !== 0 || dy !== 0) {
              this.moveNode(this.node, dx, dy);
            }
            if (this.resizeParent) {
              this.adjustParents();
            }
            if (this.edgeRouting) {
              this.localEdgeProcessing(this.node);
            }
          }
          if (this.parentX != null && this.parentY != null) {
            let geo = parent2.getGeometry();
            if (geo != null) {
              geo = geo.clone();
              geo.x = this.parentX;
              geo.y = this.parentY;
              model2.setGeometry(parent2, geo);
            }
          }
        }
      } finally {
        model2.endUpdate();
      }
    }
  }
  /**
   * Moves the specified node and all of its children by the given amount.
   */
  moveNode(node2, dx, dy) {
    node2.x += dx;
    node2.y += dy;
    this.apply(node2);
    let { child: child2 } = node2;
    while (child2 != null) {
      this.moveNode(child2, dx, dy);
      child2 = child2.next;
    }
  }
  /**
   * Called if {@link sortEdges} is true to sort the array of outgoing edges in place.
   */
  sortOutgoingEdges(source2, edges) {
    const lookup = new Dictionary_default();
    edges.sort((e1, e2) => {
      const end1 = e1.getTerminal(e1.getTerminal(false) == source2);
      let p1 = lookup.get(end1);
      if (p1 == null) {
        p1 = CellPath_default.create(end1).split(CellPath_default.PATH_SEPARATOR);
        lookup.put(end1, p1);
      }
      const end2 = e2.getTerminal(e2.getTerminal(false) === source2);
      let p2 = lookup.get(end2);
      if (p2 == null) {
        p2 = CellPath_default.create(end2).split(CellPath_default.PATH_SEPARATOR);
        lookup.put(end2, p2);
      }
      return CellPath_default.compare(p1, p2);
    });
  }
  /**
   * Stores the maximum height (relative to the layout
   * direction) of cells in each rank
   */
  findRankHeights(node2, rank) {
    const maxRankHeight = this.maxRankHeight;
    if (maxRankHeight[rank] == null || maxRankHeight[rank] < node2.height) {
      maxRankHeight[rank] = node2.height;
    }
    let { child: child2 } = node2;
    while (child2 != null) {
      this.findRankHeights(child2, rank + 1);
      child2 = child2.next;
    }
  }
  /**
   * Set the cells heights (relative to the layout
   * direction) when the tops of each rank are to be aligned
   */
  setCellHeights(node2, rank) {
    const maxRankHeight = this.maxRankHeight;
    if (maxRankHeight[rank] != null && maxRankHeight[rank] > node2.height) {
      node2.height = maxRankHeight[rank];
    }
    let { child: child2 } = node2;
    while (child2 != null) {
      this.setCellHeights(child2, rank + 1);
      child2 = child2.next;
    }
  }
  /**
   * Does a depth first search starting at the specified cell.
   * Makes sure the specified parent is never left by the
   * algorithm.
   */
  dfs(cell2, parent2) {
    const id2 = CellPath_default.create(cell2);
    let node2 = null;
    if (cell2 != null && this.visited[id2] == null && !this.isVertexIgnored(cell2)) {
      this.visited[id2] = cell2;
      node2 = this.createNode(cell2);
      const model2 = this.graph.getDataModel();
      let prev = null;
      const out = this.graph.getEdges(cell2, parent2, this.invert, !this.invert, false, true);
      const view = this.graph.getView();
      if (this.sortEdges) {
        this.sortOutgoingEdges(cell2, out);
      }
      for (let i2 = 0; i2 < out.length; i2 += 1) {
        const edge2 = out[i2];
        if (!this.isEdgeIgnored(edge2)) {
          if (this.resetEdges) {
            this.setEdgePoints(edge2, null);
          }
          if (this.edgeRouting) {
            this.setEdgeStyleEnabled(edge2, false);
            this.setEdgePoints(edge2, null);
          }
          const state2 = view.getState(edge2);
          const target2 = state2 != null ? state2.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge2, this.invert);
          const tmp2 = this.dfs(target2, parent2);
          if (tmp2 != null && target2.getGeometry() != null) {
            if (prev == null) {
              node2.child = tmp2;
            } else {
              prev.next = tmp2;
            }
            prev = tmp2;
          }
        }
      }
    }
    return node2;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  layout(node2) {
    let { child: child2 } = node2;
    while (child2 != null) {
      this.layout(child2);
      child2 = child2.next;
    }
    if (node2.child != null) {
      this.attachParent(node2, this.join(node2));
    } else {
      this.layoutLeaf(node2);
    }
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  horizontalLayout(node2, x0, y0, bounds = null) {
    node2.x += x0 + node2.offsetX;
    node2.y += y0 + node2.offsetY;
    bounds = this.apply(node2, bounds);
    const { child: child2 } = node2;
    if (child2 != null) {
      bounds = this.horizontalLayout(child2, node2.x, node2.y, bounds);
      let siblingOffset = node2.y + child2.offsetY;
      let s = child2.next;
      while (s != null) {
        bounds = this.horizontalLayout(s, node2.x + child2.offsetX, siblingOffset, bounds);
        siblingOffset += s.offsetY;
        s = s.next;
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  verticalLayout(node2, parent2, x0, y0, bounds = null) {
    node2.x = node2.x + x0 + node2.offsetY;
    node2.y = node2.y + y0 + node2.offsetX;
    bounds = this.apply(node2, bounds);
    const { child: child2 } = node2;
    if (child2 != null) {
      bounds = this.verticalLayout(child2, node2, node2.x, node2.y, bounds);
      let siblingOffset = node2.x + child2.offsetY;
      let s = child2.next;
      while (s != null) {
        bounds = this.verticalLayout(s, node2, siblingOffset, node2.y + child2.offsetX, bounds);
        siblingOffset += s.offsetY;
        s = s.next;
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  attachParent(node2, height) {
    const x = this.nodeDistance + this.levelDistance;
    const y2 = (height - node2.width) / 2 - this.nodeDistance;
    const y1 = y2 + node2.width + 2 * this.nodeDistance - height;
    node2.child.offsetX = x + node2.height;
    node2.child.offsetY = y1;
    node2.contour.upperHead = this.createLine(node2.height, 0, this.createLine(x, y1, node2.contour.upperHead));
    node2.contour.lowerHead = this.createLine(node2.height, 0, this.createLine(x, y2, node2.contour.lowerHead));
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  // layoutLeaf(node: any): void;
  layoutLeaf(node2) {
    const dist = 2 * this.nodeDistance;
    node2.contour.upperTail = this.createLine(node2.height + dist, 0);
    node2.contour.upperHead = node2.contour.upperTail;
    node2.contour.lowerTail = this.createLine(0, -node2.width - dist);
    node2.contour.lowerHead = this.createLine(node2.height + dist, 0, node2.contour.lowerTail);
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  join(node2) {
    const dist = 2 * this.nodeDistance;
    let { child: child2 } = node2;
    node2.contour = child2.contour;
    let h = child2.width + dist;
    let sum = h;
    child2 = child2.next;
    while (child2 != null) {
      const d = this.merge(node2.contour, child2.contour);
      child2.offsetY = d + h;
      child2.offsetX = 0;
      h = child2.width + dist;
      sum += d + h;
      child2 = child2.next;
    }
    return sum;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  merge(p1, p2) {
    let x = 0;
    let y = 0;
    let total = 0;
    let upper = p1.lowerHead;
    let lower = p2.upperHead;
    while (lower != null && upper != null) {
      const d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);
      y += d;
      total += d;
      if (x + lower.dx <= upper.dx) {
        x += lower.dx;
        y += lower.dy;
        lower = lower.next;
      } else {
        x -= upper.dx;
        y -= upper.dy;
        upper = upper.next;
      }
    }
    if (lower != null) {
      const b = this.bridge(p1.upperTail, 0, 0, lower, x, y);
      p1.upperTail = b.next != null ? p2.upperTail : b;
      p1.lowerTail = p2.lowerTail;
    } else {
      const b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);
      if (b.next == null) {
        p1.lowerTail = b;
      }
    }
    p1.lowerHead = p2.lowerHead;
    return total;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  // offset(p1: number, p2: number, a1: number, a2: number, b1: number, b2: number): number;
  offset(p1, p2, a1, a2, b1, b2) {
    let d = 0;
    if (b1 <= p1 || p1 + a1 <= 0) {
      return 0;
    }
    const t = b1 * a2 - a1 * b2;
    if (t > 0) {
      if (p1 < 0) {
        const s = p1 * a2;
        d = s / a1 - p2;
      } else if (p1 > 0) {
        const s = p1 * b2;
        d = s / b1 - p2;
      } else {
        d = -p2;
      }
    } else if (b1 < p1 + a1) {
      const s = (b1 - p1) * a2;
      d = b2 - (p2 + s / a1);
    } else if (b1 > p1 + a1) {
      const s = (a1 + p1) * b2;
      d = s / b1 - (p2 + a2);
    } else {
      d = b2 - (p2 + a2);
    }
    if (d > 0) {
      return d;
    }
    return 0;
  }
  bridge(line1, x1, y1, line2, x2, y2) {
    const dx = x2 + line2.dx - x1;
    let dy = 0;
    let s = 0;
    if (line2.dx === 0) {
      dy = line2.dy;
    } else {
      s = dx * line2.dy;
      dy = s / line2.dx;
    }
    const r = this.createLine(dx, dy, line2.next);
    line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);
    return r;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  createNode(cell2) {
    const node2 = {};
    node2.cell = cell2;
    node2.x = 0;
    node2.y = 0;
    node2.width = 0;
    node2.height = 0;
    const geo = this.getVertexBounds(cell2);
    if (geo != null) {
      if (this.isHorizontal()) {
        node2.width = geo.height;
        node2.height = geo.width;
      } else {
        node2.width = geo.width;
        node2.height = geo.height;
      }
    }
    node2.offsetX = 0;
    node2.offsetY = 0;
    node2.contour = {};
    return node2;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  apply(node2, bounds = null) {
    const model2 = this.graph.getDataModel();
    const cell2 = node2.cell;
    let g = cell2.getGeometry();
    if (cell2 != null && g != null) {
      if (this.isVertexMovable(cell2)) {
        g = this.setVertexLocation(cell2, node2.x, node2.y);
        if (this.resizeParent) {
          const parent2 = cell2.getParent();
          const id2 = CellPath_default.create(parent2);
          const parentsChanged = this.parentsChanged;
          if (parentsChanged[id2] == null) {
            parentsChanged[id2] = parent2;
          }
        }
      }
      if (bounds == null) {
        bounds = new Rectangle_default(g.x, g.y, g.width, g.height);
      } else {
        bounds = new Rectangle_default(Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));
      }
    }
    return bounds;
  }
  /**
   * Starts the actual compact tree layout algorithm
   * at the given node.
   */
  createLine(dx, dy, next = null) {
    const line = {
      dx,
      dy,
      next
    };
    return line;
  }
  /**
   * Adjust parent cells whose child geometries have changed. The default
   * implementation adjusts the group to just fit around the children with
   * a padding.
   */
  adjustParents() {
    const tmp2 = [];
    for (const id2 in this.parentsChanged) {
      tmp2.push(this.parentsChanged[id2]);
    }
    this.arrangeGroups(sortCells(tmp2, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);
  }
  /**
   * Moves the specified node and all of its children by the given amount.
   */
  localEdgeProcessing(node2) {
    this.processNodeOutgoing(node2);
    let { child: child2 } = node2;
    while (child2 != null) {
      this.localEdgeProcessing(child2);
      child2 = child2.next;
    }
  }
  /**
   * Separates the x position of edges as they connect to vertices
   */
  processNodeOutgoing(node2) {
    let { child: child2 } = node2;
    const parentCell = node2.cell;
    let childCount2 = 0;
    const sortedCells = [];
    while (child2 != null) {
      childCount2++;
      let sortingCriterion;
      if (this.horizontal) {
        sortingCriterion = child2.y;
      } else {
        sortingCriterion = child2.x;
      }
      sortedCells.push(new WeightedCellSorter_default(child2, sortingCriterion));
      child2 = child2.next;
    }
    sortedCells.sort(WeightedCellSorter_default.compare);
    let availableWidth = node2.width;
    const requiredWidth = (childCount2 + 1) * this.prefHozEdgeSep;
    if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
      availableWidth -= 2 * this.prefHozEdgeSep;
    }
    const edgeSpacing = availableWidth / childCount2;
    let currentXOffset = edgeSpacing / 2;
    if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {
      currentXOffset += this.prefHozEdgeSep;
    }
    let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
    let maxYOffset = 0;
    const parentBounds = this.getVertexBounds(parentCell);
    child2 = node2.child;
    for (let j = 0; j < sortedCells.length; j++) {
      const childCell = sortedCells[j].cell.cell;
      const childBounds = this.getVertexBounds(childCell);
      const edges = this.graph.getEdgesBetween(parentCell, childCell, false);
      const newPoints = [];
      let x = 0;
      let y = 0;
      for (let i2 = 0; i2 < edges.length; i2 += 1) {
        if (this.horizontal) {
          x = parentBounds.x + parentBounds.width;
          y = parentBounds.y + currentXOffset;
          newPoints.push(new Point_default(x, y));
          x = parentBounds.x + parentBounds.width + currentYOffset;
          newPoints.push(new Point_default(x, y));
          y = childBounds.y + childBounds.height / 2;
          newPoints.push(new Point_default(x, y));
          this.setEdgePoints(edges[i2], newPoints);
        } else {
          x = parentBounds.x + currentXOffset;
          y = parentBounds.y + parentBounds.height;
          newPoints.push(new Point_default(x, y));
          y = parentBounds.y + parentBounds.height + currentYOffset;
          newPoints.push(new Point_default(x, y));
          x = childBounds.x + childBounds.width / 2;
          newPoints.push(new Point_default(x, y));
          this.setEdgePoints(edges[i2], newPoints);
        }
      }
      if (j < childCount2 / 2) {
        currentYOffset += this.prefVertEdgeOff;
      } else if (j > childCount2 / 2) {
        currentYOffset -= this.prefVertEdgeOff;
      }
      currentXOffset += edgeSpacing;
      maxYOffset = Math.max(maxYOffset, currentYOffset);
    }
  }
};
var CompactTreeLayout_default = CompactTreeLayout;

// node_modules/@maxgraph/core/lib/view/layout/StackLayout.js
var StackLayout = class extends GraphLayout_default {
  constructor(graph, horizontal = null, spacing = null, x0 = null, y0 = null, border = null) {
    super(graph);
    this.border = 0;
    this.marginTop = 0;
    this.marginLeft = 0;
    this.marginRight = 0;
    this.marginBottom = 0;
    this.keepFirstLocation = false;
    this.fill = false;
    this.resizeParent = false;
    this.resizeParentMax = false;
    this.resizeLast = false;
    this.wrap = null;
    this.borderCollapse = true;
    this.allowGaps = false;
    this.gridSize = 0;
    this.horizontal = horizontal != null ? horizontal : true;
    this.spacing = spacing != null ? spacing : 0;
    this.x0 = x0 != null ? x0 : 0;
    this.y0 = y0 != null ? y0 : 0;
    this.border = border != null ? border : 0;
  }
  /**
   * Returns horizontal.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements mxGraphLayout.moveCell.
   */
  moveCell(cell2, x, y) {
    const model2 = this.graph.getDataModel();
    const parent2 = cell2.getParent();
    const horizontal = this.isHorizontal();
    if (cell2 != null && parent2 != null) {
      let i2 = 0;
      let last = 0;
      const childCount2 = parent2.getChildCount();
      let value2 = horizontal ? x : y;
      const pstate = this.graph.getView().getState(parent2);
      if (pstate != null) {
        value2 -= horizontal ? pstate.x : pstate.y;
      }
      value2 /= this.graph.view.scale;
      for (i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = parent2.getChildAt(i2);
        if (child2 !== cell2) {
          const bounds = child2.getGeometry();
          if (bounds != null) {
            const tmp2 = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;
            if (last <= value2 && tmp2 > value2) {
              break;
            }
            last = tmp2;
          }
        }
      }
      let idx = parent2.getIndex(cell2);
      idx = Math.max(0, i2 - (i2 > idx ? 1 : 0));
      model2.add(parent2, cell2, idx);
    }
  }
  /**
   * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.
   */
  getParentSize(parent2) {
    const model2 = this.graph.getDataModel();
    let pgeo = parent2.getGeometry();
    if (this.graph.container != null && (pgeo == null && model2.isLayer(parent2) || parent2 === this.graph.getView().currentRoot)) {
      const width = this.graph.container.offsetWidth - 1;
      const height = this.graph.container.offsetHeight - 1;
      pgeo = new Geometry_default(0, 0, width, height);
    }
    return pgeo;
  }
  /**
   * Returns the cells to be layouted.
   */
  getLayoutCells(parent2) {
    const model2 = this.graph.getDataModel();
    const childCount2 = parent2.getChildCount();
    const cells = [];
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = parent2.getChildAt(i2);
      if (!this.isVertexIgnored(child2) && this.isVertexMovable(child2)) {
        cells.push(child2);
      }
    }
    if (this.allowGaps) {
      cells.sort((c1, c2) => {
        const geo1 = c1.getGeometry();
        const geo2 = c2.getGeometry();
        return this.horizontal ? geo1.x === geo2.x ? 0 : geo1.x > geo2.x && geo2.x > 0 ? 1 : -1 : geo1.y === geo2.y ? 0 : geo1.y > geo2.y && geo2.y > 0 ? 1 : -1;
      });
    }
    return cells;
  }
  /**
   * Snaps the given value to the grid size.
   */
  snap(value2) {
    if (this.gridSize != null && this.gridSize > 0) {
      value2 = Math.max(value2, this.gridSize);
      if (value2 / this.gridSize > 1) {
        const mod2 = value2 % this.gridSize;
        value2 += mod2 > this.gridSize / 2 ? this.gridSize - mod2 : -mod2;
      }
    }
    return value2;
  }
  /**
   * Implements mxGraphLayout.execute.
   */
  execute(parent2) {
    if (parent2 != null) {
      const pgeo = this.getParentSize(parent2);
      const horizontal = this.isHorizontal();
      const model2 = this.graph.getDataModel();
      let fillValue = null;
      if (pgeo != null) {
        fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;
        fillValue -= 2 * this.border;
      }
      let x0 = this.x0 + this.border + this.marginLeft;
      let y0 = this.y0 + this.border + this.marginTop;
      if (this.graph.isSwimlane(parent2)) {
        const style2 = this.graph.getCellStyle(parent2);
        let start = getNumber(style2, "startSize", DEFAULT_STARTSIZE);
        const horz = getValue(style2, "horizontal", true) == 1;
        if (pgeo != null) {
          if (horz) {
            start = Math.min(start, pgeo.height);
          } else {
            start = Math.min(start, pgeo.width);
          }
        }
        if (horizontal === horz && fillValue != null) {
          fillValue -= start;
        }
        if (horz) {
          y0 += start;
        } else {
          x0 += start;
        }
      }
      model2.beginUpdate();
      try {
        let tmp2 = 0;
        let last = null;
        let lastValue = 0;
        let lastChild = null;
        const cells = this.getLayoutCells(parent2);
        for (let i2 = 0; i2 < cells.length; i2 += 1) {
          const child2 = cells[i2];
          let geo = child2.getGeometry();
          if (geo != null) {
            geo = geo.clone();
            if (this.wrap != null && last != null) {
              if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {
                last = null;
                if (horizontal) {
                  y0 += tmp2 + this.spacing;
                } else {
                  x0 += tmp2 + this.spacing;
                }
                tmp2 = 0;
              }
            }
            tmp2 = Math.max(tmp2, horizontal ? geo.height : geo.width);
            let sw = 0;
            if (!this.borderCollapse) {
              const childStyle = this.graph.getCellStyle(child2);
              sw = getNumber(childStyle, "strokeWidth", 1);
            }
            if (last != null) {
              const temp = lastValue + this.spacing + Math.floor(sw / 2);
              if (horizontal) {
                geo.x = this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;
              } else {
                geo.y = this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;
              }
            } else if (!this.keepFirstLocation) {
              if (horizontal) {
                geo.x = this.allowGaps && geo.x > x0 ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0) : x0;
              } else {
                geo.y = this.allowGaps && geo.y > y0 ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0) : y0;
              }
            }
            if (horizontal) {
              geo.y = y0;
            } else {
              geo.x = x0;
            }
            if (this.fill && fillValue != null) {
              if (horizontal) {
                geo.height = fillValue;
              } else {
                geo.width = fillValue;
              }
            }
            if (horizontal) {
              geo.width = this.snap(geo.width);
            } else {
              geo.height = this.snap(geo.height);
            }
            this.setChildGeometry(child2, geo);
            lastChild = child2;
            last = geo;
            if (horizontal) {
              lastValue = last.x + last.width + Math.floor(sw / 2);
            } else {
              lastValue = last.y + last.height + Math.floor(sw / 2);
            }
          }
        }
        if (this.resizeParent && pgeo != null && last != null && !parent2.isCollapsed()) {
          this.updateParentGeometry(parent2, pgeo, last);
        } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {
          if (horizontal) {
            last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;
          } else {
            last.height = pgeo.height - last.y - this.spacing - this.marginBottom;
          }
          this.setChildGeometry(lastChild, last);
        }
      } finally {
        model2.endUpdate();
      }
    }
  }
  /**
   * Sets the specific geometry to the given child cell.
   *
   * @param child The given child of <Cell>.
   * @param geo The specific geometry of {@link Geometry}.
   */
  setChildGeometry(child2, geo) {
    const geo2 = child2.getGeometry();
    if (geo2 == null || geo.x !== geo2.x || geo.y !== geo2.y || geo.width !== geo2.width || geo.height !== geo2.height) {
      this.graph.getDataModel().setGeometry(child2, geo);
    }
  }
  /**
   * Updates the geometry of the given parent cell.
   *
   * @param parent The given parent of <Cell>.
   * @param pgeo The new {@link Geometry} for parent.
   * @param last The last {@link Geometry}.
   */
  updateParentGeometry(parent2, pgeo, last) {
    const horizontal = this.isHorizontal();
    const model2 = this.graph.getDataModel();
    const pgeo2 = pgeo.clone();
    if (horizontal) {
      const tmp2 = last.x + last.width + this.marginRight + this.border;
      if (this.resizeParentMax) {
        pgeo2.width = Math.max(pgeo2.width, tmp2);
      } else {
        pgeo2.width = tmp2;
      }
    } else {
      const tmp2 = last.y + last.height + this.marginBottom + this.border;
      if (this.resizeParentMax) {
        pgeo2.height = Math.max(pgeo2.height, tmp2);
      } else {
        pgeo2.height = tmp2;
      }
    }
    if (pgeo.x !== pgeo2.x || pgeo.y !== pgeo2.y || pgeo.width !== pgeo2.width || pgeo.height !== pgeo2.height) {
      model2.setGeometry(parent2, pgeo2);
    }
  }
};
var StackLayout_default = StackLayout;

// node_modules/@maxgraph/core/lib/gui/MaxWindow.js
var activeWindow = null;
var MaxWindow = class extends EventSource_default {
  constructor(title, content, x, y, width = null, height = null, minimizable = true, movable = true, replaceNode = null, style2) {
    super();
    this.closeImage = `${Client_default.imageBasePath}/close.gif`;
    this.minimizeImage = `${Client_default.imageBasePath}/minimize.gif`;
    this.normalizeImage = `${Client_default.imageBasePath}/normalize.gif`;
    this.maximizeImage = `${Client_default.imageBasePath}/maximize.gif`;
    this.resizeImage = `${Client_default.imageBasePath}/resize.gif`;
    this.visible = false;
    this.minimumSize = new Rectangle_default(0, 0, 50, 40);
    this.destroyOnClose = true;
    if (content != null) {
      this.content = content;
      this.init(x, y, width, height, style2);
      this.installMaximizeHandler();
      this.installMinimizeHandler();
      this.installCloseHandler();
      this.setMinimizable(minimizable);
      this.setTitle(title);
      if (movable) {
        this.installMoveHandler();
      }
      if (replaceNode != null && replaceNode.parentNode != null) {
        replaceNode.parentNode.replaceChild(this.div, replaceNode);
      } else {
        document.body.appendChild(this.div);
      }
    }
  }
  /**
   * Initializes the DOM tree that represents the window.
   */
  init(x, y, width = null, height = null, style2 = "mxWindow") {
    this.div = document.createElement("div");
    this.div.className = style2;
    this.div.style.left = `${x}px`;
    this.div.style.top = `${y}px`;
    this.table = document.createElement("table");
    this.table.className = style2;
    if (Client_default.IS_POINTER) {
      this.div.style.touchAction = "none";
    }
    if (width != null) {
      this.div.style.width = `${width}px`;
      this.table.style.width = `${width}px`;
    }
    if (height != null) {
      this.div.style.height = `${height}px`;
      this.table.style.height = `${height}px`;
    }
    const tbody = document.createElement("tbody");
    let tr = document.createElement("tr");
    this.title = document.createElement("td");
    this.title.className = `${style2}Title`;
    this.buttons = document.createElement("div");
    this.buttons.style.position = "absolute";
    this.buttons.style.display = "inline-block";
    this.buttons.style.right = "4px";
    this.buttons.style.top = "5px";
    this.title.appendChild(this.buttons);
    tr.appendChild(this.title);
    tbody.appendChild(tr);
    tr = document.createElement("tr");
    this.td = document.createElement("td");
    this.td.className = `${style2}Pane`;
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.className = `${style2}Pane`;
    this.contentWrapper.style.width = "100%";
    this.contentWrapper.appendChild(this.content);
    if (this.content.nodeName.toUpperCase() !== "DIV") {
      this.contentWrapper.style.height = "100%";
    }
    this.td.appendChild(this.contentWrapper);
    tr.appendChild(this.td);
    tbody.appendChild(tr);
    this.table.appendChild(tbody);
    this.div.appendChild(this.table);
    const activator = (evt2) => {
      this.activate();
    };
    InternalEvent_default.addGestureListeners(this.title, activator);
    InternalEvent_default.addGestureListeners(this.table, activator);
    this.hide();
  }
  /**
   * Sets the window title to the given string. HTML markup inside the title
   * will be escaped.
   */
  setTitle(title) {
    let child2 = this.title.firstChild;
    while (child2 != null) {
      const next = child2.nextSibling;
      if (child2.nodeType === NODETYPE.TEXT) {
        child2.parentNode.removeChild(child2);
      }
      child2 = next;
    }
    write(this.title, title || "");
    this.title.appendChild(this.buttons);
  }
  /**
   * Sets if the window contents should be scrollable.
   */
  setScrollable(scrollable) {
    if (navigator.userAgent == null || navigator.userAgent.indexOf("Presto/2.5") < 0) {
      if (scrollable) {
        this.contentWrapper.style.overflow = "auto";
      } else {
        this.contentWrapper.style.overflow = "hidden";
      }
    }
  }
  /**
   * Puts the window on top of all other windows.
   */
  activate() {
    if (activeWindow !== this) {
      const style2 = getCurrentStyle(this.getElement());
      const index = style2 != null ? parseInt(style2.zIndex) : 3;
      if (activeWindow) {
        const elt2 = activeWindow.getElement();
        if (elt2 == null ? void 0 : elt2.style) {
          elt2.style.zIndex = String(index);
        }
      }
      const previousWindow = activeWindow;
      this.getElement().style.zIndex = String(index + 1);
      activeWindow = this;
      this.fireEvent(new EventObject_default(InternalEvent_default.ACTIVATE, { previousWindow }));
    }
  }
  /**
   * Returuns the outermost DOM node that makes up the window.
   */
  getElement() {
    return this.div;
  }
  /**
   * Makes sure the window is inside the client area of the window.
   */
  fit() {
    fit(this.div);
  }
  /**
   * Returns true if the window is resizable.
   */
  isResizable() {
    if (this.resize != null) {
      return this.resize.style.display !== "none";
    }
    return false;
  }
  /**
   * Sets if the window should be resizable. To avoid interference with some
   * built-in features of IE10 and later, the use of the following code is
   * recommended if there are resizable <MaxWindow>s in the page:
   *
   * ```javascript
   * if (Client.IS_POINTER)
   * {
   *   document.body.style.msTouchAction = 'none';
   * }
   * ```
   */
  setResizable(resizable) {
    if (resizable) {
      if (this.resize == null) {
        this.resize = document.createElement("img");
        this.resize.style.position = "absolute";
        this.resize.style.bottom = "2px";
        this.resize.style.right = "2px";
        this.resize.setAttribute("src", this.resizeImage);
        this.resize.style.cursor = "nw-resize";
        let startX = null;
        let startY = null;
        let width = null;
        let height = null;
        const start = (evt2) => {
          this.activate();
          startX = getClientX(evt2);
          startY = getClientY(evt2);
          width = this.div.offsetWidth;
          height = this.div.offsetHeight;
          InternalEvent_default.addGestureListeners(document, null, dragHandler, dropHandler);
          this.fireEvent(new EventObject_default(InternalEvent_default.RESIZE_START, { event: evt2 }));
          InternalEvent_default.consume(evt2);
        };
        const dragHandler = (evt2) => {
          if (startX != null && startY != null) {
            const dx = getClientX(evt2) - startX;
            const dy = getClientY(evt2) - startY;
            if (width != null && height != null) {
              this.setSize(width + dx, height + dy);
            }
            this.fireEvent(new EventObject_default(InternalEvent_default.RESIZE, { event: evt2 }));
            InternalEvent_default.consume(evt2);
          }
        };
        const dropHandler = (evt2) => {
          if (startX != null && startY != null) {
            startX = null;
            startY = null;
            InternalEvent_default.removeGestureListeners(document, null, dragHandler, dropHandler);
            this.fireEvent(new EventObject_default(InternalEvent_default.RESIZE_END, { event: evt2 }));
            InternalEvent_default.consume(evt2);
          }
        };
        InternalEvent_default.addGestureListeners(this.resize, start, dragHandler, dropHandler);
        this.div.appendChild(this.resize);
      } else {
        this.resize.style.display = "inline";
      }
    } else if (this.resize != null) {
      this.resize.style.display = "none";
    }
  }
  /**
   * Sets the size of the window.
   */
  setSize(width, height) {
    width = Math.max(this.minimumSize.width, width);
    height = Math.max(this.minimumSize.height, height);
    this.div.style.width = `${width}px`;
    this.div.style.height = `${height}px`;
    this.table.style.width = `${width}px`;
    this.table.style.height = `${height}px`;
    this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
  }
  /**
   * Sets if the window is minimizable.
   */
  setMinimizable(minimizable) {
    this.minimize.style.display = minimizable ? "" : "none";
  }
  /**
   * Returns an {@link Rectangle} that specifies the size for the minimized window.
   * A width or height of 0 means keep the existing width or height. This
   * implementation returns the height of the window title and keeps the width.
   */
  getMinimumSize() {
    return new Rectangle_default(0, 0, 0, this.title.offsetHeight);
  }
  /**
   * Installs the event listeners required for minimizing the window.
   */
  installMinimizeHandler() {
    this.minimize = document.createElement("img");
    this.minimize.setAttribute("src", this.minimizeImage);
    this.minimize.setAttribute("title", "Minimize");
    this.minimize.style.cursor = "pointer";
    this.minimize.style.marginLeft = "2px";
    this.minimize.style.display = "none";
    this.buttons.appendChild(this.minimize);
    let minimized = false;
    let maxDisplay = null;
    let height = null;
    const funct2 = (evt2) => {
      this.activate();
      if (!minimized) {
        minimized = true;
        this.minimize.setAttribute("src", this.normalizeImage);
        this.minimize.setAttribute("title", "Normalize");
        this.contentWrapper.style.display = "none";
        maxDisplay = this.maximize.style.display;
        this.maximize.style.display = "none";
        height = this.table.style.height;
        const minSize = this.getMinimumSize();
        if (minSize.height > 0) {
          this.div.style.height = `${minSize.height}px`;
          this.table.style.height = `${minSize.height}px`;
        }
        if (minSize.width > 0) {
          this.div.style.width = `${minSize.width}px`;
          this.table.style.width = `${minSize.width}px`;
        }
        if (this.resize != null) {
          this.resize.style.visibility = "hidden";
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.MINIMIZE, { event: evt2 }));
      } else {
        minimized = false;
        this.minimize.setAttribute("src", this.minimizeImage);
        this.minimize.setAttribute("title", "Minimize");
        this.contentWrapper.style.display = "";
        if (maxDisplay != null && height != null) {
          this.maximize.style.display = maxDisplay;
          this.div.style.height = height;
          this.table.style.height = height;
        }
        if (this.resize != null) {
          this.resize.style.visibility = "";
        }
        this.fireEvent(new EventObject_default(InternalEvent_default.NORMALIZE, { event: evt2 }));
      }
      InternalEvent_default.consume(evt2);
    };
    InternalEvent_default.addGestureListeners(this.minimize, funct2);
  }
  /**
   * Sets if the window is maximizable.
   */
  setMaximizable(maximizable) {
    this.maximize.style.display = maximizable ? "" : "none";
  }
  /**
   * Installs the event listeners required for maximizing the window.
   */
  installMaximizeHandler() {
    this.maximize = document.createElement("img");
    this.maximize.setAttribute("src", this.maximizeImage);
    this.maximize.setAttribute("title", "Maximize");
    this.maximize.style.cursor = "default";
    this.maximize.style.marginLeft = "2px";
    this.maximize.style.cursor = "pointer";
    this.maximize.style.display = "none";
    this.buttons.appendChild(this.maximize);
    let maximized = false;
    let x = null;
    let y = null;
    let height = null;
    let width = null;
    let minDisplay = null;
    const funct2 = (evt2) => {
      this.activate();
      if (this.maximize.style.display !== "none") {
        if (!maximized) {
          maximized = true;
          this.maximize.setAttribute("src", this.normalizeImage);
          this.maximize.setAttribute("title", "Normalize");
          this.contentWrapper.style.display = "";
          minDisplay = this.minimize.style.display;
          this.minimize.style.display = "none";
          x = parseInt(this.div.style.left);
          y = parseInt(this.div.style.top);
          height = this.table.style.height;
          width = this.table.style.width;
          this.div.style.left = "0px";
          this.div.style.top = "0px";
          const docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);
          this.div.style.width = `${document.body.clientWidth - 2}px`;
          this.div.style.height = `${docHeight - 2}px`;
          this.table.style.width = `${document.body.clientWidth - 2}px`;
          this.table.style.height = `${docHeight - 2}px`;
          if (this.resize != null) {
            this.resize.style.visibility = "hidden";
          }
          const style2 = getCurrentStyle(this.contentWrapper);
          if (style2.overflow === "auto" || this.resize != null) {
            this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
          }
          this.fireEvent(new EventObject_default(InternalEvent_default.MAXIMIZE, { event: evt2 }));
        } else {
          maximized = false;
          this.maximize.setAttribute("src", this.maximizeImage);
          this.maximize.setAttribute("title", "Maximize");
          this.contentWrapper.style.display = "";
          if (minDisplay != null) {
            this.minimize.style.display = minDisplay;
          }
          this.div.style.left = `${x}px`;
          this.div.style.top = `${y}px`;
          if (width != null && height != null) {
            this.div.style.height = height;
            this.div.style.width = width;
          }
          const style2 = getCurrentStyle(this.contentWrapper);
          if (style2.overflow === "auto" || this.resize != null) {
            this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
          }
          if (width != null && height != null) {
            this.table.style.height = height;
            this.table.style.width = width;
          }
          if (this.resize != null) {
            this.resize.style.visibility = "";
          }
          this.fireEvent(new EventObject_default(InternalEvent_default.NORMALIZE, { event: evt2 }));
        }
        InternalEvent_default.consume(evt2);
      }
    };
    InternalEvent_default.addGestureListeners(this.maximize, funct2);
    InternalEvent_default.addListener(this.title, "dblclick", funct2);
  }
  /**
   * Installs the event listeners required for moving the window.
   */
  installMoveHandler() {
    this.title.style.cursor = "move";
    InternalEvent_default.addGestureListeners(this.title, (evt2) => {
      const startX = getClientX(evt2);
      const startY = getClientY(evt2);
      const x = this.getX();
      const y = this.getY();
      const dragHandler = (evt3) => {
        const dx = getClientX(evt3) - startX;
        const dy = getClientY(evt3) - startY;
        this.setLocation(x + dx, y + dy);
        this.fireEvent(new EventObject_default(InternalEvent_default.MOVE, { event: evt3 }));
        InternalEvent_default.consume(evt3);
      };
      const dropHandler = (evt3) => {
        InternalEvent_default.removeGestureListeners(document, null, dragHandler, dropHandler);
        this.fireEvent(new EventObject_default(InternalEvent_default.MOVE_END, { event: evt3 }));
        InternalEvent_default.consume(evt3);
      };
      InternalEvent_default.addGestureListeners(document, null, dragHandler, dropHandler);
      this.fireEvent(new EventObject_default(InternalEvent_default.MOVE_START, { event: evt2 }));
      InternalEvent_default.consume(evt2);
    });
    if (Client_default.IS_POINTER) {
      this.title.style.touchAction = "none";
    }
  }
  /**
   * Sets the upper, left corner of the window.
   */
  setLocation(x, y) {
    this.div.style.left = `${x}px`;
    this.div.style.top = `${y}px`;
  }
  /**
   * Returns the current position on the x-axis.
   */
  getX() {
    return parseInt(this.div.style.left);
  }
  /**
   * Returns the current position on the y-axis.
   */
  getY() {
    return parseInt(this.div.style.top);
  }
  /**
   * Adds the <closeImage> as a new image node in <closeImg> and installs the
   * <close> event.
   */
  installCloseHandler() {
    this.closeImg = document.createElement("img");
    this.closeImg.setAttribute("src", this.closeImage);
    this.closeImg.setAttribute("title", "Close");
    this.closeImg.style.marginLeft = "2px";
    this.closeImg.style.cursor = "pointer";
    this.closeImg.style.display = "none";
    this.buttons.appendChild(this.closeImg);
    InternalEvent_default.addGestureListeners(this.closeImg, (evt2) => {
      this.fireEvent(new EventObject_default(InternalEvent_default.CLOSE, { event: evt2 }));
      if (this.destroyOnClose) {
        this.destroy();
      } else {
        this.setVisible(false);
      }
      InternalEvent_default.consume(evt2);
    });
  }
  /**
   * Sets the image associated with the window.
   *
   *
   * @param image - URL of the image to be used.
   */
  setImage(image) {
    this.image = document.createElement("img");
    this.image.setAttribute("src", image);
    this.image.setAttribute("align", "left");
    this.image.style.marginRight = "4px";
    this.image.style.marginLeft = "0px";
    this.image.style.marginTop = "-2px";
    this.title.insertBefore(this.image, this.title.firstChild);
  }
  /**
   * Sets the image associated with the window.
   *
   *
   * @param closable - Boolean specifying if the window should be closable.
   */
  setClosable(closable) {
    this.closeImg.style.display = closable ? "" : "none";
  }
  /**
   * Returns true if the window is visible.
   */
  isVisible() {
    if (this.div != null) {
      return this.div.style.display !== "none";
    }
    return false;
  }
  /**
   * Shows or hides the window depending on the given flag.
   *
   *
   * @param visible - Boolean indicating if the window should be made visible.
   */
  setVisible(visible) {
    if (this.div != null && this.isVisible() !== visible) {
      if (visible) {
        this.show();
      } else {
        this.hide();
      }
    }
  }
  /**
   * Shows the window.
   */
  show() {
    this.div.style.display = "";
    this.activate();
    const style2 = getCurrentStyle(this.contentWrapper);
    if ((style2.overflow == "auto" || this.resize != null) && this.contentWrapper.style.display != "none") {
      this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.SHOW));
  }
  /**
   * Hides the window.
   */
  hide() {
    this.div.style.display = "none";
    this.fireEvent(new EventObject_default(InternalEvent_default.HIDE));
  }
  /**
   * Destroys the window and removes all associated resources. Fires a
   * <destroy> event prior to destroying the window.
   */
  destroy() {
    this.fireEvent(new EventObject_default(InternalEvent_default.DESTROY));
    if (this.div != null) {
      InternalEvent_default.release(this.div);
      this.div.parentNode.removeChild(this.div);
      this.div = null;
    }
    this.title = null;
    this.content = null;
    this.contentWrapper = null;
  }
};
var popup = (content, isInternalWindow = false) => {
  if (isInternalWindow) {
    const div = document.createElement("div");
    div.style.overflow = "scroll";
    div.style.width = "636px";
    div.style.height = "460px";
    const pre = document.createElement("pre");
    pre.innerHTML = htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
    div.appendChild(pre);
    const w = document.body.clientWidth;
    const h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);
    const wnd = new MaxWindow("Popup Window", div, w / 2 - 320, h / 2 - 240, 640, 480, false, true);
    wnd.setClosable(true);
    wnd.setVisible(true);
  } else {
    if (Client_default.IS_NS) {
      const wnd = window.open();
      if (!wnd) {
        throw new Error("Permission not granted to open popup window");
      }
      wnd.document.writeln(`<pre>${htmlEntities(content)}</pre`);
      wnd.document.close();
    } else {
      const wnd = window.open();
      if (!wnd) {
        throw new Error("Permission not granted to open popup window");
      }
      const pre = wnd.document.createElement("pre");
      pre.innerHTML = htmlEntities(content, false).replace(/\n/g, "<br>").replace(/ /g, "&nbsp;");
      wnd.document.body.appendChild(pre);
    }
  }
};
var error = (message, width, close, icon2 = null) => {
  const div = document.createElement("div");
  div.style.padding = "20px";
  const img = document.createElement("img");
  img.setAttribute("src", icon2 || utils.errorImage);
  img.setAttribute("valign", "bottom");
  img.style.verticalAlign = "middle";
  div.appendChild(img);
  div.appendChild(document.createTextNode(" "));
  div.appendChild(document.createTextNode(" "));
  div.appendChild(document.createTextNode(" "));
  write(div, message);
  const w = document.body.clientWidth;
  const h = document.body.clientHeight || document.documentElement.clientHeight;
  const warn = new MaxWindow(Translations_default.get(utils.errorResource) || utils.errorResource, div, (w - width) / 2, h / 4, width, null, false, true);
  if (close) {
    br(div);
    const tmp2 = document.createElement("p");
    const button2 = document.createElement("button");
    button2.setAttribute("style", "float:right");
    InternalEvent_default.addListener(button2, "click", (evt2) => {
      warn.destroy();
    });
    write(button2, Translations_default.get(utils.closeResource) || utils.closeResource);
    tmp2.appendChild(button2);
    div.appendChild(tmp2);
    br(div);
    warn.setClosable(true);
  }
  warn.setVisible(true);
  return warn;
};
var MaxWindow_default = MaxWindow;

// node_modules/@maxgraph/core/lib/serialization/codecs/editor/EditorCodec.js
var EditorCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new Editor_default(__dummy), [
      "modified",
      "lastSnapshot",
      "ignoredChanges",
      "undoManager",
      "graphContainer",
      "toolbarContainer"
    ]);
  }
  /**
   * Decodes the ui-part of the configuration node by reading
   * a sequence of the following child nodes and attributes
   * and passes the control to the default decoding mechanism:
   *
   * Child Nodes:
   *
   * stylesheet - Adds a CSS stylesheet to the document.
   * resource - Adds the basename of a resource bundle.
   * add - Creates or configures a known UI element.
   *
   * These elements may appear in any order given that the
   * graph UI element is added before the toolbar element
   * (see Known Keys).
   *
   * Attributes:
   *
   * as - Key for the UI element (see below).
   * element - ID for the element in the document.
   * style - CSS style to be used for the element or window.
   * x - X coordinate for the new window.
   * y - Y coordinate for the new window.
   * width - Width for the new window.
   * height - Optional height for the new window.
   * name - Name of the stylesheet (absolute/relative URL).
   * basename - Basename of the resource bundle (see {@link Resources}).
   *
   * The x, y, width and height attributes are used to create a new
   * <MaxWindow> if the element attribute is not specified in an add
   * node. The name and basename are only used in the stylesheet and
   * resource nodes, respectively.
   *
   * Known Keys:
   *
   * graph - Main graph element (see <Editor.setGraphContainer>).
   * title - Title element (see <Editor.setTitleContainer>).
   * toolbar - Toolbar element (see <Editor.setToolbarContainer>).
   * status - Status bar element (see <Editor.setStatusContainer>).
   *
   * Example:
   *
   * ```javascript
   * <ui>
   *   <stylesheet name="css/process.css"/>
   *   <resource basename="resources/app"/>
   *   <add as="graph" element="graph"
   *     style="left:70px;right:20px;top:20px;bottom:40px"/>
   *   <add as="status" element="status"/>
   *   <add as="toolbar" x="10" y="20" width="54"/>
   * </ui>
   * ```
   */
  afterDecode(dec2, node2, obj2) {
    const defaultEdge = node2.getAttribute("defaultEdge");
    if (defaultEdge != null) {
      node2.removeAttribute("defaultEdge");
      obj2.defaultEdge = obj2.templates[defaultEdge];
    }
    const defaultGroup = node2.getAttribute("defaultGroup");
    if (defaultGroup != null) {
      node2.removeAttribute("defaultGroup");
      obj2.defaultGroup = obj2.templates[defaultGroup];
    }
    return obj2;
  }
  /**
   * Overrides decode child to handle special child nodes.
   */
  decodeChild(dec2, child2, obj2) {
    if (child2.nodeName === "Array") {
      const role = child2.getAttribute("as");
      if (role === "templates") {
        this.decodeTemplates(dec2, child2, obj2);
        return;
      }
    } else if (child2.nodeName === "ui") {
      this.decodeUi(dec2, child2, obj2);
      return;
    }
    super.decodeChild.apply(this, [dec2, child2, obj2]);
  }
  /**
   * Decodes the ui elements from the given node.
   */
  decodeUi(dec2, node2, editor2) {
    let tmp2 = node2.firstChild;
    while (tmp2 != null) {
      if (tmp2.nodeName === "add") {
        const as2 = tmp2.getAttribute("as");
        const elt2 = tmp2.getAttribute("element");
        const style2 = tmp2.getAttribute("style");
        let element = null;
        if (elt2 != null) {
          element = document.getElementById(elt2);
          if (element != null && style2 != null) {
            element.style.cssText += `;${style2}`;
          }
        } else {
          const x = parseInt(tmp2.getAttribute("x"));
          const y = parseInt(tmp2.getAttribute("y"));
          const width = tmp2.getAttribute("width") || null;
          const height = tmp2.getAttribute("height") || null;
          element = document.createElement("div");
          if (style2 != null) {
            element.style.cssText = style2;
          }
          const wnd = new MaxWindow_default(Translations_default.get(as2) || as2, element, x, y, width ? parseInt(width) : null, height ? parseInt(height) : null, false, true);
          wnd.setVisible(true);
        }
        if (as2 === "graph") {
          editor2.setGraphContainer(element);
        } else if (as2 === "toolbar") {
          editor2.setToolbarContainer(element);
        } else if (as2 === "title") {
          editor2.setTitleContainer(element);
        } else if (as2 === "status") {
          editor2.setStatusContainer(element);
        } else if (as2 === "map") {
          throw new Error("Unimplemented");
        }
      } else if (tmp2.nodeName === "resource") {
        Translations_default.add(tmp2.getAttribute("basename"));
      } else if (tmp2.nodeName === "stylesheet") {
        addLinkToHead("stylesheet", tmp2.getAttribute("name"));
      }
      tmp2 = tmp2.nextSibling;
    }
  }
  /**
   * Decodes the cells from the given node as templates.
   */
  decodeTemplates(dec2, node2, editor2) {
    if (editor2.templates == null) {
      editor2.templates = [];
    }
    const children = getChildNodes(node2);
    for (let j = 0; j < children.length; j++) {
      const name2 = children[j].getAttribute("as");
      let child2 = children[j].firstChild;
      while (child2 != null && child2.nodeType !== 1) {
        child2 = child2.nextSibling;
      }
      if (child2 != null) {
        editor2.templates[name2] = dec2.decodeCell(child2);
      }
    }
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/editor/EditorKeyHandlerCodec.js
var EditorKeyHandlerCodec = class extends ObjectCodec_default {
  constructor() {
    super(new EditorKeyHandler_default());
  }
  /**
   * Returns `null`.
   */
  encode(enc, obj2) {
    return null;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   *
   * add - Binds a keystroke to an action name.
   *
   * Attributes:
   *
   * as - Keycode.
   * action - Action name to execute in editor.
   * control - Optional boolean indicating if
   *     the control key must be pressed.
   *
   * Example:
   *
   * ```javascript
   * <EditorKeyHandler as="keyHandler">
   *   <add as="88" control="true" action="cut"/>
   *   <add as="67" control="true" action="copy"/>
   *   <add as="86" control="true" action="paste"/>
   * </EditorKeyHandler>
   * ```
   *
   * The keycodes are for the x, c and v keys.
   *
   * See also: <EditorKeyHandler.bindAction>, http://www.js-examples.com/page/tutorials__key_codes.html
   */
  decode(dec2, _node2, into2) {
    if (into2 != null) {
      const { editor: editor2 } = into2;
      let node2 = _node2.firstChild;
      while (node2 != null) {
        if (!this.processInclude(dec2, node2, into2) && node2.nodeName === "add") {
          const as2 = node2.getAttribute("as");
          const action2 = node2.getAttribute("action");
          const control = node2.getAttribute("control");
          into2.bindAction(as2, action2, control);
        }
        node2 = node2.nextSibling;
      }
    }
    return into2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/editor/EditorPopupMenuCodec.js
var EditorPopupMenuCodec = class extends ObjectCodec_default {
  constructor() {
    super(new EditorPopupMenu_default());
  }
  /**
   * Returns null.
   */
  encode(_enc, _obj) {
    return null;
  }
  /**
   * Uses the given node as the config for <EditorPopupMenu>.
   */
  decode(dec2, node2, into2) {
    const inc = node2.getElementsByTagName("include")[0];
    if (inc != null) {
      this.processInclude(dec2, inc, into2);
    } else if (into2 != null) {
      into2.config = node2;
    }
    return into2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/editor/EditorToolbarCodec.js
var EditorToolbarCodec = class _EditorToolbarCodec extends ObjectCodec_default {
  constructor() {
    super(new EditorToolbar());
  }
  /**
   * Returns `null`.
   */
  encode(_enc, _obj) {
    return null;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   *
   * add - Adds a new item to the toolbar. See below for attributes.
   * separator - Adds a vertical separator. No attributes.
   * hr - Adds a horizontal separator. No attributes.
   * br - Adds a linefeed. No attributes.
   *
   * Attributes:
   *
   * as - Resource key for the label.
   * action - Name of the action to execute in enclosing editor.
   * mode - Mode name (see below).
   * template - Template name for cell insertion.
   * style - Optional style to override the template style.
   * icon - Icon (relative/absolute URL).
   * pressedIcon - Optional icon for pressed state (relative/absolute URL).
   * id - Optional ID to be used for the created DOM element.
   * toggle - Optional 0 or 1 to disable toggling of the element. Default is 1 (true).
   *
   * The action, mode and template attributes are mutually exclusive. The style can only be used with the template attribute.
   * The add node may contain another sequence of add nodes with "as" and action attributes to create a combo box in the toolbar.
   * If the icon is specified then a list of the child node is expected to have its template attribute set and the action is ignored instead.
   *
   * Nodes with a specified template may define a function to be used for inserting the cloned template into the graph.
   * Here is an example of such a node:
   *
   * ```javascript
   * <add as="Swimlane" template="swimlane" icon="images/swimlane.gif"><![CDATA[
   *   function (editor, cell, evt, targetCell)
   *   {
   *     let pt = mxUtils.convertPoint(
   *       editor.graph.container, mxEvent.getClientX(evt),
   *         mxEvent.getClientY(evt));
   *     return editor.addVertex(targetCell, cell, pt.x, pt.y);
   *   }
   * ]]></add>
   * ```
   *
   * In the above function, editor is the enclosing {@link Editor} instance, cell is the clone of the template, evt is the mouse event that represents the
   * drop and targetCell is the cell under the mouse pointer where the drop occurred. The targetCell is retrieved using {@link Graph#getCellAt}.
   *
   * Furthermore, nodes with the mode attribute may define a function to be executed upon selection of the respective toolbar icon. In the
   * example below, the default edge style is set when this specific
   * connect-mode is activated:
   *
   * ```javascript
   * <add as="connect" mode="connect"><![CDATA[
   *   function (editor)
   *   {
   *     if (editor.defaultEdge != null)
   *     {
   *       editor.defaultEdge.style = 'straightEdge';
   *     }
   *   }
   * ]]></add>
   * ```
   *
   * Both functions require {@link allowEval} to be set to `true`.
   *
   * Modes:
   *
   * select - Left mouse button used for rubberband- & cell-selection.
   * connect - Allows connecting vertices by inserting new edges.
   * pan - Disables selection and switches to panning on the left button.
   *
   * Example:
   *
   * To add items to the toolbar:
   *
   * ```javascript
   * <EditorToolbar as="toolbar">
   *   <add as="save" action="save" icon="images/save.gif"/>
   *   <br/><hr/>
   *   <add as="select" mode="select" icon="images/select.gif"/>
   *   <add as="connect" mode="connect" icon="images/connect.gif"/>
   * </EditorToolbar>
   * ```
   */
  decode(dec, _node, into) {
    if (into != null) {
      const editor = into.editor;
      let node = _node.firstChild;
      while (node != null) {
        if (node.nodeType === NODETYPE.ELEMENT) {
          if (!this.processInclude(dec, node, into)) {
            if (node.nodeName === "separator") {
              into.addSeparator();
            } else if (node.nodeName === "br") {
              into.toolbar.addBreak();
            } else if (node.nodeName === "hr") {
              into.toolbar.addLine();
            } else if (node.nodeName === "add") {
              let as = node.getAttribute("as");
              as = Translations_default.get(as) || as;
              const icon = node.getAttribute("icon");
              const pressedIcon = node.getAttribute("pressedIcon");
              const action = node.getAttribute("action");
              const mode = node.getAttribute("mode");
              const template = node.getAttribute("template");
              const toggle = node.getAttribute("toggle") != "0";
              const text = getTextContent(node);
              let elt = null;
              let funct;
              if (action != null) {
                elt = into.addItem(as, icon, action, pressedIcon);
              } else if (mode != null) {
                funct = _EditorToolbarCodec.allowEval ? eval(text) : null;
                elt = into.addMode(as, icon, mode, pressedIcon, funct);
              } else if (template != null || text != null && text.length > 0) {
                let cell = template ? editor.templates[template] : null;
                const style = node.getAttribute("style");
                if (cell != null && style != null) {
                  cell = editor.graph.cloneCell(cell);
                  cell.setStyle(style);
                }
                let insertFunction = null;
                if (text != null && text.length > 0 && _EditorToolbarCodec.allowEval) {
                  insertFunction = eval(text);
                }
                elt = into.addPrototype(as, icon, cell, pressedIcon, insertFunction, toggle);
              } else {
                const children = getChildNodes(node);
                if (children.length > 0) {
                  if (icon == null) {
                    const combo = into.addActionCombo(as);
                    for (let i2 = 0; i2 < children.length; i2 += 1) {
                      const child2 = children[i2];
                      if (child2.nodeName === "separator") {
                        into.addOption(combo, "---");
                      } else if (child2.nodeName === "add") {
                        const lab = child2.getAttribute("as");
                        const act = child2.getAttribute("action");
                        into.addActionOption(combo, lab, act);
                      }
                    }
                  } else {
                    const select = into.addCombo();
                    const create = () => {
                      const template2 = editor.templates[select.value];
                      if (template2 != null) {
                        const clone2 = template2.clone();
                        const style2 = select.options[select.selectedIndex].cellStyle;
                        if (style2 != null) {
                          clone2.setStyle(style2);
                        }
                        return clone2;
                      }
                      GlobalConfig.logger.warn(`Template ${template2} not found`);
                      return null;
                    };
                    const img = into.addPrototype(as, icon, create, null, null, toggle);
                    InternalEvent_default.addListener(select, "change", () => {
                      into.toolbar.selectMode(img, (evt2) => {
                        const pt = convertPoint(editor.graph.container, getClientX(evt2), getClientY(evt2));
                        return editor.addVertex(null, funct(), pt.x, pt.y);
                      });
                      into.toolbar.noReset = false;
                    });
                    for (let i2 = 0; i2 < children.length; i2 += 1) {
                      const child2 = children[i2];
                      if (child2.nodeName === "separator") {
                        into.addOption(select, "---");
                      } else if (child2.nodeName === "add") {
                        const lab = child2.getAttribute("as");
                        const tmp2 = child2.getAttribute("template");
                        const option = into.addOption(select, lab, tmp2 || template);
                        option.cellStyle = child2.getAttribute("style");
                      }
                    }
                  }
                }
              }
              if (elt != null) {
                const id2 = node.getAttribute("id");
                if (id2 != null && id2.length > 0) {
                  elt.setAttribute("id", id2);
                }
              }
            }
          }
        }
        node = node.nextSibling;
      }
    }
    return into;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/CellCodec.js
var CellCodec = class extends ObjectCodec_default {
  constructor() {
    super(new Cell_default(), ["children", "edges", "overlays", "mxTransient"], ["parent", "source", "target"]);
    this.setName("Cell");
  }
  /**
   * Returns `true` since this is a cell codec.
   */
  isCellCodec() {
    return true;
  }
  /**
   * Overridden to disable conversion of value to number.
   */
  isNumericAttribute(dec2, attr, obj2) {
    return attr.nodeName !== "value" && super.isNumericAttribute(dec2, attr, obj2);
  }
  /**
   * Excludes user objects that are XML nodes.
   */
  isExcluded(obj2, attr, value2, isWrite) {
    return super.isExcluded(obj2, attr, value2, isWrite) || isWrite && attr === "value" && value2.nodeType === NODETYPE.ELEMENT;
  }
  /**
   * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).
   */
  afterEncode(enc, obj2, node2) {
    if (obj2.value != null && obj2.value.nodeType === NODETYPE.ELEMENT) {
      const tmp2 = node2;
      node2 = importNode(enc.document, obj2.value, true);
      node2.appendChild(tmp2);
      const id2 = tmp2.getAttribute("id");
      node2.setAttribute("id", String(id2));
      tmp2.removeAttribute("id");
    }
    return node2;
  }
  /**
   * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).
   */
  beforeDecode(dec2, node2, obj2) {
    let inner = node2.cloneNode(true);
    const classname = this.getName();
    if (node2.nodeName !== classname) {
      const tmp2 = node2.getElementsByTagName(classname)[0];
      if (tmp2 != null && tmp2.parentNode === node2) {
        removeWhitespace(tmp2, true);
        removeWhitespace(tmp2, false);
        tmp2.parentNode.removeChild(tmp2);
        inner = tmp2;
      } else {
        inner = null;
      }
      obj2.value = node2.cloneNode(true);
      const id2 = obj2.value.getAttribute("id");
      if (id2 != null) {
        obj2.setId(id2);
        obj2.value.removeAttribute("id");
      }
    } else {
      obj2.setId(node2.getAttribute("id"));
    }
    if (inner != null) {
      for (let i2 = 0; i2 < this.idrefs.length; i2 += 1) {
        const attr = this.idrefs[i2];
        const ref = inner.getAttribute(attr);
        if (ref != null) {
          inner.removeAttribute(attr);
          let object = dec2.objects[ref] || dec2.lookup(ref);
          if (object == null) {
            const element = dec2.getElementById(ref);
            if (element != null) {
              const decoder = CodecRegistry_default.codecs[element.nodeName] || this;
              object = decoder.decode(dec2, element);
            }
          }
          obj2[attr] = object;
        }
      }
    }
    return inner;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/ChildChangeCodec.js
var ChildChangeCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new ChildChange_default(__dummy, __dummy, __dummy), ["model", "child", "previousIndex"], ["parent", "previous"]);
  }
  /**
   * Returns `true` for the child attribute if the child cell had a previous parent or if we're reading the
   * child as an attribute rather than a child node, in which case it's always a reference.
   */
  isReference(obj2, attr, value2, isWrite) {
    if (attr === "child" && (!isWrite || obj2.model.contains(obj2.previous))) {
      return true;
    }
    return this.idrefs.indexOf(attr) >= 0;
  }
  /**
   * Excludes references to parent or previous if not in the model.
   */
  isExcluded(obj2, attr, value2, write2) {
    return super.isExcluded(obj2, attr, value2, write2) || write2 && value2 != null && (attr === "previous" || attr === "parent") && !obj2.model.contains(value2);
  }
  /**
   * Encodes the child recursively and adds the result to the given node.
   */
  afterEncode(enc, obj2, node2) {
    if (this.isReference(obj2, "child", obj2.child, true)) {
      node2.setAttribute("child", enc.getId(obj2.child));
    } else {
      enc.encodeCell(obj2.child, node2);
    }
    return node2;
  }
  /**
   * Decodes any child nodes as using the respective codec from the registry.
   */
  beforeDecode(dec2, _node2, obj2) {
    if (_node2.firstChild != null && _node2.firstChild.nodeType === NODETYPE.ELEMENT) {
      const node2 = _node2.cloneNode(true);
      let tmp2 = node2.firstChild;
      obj2.child = dec2.decodeCell(tmp2, false);
      let tmp22 = tmp2.nextSibling;
      tmp2.parentNode.removeChild(tmp2);
      tmp2 = tmp22;
      while (tmp2 != null) {
        tmp22 = tmp2.nextSibling;
        if (tmp2.nodeType === NODETYPE.ELEMENT) {
          const id2 = tmp2.getAttribute("id");
          if (dec2.lookup(id2) == null) {
            dec2.decodeCell(tmp2);
          }
        }
        tmp2.parentNode.removeChild(tmp2);
        tmp2 = tmp22;
      }
      return node2;
    } else {
      const childRef = _node2.getAttribute("child");
      obj2.child = dec2.getObject(childRef);
      return _node2;
    }
  }
  /**
   * Restores object state in the child change.
   */
  afterDecode(dec2, node2, obj2) {
    if (obj2.child != null) {
      if (obj2.child.parent != null && obj2.previous != null && obj2.child.parent !== obj2.previous) {
        obj2.previous = obj2.child.parent;
      }
      obj2.child.parent = obj2.previous;
      obj2.previous = obj2.parent;
      obj2.previousIndex = obj2.index;
    }
    return obj2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/GenericChangeCodec.js
var GenericChangeCodec = class extends ObjectCodec_default {
  /**
   *
   * @param obj An instance of the change object.
   * @param variable The field name for the change data.
   */
  constructor(obj2, variable) {
    super(obj2, ["model", "previous"], ["cell"]);
    this.variable = variable;
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(dec2, _node2, obj2) {
    if (isNode(obj2.cell)) {
      obj2.cell = dec2.decodeCell(obj2.cell, false);
    }
    obj2.previous = obj2[this.variable];
    return obj2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/GraphCodec.js
var GraphCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new Graph(__dummy), [
      "graphListeners",
      "eventListeners",
      "view",
      "container",
      "cellRenderer",
      "editor",
      "selection"
    ]);
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/GraphViewCodec.js
var GraphViewCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new GraphView_default(__dummy));
  }
  /**
   * Encodes the given {@link GraphView} using {@link encodeCell} starting at the model's root. This returns the
   * top-level graph node of the recursive encoding.
   */
  encode(enc, view) {
    return this.encodeCell(enc, view, view.graph.getDataModel().getRoot());
  }
  /**
   * Recursively encodes the specified cell.
   *
   * Uses layer as the default node name. If the cell's parent is null, then graph is used for the node name.
   * If {@link Cell.isEdge} returns `true` for the cell, then edge is used for the node name, else if {@link Cell.isVertex} returns `true` for the cell,
   * then vertex is used for the node name.
   *
   * {@link Graph.getLabel} is used to create the label attribute for the cell.
   * For graph nodes and vertices the bounds are encoded into x, y, width and height.
   * For edges the points are encoded into a points attribute as a space-separated list of comma-separated coordinate pairs (e.g. x0,y0 x1,y1 ... xn,yn).
   * All values from the cell style are added as attribute values to the node.
   */
  encodeCell(enc, view, cell2) {
    let node2;
    const model2 = view.graph.getDataModel();
    const state2 = view.getState(cell2);
    const parent2 = cell2.getParent();
    if (parent2 == null || state2 != null) {
      const childCount2 = cell2.getChildCount();
      const geo = cell2.getGeometry();
      let name2 = null;
      if (parent2 === model2.getRoot()) {
        name2 = "layer";
      } else if (parent2 == null) {
        name2 = "graph";
      } else if (cell2.isEdge()) {
        name2 = "edge";
      } else if (childCount2 > 0 && geo != null) {
        name2 = "group";
      } else if (cell2.isVertex()) {
        name2 = "vertex";
      }
      if (name2 != null) {
        node2 = enc.document.createElement(name2);
        const lab = view.graph.getLabel(cell2);
        if (lab != null) {
          node2.setAttribute("label", view.graph.getLabel(cell2));
          if (view.graph.isHtmlLabel(cell2)) {
            node2.setAttribute("html", true);
          }
        }
        if (parent2 == null) {
          const bounds = view.getGraphBounds();
          if (bounds != null) {
            node2.setAttribute("x", Math.round(bounds.x));
            node2.setAttribute("y", Math.round(bounds.y));
            node2.setAttribute("width", Math.round(bounds.width));
            node2.setAttribute("height", Math.round(bounds.height));
          }
          node2.setAttribute("scale", view.scale);
        } else if (state2 != null && geo != null) {
          for (const i2 in state2.style) {
            let value2 = state2.style[i2];
            if (typeof value2 === "function" && typeof value2 === "object") {
              value2 = StyleRegistry_default.getName(value2);
            }
            if (value2 != null && typeof value2 !== "function" && typeof value2 !== "object") {
              node2.setAttribute(i2, value2);
            }
          }
          const abs = state2.absolutePoints;
          if (abs != null && abs.length > 0) {
            let pts = `${Math.round(abs[0].x)},${Math.round(abs[0].y)}`;
            for (let i2 = 1; i2 < abs.length; i2 += 1) {
              pts += ` ${Math.round(abs[i2].x)},${Math.round(abs[i2].y)}`;
            }
            node2.setAttribute("points", pts);
          } else {
            node2.setAttribute("x", Math.round(state2.x));
            node2.setAttribute("y", Math.round(state2.y));
            node2.setAttribute("width", Math.round(state2.width));
            node2.setAttribute("height", Math.round(state2.height));
          }
          const offset = state2.absoluteOffset;
          if (offset != null) {
            if (offset.x !== 0) {
              node2.setAttribute("dx", Math.round(offset.x));
            }
            if (offset.y !== 0) {
              node2.setAttribute("dy", Math.round(offset.y));
            }
          }
        }
        for (let i2 = 0; i2 < childCount2; i2 += 1) {
          const childNode = this.encodeCell(enc, view, cell2.getChildAt(i2));
          if (childNode != null) {
            node2.appendChild(childNode);
          }
        }
      }
    }
    return node2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/ModelCodec.js
var ModelCodec = class extends ObjectCodec_default {
  constructor() {
    super(new GraphDataModel_default());
    this.setName("GraphDataModel");
  }
  /**
   * Encodes the given {@link GraphDataModel} by writing a (flat) XML sequence of cell nodes as produced by the {@link CellCodec}.
   * The sequence is wrapped-up in a node with the name `root`.
   */
  encodeObject(enc, obj2, node2) {
    const rootNode = enc.document.createElement("root");
    enc.encodeCell(obj2.getRoot(), rootNode);
    node2.appendChild(rootNode);
  }
  /**
   * Overrides decode child to handle special child nodes.
   */
  decodeChild(dec2, child2, obj2) {
    if (child2.nodeName === "root") {
      this.decodeRoot(dec2, child2, obj2);
    } else {
      this.decodeChild.apply(this, [dec2, child2, obj2]);
    }
  }
  /**
   * Reads the cells into the graph model. All cells are children of the root element in the node.
   */
  decodeRoot(dec2, root, model2) {
    let rootCell = null;
    let tmp2 = root.firstChild;
    while (tmp2 != null) {
      const cell2 = dec2.decodeCell(tmp2);
      if (cell2 != null && cell2.getParent() == null) {
        rootCell = cell2;
      }
      tmp2 = tmp2.nextSibling;
    }
    if (rootCell != null) {
      model2.setRoot(rootCell);
    }
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/RootChangeCodec.js
var RootChangeCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new RootChange_default(__dummy, __dummy), ["model", "previous", "root"]);
  }
  /**
   * Encodes the child recursively.
   */
  afterEncode(enc, obj2, node2) {
    enc.encodeCell(obj2.root, node2);
    return node2;
  }
  /**
   * Decodes the optional children as cells using the respective decoder.
   */
  beforeDecode(dec2, node2, obj2) {
    if (node2.firstChild != null && node2.firstChild.nodeType === NODETYPE.ELEMENT) {
      node2 = node2.cloneNode(true);
      let tmp2 = node2.firstChild;
      obj2.root = dec2.decodeCell(tmp2, false);
      let tmp22 = tmp2.nextSibling;
      tmp2.parentNode.removeChild(tmp2);
      tmp2 = tmp22;
      while (tmp2 != null) {
        tmp22 = tmp2.nextSibling;
        dec2.decodeCell(tmp2);
        tmp2.parentNode.removeChild(tmp2);
        tmp2 = tmp22;
      }
    }
    return node2;
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(_dec, _node2, obj2) {
    obj2.previous = obj2.root;
    return obj2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/StylesheetCodec.js
var StylesheetCodec = class _StylesheetCodec extends ObjectCodec_default {
  constructor() {
    super(new Stylesheet());
  }
  /**
   * Encodes a stylesheet. See {@link decode} for a description of the format.
   */
  encode(enc, obj2) {
    const node2 = enc.document.createElement(this.getName());
    for (const i2 in obj2.styles) {
      const style2 = obj2.styles[i2];
      const styleNode = enc.document.createElement("add");
      if (i2 != null) {
        styleNode.setAttribute("as", i2);
        for (const j in style2) {
          const value2 = this.getStringValue(j, style2[j]);
          if (value2 != null) {
            const entry2 = enc.document.createElement("add");
            entry2.setAttribute("value", value2);
            entry2.setAttribute("as", j);
            styleNode.appendChild(entry2);
          }
        }
        if (styleNode.childNodes.length > 0) {
          node2.appendChild(styleNode);
        }
      }
    }
    return node2;
  }
  /**
   * Returns the string for encoding the given value.
   */
  getStringValue(key2, value2) {
    const type = typeof value2;
    if (type === "function") {
      value2 = StyleRegistry_default.getName(value2);
    } else if (type === "object") {
      value2 = null;
    }
    return value2;
  }
  /**
   * Reads a sequence of the following child nodes and attributes:
   *
   * Child Nodes:
   *
   * add - Adds a new style.
   *
   * Attributes:
   *
   * as - Name of the style.
   * extend - Name of the style to inherit from.
   *
   * Each node contains another sequence of add and remove nodes with the following attributes:
   *
   * as - Name of the style (see {@link Constants}).
   * value - Value for the style.
   *
   * Instead of the value-attribute, one can put Javascript expressions into the node as follows if {@link allowEval} is `true`:
   * <add as="perimeter">mxPerimeter.RectanglePerimeter</add>
   *
   * A remove node will remove the entry with the name given in the as-attribute from the style.
   *
   * Example:
   *
   * ```javascript
   * <mxStylesheet as="stylesheet">
   *   <add as="text">
   *     <add as="fontSize" value="12"/>
   *   </add>
   *   <add as="defaultVertex" extend="text">
   *     <add as="shape" value="rectangle"/>
   *   </add>
   * </mxStylesheet>
   * ```
   */
  decode(dec, _node, into) {
    const obj = into || new this.template.constructor();
    const id = _node.getAttribute("id");
    if (id != null) {
      dec.objects[id] = obj;
    }
    let node = _node.firstChild;
    while (node != null) {
      if (!this.processInclude(dec, node, obj) && node.nodeName === "add") {
        const as = node.getAttribute("as");
        if (as != null) {
          const extend = node.getAttribute("extend");
          let style = extend != null ? clone(obj.styles[extend]) : null;
          if (style == null) {
            if (extend != null) {
              GlobalConfig.logger.warn(`StylesheetCodec.decode: stylesheet ${extend} not found to extend`);
            }
            style = {};
          }
          let entry = node.firstChild;
          while (entry != null) {
            if (entry.nodeType === NODETYPE.ELEMENT) {
              const key = entry.getAttribute("as");
              if (entry.nodeName === "add") {
                const text = getTextContent(entry);
                let value = null;
                if (text != null && text.length > 0 && _StylesheetCodec.allowEval) {
                  value = eval(text);
                } else {
                  value = entry.getAttribute("value");
                  if (isNumeric(value)) {
                    value = parseFloat(value);
                  }
                }
                if (value != null) {
                  style[key] = value;
                }
              } else if (entry.nodeName === "remove") {
                delete style[key];
              }
            }
            entry = entry.nextSibling;
          }
          obj.putCellStyle(as, style);
        }
      }
      node = node.nextSibling;
    }
    return obj;
  }
};
StylesheetCodec.allowEval = true;

// node_modules/@maxgraph/core/lib/serialization/codecs/TerminalChangeCodec.js
var TerminalChangeCodec = class extends ObjectCodec_default {
  constructor() {
    const __dummy = void 0;
    super(new TerminalChange_default(__dummy, __dummy, __dummy, __dummy), ["model", "previous"], ["cell", "terminal"]);
  }
  /**
   * Restores the state by assigning the previous value.
   */
  afterDecode(_dec, _node2, obj2) {
    obj2.previous = obj2.terminal;
    return obj2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/mxGraph/utils.js
var fieldMapping = /* @__PURE__ */ new Map([["autosize", "autoSize"]]);
function convertStyleFromString(input) {
  const style2 = {};
  input.startsWith(";") && (style2.ignoreDefaultStyle = true);
  const elements = input.split(";").filter(([k]) => k);
  for (const element of elements) {
    if (!element.includes("=")) {
      !style2.baseStyleNames && (style2.baseStyleNames = []);
      style2.baseStyleNames.push(element);
    } else {
      const [key2, value2] = element.split("=");
      style2[fieldMapping.get(key2) ?? key2] = convertToNumericIfNeeded(value2);
    }
  }
  return style2;
}
function convertToNumericIfNeeded(value2) {
  if (!isNumeric(value2)) {
    return value2;
  }
  let numericValue = parseFloat(value2);
  if (Number.isNaN(numericValue) || !Number.isFinite(numericValue)) {
    numericValue = 0;
  }
  return numericValue;
}

// node_modules/@maxgraph/core/lib/serialization/codecs/mxGraph/mxCellCodec.js
var mxCellCodec = class extends CellCodec {
  getName() {
    return "mxCell";
  }
  decodeAttribute(dec2, attr, obj2) {
    const attributeNodeName = attr.nodeName;
    if (obj2 && attributeNodeName == "style") {
      obj2["style"] = convertStyleFromString(attr.value);
    } else {
      super.decodeAttribute(dec2, attr, obj2);
    }
  }
};

// node_modules/@maxgraph/core/lib/serialization/codecs/mxGraph/mxGeometryCodec.js
var mxGeometryCodec = class extends ObjectCodec_default {
  getName() {
    return "mxGeometry";
  }
  constructor() {
    super(new Geometry_default());
  }
  afterDecode(dec2, node2, obj2) {
    const originalPoints = obj2.points;
    if (originalPoints) {
      const points2 = [];
      for (const pointInput of originalPoints) {
        const rawPoint = pointInput;
        points2.push(new Point_default(rawPoint.x, rawPoint.y));
      }
      obj2.points = points2;
    }
    return obj2;
  }
};

// node_modules/@maxgraph/core/lib/serialization/register.js
var registerGenericChangeCodecs = () => {
  const __dummy = void 0;
  CodecRegistry_default.register(new GenericChangeCodec(new CellAttributeChange_default(__dummy, __dummy, __dummy), "value"));
  CodecRegistry_default.register(new GenericChangeCodec(new CollapseChange_default(__dummy, __dummy, __dummy), "collapsed"));
  CodecRegistry_default.register(new GenericChangeCodec(new GeometryChange_default(__dummy, __dummy, __dummy), "geometry"));
  CodecRegistry_default.register(new GenericChangeCodec(new StyleChange_default(__dummy, __dummy, __dummy), "style"));
  CodecRegistry_default.register(new GenericChangeCodec(new ValueChange_default(__dummy, __dummy, __dummy), "value"));
  CodecRegistry_default.register(new GenericChangeCodec(new VisibleChange_default(__dummy, __dummy, __dummy), "visible"));
};
var createObjectCodec = (template2, name2) => {
  const objectCodec = new ObjectCodec_default(template2);
  objectCodec.setName(name2);
  return objectCodec;
};
var isModelCodecsRegistered = false;
var registerModelCodecs = (force = false) => {
  if (!isModelCodecsRegistered || force) {
    CodecRegistry_default.register(new CellCodec());
    CodecRegistry_default.register(new ModelCodec());
    CodecRegistry_default.register(createObjectCodec(new Geometry_default(), "Geometry"));
    CodecRegistry_default.register(createObjectCodec(new Point_default(), "Point"));
    CodecRegistry_default.register(new ObjectCodec_default({}));
    CodecRegistry_default.register(new ObjectCodec_default([]));
    CodecRegistry_default.addAlias("mxGraphModel", "GraphDataModel");
    CodecRegistry_default.addAlias("mxPoint", "Point");
    CodecRegistry_default.register(new mxCellCodec(), false);
    CodecRegistry_default.register(new mxGeometryCodec(), false);
    isModelCodecsRegistered = true;
  }
};
var isCoreCodecsRegistered = false;
var registerCoreCodecs = (force = false) => {
  if (!isCoreCodecsRegistered || force) {
    CodecRegistry_default.register(new ChildChangeCodec());
    CodecRegistry_default.register(new GraphCodec());
    CodecRegistry_default.register(new GraphViewCodec());
    CodecRegistry_default.register(new RootChangeCodec());
    CodecRegistry_default.register(new StylesheetCodec());
    CodecRegistry_default.register(new TerminalChangeCodec());
    registerGenericChangeCodecs();
    registerModelCodecs(force);
    isCoreCodecsRegistered = true;
  }
};
var isEditorCodecsRegistered = false;
var registerEditorCodecs = (force = false) => {
  if (!isEditorCodecsRegistered || force) {
    CodecRegistry_default.register(new EditorCodec());
    CodecRegistry_default.register(new EditorKeyHandlerCodec());
    CodecRegistry_default.register(new EditorPopupMenuCodec());
    CodecRegistry_default.register(new EditorToolbarCodec());
    isEditorCodecsRegistered = true;
  }
};
var registerAllCodecs = (force = false) => {
  registerCoreCodecs(force);
  registerEditorCodecs(force);
};

// node_modules/@maxgraph/core/lib/serialization/ModelXmlSerializer.js
var ModelXmlSerializer = class {
  constructor(dataModel) {
    this.dataModel = dataModel;
    this.registerCodecs();
  }
  import(input) {
    const doc = typeof input === "string" ? parseXml(input) : input.ownerDocument;
    new Codec_default(doc).decode(doc.documentElement, this.dataModel);
  }
  export(options) {
    const encodedNode = new Codec_default().encode(this.dataModel);
    return (options == null ? void 0 : options.pretty) ?? true ? getPrettyXml(encodedNode) : getXml(encodedNode);
  }
  /**
   * Hook for replacing codecs registered by default (model codecs).
   */
  registerCodecs() {
    registerModelCodecs();
  }
};

// node_modules/@maxgraph/core/lib/gui/MaxForm.js
var MaxForm = class {
  constructor(className) {
    this.table = document.createElement("table");
    this.table.className = className;
    this.body = document.createElement("tbody");
    this.table.appendChild(this.body);
  }
  /**
   * Returns the table that contains this form.
   */
  getTable() {
    return this.table;
  }
  /**
   * Helper method to add an OK and Cancel button using the respective
   * functions.
   */
  addButtons(okFunct, cancelFunct) {
    const tr = document.createElement("tr");
    let td = document.createElement("td");
    tr.appendChild(td);
    td = document.createElement("td");
    let button2 = document.createElement("button");
    write(button2, Translations_default.get("ok") || "OK");
    td.appendChild(button2);
    InternalEvent_default.addListener(button2, "click", () => {
      okFunct();
    });
    button2 = document.createElement("button");
    write(button2, Translations_default.get("cancel") || "Cancel");
    td.appendChild(button2);
    InternalEvent_default.addListener(button2, "click", () => {
      cancelFunct();
    });
    tr.appendChild(td);
    this.body.appendChild(tr);
  }
  /**
   * Adds an input for the given name, type and value and returns it.
   */
  addText(name2, value2, type = "text") {
    const input = document.createElement("input");
    input.setAttribute("type", type);
    input.value = value2;
    return this.addField(name2, input);
  }
  /**
   * Adds a checkbox for the given name and value and returns the textfield.
   */
  addCheckbox(name2, value2) {
    const input = document.createElement("input");
    input.setAttribute("type", "checkbox");
    this.addField(name2, input);
    if (value2) {
      input.checked = true;
    }
    return input;
  }
  /**
   * Adds a textarea for the given name and value and returns the textarea.
   */
  addTextarea(name2, value2, rows) {
    const input = document.createElement("textarea");
    if (Client_default.IS_NS) {
      rows--;
    }
    input.setAttribute("rows", String(rows || 2));
    input.value = value2;
    return this.addField(name2, input);
  }
  /**
   * Adds a combo for the given name and returns the combo.
   */
  addCombo(name2, isMultiSelect, size) {
    const select = document.createElement("select");
    if (size != null) {
      select.setAttribute("size", String(size));
    }
    if (isMultiSelect) {
      select.setAttribute("multiple", "true");
    }
    return this.addField(name2, select);
  }
  /**
   * Adds an option for the given label to the specified combo.
   */
  addOption(combo, label, value2, isSelected) {
    const option = document.createElement("option");
    writeln(option, label);
    option.setAttribute("value", value2);
    if (isSelected) {
      option.setAttribute("selected", String(isSelected));
    }
    combo.appendChild(option);
  }
  /**
   * Adds a new row with the name and the input field in two columns and
   * returns the given input.
   */
  addField(name2, input) {
    const tr = document.createElement("tr");
    let td = document.createElement("td");
    write(td, name2);
    tr.appendChild(td);
    td = document.createElement("td");
    td.appendChild(input);
    tr.appendChild(td);
    this.body.appendChild(tr);
    return input;
  }
};
var MaxForm_default = MaxForm;

// node_modules/@maxgraph/core/lib/util/Clipboard.js
var Clipboard = class _Clipboard {
  /**
   * Sets the cells in the clipboard. Fires a {@link mxEvent.CHANGE} event.
   */
  static setCells(cells) {
    _Clipboard.cells = cells;
  }
  /**
   * Returns  the cells in the clipboard.
   */
  static getCells() {
    return _Clipboard.cells;
  }
  /**
   * Returns true if the clipboard currently has not data stored.
   */
  static isEmpty() {
    return !_Clipboard.getCells();
  }
  /**
   * Cuts the given array of {@link mxCell} from the specified graph.
   * If cells is null then the selection cells of the graph will
   * be used. Returns the cells that have been cut from the graph.
   *
   * @param graph - {@link graph} that contains the cells to be cut.
   * @param cells - Optional array of {@link mxCell} to be cut.
   */
  static cut(graph, cells = []) {
    cells = _Clipboard.copy(graph, cells);
    _Clipboard.insertCount = 0;
    _Clipboard.removeCells(graph, cells);
    return cells;
  }
  /**
   * Hook to remove the given cells from the given graph after
   * a cut operation.
   *
   * @param graph - {@link graph} that contains the cells to be cut.
   * @param cells - Array of {@link mxCell} to be cut.
   */
  static removeCells(graph, cells) {
    graph.removeCells(cells);
  }
  /**
   * Copies the given array of {@link mxCell} from the specified
   * graph to {@link cells}. Returns the original array of cells that has
   * been cloned. Descendants of cells in the array are ignored.
   *
   * @param graph - {@link graph} that contains the cells to be copied.
   * @param cells - Optional array of {@link mxCell} to be copied.
   */
  static copy(graph, cells) {
    cells = cells || graph.getSelectionCells();
    const result2 = getTopmostCells(graph.getExportableCells(cells));
    _Clipboard.insertCount = 1;
    _Clipboard.setCells(graph.cloneCells(result2));
    return result2;
  }
  /**
   * Pastes the {@link cells} into the specified graph restoring
   * the relation to {@link parents}, if possible. If the parents
   * are no longer in the graph or invisible then the
   * cells are added to the graph's default or into the
   * swimlane under the cell's new location if one exists.
   * The cells are added to the graph using {@link graph.importCells}
   * and returned.
   *
   * @param graph - {@link graph} to paste the {@link cells} into.
   */
  static paste(graph) {
    let cells = null;
    if (!_Clipboard.isEmpty() && _Clipboard.getCells()) {
      cells = graph.getImportableCells(_Clipboard.getCells());
      const delta = _Clipboard.insertCount * _Clipboard.STEPSIZE;
      const parent2 = graph.getDefaultParent();
      cells = graph.importCells(cells, delta, delta, parent2);
      _Clipboard.insertCount++;
      graph.setSelectionCells(cells);
    }
    return cells;
  }
};
Clipboard.STEPSIZE = 10;
Clipboard.insertCount = 1;
var Clipboard_default = Clipboard;

// node_modules/@maxgraph/core/lib/gui/MaxLog.js
var MaxLog = class _MaxLog {
  /**
   * Initializes the DOM node for the console.
   * This requires `document.body` to point to a non-null value.
   * This is called from within setVisible if the log has not yet been initialized.
   */
  static init() {
    if (_MaxLog.window == null && document.body != null) {
      const title = `${_MaxLog.consoleName} - mxGraph ${Client_default.VERSION}`;
      const table = document.createElement("table");
      table.setAttribute("width", "100%");
      table.setAttribute("height", "100%");
      const tbody = document.createElement("tbody");
      let tr = document.createElement("tr");
      const td = document.createElement("td");
      td.style.verticalAlign = "top";
      _MaxLog.textarea = document.createElement("textarea");
      _MaxLog.textarea.setAttribute("wrap", "off");
      _MaxLog.textarea.setAttribute("readOnly", "true");
      _MaxLog.textarea.style.height = "100%";
      _MaxLog.textarea.style.resize = "none";
      _MaxLog.textarea.value = _MaxLog.buffer;
      if (Client_default.IS_NS && document.compatMode !== "BackCompat") {
        _MaxLog.textarea.style.width = "99%";
      } else {
        _MaxLog.textarea.style.width = "100%";
      }
      td.appendChild(_MaxLog.textarea);
      tr.appendChild(td);
      tbody.appendChild(tr);
      tr = document.createElement("tr");
      _MaxLog.td = document.createElement("td");
      _MaxLog.td.style.verticalAlign = "top";
      _MaxLog.td.setAttribute("height", "30px");
      tr.appendChild(_MaxLog.td);
      tbody.appendChild(tr);
      table.appendChild(tbody);
      _MaxLog.addButton("Info", function(evt2) {
        _MaxLog.info();
      });
      _MaxLog.addButton("DOM", function(evt2) {
        const content = getInnerHtml(document.body);
        _MaxLog.debug(content);
      });
      _MaxLog.addButton("Trace", function(evt2) {
        _MaxLog.TRACE = !_MaxLog.TRACE;
        if (_MaxLog.TRACE) {
          _MaxLog.debug("Tracing enabled");
        } else {
          _MaxLog.debug("Tracing disabled");
        }
      });
      _MaxLog.addButton("Copy", function(evt2) {
        try {
          copyTextToClipboard(_MaxLog.textarea.value);
        } catch (err) {
          alert(err);
        }
      });
      _MaxLog.addButton("Show", function(evt2) {
        try {
          popup(_MaxLog.textarea.value);
        } catch (err) {
          alert(err);
        }
      });
      _MaxLog.addButton("Clear", function(evt2) {
        _MaxLog.textarea.value = "";
      });
      let h = 0;
      let w = 0;
      if (typeof window.innerWidth === "number") {
        h = window.innerHeight;
        w = window.innerWidth;
      } else {
        h = document.documentElement.clientHeight || document.body.clientHeight;
        w = document.body.clientWidth;
      }
      _MaxLog.window = new MaxWindow_default(title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);
      _MaxLog.window.setMaximizable(true);
      _MaxLog.window.setScrollable(false);
      _MaxLog.window.setResizable(true);
      _MaxLog.window.setClosable(true);
      _MaxLog.window.destroyOnClose = false;
      if (Client_default.IS_NS && !Client_default.IS_GC && !Client_default.IS_SF && document.compatMode !== "BackCompat") {
        const elt2 = _MaxLog.window.getElement();
        const resizeHandler = (sender, evt2) => {
          _MaxLog.textarea.style.height = `${Math.max(0, elt2.offsetHeight - 70)}px`;
        };
        _MaxLog.window.addListener(InternalEvent_default.RESIZE_END, resizeHandler);
        _MaxLog.window.addListener(InternalEvent_default.MAXIMIZE, resizeHandler);
        _MaxLog.window.addListener(InternalEvent_default.NORMALIZE, resizeHandler);
        _MaxLog.textarea.style.height = "92px";
      }
    }
  }
  /**
   * Writes the current navigator information to the console.
   */
  static info() {
    _MaxLog.writeln(toString(navigator));
  }
  /**
   * Adds a button to the console using the given label and function.
   */
  static addButton(lab, funct2) {
    const button2 = document.createElement("button");
    write(button2, lab);
    InternalEvent_default.addListener(button2, "click", funct2);
    _MaxLog.td.appendChild(button2);
  }
  /**
   * Returns `true` if the console is visible.
   */
  static isVisible() {
    if (_MaxLog.window != null) {
      return _MaxLog.window.isVisible();
    }
    return false;
  }
  /**
   * Shows the console.
   */
  static show() {
    _MaxLog.setVisible(true);
  }
  /**
   * Shows or hides the console.
   */
  static setVisible(visible) {
    if (_MaxLog.window == null) {
      _MaxLog.init();
    }
    if (_MaxLog.window != null) {
      _MaxLog.window.setVisible(visible);
    }
  }
  /**
   * Writes the specified string to the console if {@link TRACE} is `true` and returns the current time in milliseconds.
   */
  static enter(string) {
    if (_MaxLog.TRACE) {
      _MaxLog.writeln(`Entering ${string}`);
      return (/* @__PURE__ */ new Date()).getTime();
    }
  }
  /**
   * Writes the specified string to the console if {@link TRACE} is `true` and computes the difference between the current
   * time and t0 in milliseconds.
   *
   * @see {@link enter} for an example.
   */
  static leave(string, t0) {
    if (_MaxLog.TRACE) {
      const dt = getElapseMillisecondsMessage(t0);
      _MaxLog.writeln(`Leaving ${string}${dt}`);
    }
  }
  /**
   * Adds all arguments to the console if {@link DEBUG} is enabled.
   */
  static debug(...args) {
    if (_MaxLog.DEBUG) {
      _MaxLog.writeln(...args);
    }
  }
  /**
   * Adds all arguments to the console if {@link TRACE} is enabled.
   */
  static trace(...args) {
    if (_MaxLog.TRACE) {
      _MaxLog.writeln(...args);
    }
  }
  /**
   * Adds all arguments to the console if {@link WARN} is enabled.
   */
  static warn(...args) {
    if (_MaxLog.WARN) {
      _MaxLog.writeln(...args);
    }
  }
  /**
   * Adds the specified strings to the console.
   */
  static write(...args) {
    let string = "";
    for (let i2 = 0; i2 < args.length; i2 += 1) {
      string += args[i2];
      if (i2 < args.length - 1) {
        string += " ";
      }
    }
    if (_MaxLog.textarea != null) {
      _MaxLog.textarea.value = _MaxLog.textarea.value + string;
      if (navigator.userAgent != null && navigator.userAgent.indexOf("Presto/2.5") >= 0) {
        _MaxLog.textarea.style.visibility = "hidden";
        _MaxLog.textarea.style.visibility = "visible";
      }
      _MaxLog.textarea.scrollTop = _MaxLog.textarea.scrollHeight;
    } else {
      _MaxLog.buffer += string;
    }
  }
  /**
   * Adds the specified strings to the console, appending a linefeed at the end of each string.
   */
  static writeln(...args) {
    let string = "";
    for (let i2 = 0; i2 < args.length; i2 += 1) {
      string += args[i2];
      if (i2 < args.length - 1) {
        string += " ";
      }
    }
    _MaxLog.write(`${string}
`);
  }
};
MaxLog.textarea = null;
MaxLog.consoleName = "Console";
MaxLog.TRACE = false;
MaxLog.DEBUG = true;
MaxLog.WARN = true;
MaxLog.buffer = "";
var MaxLog_default = MaxLog;

// node_modules/@maxgraph/core/lib/view/handler/RubberBandHandler.js
var RubberBandHandler = class {
  constructor(graph) {
    this.first = null;
    this.destroyed = false;
    this.dragHandler = null;
    this.dropHandler = null;
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    this.defaultOpacity = 20;
    this.enabled = true;
    this.div = null;
    this.sharedDiv = null;
    this.currentX = 0;
    this.currentY = 0;
    this.fadeOut = false;
    this.graph = graph;
    this.graph.addMouseListener(this);
    this.forceRubberbandHandler = (sender, evt2) => {
      const evtName = evt2.getProperty("eventName");
      const me = evt2.getProperty("event");
      if (evtName === InternalEvent_default.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {
        const offset = getOffset(this.graph.container);
        const origin = getScrollOrigin(this.graph.container);
        origin.x -= offset.x;
        origin.y -= offset.y;
        this.start(me.getX() + origin.x, me.getY() + origin.y);
        me.consume(false);
      }
    };
    this.graph.addListener(InternalEvent_default.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);
    this.panHandler = () => {
      this.repaint();
    };
    this.graph.addListener(InternalEvent_default.PAN, this.panHandler);
    this.gestureHandler = (sender, eo) => {
      if (this.first) {
        this.reset();
      }
    };
    this.graph.addListener(InternalEvent_default.GESTURE, this.gestureHandler);
  }
  /**
   * Creates the rubberband selection shape.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation updates
   * <enabled>.
   */
  setEnabled(enabled2) {
    this.enabled = enabled2;
  }
  /**
   * Returns true if the given {@link MouseEvent} should start rubberband selection.
   * This implementation returns true if the alt key is pressed.
   */
  isForceRubberbandEvent(me) {
    return isAltDown(me.getEvent());
  }
  /**
   * Handles the event by initiating a rubberband selection. By consuming the
   * event all subsequent events of the gesture are redirected to this
   * handler.
   */
  mouseDown(sender, me) {
    if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && !me.getState() && !isMultiTouchEvent(me.getEvent())) {
      const offset = getOffset(this.graph.container);
      const origin = getScrollOrigin(this.graph.container);
      origin.x -= offset.x;
      origin.y -= offset.y;
      this.start(me.getX() + origin.x, me.getY() + origin.y);
      me.consume(false);
    }
  }
  /**
   * Creates the rubberband selection shape.
   */
  start(x, y) {
    this.first = new Point_default(x, y);
    const { container } = this.graph;
    function createMouseEvent(evt2) {
      const me = new InternalMouseEvent_default(evt2);
      const pt = convertPoint(container, me.getX(), me.getY());
      me.graphX = pt.x;
      me.graphY = pt.y;
      return me;
    }
    this.dragHandler = (evt2) => {
      this.mouseMove(this.graph, createMouseEvent(evt2));
    };
    this.dropHandler = (evt2) => {
      this.mouseUp(this.graph, createMouseEvent(evt2));
    };
    if (Client_default.IS_FF) {
      InternalEvent_default.addGestureListeners(document, null, this.dragHandler, this.dropHandler);
    }
  }
  /**
   * Handles the event by updating therubberband selection.
   */
  mouseMove(sender, me) {
    if (!me.isConsumed() && this.first) {
      const origin = getScrollOrigin(this.graph.container);
      const offset = getOffset(this.graph.container);
      origin.x -= offset.x;
      origin.y -= offset.y;
      const x = me.getX() + origin.x;
      const y = me.getY() + origin.y;
      const dx = this.first.x - x;
      const dy = this.first.y - y;
      const tol = this.graph.getEventTolerance();
      if (this.div || Math.abs(dx) > tol || Math.abs(dy) > tol) {
        if (!this.div) {
          this.div = this.createShape();
        }
        clearSelection();
        this.update(x, y);
        me.consume();
      }
    }
  }
  /**
   * Creates the rubberband selection shape.
   */
  createShape() {
    if (!this.sharedDiv) {
      this.sharedDiv = document.createElement("div");
      this.sharedDiv.className = "mxRubberband";
      setOpacity(this.sharedDiv, this.defaultOpacity);
    }
    this.graph.container.appendChild(this.sharedDiv);
    const result2 = this.sharedDiv;
    if (Client_default.IS_SVG && this.fadeOut) {
      this.sharedDiv = null;
    }
    return result2;
  }
  /**
   * Returns true if this handler is active.
   */
  isActive(sender, me) {
    return this.div && this.div.style.display !== "none";
  }
  /**
   * Handles the event by selecting the region of the rubberband using
   * {@link Graph#selectRegion}.
   */
  mouseUp(sender, me) {
    const active = this.isActive();
    this.reset();
    if (active) {
      this.execute(me.getEvent());
      me.consume();
    }
  }
  /**
   * Resets the state of this handler and selects the current region
   * for the given event.
   */
  execute(evt2) {
    const rect = new Rectangle_default(this.x, this.y, this.width, this.height);
    this.graph.selectRegion(rect, evt2);
  }
  /**
   * Resets the state of the rubberband selection.
   */
  reset() {
    if (this.div) {
      if (Client_default.IS_SVG && this.fadeOut) {
        const temp = this.div;
        setPrefixedStyle(temp.style, "transition", "all 0.2s linear");
        temp.style.pointerEvents = "none";
        temp.style.opacity = String(0);
        window.setTimeout(() => {
          if (temp.parentNode)
            temp.parentNode.removeChild(temp);
        }, 200);
      } else {
        if (this.div.parentNode)
          this.div.parentNode.removeChild(this.div);
      }
    }
    InternalEvent_default.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);
    this.dragHandler = null;
    this.dropHandler = null;
    this.currentX = 0;
    this.currentY = 0;
    this.first = null;
    this.div = null;
  }
  /**
   * Sets <currentX> and <currentY> and calls <repaint>.
   */
  update(x, y) {
    this.currentX = x;
    this.currentY = y;
    this.repaint();
  }
  /**
   * Computes the bounding box and updates the style of the <div>.
   */
  repaint() {
    if (this.div && this.first) {
      const x = this.currentX - this.graph.getPanDx();
      const y = this.currentY - this.graph.getPanDy();
      this.x = Math.min(this.first.x, x);
      this.y = Math.min(this.first.y, y);
      this.width = Math.max(this.first.x, x) - this.x;
      this.height = Math.max(this.first.y, y) - this.y;
      const dx = 0;
      const dy = 0;
      this.div.style.left = `${this.x + dx}px`;
      this.div.style.top = `${this.y + dy}px`;
      this.div.style.width = `${Math.max(1, this.width)}px`;
      this.div.style.height = `${Math.max(1, this.height)}px`;
    }
  }
  /**
   * Destroys the handler and all its resources and DOM nodes. This does
   * normally not need to be called, it is called automatically when the
   * window unloads.
   */
  onDestroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.graph.removeMouseListener(this);
      this.graph.removeListener(this.forceRubberbandHandler);
      this.graph.removeListener(this.panHandler);
      this.reset();
      if (this.sharedDiv) {
        this.sharedDiv = null;
      }
    }
  }
};
RubberBandHandler.pluginId = "RubberBandHandler";
var RubberBandHandler_default = RubberBandHandler;

// node_modules/@maxgraph/core/lib/util/printUtils.js
var printUtils_exports = {};
__export(printUtils_exports, {
  getScaleForPageCount: () => getScaleForPageCount,
  printScreen: () => printScreen,
  show: () => show
});
var getScaleForPageCount = (pageCount, graph, pageFormat, border = 0) => {
  if (pageCount < 1) {
    return 1;
  }
  pageFormat = pageFormat != null ? pageFormat : new Rectangle_default(...PAGE_FORMAT_A4_PORTRAIT);
  const availablePageWidth = pageFormat.width - border * 2;
  const availablePageHeight = pageFormat.height - border * 2;
  const graphBounds = graph.getGraphBounds().clone();
  const sc = graph.getView().getScale();
  graphBounds.width /= sc;
  graphBounds.height /= sc;
  const graphWidth = graphBounds.width;
  const graphHeight = graphBounds.height;
  let scale = 1;
  const pageFormatAspectRatio = availablePageWidth / availablePageHeight;
  const graphAspectRatio = graphWidth / graphHeight;
  const pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;
  const pageRoot = Math.sqrt(pageCount);
  const pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);
  let numRowPages = pageRoot * pagesAspectRatioSqrt;
  let numColumnPages = pageRoot / pagesAspectRatioSqrt;
  if (numRowPages < 1 && numColumnPages > pageCount) {
    const scaleChange = numColumnPages / pageCount;
    numColumnPages = pageCount;
    numRowPages /= scaleChange;
  }
  if (numColumnPages < 1 && numRowPages > pageCount) {
    const scaleChange = numRowPages / pageCount;
    numRowPages = pageCount;
    numColumnPages /= scaleChange;
  }
  let currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
  let numLoops = 0;
  while (currentTotalPages > pageCount) {
    let roundRowDownProportion = Math.floor(numRowPages) / numRowPages;
    let roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;
    if (roundRowDownProportion == 1) {
      roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;
    }
    if (roundColumnDownProportion == 1) {
      roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;
    }
    let scaleChange = 1;
    if (roundRowDownProportion > roundColumnDownProportion) {
      scaleChange = roundRowDownProportion;
    } else {
      scaleChange = roundColumnDownProportion;
    }
    numRowPages *= scaleChange;
    numColumnPages *= scaleChange;
    currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);
    numLoops++;
    if (numLoops > 10) {
      break;
    }
  }
  const posterWidth = availablePageWidth * numRowPages;
  scale = posterWidth / graphWidth;
  return scale * 0.99999;
};
var show = (graph, doc = null, x0 = 0, y0 = 0, w = null, h = null) => {
  x0 = x0 != null ? x0 : 0;
  y0 = y0 != null ? y0 : 0;
  if (doc == null) {
    const wnd = window.open();
    doc = wnd.document;
  } else {
    doc.open();
  }
  const bounds = graph.getGraphBounds();
  const dx = Math.ceil(x0 - bounds.x);
  const dy = Math.ceil(y0 - bounds.y);
  if (w == null) {
    w = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);
  }
  if (h == null) {
    h = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);
  }
  doc.writeln("<html><head>");
  const base = document.getElementsByTagName("base");
  for (let i2 = 0; i2 < base.length; i2 += 1) {
    doc.writeln(getOuterHtml(base[i2]));
  }
  const links = document.getElementsByTagName("link");
  for (let i2 = 0; i2 < links.length; i2 += 1) {
    doc.writeln(getOuterHtml(links[i2]));
  }
  const styles = document.getElementsByTagName("style");
  for (let i2 = 0; i2 < styles.length; i2 += 1) {
    doc.writeln(getOuterHtml(styles[i2]));
  }
  doc.writeln('</head><body style="margin:0px;"></body></html>');
  doc.close();
  const outer = doc.createElement("div");
  outer.style.position = "absolute";
  outer.style.overflow = "hidden";
  outer.style.width = `${w}px`;
  outer.style.height = `${h}px`;
  const div = doc.createElement("div");
  div.style.position = "absolute";
  div.style.left = `${dx}px`;
  div.style.top = `${dy}px`;
  if (graph.container && graph.view.drawPane) {
    let node2 = graph.container.firstChild;
    let svg = null;
    while (node2 != null) {
      const clone2 = node2.cloneNode(true);
      if (node2 == graph.view.drawPane.ownerSVGElement) {
        outer.appendChild(clone2);
        svg = clone2;
      } else {
        div.appendChild(clone2);
      }
      node2 = node2.nextSibling;
    }
    doc.body.appendChild(outer);
    if (div.firstChild != null) {
      doc.body.appendChild(div);
    }
    if (svg != null) {
      svg.style.minWidth = "";
      svg.style.minHeight = "";
      if (svg.firstChild)
        svg.firstChild.setAttribute("transform", `translate(${dx},${dy})`);
    }
    removeCursors(doc.body);
  }
  return doc;
};
var printScreen = (graph) => {
  const wnd = window.open();
  if (!wnd)
    return;
  const bounds = graph.getGraphBounds();
  show(graph, wnd.document);
  const print = () => {
    wnd.focus();
    wnd.print();
    wnd.close();
  };
  if (Client_default.IS_GC) {
    wnd.setTimeout(print, 500);
  } else {
    print();
  }
};

// node_modules/@maxgraph/core/lib/editor/Editor.js
var Editor = class extends EventSource_default {
  constructor(config) {
    super();
    this.onInit = null;
    this.lastSnapshot = null;
    this.ignoredChanges = null;
    this.rubberband = null;
    this.isActive = null;
    this.destroyed = false;
    this.askZoomResource = Client_default.language !== "none" ? "askZoom" : "";
    this.lastSavedResource = Client_default.language !== "none" ? "lastSaved" : "";
    this.currentFileResource = Client_default.language !== "none" ? "currentFile" : "";
    this.propertiesResource = Client_default.language !== "none" ? "properties" : "";
    this.tasksResource = Client_default.language !== "none" ? "tasks" : "";
    this.helpResource = Client_default.language !== "none" ? "help" : "";
    this.outlineResource = Client_default.language !== "none" ? "outline" : "";
    this.outline = null;
    this.graphRenderHint = null;
    this.toolbar = null;
    this.status = null;
    this.popupHandler = null;
    this.undoManager = null;
    this.keyHandler = null;
    this.actions = {};
    this.dblClickAction = "edit";
    this.swimlaneRequired = false;
    this.disableContextMenu = true;
    this.insertFunction = null;
    this.forcedInserting = false;
    this.templates = null;
    this.defaultEdge = null;
    this.defaultEdgeStyle = null;
    this.defaultGroup = null;
    this.groupBorderSize = null;
    this.filename = null;
    this.linefeed = "&#xa;";
    this.postParameterName = "xml";
    this.escapePostData = true;
    this.urlPost = null;
    this.urlImage = null;
    this.horizontalFlow = false;
    this.layoutDiagram = false;
    this.swimlaneSpacing = 0;
    this.maintainSwimlanes = false;
    this.layoutSwimlanes = false;
    this.cycleAttributeValues = [];
    this.cycleAttributeIndex = 0;
    this.cycleAttributeName = "fillColor";
    this.tasks = null;
    this.tasksWindowImage = null;
    this.tasksTop = 20;
    this.help = null;
    this.helpWindowImage = null;
    this.urlHelp = null;
    this.helpWidth = 300;
    this.helpHeight = 260;
    this.propertiesWidth = 240;
    this.propertiesHeight = null;
    this.movePropertiesDialog = false;
    this.validating = false;
    this.modified = false;
    this.actions = {};
    this.addActions();
    if (document.body != null) {
      this.cycleAttributeValues = [];
      this.popupHandler = new EditorPopupMenu_default();
      this.undoManager = new UndoManager_default();
      this.graph = this.createGraph();
      this.toolbar = this.createToolbar();
      this.keyHandler = new EditorKeyHandler_default(this);
      this.configure(config);
      this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;
      if (this.onInit != null) {
        this.onInit();
      }
    }
  }
  /**
   * Returns {@link modified}.
   */
  isModified() {
    return this.modified;
  }
  /**
   * Sets {@link modified} to the specified boolean value.
   * @param value
   */
  setModified(value2) {
    this.modified = value2;
  }
  /**
   * Adds the built-in actions to the editor instance.
   * save - Saves the graph using <urlPost>.
   * print - Shows the graph in a new print preview window.
   * show - Shows the graph in a new window.
   * exportImage - Shows the graph as a bitmap image using <getUrlImage>.
   * refresh - Refreshes the graph's display.
   * cut - Copies the current selection into the clipboard
   * and removes it from the graph.
   * copy - Copies the current selection into the clipboard.
   * paste - Pastes the clipboard into the graph.
   * delete - Removes the current selection from the graph.
   * group - Puts the current selection into a new group.
   * ungroup - Removes the selected groups and selects the children.
   * undo - Undoes the last change on the graph model.
   * redo - Redoes the last change on the graph model.
   * zoom - Sets the zoom via a dialog.
   * zoomIn - Zooms into the graph.
   * zoomOut - Zooms out of the graph
   * actualSize - Resets the scale and translation on the graph.
   * fit - Changes the scale so that the graph fits into the window.
   * showProperties - Shows the properties dialog.
   * selectAll - Selects all cells.
   * selectNone - Clears the selection.
   * selectVertices - Selects all vertices.
   * selectEdges = Selects all edges.
   * edit - Starts editing the current selection cell.
   * enterGroup - Drills down into the current selection cell.
   * exitGroup - Moves up in the drilling hierachy
   * home - Moves to the topmost parent in the drilling hierarchy
   * selectPrevious - Selects the previous cell.
   * selectNext - Selects the next cell.
   * selectParent - Selects the parent of the selection cell.
   * selectChild - Selects the first child of the selection cell.
   * collapse - Collapses the currently selected cells.
   * expand - Expands the currently selected cells.
   * bold - Toggle bold text style.
   * italic - Toggle italic text style.
   * underline - Toggle underline text style.
   * alignCellsLeft - Aligns the selection cells at the left.
   * alignCellsCenter - Aligns the selection cells in the center.
   * alignCellsRight - Aligns the selection cells at the right.
   * alignCellsTop - Aligns the selection cells at the top.
   * alignCellsMiddle - Aligns the selection cells in the middle.
   * alignCellsBottom - Aligns the selection cells at the bottom.
   * alignFontLeft - Sets the horizontal text alignment to left.
   * alignFontCenter - Sets the horizontal text alignment to center.
   * alignFontRight - Sets the horizontal text alignment to right.
   * alignFontTop - Sets the vertical text alignment to top.
   * alignFontMiddle - Sets the vertical text alignment to middle.
   * alignFontBottom - Sets the vertical text alignment to bottom.
   * toggleTasks - Shows or hides the tasks window.
   * toggleHelp - Shows or hides the help window.
   * toggleOutline - Shows or hides the outline window.
   * toggleConsole - Shows or hides the console window.
   */
  addActions() {
    this.addAction("save", (editor2) => {
      editor2.save();
    });
    this.addAction("print", (editor2) => {
      const preview = new PrintPreview_default(editor2.graph, 1);
      preview.open();
    });
    this.addAction("show", (editor2) => {
      show(editor2.graph, null, 10, 10);
    });
    this.addAction("exportImage", (editor2) => {
      const url = editor2.getUrlImage();
      if (url == null || Client_default.IS_LOCAL) {
        editor2.execute("show");
      } else {
        const node2 = getViewXml(editor2.graph, 1);
        const xml = getXml(node2, "\n");
        submit(url, `${editor2.postParameterName}=${encodeURIComponent(xml)}`, document, "_blank");
      }
    });
    this.addAction("refresh", (editor2) => {
      editor2.graph.refresh();
    });
    this.addAction("cut", (editor2) => {
      if (editor2.graph.isEnabled()) {
        Clipboard_default.cut(editor2.graph);
      }
    });
    this.addAction("copy", (editor2) => {
      if (editor2.graph.isEnabled()) {
        Clipboard_default.copy(editor2.graph);
      }
    });
    this.addAction("paste", (editor2) => {
      if (editor2.graph.isEnabled()) {
        Clipboard_default.paste(editor2.graph);
      }
    });
    this.addAction("delete", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.removeCells();
      }
    });
    this.addAction("group", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setSelectionCell(editor2.groupCells());
      }
    });
    this.addAction("ungroup", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setSelectionCells(editor2.graph.ungroupCells());
      }
    });
    this.addAction("removeFromParent", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.removeCellsFromParent();
      }
    });
    this.addAction("undo", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.undo();
      }
    });
    this.addAction("redo", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.redo();
      }
    });
    this.addAction("zoomIn", (editor2) => {
      editor2.graph.zoomIn();
    });
    this.addAction("zoomOut", (editor2) => {
      editor2.graph.zoomOut();
    });
    this.addAction("actualSize", (editor2) => {
      editor2.graph.zoomActual();
    });
    this.addAction("fit", (editor2) => {
      editor2.graph.fit();
    });
    this.addAction("showProperties", (editor2, cell2) => {
      editor2.showProperties(cell2);
    });
    this.addAction("selectAll", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectAll();
      }
    });
    this.addAction("selectNone", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.clearSelection();
      }
    });
    this.addAction("selectVertices", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectVertices();
      }
    });
    this.addAction("selectEdges", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectEdges();
      }
    });
    this.addAction("edit", (editor2, cell2) => {
      if (editor2.graph.isEnabled() && editor2.graph.isCellEditable(cell2)) {
        editor2.graph.startEditingAtCell(cell2);
      }
    });
    this.addAction("toBack", (editor2, cell2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.orderCells(true);
      }
    });
    this.addAction("toFront", (editor2, cell2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.orderCells(false);
      }
    });
    this.addAction("enterGroup", (editor2, cell2) => {
      editor2.graph.enterGroup(cell2);
    });
    this.addAction("exitGroup", (editor2) => {
      editor2.graph.exitGroup();
    });
    this.addAction("home", (editor2) => {
      editor2.graph.home();
    });
    this.addAction("selectPrevious", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectPreviousCell();
      }
    });
    this.addAction("selectNext", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectNextCell();
      }
    });
    this.addAction("selectParent", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectParentCell();
      }
    });
    this.addAction("selectChild", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.selectChildCell();
      }
    });
    this.addAction("collapse", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.foldCells(true);
      }
    });
    this.addAction("collapseAll", (editor2) => {
      if (editor2.graph.isEnabled()) {
        const cells = editor2.graph.getChildVertices();
        editor2.graph.foldCells(true, false, cells);
      }
    });
    this.addAction("expand", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.foldCells(false);
      }
    });
    this.addAction("expandAll", (editor2) => {
      if (editor2.graph.isEnabled()) {
        const cells = editor2.graph.getChildVertices();
        editor2.graph.foldCells(false, false, cells);
      }
    });
    this.addAction("bold", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.toggleCellStyleFlags("fontStyle", FONT.BOLD);
      }
    });
    this.addAction("italic", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.toggleCellStyleFlags("fontStyle", FONT.ITALIC);
      }
    });
    this.addAction("underline", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.toggleCellStyleFlags("fontStyle", FONT.UNDERLINE);
      }
    });
    this.addAction("alignCellsLeft", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.LEFT);
      }
    });
    this.addAction("alignCellsCenter", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.CENTER);
      }
    });
    this.addAction("alignCellsRight", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.RIGHT);
      }
    });
    this.addAction("alignCellsTop", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.TOP);
      }
    });
    this.addAction("alignCellsMiddle", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.MIDDLE);
      }
    });
    this.addAction("alignCellsBottom", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.alignCells(ALIGN.BOTTOM);
      }
    });
    this.addAction("alignFontLeft", (editor2) => {
      editor2.graph.setCellStyles("align", ALIGN.LEFT);
    });
    this.addAction("alignFontCenter", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setCellStyles("align", ALIGN.CENTER);
      }
    });
    this.addAction("alignFontRight", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setCellStyles("align", ALIGN.RIGHT);
      }
    });
    this.addAction("alignFontTop", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setCellStyles("verticalAlign", ALIGN.TOP);
      }
    });
    this.addAction("alignFontMiddle", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setCellStyles("verticalAlign", ALIGN.MIDDLE);
      }
    });
    this.addAction("alignFontBottom", (editor2) => {
      if (editor2.graph.isEnabled()) {
        editor2.graph.setCellStyles("verticalAlign", ALIGN.BOTTOM);
      }
    });
    this.addAction("zoom", (editor2) => {
      const current = editor2.graph.getView().scale * 100;
      const preInput = prompt(Translations_default.get(editor2.askZoomResource) || editor2.askZoomResource, String(current));
      if (preInput) {
        const scale = parseFloat(preInput) / 100;
        if (!isNaN(scale)) {
          editor2.graph.getView().setScale(scale);
        }
      }
    });
    this.addAction("toggleTasks", (editor2) => {
      if (editor2.tasks != null) {
        editor2.tasks.setVisible(!editor2.tasks.isVisible());
      } else {
        editor2.showTasks();
      }
    });
    this.addAction("toggleHelp", (editor2) => {
      if (editor2.help != null) {
        editor2.help.setVisible(!editor2.help.isVisible());
      } else {
        editor2.showHelp();
      }
    });
    this.addAction("toggleOutline", (editor2) => {
      if (editor2.outline == null) {
        editor2.showOutline();
      } else {
        editor2.outline.setVisible(!editor2.outline.isVisible());
      }
    });
    this.addAction("toggleConsole", (editor2) => {
      MaxLog_default.setVisible(!MaxLog_default.isVisible());
    });
  }
  /**
   * Configures the editor using the specified node. To load the
   * configuration from a given URL the following code can be used to obtain
   * the XML node.
   *
   * @example
   * ```javascript
   * var node = mxUtils.load(url).getDocumentElement();
   * ```
   * @param node XML node that contains the configuration.
   */
  configure(node2) {
    if (node2 != null) {
      const dec2 = new Codec_default(node2.ownerDocument);
      dec2.decode(node2, this);
      this.resetHistory();
    }
  }
  /**
   * Resets the cookie that is used to remember if the editor has already been used.
   */
  resetFirstTime() {
    document.cookie = "mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/";
  }
  /**
   * Resets the command history, modified state and counters.
   */
  resetHistory() {
    this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
    this.undoManager.clear();
    this.ignoredChanges = 0;
    this.setModified(false);
  }
  /**
   * Binds the specified actionname to the specified function.
   *
   * @example
   * ```javascript
   * editor.addAction('test', function(editor: Editor, cell: Cell)
   * {
   * 		mxUtils.alert("test "+cell);
   * });
   * ```
   * @param actionname String that specifies the name of the action to be added.
   * @param funct Function that implements the new action. The first argument
   * of the function is the editor it is used with,
   * the second argument is the cell it operates upon.
   */
  addAction(actionname, funct2) {
    this.actions[actionname] = funct2;
  }
  /**
   * Executes the function with the given name in {@link actions} passing the
   * editor instance and given cell as the first and second argument. All
   * additional arguments are passed to the action as well. This method
   * contains a try-catch block and displays an error message if an action
   * causes an exception. The exception is re-thrown after the error
   * message was displayed.
   *
   * @example
   * ```javascript
   * editor.execute("showProperties", cell);
   * ```
   * @param actionname
   * @param cell
   * @param evt
   */
  execute(actionname, cell2 = null, evt2 = null) {
    const action2 = this.actions[actionname];
    if (action2 != null) {
      try {
        const args = [this, cell2, evt2];
        action2.apply(this, args);
      } catch (e) {
        error(`Cannot execute ${actionname}: ${e.message}`, 280, true);
        throw e;
      }
    } else {
      error(`Cannot find action ${actionname}`, 280, true);
    }
  }
  /**
   * Adds the specified template under the given name in {@link templates}.
   * @param name
   * @param template
   */
  addTemplate(name2, template2) {
    this.templates[name2] = template2;
  }
  /**
   * Returns the template for the given name.
   * @param name
   */
  getTemplate(name2) {
    return this.templates[name2];
  }
  /**
   * Creates the {@link graph} for the editor. The graph is created with no
   * container and is initialized from {@link setGraphContainer}.
   * @returns graph instance
   */
  createGraph() {
    const __dummy = void 0;
    const graph = new Graph(__dummy);
    graph.setTooltips(true);
    graph.setPanning(true);
    this.installDblClickHandler(graph);
    this.installUndoHandler(graph);
    this.installDrillHandler(graph);
    this.installChangeHandler(graph);
    this.installInsertHandler(graph);
    const popupMenuHandler = graph.getPlugin("PopupMenuHandler");
    if (popupMenuHandler) {
      popupMenuHandler.factoryMethod = (menu2, cell2, evt2) => {
        return this.createPopupMenu(menu2, cell2, evt2);
      };
    }
    const connectionHandler = graph.getPlugin("ConnectionHandler");
    if (connectionHandler) {
      connectionHandler.factoryMethod = (source2, target2) => {
        return this.createEdge(source2, target2);
      };
    }
    this.createSwimlaneManager(graph);
    this.createLayoutManager(graph);
    return graph;
  }
  /**
   * Sets the graph's container using [@link mxGraph.init}.
   * @param graph
   * @returns SwimlaneManager instance
   */
  createSwimlaneManager(graph) {
    const swimlaneMgr = new SwimlaneManager_default(graph, false);
    swimlaneMgr.isHorizontal = () => {
      return this.horizontalFlow;
    };
    swimlaneMgr.isEnabled = () => {
      return this.maintainSwimlanes;
    };
    return swimlaneMgr;
  }
  /**
   * Creates a layout manager for the swimlane and diagram layouts, that
   * is, the locally defined inter and intraswimlane layouts.
   * @param graph
   * @returns LayoutManager instance
   */
  createLayoutManager(graph) {
    const layoutMgr = new LayoutManager_default(graph);
    layoutMgr.getLayout = (cell2) => {
      let layout = null;
      const model2 = this.graph.getDataModel();
      if (cell2.getParent() != null) {
        if (this.layoutSwimlanes && graph.isSwimlane(cell2)) {
          if (this.swimlaneLayout == null) {
            this.swimlaneLayout = this.createSwimlaneLayout();
          }
          layout = this.swimlaneLayout;
        } else if (this.layoutDiagram && (graph.isValidRoot(cell2) || cell2.getParent().getParent() == null)) {
          if (this.diagramLayout == null) {
            this.diagramLayout = this.createDiagramLayout();
          }
          layout = this.diagramLayout;
        }
      }
      return layout;
    };
    return layoutMgr;
  }
  /**
   * Sets the graph's container using {@link graph.init}.
   * @param container
   */
  setGraphContainer(container) {
    if (this.graph.container == null) {
      this.graph.init(container);
      this.rubberband = new RubberBandHandler_default(this.graph);
      if (this.disableContextMenu) {
        InternalEvent_default.disableContextMenu(container);
      }
    }
  }
  /**
   * Overrides {@link graph.dblClick} to invoke {@link dblClickAction}
   * on a cell and reset the selection tool in the toolbar.
   * @param graph
   */
  installDblClickHandler(graph) {
    graph.addListener(InternalEvent_default.DOUBLE_CLICK, (sender, evt2) => {
      const cell2 = evt2.getProperty("cell");
      if (cell2 != null && graph.isEnabled() && this.dblClickAction != null) {
        this.execute(this.dblClickAction, cell2);
        evt2.consume();
      }
    });
  }
  /**
   * Adds the {@link undoManager} to the graph model and the view.
   * @param graph
   */
  installUndoHandler(graph) {
    const listener = (sender, evt2) => {
      const edit = evt2.getProperty("edit");
      this.undoManager.undoableEditHappened(edit);
    };
    graph.getDataModel().addListener(InternalEvent_default.UNDO, listener);
    graph.getView().addListener(InternalEvent_default.UNDO, listener);
    const undoHandler = (sender, evt2) => {
      const { changes } = evt2.getProperty("edit");
      graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));
    };
    this.undoManager.addListener(InternalEvent_default.UNDO, undoHandler);
    this.undoManager.addListener(InternalEvent_default.REDO, undoHandler);
  }
  /**
   * Installs listeners for dispatching the {@link root} event.
   * @param graph
   */
  installDrillHandler(graph) {
    const listener = (sender) => {
      this.fireEvent(new EventObject_default(InternalEvent_default.ROOT));
    };
    graph.getView().addListener(InternalEvent_default.DOWN, listener);
    graph.getView().addListener(InternalEvent_default.UP, listener);
  }
  /**
   * Installs the listeners required to automatically validate
   * the graph. On each change of the root, this implementation
   * fires a {@link root} event.
   * @param graph
   */
  installChangeHandler(graph) {
    const listener = (sender, evt2) => {
      this.setModified(true);
      if (this.validating == true) {
        graph.validateGraph();
      }
      const { changes } = evt2.getProperty("edit");
      for (let i2 = 0; i2 < changes.length; i2 += 1) {
        const change = changes[i2];
        if (change instanceof RootChange_default || change instanceof ValueChange_default && change.cell === this.graph.model.root || change instanceof CellAttributeChange_default && change.cell === this.graph.model.root) {
          this.fireEvent(new EventObject_default(InternalEvent_default.ROOT));
          break;
        }
      }
    };
    graph.getDataModel().addListener(InternalEvent_default.CHANGE, listener);
  }
  /**
   * Installs the handler for invoking {@link insertFunction} if one is defined.
   * @param graph
   */
  installInsertHandler(graph) {
    const insertHandler = {
      mouseDown: (sender, me) => {
        if (this.insertFunction != null && !me.isPopupTrigger() && (this.forcedInserting || me.getState() == null)) {
          this.graph.clearSelection();
          this.insertFunction(me.getEvent(), me.getCell());
          this.isActive = true;
          me.consume();
        }
      },
      mouseMove: (sender, me) => {
        if (this.isActive) {
          me.consume();
        }
      },
      mouseUp: (sender, me) => {
        if (this.isActive) {
          this.isActive = false;
          me.consume();
        }
      }
    };
    graph.addMouseListener(insertHandler);
  }
  /**
   * Creates the layout instance used to layout the
   * swimlanes in the diagram.
   * @returns StackLayout instance
   */
  createDiagramLayout() {
    const gs = this.graph.gridSize;
    const layout = new StackLayout_default(this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * gs, 2 * gs);
    layout.isVertexIgnored = (cell2) => {
      return !layout.graph.isSwimlane(cell2);
    };
    return layout;
  }
  /**
   * Creates the layout instance used to layout the
   * children of each swimlane.
   * @returns CompactTreeLayout instance
   */
  createSwimlaneLayout() {
    return new CompactTreeLayout_default(this.graph, this.horizontalFlow);
  }
  /**
   * Creates the {@link toolbar} with no container.
   * @returns EditorToolbar instance
   */
  createToolbar() {
    return new EditorToolbar(null, this);
  }
  /**
   * Initializes the toolbar for the given container.
   * @param container
   */
  setToolbarContainer(container) {
    this.toolbar.init(container);
  }
  /**
   * Creates the {@link status} using the specified container.
   * This implementation adds listeners in the editor to
   * display the last saved time and the current filename
   * in the status bar.
   * @param container DOM node that will contain the statusbar.
   */
  setStatusContainer(container) {
    if (this.status == null) {
      this.status = container;
      this.addListener(InternalEvent_default.SAVE, () => {
        const tstamp = (/* @__PURE__ */ new Date()).toLocaleString();
        this.setStatus(`${Translations_default.get(this.lastSavedResource) || this.lastSavedResource}: ${tstamp}`);
      });
      this.addListener(InternalEvent_default.OPEN, () => {
        this.setStatus(`${Translations_default.get(this.currentFileResource) || this.currentFileResource}: ${this.filename}`);
      });
    }
  }
  /**
   * Display the specified message in the status bar.
   * @param message String the specified the message to be displayed.
   */
  setStatus(message) {
    if (this.status != null && message != null) {
      this.status.innerHTML = message;
    }
  }
  /**
   * Creates a listener to update the inner HTML of the
   * specified DOM node with the value of {@link getTitle}.
   * @param container DOM node that will contain the title.
   */
  setTitleContainer(container) {
    this.addListener(InternalEvent_default.ROOT, (sender) => {
      container.innerHTML = this.getTitle();
    });
  }
  /**
   * Executes a vertical or horizontal compact tree layout
   * using the specified cell as an argument. The cell may
   * either be a group or the root of a tree.
   * @param cell {@link mxCell} to use in the compact tree layout.
   * @param horizontal Optional boolean to specify the tree's
   * orientation. Default is true.
   */
  treeLayout(cell2, horizontal) {
    if (cell2 != null) {
      const layout = new CompactTreeLayout_default(this.graph, horizontal);
      layout.execute(cell2);
    }
  }
  /**
   * Returns the string value for the current root of the diagram.
   */
  getTitle() {
    let title = "";
    const { graph } = this;
    let cell2 = graph.getCurrentRoot();
    while (cell2 != null && cell2.getParent().getParent() != null) {
      if (graph.isValidRoot(cell2)) {
        title = ` > ${graph.convertValueToString(cell2)}${title}`;
      }
      cell2 = cell2.getParent();
    }
    const prefix = this.getRootTitle();
    return prefix + title;
  }
  /**
   * Returns the string value of the root cell in {@link graph.model}.
   */
  getRootTitle() {
    const root = this.graph.getDataModel().getRoot();
    return this.graph.convertValueToString(root);
  }
  /**
   * Undo the last change in {@link graph}.
   */
  undo() {
    this.undoManager.undo();
  }
  /**
   * Redo the last change in {@link graph}.
   */
  redo() {
    this.undoManager.redo();
  }
  /**
   * Invokes {@link createGroup} to create a new group cell and the invokes
   * {@link graph.groupCells}, using the grid size of the graph as the spacing
   * in the group's content area.
   */
  groupCells() {
    const border = this.groupBorderSize != null ? this.groupBorderSize : this.graph.gridSize;
    return this.graph.groupCells(this.createGroup(), border);
  }
  /**
   * Creates and returns a clone of {@link defaultGroup} to be used
   * as a new group cell in {@link group}.
   * @returns Cell
   */
  createGroup() {
    return cloneCell(this.defaultGroup);
  }
  /**
   * Opens the specified file synchronously and parses it using
   * {@link readGraphModel}. It updates {@link filename} and fires an <open>-event after
   * the file has been opened. Exceptions should be handled as follows:
   *
   * @example
   * ```javascript
   * try
   * {
   *   editor.open(filename);
   * }
   * catch (e)
   * {
   *   mxUtils.error('Cannot open ' + filename +
   *     ': ' + e.message, 280, true);
   * }
   * ```
   *
   * @param filename URL of the file to be opened.
   */
  open(filename) {
    if (filename != null) {
      const xml = load(filename).getXml();
      this.readGraphModel(xml.documentElement);
      this.filename = filename;
      this.fireEvent(new EventObject_default(InternalEvent_default.OPEN, { filename }));
    }
  }
  /**
   * Reads the specified XML node into the existing graph model and resets the command history and modified state.
   * @param node the XML node to be read into the graph model.
   */
  readGraphModel(node2) {
    new ModelXmlSerializer(this.graph.getDataModel()).import(node2);
    this.resetHistory();
  }
  /**
   * Posts the string returned by {@link writeGraphModel} to the given URL or the
   * URL returned by {@link getUrlPost}. The actual posting is carried out by
   * {@link postDiagram}. If the URL is null then the resulting XML will be
   * displayed using {@link popup}. Exceptions should be handled as
   * follows:
   *
   * @example
   * ```javascript
   * try
   * {
   *   editor.save();
   * }
   * catch (e)
   * {
   *   mxUtils.error('Cannot save : ' + e.message, 280, true);
   * }
   * ```
   *
   * @param url
   * @param linefeed
   */
  save(url = null, linefeed = this.linefeed) {
    url = url || this.getUrlPost();
    if (url != null && url.length > 0) {
      const data = this.writeGraphModel(linefeed);
      this.postDiagram(url, data);
      this.setModified(false);
    }
    this.fireEvent(new EventObject_default(InternalEvent_default.SAVE, { url }));
  }
  /**
   * Hook for subclassers to override the posting of a diagram
   * represented by the given node to the given URL. This fires
   * an asynchronous {@link post} event if the diagram has been posted.
   *
   * ### Example:
   *
   * To replace the diagram with the diagram in the response, use the
   * following code.
   *
   * @example
   * ```javascript
   * editor.addListener(mxEvent.POST, function(sender, evt)
   * {
   *   // Process response (replace diagram)
   *   var req = evt.getProperty('request');
   *   var root = req.getDocumentElement();
   *   editor.graph.readGraphModel(root)
   * });
   * ```
   * @param url
   * @param data
   */
  postDiagram(url, data) {
    if (this.escapePostData) {
      data = encodeURIComponent(data);
    }
    post(url, `${this.postParameterName}=${data}`, (req) => {
      this.fireEvent(new EventObject_default(InternalEvent_default.POST, { request: req, url, data }));
    });
  }
  /**
   * Hook to create the string representation of the diagram.
   *
   * The default implementation uses {@link ModelXmlSerializer} to encode the graph model.
   *
   * @param linefeed Optional character to be used as the linefeed. Default is {@link linefeed}.
   */
  writeGraphModel(linefeed) {
    return new ModelXmlSerializer(this.graph.getDataModel()).export({ pretty: false });
  }
  /**
   * Returns the URL to post the diagram to. This is used
   * in {@link save}. The default implementation returns {@link urlPost},
   * adding <code>?draft=true</code>.
   */
  getUrlPost() {
    return this.urlPost;
  }
  /**
   * Returns the URL to create the image with. This is typically
   * the URL of a backend which accepts an XML representation
   * of a graph view to create an image. The function is used
   * in the image action to create an image. This implementation
   * returns {@link urlImage}.
   */
  getUrlImage() {
    return this.urlImage;
  }
  /**
   * Swaps the styles for the given names in the graph's
   * stylesheet and refreshes the graph.
   * @param first
   * @param second
   */
  swapStyles(first, second) {
    const style2 = this.graph.getStylesheet().styles[second];
    this.graph.getView().getStylesheet().putCellStyle(second, this.graph.getStylesheet().styles[first]);
    this.graph.getStylesheet().putCellStyle(first, style2);
    this.graph.refresh();
  }
  /**
   * Creates and shows the properties dialog for the given
   * cell. The content area of the dialog is created using
   * {@link createProperties}.
   * @param cell
   */
  showProperties(cell2 = null) {
    cell2 = cell2 || this.graph.getSelectionCell();
    if (cell2 == null) {
      cell2 = this.graph.getCurrentRoot();
      if (cell2 == null) {
        cell2 = this.graph.getDataModel().getRoot();
      }
    }
    if (cell2 != null) {
      this.graph.stopEditing(true);
      const offset = getOffset(this.graph.container);
      let x = offset.x + 10;
      let { y } = offset;
      if (this.properties != null && !this.movePropertiesDialog) {
        x = this.properties.getX();
        y = this.properties.getY();
      } else {
        const bounds = this.graph.getCellBounds(cell2);
        if (bounds != null) {
          x += bounds.x + Math.min(200, bounds.width);
          y += bounds.y;
        }
      }
      this.hideProperties();
      const node2 = this.createProperties(cell2);
      if (node2 != null) {
        this.properties = new MaxWindow_default(Translations_default.get(this.propertiesResource) || this.propertiesResource, node2, x, y, this.propertiesWidth, this.propertiesHeight, false);
        this.properties.setVisible(true);
      }
    }
  }
  /**
   * Returns true if the properties dialog is currently visible.
   */
  isPropertiesVisible() {
    return this.properties != null;
  }
  /**
   * Creates and returns the DOM node that represents the contents
   * of the properties dialog for the given cell. This implementation
   * works for user objects that are XML nodes and display all the
   * node attributes in a form.
   */
  createProperties(cell2) {
    const model2 = this.graph.getDataModel();
    const value2 = cell2.getValue();
    if (isNode(value2)) {
      const form = new MaxForm_default("properties");
      const id2 = form.addText("ID", cell2.getId());
      id2.setAttribute("readonly", "true");
      let geo = null;
      let yField = null;
      let xField = null;
      let widthField = null;
      let heightField = null;
      if (cell2.isVertex()) {
        geo = cell2.getGeometry();
        if (geo != null) {
          yField = form.addText("top", geo.y);
          xField = form.addText("left", geo.x);
          widthField = form.addText("width", geo.width);
          heightField = form.addText("height", geo.height);
        }
      }
      const tmp2 = cell2.getStyle();
      const style2 = form.addText("Style", tmp2 || "");
      const attrs = value2.attributes;
      const texts = [];
      for (let i2 = 0; i2 < attrs.length; i2 += 1) {
        const val = attrs[i2].value;
        texts.push(form.addTextarea(attrs[i2].nodeName, val, attrs[i2].nodeName === "label" ? 4 : 2));
      }
      const okFunction = () => {
        this.hideProperties();
        model2.beginUpdate();
        try {
          if (geo != null && xField != null && yField != null && widthField != null && heightField != null) {
            geo = geo.clone();
            geo.x = parseFloat(xField.value);
            geo.y = parseFloat(yField.value);
            geo.width = parseFloat(widthField.value);
            geo.height = parseFloat(heightField.value);
            model2.setGeometry(cell2, geo);
          }
          if (style2.value.length > 0) {
            model2.setStyle(cell2, style2.value);
          } else {
            model2.setStyle(cell2, {});
          }
          for (let i2 = 0; i2 < attrs.length; i2 += 1) {
            const edit = new CellAttributeChange_default(cell2, attrs[i2].nodeName, texts[i2].value);
            model2.execute(edit);
          }
          if (this.graph.isAutoSizeCell(cell2)) {
            this.graph.updateCellSize(cell2);
          }
        } finally {
          model2.endUpdate();
        }
      };
      const cancelFunction = () => {
        this.hideProperties();
      };
      form.addButtons(okFunction, cancelFunction);
      return form.table;
    }
    return null;
  }
  /**
   * Hides the properties dialog.
   */
  hideProperties() {
    if (this.properties != null) {
      this.properties.destroy();
      this.properties = null;
    }
  }
  /**
   * Shows the tasks window. The tasks window is created using {@link createTasks}. The
   * default width of the window is 200 pixels, the y-coordinate of the location
   * can be specifies in {@link tasksTop} and the x-coordinate is right aligned with a
   * 20 pixel offset from the right border. To change the location of the tasks
   * window, the following code can be used:
   *
   * @example
   * ```javascript
   * var oldShowTasks = Editor.prototype.showTasks;
   * Editor.prototype.showTasks = function()
   * {
   *   oldShowTasks.apply(this, arguments); // "supercall"
   *
   *   if (this.tasks != null)
   *   {
   *     this.tasks.setLocation(10, 10);
   *   }
   * };
   * ```
   */
  showTasks() {
    if (this.tasks == null) {
      const div = document.createElement("div");
      div.style.padding = "4px";
      div.style.paddingLeft = "20px";
      const w = document.body.clientWidth;
      const wnd = new MaxWindow_default(Translations_default.get(this.tasksResource) || this.tasksResource, div, w - 220, this.tasksTop, 200);
      wnd.setClosable(true);
      wnd.destroyOnClose = false;
      const funct2 = (sender) => {
        InternalEvent_default.release(div);
        div.innerHTML = "";
        this.createTasks(div);
      };
      this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, funct2);
      this.graph.getSelectionModel().addListener(InternalEvent_default.CHANGE, funct2);
      this.graph.addListener(InternalEvent_default.ROOT, funct2);
      if (this.tasksWindowImage != null) {
        wnd.setImage(this.tasksWindowImage);
      }
      this.tasks = wnd;
      this.createTasks(div);
    }
    this.tasks.setVisible(true);
  }
  /**
   * Updates the contents of the tasks window using {@link createTasks}.
   * @param div
   */
  refreshTasks(div) {
    if (this.tasks != null) {
      const div2 = this.tasks.content;
      InternalEvent_default.release(div2);
      div2.innerHTML = "";
      this.createTasks(div2);
    }
  }
  /**
   * Updates the contents of the given DOM node to
   * display the tasks associated with the current
   * editor state. This is invoked whenever there
   * is a possible change of state in the editor.
   * Default implementation is empty.
   * @param div
   */
  createTasks(div) {
  }
  /**
   * Shows the help window. If the help window does not exist
   * then it is created using an iframe pointing to the resource
   * for the <code>urlHelp</code> key or {@link urlHelp} if the resource
   * is undefined.
   * @param tasks
   */
  showHelp(tasks = null) {
    if (this.help == null) {
      const frame = document.createElement("iframe");
      frame.setAttribute("src", Translations_default.get("urlHelp") || this.urlHelp);
      frame.setAttribute("height", "100%");
      frame.setAttribute("width", "100%");
      frame.setAttribute("frameBorder", "0");
      frame.style.backgroundColor = "white";
      const w = document.body.clientWidth;
      const h = document.body.clientHeight || document.documentElement.clientHeight;
      const wnd = new MaxWindow_default(Translations_default.get(this.helpResource) || this.helpResource, frame, (w - this.helpWidth) / 2, (h - this.helpHeight) / 3, this.helpWidth, this.helpHeight);
      wnd.setMaximizable(true);
      wnd.setClosable(true);
      wnd.destroyOnClose = false;
      wnd.setResizable(true);
      if (this.helpWindowImage != null) {
        wnd.setImage(this.helpWindowImage);
      }
      if (Client_default.IS_NS) {
        const handler = (sender) => {
          const h2 = wnd.div.offsetHeight;
          frame.setAttribute("height", `${h2 - 26}px`);
        };
        wnd.addListener(InternalEvent_default.RESIZE_END, handler);
        wnd.addListener(InternalEvent_default.MAXIMIZE, handler);
        wnd.addListener(InternalEvent_default.NORMALIZE, handler);
        wnd.addListener(InternalEvent_default.SHOW, handler);
      }
      this.help = wnd;
    }
    this.help.setVisible(true);
  }
  /**
   * Shows the outline window. If the window does not exist, then it is
   * created using an {@link outline}.
   */
  showOutline() {
    const create = this.outline == null;
    if (create) {
      const div = document.createElement("div");
      div.style.overflow = "hidden";
      div.style.position = "relative";
      div.style.width = "100%";
      div.style.height = "100%";
      div.style.background = "white";
      div.style.cursor = "move";
      const wnd = new MaxWindow_default(Translations_default.get(this.outlineResource) || this.outlineResource, div, 600, 480, 200, 200, false);
      const outline = new Outline_default(this.graph, div);
      wnd.setClosable(true);
      wnd.setResizable(true);
      wnd.destroyOnClose = false;
      wnd.addListener(InternalEvent_default.RESIZE_END, () => {
        outline.update();
      });
      this.outline = wnd;
      this.outline.Outline = outline;
    }
    this.outline.setVisible(true);
    this.outline.outline.update(true);
  }
  /**
   * Puts the graph into the specified mode. The following mode names are supported:
   * - select - Selects using the left mouse button, new connections are disabled.
   * - connect - Selects using the left mouse button or creates new connections if mouse over cell hotspot. See {@link ConnectionHandler}.
   * - pan - Pans using the left mouse button, new connections are disabled.
   */
  setMode(modename) {
    const panningHandler = this.graph.getPlugin("PanningHandler");
    if (modename === "select") {
      panningHandler && (panningHandler.useLeftButtonForPanning = false);
      this.graph.setConnectable(false);
    } else if (modename === "connect") {
      panningHandler && (panningHandler.useLeftButtonForPanning = false);
      this.graph.setConnectable(true);
    } else if (modename === "pan") {
      panningHandler && (panningHandler.useLeftButtonForPanning = true);
      this.graph.setConnectable(false);
    }
  }
  /**
   * Uses {@link popupHandler} to create the menu in the graph's
   * panning handler. The redirection is setup in {@link setToolbarContainer}.
   * @param menu
   * @param cell
   * @param evt
   */
  createPopupMenu(menu2, cell2, evt2) {
    this.popupHandler.createMenu(this, menu2, cell2, evt2);
  }
  /**
   * Uses {@link defaultEdge} as the prototype for creating new edges
   * in the connection handler of the graph. The style of the
   * edge will be overridden with the value returned by {@link getEdgeStyle}.
   * @param source
   * @param target
   */
  createEdge(source2, target2) {
    let e;
    if (this.defaultEdge != null) {
      e = cloneCell(this.defaultEdge);
    } else {
      e = new Cell_default("");
      e.setEdge(true);
      const geo = new Geometry_default();
      geo.relative = true;
      e.setGeometry(geo);
    }
    const style2 = this.getEdgeStyle();
    if (style2 != null) {
      e.setStyle(style2);
    }
    return e;
  }
  /**
   * Returns a string identifying the style of new edges.
   * The function is used in {@link createEdge} when new edges
   * are created in the graph.
   */
  getEdgeStyle() {
    return this.defaultEdgeStyle;
  }
  /**
   * Returns the next attribute in {@link cycleAttributeValues}
   * or null, if not attribute should be used in the specified cell.
   * @param cell
   */
  consumeCycleAttribute(cell2) {
    return this.cycleAttributeValues != null && this.cycleAttributeValues.length > 0 && this.graph.isSwimlane(cell2) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] : null;
  }
  /**
   * Uses the returned value from {@link consumeCycleAttribute}
   * as the value for the {@link cycleAttributeName} key in the given cell's style.
   * @param cell
   */
  cycleAttribute(cell2) {
    if (this.cycleAttributeName != null) {
      const value2 = this.consumeCycleAttribute(cell2);
      if (value2 != null) {
        cell2.setStyle(`${cell2.getStyle()};${this.cycleAttributeName}=${value2}`);
      }
    }
  }
  /**
   * Adds the given vertex as a child of parent at the specified
   * x and y coordinate and fires an {@link addVertex} event.
   * @param parent
   * @param vertex
   * @param x
   * @param y
   */
  addVertex(parent2, vertex, x, y) {
    const model2 = this.graph.getDataModel();
    while (parent2 != null && !this.graph.isValidDropTarget(parent2)) {
      parent2 = parent2.getParent();
    }
    parent2 = parent2 != null ? parent2 : this.graph.getSwimlaneAt(x, y);
    const { scale } = this.graph.getView();
    let geo = vertex.getGeometry();
    const pgeo = parent2.getGeometry();
    if (this.graph.isSwimlane(vertex) && !this.graph.swimlaneNesting) {
      parent2 = null;
    } else if (parent2 == null && this.swimlaneRequired) {
      return null;
    } else if (parent2 != null && pgeo != null) {
      const state2 = this.graph.getView().getState(parent2);
      if (state2 != null) {
        x -= state2.origin.x * scale;
        y -= state2.origin.y * scale;
        if (this.graph.isConstrainedMoving) {
          const { width } = geo;
          const { height } = geo;
          let tmp2 = state2.x + state2.width;
          if (x + width > tmp2) {
            x -= x + width - tmp2;
          }
          tmp2 = state2.y + state2.height;
          if (y + height > tmp2) {
            y -= y + height - tmp2;
          }
        }
      } else if (pgeo != null) {
        x -= pgeo.x * scale;
        y -= pgeo.y * scale;
      }
    }
    geo = geo.clone();
    geo.x = this.graph.snap(x / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);
    geo.y = this.graph.snap(y / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);
    vertex.setGeometry(geo);
    if (parent2 == null) {
      parent2 = this.graph.getDefaultParent();
    }
    this.cycleAttribute(vertex);
    this.fireEvent(new EventObject_default(InternalEvent_default.BEFORE_ADD_VERTEX, { vertex, parent: parent2 }));
    model2.beginUpdate();
    try {
      vertex = this.graph.addCell(vertex, parent2);
      if (vertex != null) {
        this.graph.constrainChild(vertex);
        this.fireEvent(new EventObject_default(InternalEvent_default.ADD_VERTEX, { vertex }));
      }
    } finally {
      model2.endUpdate();
    }
    if (vertex != null) {
      this.graph.setSelectionCell(vertex);
      this.graph.scrollCellToVisible(vertex);
      this.fireEvent(new EventObject_default(InternalEvent_default.AFTER_ADD_VERTEX, { vertex }));
    }
    return vertex;
  }
  /**
   * Removes the editor and all its associated resources. This does not
   * normally need to be called, it is called automatically when the window
   * unloads.
   */
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      if (this.tasks != null) {
        this.tasks.destroy();
      }
      if (this.outline != null) {
        this.outline.destroy();
      }
      if (this.properties != null) {
        this.properties.destroy();
      }
      if (this.keyHandler != null) {
        this.keyHandler.destroy();
      }
      if (this.rubberband != null) {
        this.rubberband.onDestroy();
      }
      if (this.toolbar != null) {
        this.toolbar.destroy();
      }
      if (this.graph != null) {
        this.graph.destroy();
      }
      this.status = null;
      this.templates = null;
    }
  }
};
var Editor_default = Editor;

// node_modules/@maxgraph/core/lib/view/cell/CellTracker.js
var CellTracker = class extends CellMarker_default {
  constructor(graph, color, funct2 = null) {
    super(graph, color);
    this.destroyed = false;
    this.graph.addMouseListener(this);
    if (funct2) {
      this.getCell = funct2;
    }
  }
  /**
   * Ignores the event. The event is not consumed.
   */
  mouseDown(sender, me) {
    return;
  }
  /**
   * Handles the event by highlighting the cell under the mousepointer if it
   * is over the hotspot region of the cell.
   */
  mouseMove(sender, me) {
    if (this.isEnabled()) {
      this.process(me);
    }
  }
  /**
   * Handles the event by resetting the highlight.
   */
  mouseUp(sender, me) {
    return;
  }
  /**
   * Destroys the object and all its resources and DOM nodes. This doesn't
   * normally need to be called. It is called automatically when the window
   * unloads.
   */
  destroy() {
    if (!this.destroyed) {
      this.destroyed = true;
      this.graph.removeMouseListener(this);
      super.destroy();
    }
  }
};
var CellTracker_default = CellTracker;

// node_modules/@maxgraph/core/lib/view/cell/VertexHandle.js
var VertexHandle = class {
  constructor(state2, cursor = "default", image = null, shape2 = null) {
    this.dependencies = ["snap", "cells"];
    this.cursor = "default";
    this.image = null;
    this.ignoreGrid = false;
    this.active = true;
    this.graph = state2.view.graph;
    this.state = state2;
    this.cursor = cursor;
    this.image = image;
    this.shape = shape2;
    this.init();
  }
  /**
   * Hook for subclassers to return the current position of the handle.
   */
  getPosition(bounds) {
    return new Point_default();
  }
  /**
   * Hooks for subclassers to update the style in the <state>.
   */
  setPosition(bounds, pt, me) {
    return;
  }
  /**
   * Hook for subclassers to execute the handle.
   */
  execute(me) {
    return;
  }
  /**
   * Sets the cell style with the given name to the corresponding value in <state>.
   */
  copyStyle(key2) {
    this.graph.setCellStyles(key2, this.state.style[key2], [this.state.cell]);
  }
  /**
   * Processes the given {@link MouseEvent} and invokes <setPosition>.
   */
  processEvent(me) {
    const { scale } = this.graph.view;
    const tr = this.graph.view.translate;
    let pt = new Point_default(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);
    if (this.shape != null && this.shape.bounds != null) {
      pt.x -= this.shape.bounds.width / scale / 4;
      pt.y -= this.shape.bounds.height / scale / 4;
    }
    const alpha1 = -toRadians(this.getRotation());
    const alpha2 = -toRadians(this.getTotalRotation()) - alpha1;
    pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));
    this.redraw();
  }
  /**
   * Should be called after <setPosition> in <processEvent>.
   * This repaints the state using {@link CellRenderer}.
   */
  positionChanged() {
    if (this.state.text != null) {
      this.state.text.apply(this.state);
    }
    if (this.state.shape != null) {
      this.state.shape.apply(this.state);
    }
    this.graph.cellRenderer.redraw(this.state, true);
  }
  /**
   * Returns the rotation defined in the style of the cell.
   */
  getRotation() {
    if (this.state.shape != null) {
      return this.state.shape.getRotation();
    }
    return 0;
  }
  /**
   * Returns the rotation from the style and the rotation from the direction of
   * the cell.
   */
  getTotalRotation() {
    if (this.state.shape != null) {
      return this.state.shape.getShapeRotation();
    }
    return 0;
  }
  /**
   * Creates and initializes the shapes required for this handle.
   */
  init() {
    const html = this.isHtmlRequired();
    if (this.image) {
      this.shape = new ImageShape_default(new Rectangle_default(0, 0, this.image.width, this.image.height), this.image.src);
      this.shape.preserveImageAspect = false;
    } else if (!this.shape) {
      this.shape = this.createShape(html);
    }
    this.initShape(html);
  }
  /**
   * Creates and returns the shape for this handle.
   */
  createShape(html) {
    const bounds = new Rectangle_default(0, 0, HANDLE_SIZE, HANDLE_SIZE);
    return new RectangleShape_default(bounds, HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);
  }
  /**
   * Initializes <shape> and sets its cursor.
   */
  initShape(html) {
    const shape2 = this.shape;
    if (html && shape2.isHtmlAllowed()) {
      shape2.dialect = DIALECT.STRICTHTML;
      shape2.init(this.graph.container);
    } else {
      shape2.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;
      if (this.cursor) {
        shape2.init(this.graph.getView().getOverlayPane());
      }
    }
    InternalEvent_default.redirectMouseEvents(shape2.node, this.graph, this.state);
    shape2.node.style.cursor = this.cursor;
  }
  /**
   * Renders the shape for this handle.
   */
  redraw() {
    if (this.shape && this.state.shape) {
      let pt = this.getPosition(this.state.getPaintBounds());
      if (pt) {
        const alpha = toRadians(this.getTotalRotation());
        pt = this.rotatePoint(this.flipPoint(pt), alpha);
        const { scale } = this.graph.view;
        const tr = this.graph.view.translate;
        const shapeBounds = this.shape.bounds;
        shapeBounds.x = Math.floor((pt.x + tr.x) * scale - shapeBounds.width / 2);
        shapeBounds.y = Math.floor((pt.y + tr.y) * scale - shapeBounds.height / 2);
        this.shape.redraw();
      }
    }
  }
  /**
   * Returns true if this handle should be rendered in HTML. This returns true if
   * the text node is in the graph container.
   */
  isHtmlRequired() {
    return !!this.state.text && this.state.text.node.parentNode === this.graph.container;
  }
  /**
   * Rotates the point by the given angle.
   */
  rotatePoint(pt, alpha) {
    const bounds = this.state.getCellBounds();
    const cx = new Point_default(bounds.getCenterX(), bounds.getCenterY());
    const cos = Math.cos(alpha);
    const sin = Math.sin(alpha);
    return getRotatedPoint(pt, cos, sin, cx);
  }
  /**
   * Flips the given point vertically and/or horizontally.
   */
  flipPoint(pt) {
    if (this.state.shape) {
      const bounds = this.state.getCellBounds();
      if (this.state.shape.flipH) {
        pt.x = 2 * bounds.x + bounds.width - pt.x;
      }
      if (this.state.shape.flipV) {
        pt.y = 2 * bounds.y + bounds.height - pt.y;
      }
    }
    return pt;
  }
  /**
   * Snaps the given point to the grid if ignore is false. This modifies
   * the given point in-place and also returns it.
   */
  snapPoint(pt, ignore) {
    if (!ignore) {
      pt.x = this.graph.snap(pt.x);
      pt.y = this.graph.snap(pt.y);
    }
    return pt;
  }
  /**
   * Shows or hides this handle.
   */
  setVisible(visible) {
    if (this.shape && this.shape.node) {
      this.shape.node.style.display = visible ? "" : "none";
    }
  }
  /**
   * Resets the state of this handle by setting its visibility to true.
   */
  reset() {
    this.setVisible(true);
    this.state.style = this.graph.getCellStyle(this.state.cell);
    this.positionChanged();
  }
  /**
   * Destroys this handle.
   */
  destroy() {
    if (this.shape) {
      this.shape.destroy();
      this.shape = null;
    }
  }
};
var VertexHandle_default = VertexHandle;

// node_modules/@maxgraph/core/lib/view/layout/CircleLayout.js
var CircleLayout = class extends GraphLayout_default {
  /**
   * Constructs a new circular layout for the specified radius.
   *
   * @param graph {@link Graph} that contains the cells.
   * @param radius Optional radius as an int. Default is 100.
   */
  constructor(graph, radius = 100) {
    super(graph);
    this.moveCircle = false;
    this.x0 = 0;
    this.y0 = 0;
    this.resetEdges = true;
    this.disableEdgeStyle = true;
    this.radius = radius;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   */
  execute(parent2) {
    this.graph.batchUpdate(() => {
      let max = 0;
      let top = null;
      let left = null;
      const vertices = [];
      const childCount2 = parent2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const cell2 = parent2.getChildAt(i2);
        if (!this.isVertexIgnored(cell2)) {
          vertices.push(cell2);
          const bounds = this.getVertexBounds(cell2);
          if (top == null) {
            top = bounds.y;
          } else {
            top = Math.min(top, bounds.y);
          }
          if (left == null) {
            left = bounds.x;
          } else {
            left = Math.min(left, bounds.x);
          }
          max = Math.max(max, Math.max(bounds.width, bounds.height));
        } else if (!this.isEdgeIgnored(cell2)) {
          if (this.resetEdges) {
            this.graph.resetEdge(cell2);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(cell2, false);
          }
        }
      }
      const r = this.getRadius(vertices.length, max);
      if (this.moveCircle) {
        left = this.x0;
        top = this.y0;
      }
      this.circle(vertices, r, left, top);
    });
  }
  /**
   * Returns the radius to be used for the given vertex count. Max is the maximum
   * width or height of all vertices in the layout.
   */
  getRadius(count, max) {
    return Math.max(count * max / Math.PI, this.radius);
  }
  /**
   * Executes the circular layout for the specified array
   * of vertices and the given radius. This is called from
   * <execute>.
   */
  circle(vertices, r, left, top) {
    const vertexCount = vertices.length;
    const phi = 2 * Math.PI / vertexCount;
    vertices.forEach((vertex, i2) => {
      if (this.isVertexMovable(vertex)) {
        this.setVertexLocation(vertex, Math.round(left + r + r * Math.sin(i2 * phi)), Math.round(top + r + r * Math.cos(i2 * phi)));
      }
    });
  }
};
var CircleLayout_default = CircleLayout;

// node_modules/@maxgraph/core/lib/view/layout/CompositeLayout.js
var CompositeLayout = class extends GraphLayout_default {
  /**
   * Constructs a new layout using the given layouts. The graph instance is
   * required for creating the transaction that contains all layouts.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param layouts Array of {@link GraphLayout}s.
   * @param master Optional layout that handles moves. If no layout is given, then the first layout of the above array is used to handle moves.
   */
  constructor(graph, layouts, master) {
    super(graph);
    this.layouts = layouts;
    this.master = master;
  }
  /**
   * Calls `move` on {@link master} or the first layout in {@link layouts}.
   */
  moveCell(cell2, x, y) {
    if (this.master != null) {
      this.master.moveCell.apply(this.master, [cell2, x, y]);
    } else {
      this.layouts[0].moveCell.apply(this.layouts[0], [cell2, x, y]);
    }
  }
  /**
   * Implements {@link GraphLayout#execute} by executing all {@link layouts} in a single transaction.
   */
  execute(parent2) {
    this.graph.batchUpdate(() => {
      for (let i2 = 0; i2 < this.layouts.length; i2 += 1) {
        this.layouts[i2].execute.apply(this.layouts[i2], [parent2]);
      }
    });
  }
};
var CompositeLayout_default = CompositeLayout;

// node_modules/@maxgraph/core/lib/view/layout/EdgeLabelLayout.js
var EdgeLabelLayout = class extends GraphLayout_default {
  constructor(graph, radius) {
    super(graph);
  }
  /**
   * Implements {@link GraphLayout.execute}
   */
  execute(parent2) {
    const { view } = this.graph;
    const model2 = this.graph.getDataModel();
    const edges = [];
    const vertices = [];
    const childCount2 = parent2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const cell2 = parent2.getChildAt(i2);
      const state2 = view.getState(cell2);
      if (state2 != null) {
        if (!this.isVertexIgnored(cell2)) {
          vertices.push(state2);
        } else if (!this.isEdgeIgnored(cell2)) {
          edges.push(state2);
        }
      }
    }
    this.placeLabels(vertices, edges);
  }
  /**
   * Places the labels of the given edges.
   *
   * @param v   vertexes
   * @param e   edges
   */
  placeLabels(v, e) {
    this.graph.batchUpdate(() => {
      for (let i2 = 0; i2 < e.length; i2 += 1) {
        const edge2 = e[i2];
        if (edge2 != null && edge2.text != null && edge2.text.boundingBox != null) {
          for (let j = 0; j < v.length; j += 1) {
            const vertex = v[j];
            if (vertex != null) {
              this.avoid(edge2, vertex);
            }
          }
        }
      }
    });
  }
  /**
   * Places the labels of the given edges.
   */
  avoid(edge2, vertex) {
    const model2 = this.graph.getDataModel();
    const labRect = edge2.text.boundingBox;
    if (intersects2(labRect, vertex)) {
      const dy1 = -labRect.y - labRect.height + vertex.y;
      const dy2 = -labRect.y + vertex.y + vertex.height;
      let dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;
      const dx1 = -labRect.x - labRect.width + vertex.x;
      const dx2 = -labRect.x + vertex.x + vertex.width;
      let dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;
      if (Math.abs(dx) < Math.abs(dy)) {
        dy = 0;
      } else {
        dx = 0;
      }
      let g = edge2.cell.getGeometry();
      if (g != null) {
        g = g.clone();
        if (g.offset != null) {
          g.offset.x += dx;
          g.offset.y += dy;
        } else {
          g.offset = new Point_default(dx, dy);
        }
        model2.setGeometry(edge2.cell, g);
      }
    }
  }
};
var EdgeLabelLayout_default = EdgeLabelLayout;

// node_modules/@maxgraph/core/lib/view/layout/FastOrganicLayout.js
var MxFastOrganicLayout = class extends GraphLayout_default {
  constructor(graph) {
    super(graph);
    this.useInputOrigin = true;
    this.resetEdges = true;
    this.disableEdgeStyle = true;
    this.forceConstant = 50;
    this.forceConstantSquared = 0;
    this.minDistanceLimit = 2;
    this.maxDistanceLimit = 500;
    this.minDistanceLimitSquared = 4;
    this.initialTemp = 200;
    this.temperature = 0;
    this.maxIterations = 0;
    this.iteration = 0;
    this.vertexArray = [];
    this.dispX = [];
    this.dispY = [];
    this.cellLocation = [];
    this.radius = [];
    this.radiusSquared = [];
    this.isMoveable = [];
    this.neighbours = {};
    this.indices = {};
    this.allowedToRun = true;
  }
  /**
   * Returns a boolean indicating if the given <Cell> should be ignored as a
   * vertex. This returns true if the cell has no connections.
   *
   * @param vertex <Cell> whose ignored state should be returned.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;
  }
  /**
   * Implements {@link GraphLayout#execute}. This operates on all children of the
   * given parent where <isVertexIgnored> returns false.
   */
  execute(parent2) {
    this.vertexArray = [];
    let cells = this.graph.getChildVertices(parent2);
    for (let i2 = 0; i2 < cells.length; i2 += 1) {
      if (!this.isVertexIgnored(cells[i2])) {
        this.vertexArray.push(cells[i2]);
      }
    }
    const initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;
    const n = this.vertexArray.length;
    this.indices = {};
    this.dispX = [];
    this.dispY = [];
    this.cellLocation = [];
    this.isMoveable = [];
    this.neighbours = {};
    this.radius = [];
    this.radiusSquared = [];
    if (this.forceConstant < 1e-3) {
      this.forceConstant = 1e-3;
    }
    this.forceConstantSquared = this.forceConstant * this.forceConstant;
    for (let i2 = 0; i2 < this.vertexArray.length; i2 += 1) {
      const vertex = this.vertexArray[i2];
      this.cellLocation[i2] = [];
      const id2 = ObjectIdentity_default.get(vertex);
      this.indices[id2] = i2;
      const bounds = this.getVertexBounds(vertex);
      const { width } = bounds;
      const { height } = bounds;
      const { x } = bounds;
      const { y } = bounds;
      this.cellLocation[i2][0] = x + width / 2;
      this.cellLocation[i2][1] = y + height / 2;
      this.radius[i2] = Math.min(width, height);
      this.radiusSquared[i2] = this.radius[i2] * this.radius[i2];
    }
    this.graph.batchUpdate(() => {
      for (let i2 = 0; i2 < n; i2 += 1) {
        this.dispX[i2] = 0;
        this.dispY[i2] = 0;
        this.isMoveable[i2] = this.isVertexMovable(this.vertexArray[i2]);
        const edges = this.graph.getConnections(this.vertexArray[i2], parent2);
        cells = this.graph.getOpposites(edges, this.vertexArray[i2]);
        this.neighbours[i2] = [];
        for (let j = 0; j < cells.length; j += 1) {
          if (this.resetEdges) {
            this.graph.resetEdge(edges[j]);
          }
          if (this.disableEdgeStyle) {
            this.setEdgeStyleEnabled(edges[j], false);
          }
          const id2 = ObjectIdentity_default.get(cells[j]);
          const index = this.indices[id2];
          if (index != null) {
            this.neighbours[i2][j] = index;
          } else {
            this.neighbours[i2][j] = i2;
          }
        }
      }
      this.temperature = this.initialTemp;
      if (this.maxIterations === 0) {
        this.maxIterations = 20 * Math.sqrt(n);
      }
      for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration += 1) {
        if (!this.allowedToRun) {
          return;
        }
        this.calcRepulsion();
        this.calcAttraction();
        this.calcPositions();
        this.reduceTemperature();
      }
      let minx = null;
      let miny = null;
      for (let i2 = 0; i2 < this.vertexArray.length; i2 += 1) {
        const vertex = this.vertexArray[i2];
        if (this.isVertexMovable(vertex)) {
          const bounds = this.getVertexBounds(vertex);
          if (bounds != null) {
            this.cellLocation[i2][0] -= bounds.width / 2;
            this.cellLocation[i2][1] -= bounds.height / 2;
            const x = this.graph.snap(Math.round(this.cellLocation[i2][0]));
            const y = this.graph.snap(Math.round(this.cellLocation[i2][1]));
            this.setVertexLocation(vertex, x, y);
            if (minx == null) {
              minx = x;
            } else {
              minx = Math.min(minx, x);
            }
            if (miny == null) {
              miny = y;
            } else {
              miny = Math.min(miny, y);
            }
          }
        }
      }
      let dx = -(minx || 0) + 1;
      let dy = -(miny || 0) + 1;
      if (initialBounds != null) {
        dx += initialBounds.x;
        dy += initialBounds.y;
      }
      this.graph.moveCells(this.vertexArray, dx, dy);
    });
  }
  /**
   * Takes the displacements calculated for each cell and applies them to the
   * local cache of cell positions. Limits the displacement to the current
   * temperature.
   */
  calcPositions() {
    for (let index = 0; index < this.vertexArray.length; index += 1) {
      if (this.isMoveable[index]) {
        let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);
        if (deltaLength < 1e-3) {
          deltaLength = 1e-3;
        }
        const newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);
        const newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);
        this.dispX[index] = 0;
        this.dispY[index] = 0;
        this.cellLocation[index][0] += newXDisp;
        this.cellLocation[index][1] += newYDisp;
      }
    }
  }
  /**
   * Calculates the attractive forces between all laid out nodes linked by
   * edges
   */
  calcAttraction() {
    for (let i2 = 0; i2 < this.vertexArray.length; i2 += 1) {
      for (let k = 0; k < this.neighbours[i2].length; k += 1) {
        const j = this.neighbours[i2][k];
        if (i2 !== j && this.isMoveable[i2] && this.isMoveable[j]) {
          const xDelta = this.cellLocation[i2][0] - this.cellLocation[j][0];
          const yDelta = this.cellLocation[i2][1] - this.cellLocation[j][1];
          let deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i2] - this.radiusSquared[j];
          if (deltaLengthSquared < this.minDistanceLimitSquared) {
            deltaLengthSquared = this.minDistanceLimitSquared;
          }
          const deltaLength = Math.sqrt(deltaLengthSquared);
          const force = deltaLengthSquared / this.forceConstant;
          const displacementX = xDelta / deltaLength * force;
          const displacementY = yDelta / deltaLength * force;
          this.dispX[i2] -= displacementX;
          this.dispY[i2] -= displacementY;
          this.dispX[j] += displacementX;
          this.dispY[j] += displacementY;
        }
      }
    }
  }
  /**
   * Calculates the repulsive forces between all laid out nodes
   */
  calcRepulsion() {
    const vertexCount = this.vertexArray.length;
    for (let i2 = 0; i2 < vertexCount; i2 += 1) {
      for (let j = i2; j < vertexCount; j += 1) {
        if (!this.allowedToRun) {
          return;
        }
        if (j !== i2 && this.isMoveable[i2] && this.isMoveable[j]) {
          let xDelta = this.cellLocation[i2][0] - this.cellLocation[j][0];
          let yDelta = this.cellLocation[i2][1] - this.cellLocation[j][1];
          if (xDelta === 0) {
            xDelta = 0.01 + Math.random();
          }
          if (yDelta === 0) {
            yDelta = 0.01 + Math.random();
          }
          const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);
          let deltaLengthWithRadius = deltaLength - this.radius[i2] - this.radius[j];
          if (deltaLengthWithRadius > this.maxDistanceLimit) {
            continue;
          }
          if (deltaLengthWithRadius < this.minDistanceLimit) {
            deltaLengthWithRadius = this.minDistanceLimit;
          }
          const force = this.forceConstantSquared / deltaLengthWithRadius;
          const displacementX = xDelta / deltaLength * force;
          const displacementY = yDelta / deltaLength * force;
          this.dispX[i2] += displacementX;
          this.dispY[i2] += displacementY;
          this.dispX[j] -= displacementX;
          this.dispY[j] -= displacementY;
        }
      }
    }
  }
  /**
   * Reduces the temperature of the layout from an initial setting in a linear
   * fashion to zero.
   */
  reduceTemperature() {
    this.temperature = this.initialTemp * (1 - this.iteration / this.maxIterations);
  }
};
var FastOrganicLayout_default = MxFastOrganicLayout;

// node_modules/@maxgraph/core/lib/view/layout/ParallelEdgeLayout.js
var ParallelEdgeLayout = class extends GraphLayout_default {
  constructor(graph) {
    super(graph);
    this.spacing = 20;
    this.checkOverlap = false;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   */
  execute(parent2, cells = null) {
    const lookup = this.findParallels(parent2, cells);
    this.graph.batchUpdate(() => {
      for (const i2 in lookup) {
        const parallels = lookup[i2];
        if (parallels.length > 1) {
          this.layout(parallels);
        }
      }
    });
  }
  /**
   * Finds the parallel edges in the given parent.
   */
  findParallels(parent2, cells = null) {
    const lookup = [];
    const addCell = (cell2) => {
      if (!this.isEdgeIgnored(cell2)) {
        const id2 = this.getEdgeId(cell2);
        if (id2 != null) {
          if (lookup[id2] == null) {
            lookup[id2] = [];
          }
          lookup[id2].push(cell2);
        }
      }
    };
    if (cells != null) {
      for (let i2 = 0; i2 < cells.length; i2 += 1) {
        addCell(cells[i2]);
      }
    } else {
      const model2 = this.graph.getDataModel();
      const childCount2 = parent2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        addCell(parent2.getChildAt(i2));
      }
    }
    return lookup;
  }
  /**
   * Returns a unique ID for the given edge. The id is independent of the
   * edge direction and is built using the visible terminal of the given
   * edge.
   */
  getEdgeId(edge2) {
    const view = this.graph.getView();
    let src = view.getVisibleTerminal(edge2, true);
    let trg = view.getVisibleTerminal(edge2, false);
    let pts = "";
    if (src != null && trg != null) {
      src = ObjectIdentity_default.get(src);
      trg = ObjectIdentity_default.get(trg);
      if (this.checkOverlap) {
        const state2 = this.graph.view.getState(edge2);
        if (state2 != null && state2.absolutePoints != null) {
          const tmp2 = [];
          for (let i2 = 0; i2 < state2.absolutePoints.length; i2 += 1) {
            const pt = state2.absolutePoints[i2];
            if (pt != null) {
              tmp2.push(pt.x, pt.y);
            }
          }
          pts = tmp2.join(",");
        }
      }
      return (src > trg ? `${trg}-${src}` : `${src}-${trg}`) + pts;
    }
    return null;
  }
  /**
   * Lays out the parallel edges in the given array.
   */
  layout(parallels) {
    const edge2 = parallels[0];
    const view = this.graph.getView();
    const model2 = this.graph.getDataModel();
    const src = view.getVisibleTerminal(edge2, true).getGeometry();
    const trg = view.getVisibleTerminal(edge2, false).getGeometry();
    let x0;
    let y0;
    if (src === trg) {
      x0 = src.x + src.width + this.spacing;
      y0 = src.y + src.height / 2;
      for (let i2 = 0; i2 < parallels.length; i2 += 1) {
        this.route(parallels[i2], x0, y0);
        x0 += this.spacing;
      }
    } else if (src != null && trg != null) {
      const scx = src.x + src.width / 2;
      const scy = src.y + src.height / 2;
      const tcx = trg.x + trg.width / 2;
      const tcy = trg.y + trg.height / 2;
      const dx = tcx - scx;
      const dy = tcy - scy;
      const len = Math.sqrt(dx * dx + dy * dy);
      if (len > 0) {
        x0 = scx + dx / 2;
        y0 = scy + dy / 2;
        const nx = dy * this.spacing / len;
        const ny = dx * this.spacing / len;
        x0 += nx * (parallels.length - 1) / 2;
        y0 -= ny * (parallels.length - 1) / 2;
        for (let i2 = 0; i2 < parallels.length; i2 += 1) {
          this.route(parallels[i2], x0, y0);
          x0 -= nx;
          y0 += ny;
        }
      }
    }
  }
  /**
   * Routes the given edge via the given point.
   */
  route(edge2, x, y) {
    if (this.graph.isCellMovable(edge2)) {
      this.setEdgePoints(edge2, [new Point_default(x, y)]);
    }
  }
};
var ParallelEdgeLayout_default = ParallelEdgeLayout;

// node_modules/@maxgraph/core/lib/view/layout/PartitionLayout.js
var PartitionLayout = class extends GraphLayout_default {
  constructor(graph, horizontal = true, spacing = 0, border = 0) {
    super(graph);
    this.resizeVertices = true;
    this.horizontal = horizontal != null ? horizontal : true;
    this.spacing = spacing || 0;
    this.border = border || 0;
  }
  /**
   * Returns <horizontal>.
   */
  isHorizontal() {
    return this.horizontal;
  }
  /**
   * Implements {@link GraphLayout.moveCell}.
   *
   * @param {mxCell} cell
   * @param {number} x
   * @param {number} y
   * @memberof mxPartitionLayout
   */
  moveCell(cell2, x, y) {
    const model2 = this.graph.getDataModel();
    const parent2 = cell2.getParent();
    if (cell2 != null && parent2 != null) {
      let i2 = 0;
      let last = 0;
      const childCount2 = parent2.getChildCount();
      for (i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = parent2.getChildAt(i2);
        const bounds = this.getVertexBounds(child2);
        if (bounds != null) {
          const tmp2 = bounds.x + bounds.width / 2;
          if (last < x && tmp2 > x) {
            break;
          }
          last = tmp2;
        }
      }
      let idx = parent2.getIndex(cell2);
      idx = Math.max(0, i2 - (i2 > idx ? 1 : 0));
      model2.add(parent2, cell2, idx);
    }
  }
  /**
   * Implements {@link GraphLayout#execute}. All children where <isVertexIgnored>
   * returns false and <isVertexMovable> returns true are modified.
   */
  execute(parent2) {
    const horizontal = this.isHorizontal();
    const model2 = this.graph.getDataModel();
    let pgeo = parent2.getGeometry();
    if (this.graph.container != null && (pgeo == null && model2.isLayer(parent2) || parent2 === this.graph.getView().currentRoot)) {
      const width = this.graph.container.offsetWidth - 1;
      const height = this.graph.container.offsetHeight - 1;
      pgeo = new Rectangle_default(0, 0, width, height);
    }
    if (pgeo != null) {
      const children = [];
      const childCount2 = parent2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = parent2.getChildAt(i2);
        if (!this.isVertexIgnored(child2) && this.isVertexMovable(child2)) {
          children.push(child2);
        }
      }
      const n = children.length;
      if (n > 0) {
        let x0 = this.border;
        let y0 = this.border;
        let other = horizontal ? pgeo.height : pgeo.width;
        other -= 2 * this.border;
        const size = this.graph.isSwimlane(parent2) ? this.graph.getStartSize(parent2) : new Rectangle_default();
        other -= horizontal ? size.height : size.width;
        x0 += size.width;
        y0 += size.height;
        const tmp2 = this.border + (n - 1) * this.spacing;
        const value2 = horizontal ? (pgeo.width - x0 - tmp2) / n : (pgeo.height - y0 - tmp2) / n;
        if (value2 > 0) {
          model2.beginUpdate();
          try {
            for (let i2 = 0; i2 < n; i2 += 1) {
              const child2 = children[i2];
              let geo = child2.getGeometry();
              if (geo != null) {
                geo = geo.clone();
                geo.x = x0;
                geo.y = y0;
                if (horizontal) {
                  if (this.resizeVertices) {
                    geo.width = value2;
                    geo.height = other;
                  }
                  x0 += value2 + this.spacing;
                } else {
                  if (this.resizeVertices) {
                    geo.height = value2;
                    geo.width = other;
                  }
                  y0 += value2 + this.spacing;
                }
                model2.setGeometry(child2, geo);
              }
            }
          } finally {
            model2.endUpdate();
          }
        }
      }
    }
  }
};
var PartitionLayout_default = PartitionLayout;

// node_modules/@maxgraph/core/lib/view/layout/RadialTreeLayout.js
var RadialTreeLayout = class extends CompactTreeLayout {
  constructor(graph) {
    super(graph, false);
    this.centerX = null;
    this.centerY = null;
    this.angleOffset = 0.5;
    this.rootx = 0;
    this.rooty = 0;
    this.levelDistance = 120;
    this.nodeDistance = 10;
    this.autoRadius = false;
    this.sortEdges = false;
    this.rowMinX = {};
    this.rowMaxX = {};
    this.rowMinCenX = {};
    this.rowMaxCenX = {};
    this.rowRadi = {};
    this.row = [];
  }
  /**
   * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.
   *
   * @param vertex {@link mxCell} whose ignored state should be returned.
   * @return true if the cell has no connections.
   */
  isVertexIgnored(vertex) {
    return super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0;
  }
  /**
   * Implements {@link GraphLayout#execute}.
   *
   * If the parent has any connected edges, then it is used as the root of
   * the tree. Else, {@link Graph#findTreeRoots} will be used to find a suitable
   * root node within the set of children of the given parent.
   *
   * @param parent    {@link mxCell} whose children should be laid out.
   * @param root      Optional {@link mxCell} that will be used as the root of the tree.
   */
  execute(parent2, root = null) {
    this.parent = parent2;
    this.useBoundingBox = false;
    this.edgeRouting = false;
    super.execute(parent2, root || void 0);
    let bounds = null;
    const rootBounds = this.getVertexBounds(this.root);
    this.centerX = rootBounds.x + rootBounds.width / 2;
    this.centerY = rootBounds.y + rootBounds.height / 2;
    for (const vertex in this.visited) {
      const vertexBounds = this.getVertexBounds(this.visited[vertex]);
      bounds = bounds != null ? bounds : vertexBounds.clone();
      bounds.add(vertexBounds);
    }
    this.calcRowDims([this.node], 0);
    let maxLeftGrad = 0;
    let maxRightGrad = 0;
    for (let i2 = 0; i2 < this.row.length; i2 += 1) {
      const leftGrad = (this.centerX - this.rowMinX[i2] - this.nodeDistance) / this.rowRadi[i2];
      const rightGrad = (this.rowMaxX[i2] - this.centerX - this.nodeDistance) / this.rowRadi[i2];
      maxLeftGrad = Math.max(maxLeftGrad, leftGrad);
      maxRightGrad = Math.max(maxRightGrad, rightGrad);
    }
    for (let i2 = 0; i2 < this.row.length; i2 += 1) {
      const xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i2];
      const xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i2];
      const fullWidth = xRightLimit - xLeftLimit;
      for (let j = 0; j < this.row[i2].length; j++) {
        const row2 = this.row[i2];
        const node2 = row2[j];
        const vertexBounds = this.getVertexBounds(node2.cell);
        const xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;
        const theta = 2 * Math.PI * xProportion;
        node2.theta = theta;
      }
    }
    for (let i2 = this.row.length - 2; i2 >= 0; i2--) {
      const row2 = this.row[i2];
      for (let j = 0; j < row2.length; j++) {
        const node2 = row2[j];
        let { child: child2 } = node2;
        let counter = 0;
        let totalTheta = 0;
        while (child2 != null) {
          totalTheta += child2.theta;
          counter++;
          child2 = child2.next;
        }
        if (counter > 0) {
          const averTheta = totalTheta / counter;
          if (averTheta > node2.theta && j < row2.length - 1) {
            const nextTheta = row2[j + 1].theta;
            node2.theta = Math.min(averTheta, nextTheta - Math.PI / 10);
          } else if (averTheta < node2.theta && j > 0) {
            const lastTheta = row2[j - 1].theta;
            node2.theta = Math.max(averTheta, lastTheta + Math.PI / 10);
          }
        }
      }
    }
    for (let i2 = 0; i2 < this.row.length; i2 += 1) {
      for (let j = 0; j < this.row[i2].length; j++) {
        const row2 = this.row[i2];
        const node2 = row2[j];
        const vertexBounds = this.getVertexBounds(node2.cell);
        this.setVertexLocation(node2.cell, this.centerX - vertexBounds.width / 2 + this.rowRadi[i2] * Math.cos(node2.theta), this.centerY - vertexBounds.height / 2 + this.rowRadi[i2] * Math.sin(node2.theta));
      }
    }
  }
  /**
   * Recursive function to calculate the dimensions of each row
   *
   * @param row      Array of internal nodes, the children of which are to be processed.
   * @param rowNum   Integer indicating which row is being processed.
   */
  calcRowDims(row2, rowNum) {
    if (row2 == null || row2.length === 0) {
      return;
    }
    this.rowMinX[rowNum] = this.centerX;
    this.rowMaxX[rowNum] = this.centerX;
    this.rowMinCenX[rowNum] = this.centerX;
    this.rowMaxCenX[rowNum] = this.centerX;
    this.row[rowNum] = [];
    let rowHasChildren = false;
    for (let i2 = 0; i2 < row2.length; i2 += 1) {
      let child2 = row2[i2] != null ? row2[i2].child : null;
      while (child2 != null) {
        const { cell: cell2 } = child2;
        const vertexBounds = this.getVertexBounds(cell2);
        this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);
        this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);
        this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);
        this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);
        this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;
        if (child2.child != null) {
          rowHasChildren = true;
        }
        this.row[rowNum].push(child2);
        child2 = child2.next;
      }
    }
    if (rowHasChildren) {
      this.calcRowDims(this.row[rowNum], rowNum + 1);
    }
  }
};
var RadialTreeLayout_default = RadialTreeLayout;

// node_modules/@maxgraph/core/lib/view/layout/datatypes/HierarchicalEdgeStyle.js
var HierarchicalEdgeStyle = {
  ORTHOGONAL: 1,
  POLYLINE: 2,
  STRAIGHT: 3,
  CURVE: 4
};
var HierarchicalEdgeStyle_default = HierarchicalEdgeStyle;

// node_modules/@maxgraph/core/lib/view/layout/datatypes/GraphAbstractHierarchyCell.js
var GraphAbstractHierarchyCell = class extends Cell_default {
  constructor() {
    super();
    this.swimlaneIndex = null;
    this.maxRank = -1;
    this.minRank = -1;
    this.width = 0;
    this.height = 0;
    this.nextLayerConnectedCells = null;
    this.previousLayerConnectedCells = null;
    this.x = [];
    this.y = [];
    this.temp = [];
  }
  /**
   * Returns whether or not this cell is an edge
   */
  isEdge() {
    return false;
  }
  /**
   * Returns whether or not this cell is a node
   */
  isVertex() {
    return false;
  }
  /**
   * Set the value of x for the specified layer
   */
  setX(layer, value2) {
    if (this.isVertex()) {
      this.x[0] = value2;
    } else if (this.isEdge()) {
      this.x[layer - this.minRank - 1] = value2;
    }
  }
  /**
   * Gets the value of x on the specified layer
   */
  getX(layer) {
    if (this.isVertex()) {
      return this.x[0];
    }
    if (this.isEdge()) {
      return this.x[layer - this.minRank - 1];
    }
    return 0;
  }
  /**
   * Set the value of y for the specified layer
   */
  setY(layer, value2) {
    if (this.isVertex()) {
      this.y[0] = value2;
    } else if (this.isEdge()) {
      this.y[layer - this.minRank - 1] = value2;
    }
  }
};
var GraphAbstractHierarchyCell_default = GraphAbstractHierarchyCell;

// node_modules/@maxgraph/core/lib/view/layout/datatypes/GraphHierarchyNode.js
var GraphHierarchyNode = class extends GraphAbstractHierarchyCell_default {
  /**
   * Constructs an internal node to represent the specified real graph cell
   *
   * @param cell the real graph cell this node represents
   */
  constructor(cell2) {
    super();
    this.ids = [];
    this.hashCode = false;
    this.cell = cell2;
    this.id = ObjectIdentity_default.get(cell2);
    this.connectsAsTarget = [];
    this.connectsAsSource = [];
  }
  /**
   * Returns the integer value of the layer that this node resides in
   */
  getRankValue(layer) {
    return this.maxRank;
  }
  /**
   * Returns the cells this cell connects to on the next layer up
   */
  getNextLayerConnectedCells(layer) {
    if (this.nextLayerConnectedCells == null) {
      this.nextLayerConnectedCells = {};
      this.nextLayerConnectedCells[0] = [];
      for (let i2 = 0; i2 < this.connectsAsTarget.length; i2 += 1) {
        const edge2 = this.connectsAsTarget[i2];
        if (edge2.maxRank === -1 || edge2.maxRank === layer + 1) {
          this.nextLayerConnectedCells[0].push(edge2.source);
        } else {
          this.nextLayerConnectedCells[0].push(edge2);
        }
      }
    }
    return this.nextLayerConnectedCells[0];
  }
  /**
   * Returns the cells this cell connects to on the next layer down
   */
  getPreviousLayerConnectedCells(layer) {
    if (this.previousLayerConnectedCells == null) {
      this.previousLayerConnectedCells = [];
      this.previousLayerConnectedCells[0] = [];
      for (let i2 = 0; i2 < this.connectsAsSource.length; i2 += 1) {
        const edge2 = this.connectsAsSource[i2];
        if (edge2.minRank === -1 || edge2.minRank === layer - 1) {
          this.previousLayerConnectedCells[0].push(edge2.target);
        } else {
          this.previousLayerConnectedCells[0].push(edge2);
        }
      }
    }
    return this.previousLayerConnectedCells[0];
  }
  /**
   * Returns true.
   */
  isVertex() {
    return true;
  }
  /**
   * Gets the value of temp for the specified layer
   */
  getGeneralPurposeVariable(layer) {
    return this.temp[0];
  }
  /**
   * Set the value of temp for the specified layer
   */
  setGeneralPurposeVariable(layer, value2) {
    this.temp[0] = value2;
  }
  isAncestor(otherNode) {
    if (otherNode != null && this.hashCode != null && otherNode.hashCode != null && this.hashCode.length < otherNode.hashCode.length) {
      if (this.hashCode === otherNode.hashCode) {
        return true;
      }
      if (this.hashCode == null || this.hashCode == null) {
        return false;
      }
      for (let i2 = 0; i2 < this.hashCode.length; i2 += 1) {
        if (this.hashCode[i2] !== otherNode.hashCode[i2]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Gets the core vertex associated with this wrapper
   */
  getCoreCell() {
    return this.cell;
  }
};
var GraphHierarchyNode_default = GraphHierarchyNode;

// node_modules/@maxgraph/core/lib/view/layout/datatypes/GraphHierarchyEdge.js
var GraphHierarchyEdge = class extends GraphAbstractHierarchyCell_default {
  /**
   * Constructs a hierarchy edge
   *
   * @param edges a list of real graph edges this abstraction represents
   */
  constructor(edges) {
    super();
    this.source = null;
    this.target = null;
    this.isReversed = false;
    this.edges = edges;
    this.ids = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      this.ids.push(ObjectIdentity_default.get(edges[i2]));
    }
  }
  /**
   * Inverts the direction of this internal edge(s)
   */
  invert() {
    const temp = this.source;
    this.source = this.target;
    this.target = temp;
    this.isReversed = !this.isReversed;
  }
  /**
   * Returns the cells this cell connects to on the next layer up
   */
  getNextLayerConnectedCells(layer) {
    if (this.nextLayerConnectedCells == null) {
      this.nextLayerConnectedCells = [];
      for (let i2 = 0; i2 < this.temp.length; i2 += 1) {
        this.nextLayerConnectedCells[i2] = [];
        if (i2 === this.temp.length - 1) {
          this.nextLayerConnectedCells[i2].push(this.source);
        } else {
          this.nextLayerConnectedCells[i2].push(this);
        }
      }
    }
    return this.nextLayerConnectedCells[layer - this.minRank - 1];
  }
  /**
   * Returns the cells this cell connects to on the next layer down
   */
  getPreviousLayerConnectedCells(layer) {
    if (this.previousLayerConnectedCells == null) {
      this.previousLayerConnectedCells = [];
      for (let i2 = 0; i2 < this.temp.length; i2 += 1) {
        this.previousLayerConnectedCells[i2] = [];
        if (i2 === 0) {
          this.previousLayerConnectedCells[i2].push(this.target);
        } else {
          this.previousLayerConnectedCells[i2].push(this);
        }
      }
    }
    return this.previousLayerConnectedCells[layer - this.minRank - 1];
  }
  /**
   * Returns true.
   */
  isEdge() {
    return true;
  }
  /**
   * Gets the value of temp for the specified layer
   */
  getGeneralPurposeVariable(layer) {
    return this.temp[layer - this.minRank - 1];
  }
  /**
   * Set the value of temp for the specified layer
   */
  setGeneralPurposeVariable(layer, value2) {
    this.temp[layer - this.minRank - 1] = value2;
  }
  /**
   * Gets the first core edge associated with this wrapper
   */
  getCoreCell() {
    if (this.edges.length > 0) {
      return this.edges[0];
    }
    return null;
  }
};
var GraphHierarchyEdge_default = GraphHierarchyEdge;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/GraphHierarchyModel.js
var GraphHierarchyModel = class {
  /**
   *
   * Creates an internal ordered graph model using the vertices passed in. If
   * there are any, leftward edge need to be inverted in the internal model
   *
   * @param layout
   * @param vertices the vertices for this hierarchy
   * @param roots
   * @param parent
   * @param tightenToSource whether or not to tighten vertices towards the sources
   */
  constructor(layout, vertices, roots, parent2, tightenToSource) {
    this.ranks = null;
    this.roots = null;
    this.parent = null;
    this.dfsCount = 0;
    this.SOURCESCANSTARTRANK = 1e8;
    this.tightenToSource = false;
    const graph = layout.getGraph();
    this.tightenToSource = tightenToSource;
    this.roots = roots;
    this.parent = parent2;
    this.vertexMapper = new Dictionary_default();
    this.edgeMapper = new Dictionary_default();
    this.maxRank = 0;
    const internalVertices = {};
    if (vertices == null) {
      vertices = graph.getChildVertices(parent2);
    }
    this.maxRank = this.SOURCESCANSTARTRANK;
    this.createInternalCells(layout, vertices, internalVertices);
    for (let i2 = 0; i2 < vertices.length; i2 += 1) {
      const edges = internalVertices[i2].connectsAsSource;
      for (let j = 0; j < edges.length; j++) {
        const internalEdge = edges[j];
        const realEdges = internalEdge.edges;
        if (realEdges != null && realEdges.length > 0) {
          const realEdge = realEdges[0];
          let targetCell = layout.getVisibleTerminal(realEdge, false);
          let internalTargetCell = this.vertexMapper.get(targetCell);
          if (internalVertices[i2] === internalTargetCell) {
            targetCell = layout.getVisibleTerminal(realEdge, true);
            internalTargetCell = this.vertexMapper.get(targetCell);
          }
          if (internalTargetCell != null && internalVertices[i2] !== internalTargetCell) {
            internalEdge.target = internalTargetCell;
            if (internalTargetCell.connectsAsTarget.length === 0) {
              internalTargetCell.connectsAsTarget = [];
            }
            if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {
              internalTargetCell.connectsAsTarget.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i2].temp[0] = 1;
    }
  }
  /**
   * Creates all edges in the internal model
   *
   * @param layout Reference to the <HierarchicalLayout> algorithm.
   * @param vertices Array of {@link Cells} that represent the vertices whom are to
   * have an internal representation created.
   * @param internalVertices The array of {@link GraphHierarchyNodes} to have their
   * information filled in using the real vertices.
   */
  createInternalCells(layout, vertices, internalVertices) {
    const graph = layout.getGraph();
    for (let i2 = 0; i2 < vertices.length; i2 += 1) {
      internalVertices[i2] = new GraphHierarchyNode_default(vertices[i2]);
      this.vertexMapper.put(vertices[i2], internalVertices[i2]);
      const conns = layout.getEdges(vertices[i2]);
      internalVertices[i2].connectsAsSource = [];
      for (let j = 0; j < conns.length; j++) {
        const cell2 = layout.getVisibleTerminal(conns[j], false);
        if (cell2 !== vertices[i2] && cell2.isVertex() && !layout.isVertexIgnored(cell2)) {
          const undirectedEdges = layout.getEdgesBetween(vertices[i2], cell2, false);
          const directedEdges = layout.getEdgesBetween(vertices[i2], cell2, true);
          if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
            const internalEdge = new GraphHierarchyEdge_default(undirectedEdges);
            for (let k = 0; k < undirectedEdges.length; k++) {
              const edge2 = undirectedEdges[k];
              this.edgeMapper.put(edge2, internalEdge);
              graph.resetEdge(edge2);
              if (layout.disableEdgeStyle) {
                layout.setEdgeStyleEnabled(edge2, false);
                layout.setOrthogonalEdge(edge2, true);
              }
            }
            internalEdge.source = internalVertices[i2];
            if (internalVertices[i2].connectsAsSource.indexOf(internalEdge) < 0) {
              internalVertices[i2].connectsAsSource.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i2].temp[0] = 0;
    }
  }
  /**
   * Basic determination of minimum layer ranking by working from from sources
   * or sinks and working through each node in the relevant edge direction.
   * Starting at the sinks is basically a longest path layering algorithm.
   */
  initialRank() {
    const startNodes = [];
    if (this.roots != null) {
      for (let i2 = 0; i2 < this.roots.length; i2 += 1) {
        const internalNode = this.vertexMapper.get(this.roots[i2]);
        if (internalNode != null) {
          startNodes.push(internalNode);
        }
      }
    }
    const internalNodes = this.vertexMapper.getValues();
    for (let i2 = 0; i2 < internalNodes.length; i2 += 1) {
      internalNodes[i2].temp[0] = -1;
    }
    const startNodesCopy = startNodes.slice();
    while (startNodes.length > 0) {
      const internalNode = startNodes[0];
      const layerDeterminingEdges = internalNode.connectsAsTarget;
      const edgesToBeMarked = internalNode.connectsAsSource;
      let allEdgesScanned = true;
      let minimumLayer = this.SOURCESCANSTARTRANK;
      for (let i2 = 0; i2 < layerDeterminingEdges.length; i2 += 1) {
        const internalEdge = layerDeterminingEdges[i2];
        if (internalEdge.temp[0] === 5270620) {
          const otherNode = internalEdge.source;
          minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
        } else {
          allEdgesScanned = false;
          break;
        }
      }
      if (allEdgesScanned) {
        internalNode.temp[0] = minimumLayer;
        this.maxRank = Math.min(this.maxRank, minimumLayer);
        if (edgesToBeMarked != null) {
          for (let i2 = 0; i2 < edgesToBeMarked.length; i2 += 1) {
            const internalEdge = edgesToBeMarked[i2];
            internalEdge.temp[0] = 5270620;
            const otherNode = internalEdge.target;
            if (otherNode.temp[0] === -1) {
              startNodes.push(otherNode);
              otherNode.temp[0] = -2;
            }
          }
        }
        startNodes.shift();
      } else {
        const removedCell = startNodes.shift();
        startNodes.push(internalNode);
        if (removedCell === internalNode && startNodes.length === 1) {
          break;
        }
      }
    }
    for (let i2 = 0; i2 < internalNodes.length; i2 += 1) {
      internalNodes[i2].temp[0] -= this.maxRank;
    }
    for (let i2 = 0; i2 < startNodesCopy.length; i2 += 1) {
      const internalNode = startNodesCopy[i2];
      let currentMaxLayer = 0;
      const layerDeterminingEdges = internalNode.connectsAsSource;
      for (let j = 0; j < layerDeterminingEdges.length; j++) {
        const internalEdge = layerDeterminingEdges[j];
        const otherNode = internalEdge.target;
        internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);
        currentMaxLayer = internalNode.temp[0];
      }
    }
    this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;
  }
  /**
   * Fixes the layer assignments to the values stored in the nodes. Also needs
   * to create dummy nodes for edges that cross layers.
   */
  fixRanks() {
    const rankList = {};
    this.ranks = [];
    for (let i2 = 0; i2 < this.maxRank + 1; i2 += 1) {
      rankList[i2] = [];
      this.ranks.push(rankList[i2]);
    }
    let rootsArray = null;
    if (this.roots != null) {
      const oldRootsArray = this.roots;
      rootsArray = [];
      for (let i2 = 0; i2 < oldRootsArray.length; i2 += 1) {
        const cell2 = oldRootsArray[i2];
        const internalNode = this.vertexMapper.get(cell2);
        rootsArray[i2] = internalNode;
      }
    }
    this.visit((parent2, node2, edge2, layer, seen) => {
      if (seen == 0 && node2.maxRank < 0 && node2.minRank < 0) {
        rankList[node2.temp[0]].push(node2);
        node2.maxRank = node2.temp[0];
        node2.minRank = node2.temp[0];
        node2.temp[0] = rankList[node2.maxRank].length - 1;
      }
      if (parent2 != null && edge2 != null) {
        const parentToCellRankDifference = parent2.maxRank - node2.maxRank;
        if (parentToCellRankDifference > 1) {
          edge2.maxRank = parent2.maxRank;
          edge2.minRank = node2.maxRank;
          edge2.temp = [];
          edge2.x = [];
          edge2.y = [];
          for (let i2 = edge2.minRank + 1; i2 < edge2.maxRank; i2 += 1) {
            rankList[i2].push(edge2);
            edge2.setGeneralPurposeVariable(i2, rankList[i2].length - 1);
          }
        }
      }
    }, rootsArray, false, null);
  }
  /**
   * A depth first search through the internal heirarchy model.
   *
   * @param visitor The visitor function pattern to be called for each node.
   * @param trackAncestors Whether or not the search is to keep track all nodes
   * directly above this one in the search path.
   */
  visit(visitor, dfsRoots, trackAncestors, seenNodes = null) {
    if (dfsRoots != null) {
      for (let i2 = 0; i2 < dfsRoots.length; i2 += 1) {
        const internalNode = dfsRoots[i2];
        if (internalNode != null) {
          if (seenNodes == null) {
            seenNodes = {};
          }
          if (trackAncestors) {
            internalNode.hashCode = [];
            internalNode.hashCode[0] = this.dfsCount;
            internalNode.hashCode[1] = i2;
            this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i2, 0);
          } else {
            this.dfs(null, internalNode, null, visitor, seenNodes, 0);
          }
        }
      }
      this.dfsCount++;
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs a set of all of the
   * ancestor node of the current node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  dfs(parent2, root, connectingEdge, visitor, seen, layer) {
    if (root != null) {
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent2, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i2 = 0; i2 < outgoingEdges.length; i2 += 1) {
          const internalEdge = outgoingEdges[i2];
          const targetNode = internalEdge.target;
          this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);
        }
      } else {
        visitor(parent2, root, connectingEdge, layer, 1);
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of cells ancestors, but it
   * should be only used when necessary because of it can be computationally
   * intensive for deep searches.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs
   * @param ancestors the parent hash code
   * @param childHash the new hash code for this node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  extendedDfs(parent2, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
    if (root != null) {
      if (parent2 != null) {
        if (root.hashCode == null || root.hashCode[0] != parent2.hashCode[0]) {
          const hashCodeLength = parent2.hashCode.length + 1;
          root.hashCode = parent2.hashCode.slice();
          root.hashCode[hashCodeLength - 1] = childHash;
        }
      }
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent2, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i2 = 0; i2 < outgoingEdges.length; i2 += 1) {
          const internalEdge = outgoingEdges[i2];
          const targetNode = internalEdge.target;
          this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i2, layer + 1);
        }
      } else {
        visitor(parent2, root, connectingEdge, layer, 1);
      }
    }
  }
};
var GraphHierarchyModel_default = GraphHierarchyModel;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/HierarchicalLayoutStage.js
var HierarchicalLayoutStage = class {
};
var HierarchicalLayoutStage_default = HierarchicalLayoutStage;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/MinimumCycleRemover.js
var MinimumCycleRemover = class extends HierarchicalLayoutStage_default {
  /**
   * Creates a cycle remover for the given internal model.
   */
  constructor(layout) {
    super();
    this.layout = layout;
  }
  /**
   * Takes the graph detail and configuration information within the facade
   * and creates the resulting laid out graph within that facade for further
   * use.
   */
  execute(parent2) {
    const model2 = this.layout.getDataModel();
    const seenNodes = {};
    const unseenNodesArray = model2.vertexMapper.getValues();
    const unseenNodes = {};
    for (let i2 = 0; i2 < unseenNodesArray.length; i2 += 1) {
      unseenNodes[unseenNodesArray[i2].id] = unseenNodesArray[i2];
    }
    let rootsArray = null;
    if (model2.roots != null) {
      const modelRoots = model2.roots;
      rootsArray = [];
      for (let i2 = 0; i2 < modelRoots.length; i2 += 1) {
        rootsArray[i2] = model2.vertexMapper.get(modelRoots[i2]);
      }
    }
    model2.visit((parent3, node2, connectingEdge, layer, seen) => {
      if (node2.isAncestor(parent3)) {
        connectingEdge.invert();
        remove(connectingEdge, parent3.connectsAsSource);
        parent3.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node2.connectsAsTarget);
        node2.connectsAsSource.push(connectingEdge);
      }
      seenNodes[node2.id] = node2;
      delete unseenNodes[node2.id];
    }, rootsArray, true, null);
    const seenNodesCopy = clone(seenNodes, null, true);
    model2.visit((parent3, node2, connectingEdge, layer, seen) => {
      if (node2.isAncestor(parent3)) {
        connectingEdge.invert();
        remove(connectingEdge, parent3.connectsAsSource);
        node2.connectsAsSource.push(connectingEdge);
        parent3.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node2.connectsAsTarget);
      }
      seenNodes[node2.id] = node2;
      delete unseenNodes[node2.id];
    }, Object.values(unseenNodes), true, seenNodesCopy);
  }
};
var MinimumCycleRemover_default = MinimumCycleRemover;

// node_modules/@maxgraph/core/lib/view/layout/util/MedianCellSorter.js
var MedianCellSorter = class {
  constructor() {
    this.medianValue = 0;
    this.cell = false;
  }
  /**
   * Compares two MedianCellSorters.
   */
  compare(a, b) {
    if (a != null && b != null) {
      if (b.medianValue > a.medianValue) {
        return -1;
      }
      if (b.medianValue < a.medianValue) {
        return 1;
      }
      return 0;
    }
    return 0;
  }
};
var MedianCellSorter_default = MedianCellSorter;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/MedianHybridCrossingReduction.js
var MedianHybridCrossingReduction = class extends HierarchicalLayoutStage_default {
  constructor(layout) {
    super();
    this.maxIterations = 24;
    this.nestedBestRanks = null;
    this.currentBestCrossings = 0;
    this.iterationsWithoutImprovement = 0;
    this.maxNoImprovementIterations = 2;
    this.layout = layout;
  }
  /**
   * Performs a vertex ordering within ranks as described by Gansner et al
   * 1993
   */
  execute(parent2) {
    const model2 = this.layout.getDataModel();
    let ranks = model2.ranks;
    this.nestedBestRanks = [];
    for (let i2 = 0; i2 < ranks.length; i2 += 1) {
      this.nestedBestRanks[i2] = ranks[i2].slice();
    }
    let iterationsWithoutImprovement = 0;
    let currentBestCrossings = this.calculateCrossings(model2);
    for (let i2 = 0; i2 < this.maxIterations && iterationsWithoutImprovement < this.maxNoImprovementIterations; i2++) {
      this.weightedMedian(i2, model2);
      this.transpose(i2, model2);
      const candidateCrossings = this.calculateCrossings(model2);
      if (candidateCrossings < currentBestCrossings) {
        currentBestCrossings = candidateCrossings;
        iterationsWithoutImprovement = 0;
        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {
          const rank = ranks[j];
          for (let k = 0; k < rank.length; k += 1) {
            const cell2 = rank[k];
            this.nestedBestRanks[j][cell2.getGeneralPurposeVariable(j)] = cell2;
          }
        }
      } else {
        iterationsWithoutImprovement += 1;
        for (let j = 0; j < this.nestedBestRanks.length; j += 1) {
          const rank = ranks[j];
          for (let k = 0; k < rank.length; k += 1) {
            const cell2 = rank[k];
            cell2.setGeneralPurposeVariable(j, k);
          }
        }
      }
      if (currentBestCrossings === 0) {
        break;
      }
    }
    ranks = [];
    const rankList = [];
    for (let i2 = 0; i2 < model2.maxRank + 1; i2 += 1) {
      rankList[i2] = [];
      ranks[i2] = rankList[i2];
    }
    for (let i2 = 0; i2 < this.nestedBestRanks.length; i2 += 1) {
      for (let j = 0; j < this.nestedBestRanks[i2].length; j += 1) {
        rankList[i2].push(this.nestedBestRanks[i2][j]);
      }
    }
    model2.ranks = ranks;
  }
  /**
   * Calculates the total number of edge crossing in the current graph.
   * Returns the current number of edge crossings in the hierarchy graph
   * model in the current candidate layout
   *
   * @param model the internal model describing the hierarchy
   */
  calculateCrossings(model2) {
    const ranks = model2.ranks;
    const numRanks = ranks.length;
    let totalCrossings = 0;
    for (let i2 = 1; i2 < numRanks; i2 += 1) {
      totalCrossings += this.calculateRankCrossing(i2, model2);
    }
    return totalCrossings;
  }
  /**
   * Calculates the number of edges crossings between the specified rank and
   * the rank below it. Returns the number of edges crossings with the rank
   * beneath
   *
   * @param i  the topmost rank of the pair ( higher rank value )
   * @param model the internal model describing the hierarchy
   */
  calculateRankCrossing(i2, model2) {
    let totalCrossings = 0;
    const ranks = model2.ranks;
    const rank = ranks[i2];
    const previousRank = ranks[i2 - 1];
    const tmpIndices = [];
    for (let j = 0; j < rank.length; j += 1) {
      const node2 = rank[j];
      const rankPosition = node2.getGeneralPurposeVariable(i2);
      const connectedCells = node2.getPreviousLayerConnectedCells(i2);
      const nodeIndices = [];
      for (let k = 0; k < connectedCells.length; k += 1) {
        const connectedNode = connectedCells[k];
        const otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i2 - 1);
        nodeIndices.push(otherCellRankPosition);
      }
      nodeIndices.sort((x, y) => {
        return x - y;
      });
      tmpIndices[rankPosition] = nodeIndices;
    }
    let indices = [];
    for (let j = 0; j < tmpIndices.length; j++) {
      indices = indices.concat(tmpIndices[j]);
    }
    let firstIndex = 1;
    while (firstIndex < previousRank.length) {
      firstIndex <<= 1;
    }
    const treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    const tree = [];
    for (let j = 0; j < treeSize; ++j) {
      tree[j] = 0;
    }
    for (let j = 0; j < indices.length; j += 1) {
      const index = indices[j];
      let treeIndex = index + firstIndex;
      ++tree[treeIndex];
      while (treeIndex > 0) {
        if (treeIndex % 2) {
          totalCrossings += tree[treeIndex + 1];
        }
        treeIndex = treeIndex - 1 >> 1;
        ++tree[treeIndex];
      }
    }
    return totalCrossings;
  }
  /**
   * Takes each possible adjacent cell pair on each rank and checks if
   * swapping them around reduces the number of crossing
   *
   * @param mainLoopIteration the iteration number of the main loop
   * @param model the internal model describing the hierarchy
   */
  transpose(mainLoopIteration, model2) {
    let improved = true;
    let count = 0;
    const maxCount = 10;
    while (improved && count++ < maxCount) {
      const nudge = mainLoopIteration % 2 === 1 && count % 2 === 1;
      improved = false;
      const ranks = model2.ranks;
      for (let i2 = 0; i2 < ranks.length; i2 += 1) {
        const rank = ranks[i2];
        const orderedCells = [];
        for (let j = 0; j < rank.length; j++) {
          const cell2 = rank[j];
          let tempRank = cell2.getGeneralPurposeVariable(i2);
          if (tempRank < 0) {
            tempRank = j;
          }
          orderedCells[tempRank] = cell2;
        }
        let leftCellAboveConnections = null;
        let leftCellBelowConnections = null;
        let rightCellAboveConnections = null;
        let rightCellBelowConnections = null;
        let leftAbovePositions = null;
        let leftBelowPositions = null;
        let rightAbovePositions = null;
        let rightBelowPositions = null;
        let leftCell = null;
        let rightCell = null;
        for (let j = 0; j < rank.length - 1; j++) {
          if (j === 0) {
            leftCell = orderedCells[j];
            leftCellAboveConnections = leftCell.getNextLayerConnectedCells(i2);
            leftCellBelowConnections = leftCell.getPreviousLayerConnectedCells(i2);
            leftAbovePositions = [];
            leftBelowPositions = [];
            for (let k = 0; k < leftCellAboveConnections.length; k++) {
              leftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i2 + 1);
            }
            for (let k = 0; k < leftCellBelowConnections.length; k++) {
              leftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i2 - 1);
            }
          } else {
            leftCellAboveConnections = rightCellAboveConnections;
            leftCellBelowConnections = rightCellBelowConnections;
            leftAbovePositions = rightAbovePositions;
            leftBelowPositions = rightBelowPositions;
            leftCell = rightCell;
          }
          rightCell = orderedCells[j + 1];
          rightCellAboveConnections = rightCell.getNextLayerConnectedCells(i2);
          rightCellBelowConnections = rightCell.getPreviousLayerConnectedCells(i2);
          rightAbovePositions = [];
          rightBelowPositions = [];
          for (let k = 0; k < rightCellAboveConnections.length; k++) {
            rightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i2 + 1);
          }
          for (let k = 0; k < rightCellBelowConnections.length; k++) {
            rightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i2 - 1);
          }
          let totalCurrentCrossings = 0;
          let totalSwitchedCrossings = 0;
          for (let k = 0; k < leftAbovePositions.length; k += 1) {
            for (let ik = 0; ik < rightAbovePositions.length; ik += 1) {
              if (leftAbovePositions[k] > rightAbovePositions[ik]) {
                totalCurrentCrossings += 1;
              }
              if (leftAbovePositions[k] < rightAbovePositions[ik]) {
                totalSwitchedCrossings += 1;
              }
            }
          }
          for (let k = 0; k < leftBelowPositions.length; k += 1) {
            for (let ik = 0; ik < rightBelowPositions.length; ik += 1) {
              if (leftBelowPositions[k] > rightBelowPositions[ik]) {
                totalCurrentCrossings += 1;
              }
              if (leftBelowPositions[k] < rightBelowPositions[ik]) {
                totalSwitchedCrossings += 1;
              }
            }
          }
          if (totalSwitchedCrossings < totalCurrentCrossings || totalSwitchedCrossings === totalCurrentCrossings && nudge) {
            const temp = leftCell.getGeneralPurposeVariable(i2);
            leftCell.setGeneralPurposeVariable(i2, rightCell.getGeneralPurposeVariable(i2));
            rightCell.setGeneralPurposeVariable(i2, temp);
            rightCellAboveConnections = leftCellAboveConnections;
            rightCellBelowConnections = leftCellBelowConnections;
            rightAbovePositions = leftAbovePositions;
            rightBelowPositions = leftBelowPositions;
            rightCell = leftCell;
            if (!nudge) {
              improved = true;
            }
          }
        }
      }
    }
  }
  /**
   * Sweeps up or down the layout attempting to minimise the median placement
   * of connected cells on adjacent ranks
   *
   * @param iteration the iteration number of the main loop
   * @param model the internal model describing the hierarchy
   */
  weightedMedian(iteration, model2) {
    const downwardSweep = iteration % 2 === 0;
    if (downwardSweep) {
      for (let j = model2.maxRank - 1; j >= 0; j -= 1) {
        this.medianRank(j, downwardSweep);
      }
    } else {
      for (let j = 1; j < model2.maxRank; j += 1) {
        this.medianRank(j, downwardSweep);
      }
    }
  }
  /**
   * Attempts to minimise the median placement of connected cells on this rank
   * and one of the adjacent ranks
   *
   * @param rankValue the layer number of this rank
   * @param downwardSweep whether or not this is a downward sweep through the graph
   */
  medianRank(rankValue, downwardSweep) {
    const nestedBestRanks = this.nestedBestRanks;
    const numCellsForRank = nestedBestRanks[rankValue].length;
    const medianValues = [];
    const reservedPositions = {};
    for (let i2 = 0; i2 < numCellsForRank; i2 += 1) {
      const cell2 = nestedBestRanks[rankValue][i2];
      const sorterEntry = new MedianCellSorter_default();
      sorterEntry.cell = cell2;
      const nextLevelConnectedCells = downwardSweep ? cell2.getNextLayerConnectedCells(rankValue) : cell2.getPreviousLayerConnectedCells(rankValue);
      const nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;
      if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {
        sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);
        medianValues.push(sorterEntry);
      } else {
        reservedPositions[cell2.getGeneralPurposeVariable(rankValue)] = true;
      }
    }
    medianValues.sort(new MedianCellSorter_default().compare);
    for (let i2 = 0; i2 < numCellsForRank; i2 += 1) {
      if (reservedPositions[i2] == null) {
        const cell2 = medianValues.shift().cell;
        cell2.setGeneralPurposeVariable(rankValue, i2);
      }
    }
  }
  /**
   * Calculates the median rank order positioning for the specified cell using
   * the connected cells on the specified rank. Returns the median rank
   * ordering value of the connected cells
   *
   * @param connectedCells the cells on the specified rank connected to the
   * specified cell
   * @param rankValue the rank that the connected cell lie upon
   */
  medianValue(connectedCells, rankValue) {
    const medianValues = [];
    let arrayCount = 0;
    for (let i2 = 0; i2 < connectedCells.length; i2 += 1) {
      const cell2 = connectedCells[i2];
      medianValues[arrayCount++] = cell2.getGeneralPurposeVariable(rankValue);
    }
    medianValues.sort((a, b) => {
      return a - b;
    });
    if (arrayCount % 2 === 1) {
      return medianValues[Math.floor(arrayCount / 2)];
    }
    if (arrayCount === 2) {
      return (medianValues[0] + medianValues[1]) / 2;
    }
    const medianPoint = arrayCount / 2;
    const leftMedian = medianValues[medianPoint - 1] - medianValues[0];
    const rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];
    return (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint] * leftMedian) / (leftMedian + rightMedian);
  }
};
var MedianHybridCrossingReduction_default = MedianHybridCrossingReduction;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/CoordinateAssignment.js
var CoordinateAssignment = class extends HierarchicalLayoutStage_default {
  /**
   * Creates a coordinate assignment.
   *
   * @param layout
   * @param intraCellSpacing the minimum buffer between cells on the same rank interRankCellSpacing
   * @param interRankCellSpacing the minimum distance between cells on adjacent ranks
   * @param orientation the position of the root node(s) relative to the graph
   * @param initialX the leftmost coordinate node placement starts at
   * @param parallelEdgeSpacing
   */
  constructor(layout, intraCellSpacing = 30, interRankCellSpacing = 100, orientation, initialX, parallelEdgeSpacing = 10) {
    super();
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.parallelEdgeSpacing = 10;
    this.maxIterations = 8;
    this.prefHozEdgeSep = 5;
    this.prefVertEdgeOff = 2;
    this.minEdgeJetty = 12;
    this.channelBuffer = 4;
    this.jettyPositions = null;
    this.orientation = DIRECTION.NORTH;
    this.limitX = null;
    this.currentXDelta = null;
    this.widestRank = null;
    this.rankTopY = null;
    this.rankBottomY = null;
    this.widestRankValue = null;
    this.rankWidths = null;
    this.rankY = null;
    this.fineTuning = true;
    this.nextLayerConnectedCache = null;
    this.previousLayerConnectedCache = null;
    this.groupPadding = 10;
    this.layout = layout;
    this.intraCellSpacing = intraCellSpacing;
    this.interRankCellSpacing = interRankCellSpacing;
    this.orientation = orientation;
    this.initialX = initialX;
    this.parallelEdgeSpacing = parallelEdgeSpacing;
  }
  /**
   * Utility method to display current positions
   */
  printStatus() {
    const model2 = this.layout.getDataModel();
    const ranks = model2.ranks;
    const logger = GlobalConfig.logger;
    logger.show();
    logger.info("======Coord assignment debug=======");
    for (let j = 0; j < ranks.length; j++) {
      const rank = ranks[j];
      const cellsInfo = rank.map((cell2) => String(cell2.getGeneralPurposeVariable(j))).join("  ");
      logger.info(`Rank ${j} : ${cellsInfo}`);
    }
    logger.info("====================================");
  }
  /**
   * A basic horizontal coordinate assignment algorithm
   */
  execute(parent2) {
    this.jettyPositions = Object();
    const model2 = this.layout.getDataModel();
    this.currentXDelta = 0;
    this.initialCoords(this.layout.getGraph(), model2);
    if (this.fineTuning) {
      this.minNode(model2);
    }
    let bestXDelta = 1e8;
    if (this.fineTuning) {
      for (let i2 = 0; i2 < this.maxIterations; i2 += 1) {
        if (i2 !== 0) {
          this.medianPos(i2, model2);
          this.minNode(model2);
        }
        const ranks = model2.ranks;
        if (this.currentXDelta < bestXDelta) {
          for (let j = 0; j < ranks.length; j++) {
            const rank = ranks[j];
            for (let k = 0; k < rank.length; k++) {
              const cell2 = rank[k];
              cell2.setX(j, cell2.getGeneralPurposeVariable(j));
            }
          }
          bestXDelta = this.currentXDelta;
        } else {
          for (let j = 0; j < ranks.length; j++) {
            const rank = ranks[j];
            for (let k = 0; k < rank.length; k++) {
              const cell2 = rank[k];
              cell2.setGeneralPurposeVariable(j, cell2.getX(j));
            }
          }
        }
        this.minPath(this.layout.getGraph(), model2);
        this.currentXDelta = 0;
      }
    }
    this.setCellLocations(this.layout.getGraph(), model2);
  }
  /**
   * Performs one median positioning sweep in both directions
   */
  minNode(model2) {
    const nodeList = [];
    const map = new Dictionary_default();
    const rank = [];
    for (let i2 = 0; i2 <= model2.maxRank; i2 += 1) {
      rank[i2] = model2.ranks[i2];
      for (let j = 0; j < rank[i2].length; j += 1) {
        const node2 = rank[i2][j];
        const nodeWrapper = new WeightedCellSorter_default(node2, i2);
        nodeWrapper.rankIndex = j;
        nodeWrapper.visited = true;
        nodeList.push(nodeWrapper);
        map.put(node2, nodeWrapper);
      }
    }
    const maxTries = nodeList.length * 10;
    let count = 0;
    const tolerance = 1;
    while (nodeList.length > 0 && count <= maxTries) {
      const cellWrapper = nodeList.shift();
      const cell2 = cellWrapper.cell;
      const rankValue = cellWrapper.weightedValue;
      const rankIndex = parseInt(String(cellWrapper.rankIndex));
      const nextLayerConnectedCells = cell2.getNextLayerConnectedCells(rankValue);
      const previousLayerConnectedCells = cell2.getPreviousLayerConnectedCells(rankValue);
      const numNextLayerConnected = nextLayerConnectedCells.length;
      const numPreviousLayerConnected = previousLayerConnectedCells.length;
      const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);
      const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);
      const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;
      const currentPosition = cell2.getGeneralPurposeVariable(rankValue);
      let cellMedian = currentPosition;
      if (numConnectedNeighbours > 0) {
        cellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel * numPreviousLayerConnected) / numConnectedNeighbours;
      }
      let positionChanged = false;
      if (cellMedian < currentPosition - tolerance) {
        if (rankIndex === 0) {
          cell2.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const leftCell = rank[rankValue][rankIndex - 1];
          let leftLimit = leftCell.getGeneralPurposeVariable(rankValue);
          leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell2.width / 2;
          if (leftLimit < cellMedian) {
            cell2.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (leftLimit < cell2.getGeneralPurposeVariable(rankValue) - tolerance) {
            cell2.setGeneralPurposeVariable(rankValue, leftLimit);
            positionChanged = true;
          }
        }
      } else if (cellMedian > currentPosition + tolerance) {
        const rankSize = rank[rankValue].length;
        if (rankIndex === rankSize - 1) {
          cell2.setGeneralPurposeVariable(rankValue, cellMedian);
          positionChanged = true;
        } else {
          const rightCell = rank[rankValue][rankIndex + 1];
          let rightLimit = rightCell.getGeneralPurposeVariable(rankValue);
          rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell2.width / 2;
          if (rightLimit > cellMedian) {
            cell2.setGeneralPurposeVariable(rankValue, cellMedian);
            positionChanged = true;
          } else if (rightLimit > cell2.getGeneralPurposeVariable(rankValue) + tolerance) {
            cell2.setGeneralPurposeVariable(rankValue, rightLimit);
            positionChanged = true;
          }
        }
      }
      if (positionChanged) {
        for (let i2 = 0; i2 < nextLayerConnectedCells.length; i2 += 1) {
          const connectedCell = nextLayerConnectedCells[i2];
          const connectedCellWrapper = map.get(connectedCell);
          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }
        for (let i2 = 0; i2 < previousLayerConnectedCells.length; i2 += 1) {
          const connectedCell = previousLayerConnectedCells[i2];
          const connectedCellWrapper = map.get(connectedCell);
          if (connectedCellWrapper != null) {
            if (connectedCellWrapper.visited == false) {
              connectedCellWrapper.visited = true;
              nodeList.push(connectedCellWrapper);
            }
          }
        }
      }
      cellWrapper.visited = false;
      count += 1;
    }
  }
  /**
   * Performs one median positioning sweep in one direction
   *
   * @param i the iteration of the whole process
   * @param model an internal model of the hierarchical layout
   */
  medianPos(i2, model2) {
    const downwardSweep = i2 % 2 === 0;
    if (downwardSweep) {
      for (let j = model2.maxRank; j > 0; j--) {
        this.rankMedianPosition(j - 1, model2, j);
      }
    } else {
      for (let j = 0; j < model2.maxRank - 1; j++) {
        this.rankMedianPosition(j + 1, model2, j);
      }
    }
  }
  /**
   * Performs median minimisation over one rank.
   *
   * @param rankValue the layer number of this rank
   * @param model an internal model of the hierarchical layout
   * @param nextRankValue the layer number whose connected cels are to be laid out
   * relative to
   */
  rankMedianPosition(rankValue, model2, nextRankValue) {
    const ranks = model2.ranks;
    const rank = ranks[rankValue];
    const weightedValues = [];
    const cellMap = {};
    for (let i2 = 0; i2 < rank.length; i2 += 1) {
      const currentCell = rank[i2];
      weightedValues[i2] = new WeightedCellSorter_default(currentCell);
      weightedValues[i2].rankIndex = i2;
      cellMap[currentCell.id] = weightedValues[i2];
      let nextLayerConnectedCells = null;
      if (nextRankValue < rankValue) {
        nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);
      } else {
        nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);
      }
      weightedValues[i2].weightedValue = this.calculatedWeightedValue(currentCell, nextLayerConnectedCells);
    }
    weightedValues.sort(WeightedCellSorter_default.compare);
    for (let i2 = 0; i2 < weightedValues.length; i2 += 1) {
      let numConnectionsNextLevel = 0;
      const cell2 = weightedValues[i2].cell;
      let nextLayerConnectedCells = null;
      let medianNextLevel = 0;
      if (nextRankValue < rankValue) {
        nextLayerConnectedCells = cell2.getPreviousLayerConnectedCells(rankValue).slice();
      } else {
        nextLayerConnectedCells = cell2.getNextLayerConnectedCells(rankValue).slice();
      }
      if (nextLayerConnectedCells != null) {
        numConnectionsNextLevel = nextLayerConnectedCells.length;
        if (numConnectionsNextLevel > 0) {
          medianNextLevel = this.medianXValue(nextLayerConnectedCells, nextRankValue);
        } else {
          medianNextLevel = cell2.getGeneralPurposeVariable(rankValue);
        }
      }
      let leftBuffer = 0;
      let leftLimit = -1e8;
      for (let j = weightedValues[i2].rankIndex - 1; j >= 0; ) {
        const weightedValue = cellMap[rank[j].id];
        if (weightedValue != null) {
          const leftCell = weightedValue.cell;
          if (weightedValue.visited) {
            leftLimit = leftCell.getGeneralPurposeVariable(rankValue) + leftCell.width / 2 + this.intraCellSpacing + leftBuffer + cell2.width / 2;
            j = -1;
          } else {
            leftBuffer += leftCell.width + this.intraCellSpacing;
            j--;
          }
        }
      }
      let rightBuffer = 0;
      let rightLimit = 1e8;
      for (let j = weightedValues[i2].rankIndex + 1; j < weightedValues.length; ) {
        const weightedValue = cellMap[rank[j].id];
        if (weightedValue != null) {
          const rightCell = weightedValue.cell;
          if (weightedValue.visited) {
            rightLimit = rightCell.getGeneralPurposeVariable(rankValue) - rightCell.width / 2 - this.intraCellSpacing - rightBuffer - cell2.width / 2;
            j = weightedValues.length;
          } else {
            rightBuffer += rightCell.width + this.intraCellSpacing;
            j++;
          }
        }
      }
      if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
        cell2.setGeneralPurposeVariable(rankValue, medianNextLevel);
      } else if (medianNextLevel < leftLimit) {
        cell2.setGeneralPurposeVariable(rankValue, leftLimit);
        this.currentXDelta = this.currentXDelta + leftLimit - medianNextLevel;
      } else if (medianNextLevel > rightLimit) {
        cell2.setGeneralPurposeVariable(rankValue, rightLimit);
        this.currentXDelta = this.currentXDelta + medianNextLevel - rightLimit;
      }
      weightedValues[i2].visited = true;
    }
  }
  /**
   * Calculates the priority the specified cell has based on the type of its
   * cell and the cells it is connected to on the next layer
   *
   * @param currentCell the cell whose weight is to be calculated
   * @param collection the cells the specified cell is connected to
   */
  calculatedWeightedValue(currentCell, collection) {
    let totalWeight = 0;
    for (let i2 = 0; i2 < collection.length; i2 += 1) {
      const cell2 = collection[i2];
      if (currentCell.isVertex() && cell2.isVertex()) {
        totalWeight += 1;
      } else if (currentCell.isEdge() && cell2.isEdge()) {
        totalWeight += 8;
      } else {
        totalWeight += 2;
      }
    }
    return totalWeight;
  }
  /**
   * Calculates the median position of the connected cell on the specified
   * rank
   *
   * @param connectedCells the cells the candidate connects to on this level
   * @param rankValue the layer number of this rank
   */
  medianXValue(connectedCells, rankValue) {
    if (connectedCells.length === 0) {
      return 0;
    }
    const medianValues = [];
    for (let i2 = 0; i2 < connectedCells.length; i2 += 1) {
      medianValues[i2] = connectedCells[i2].getGeneralPurposeVariable(rankValue);
    }
    medianValues.sort((a, b) => a - b);
    if (connectedCells.length % 2 === 1) {
      return medianValues[Math.floor(connectedCells.length / 2)];
    }
    const medianPoint = connectedCells.length / 2;
    const leftMedian = medianValues[medianPoint - 1];
    const rightMedian = medianValues[medianPoint];
    return (leftMedian + rightMedian) / 2;
  }
  /**
   * Sets up the layout in an initial positioning. The ranks are all centered
   * as much as possible along the middle vertex in each rank. The other cells
   * are then placed as close as possible on either side.
   *
   * @param facade the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  initialCoords(facade, model2) {
    this.calculateWidestRank(facade, model2);
    for (let i2 = this.widestRank; i2 >= 0; i2--) {
      if (i2 < model2.maxRank) {
        this.rankCoordinates(i2, facade, model2);
      }
    }
    for (let i2 = this.widestRank + 1; i2 <= model2.maxRank; i2 += 1) {
      if (i2 > 0) {
        this.rankCoordinates(i2, facade, model2);
      }
    }
  }
  /**
   * Sets up the layout in an initial positioning. All the first cells in each
   * rank are moved to the left and the rest of the rank inserted as close
   * together as their size and buffering permits. This method works on just
   * the specified rank.
   *
   * @param rankValue the current rank being processed
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  rankCoordinates(rankValue, graph, model2) {
    const ranks = model2.ranks;
    const rank = ranks[rankValue];
    let maxY = 0;
    let localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue]) / 2;
    let boundsWarning = false;
    for (let i2 = 0; i2 < rank.length; i2 += 1) {
      const node2 = rank[i2];
      if (node2.isVertex()) {
        const bounds = this.layout.getVertexBounds(node2.cell);
        if (bounds != null) {
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            node2.width = bounds.width;
            node2.height = bounds.height;
          } else {
            node2.width = bounds.height;
            node2.height = bounds.width;
          }
        } else {
          boundsWarning = true;
        }
        maxY = Math.max(maxY, node2.height);
      } else if (node2.isEdge()) {
        let numEdges = 1;
        if (node2.edges != null) {
          numEdges = node2.edges.length;
        } else {
          GlobalConfig.logger.warn("edge.edges is null");
        }
        node2.width = (numEdges - 1) * this.parallelEdgeSpacing;
      }
      localX += node2.width / 2;
      node2.setX(rankValue, localX);
      node2.setGeneralPurposeVariable(rankValue, localX);
      localX += node2.width / 2;
      localX += this.intraCellSpacing;
    }
    if (boundsWarning) {
      GlobalConfig.logger.warn("At least one cell has no bounds");
    }
  }
  /**
   * Calculates the width rank in the hierarchy. Also set the y value of each
   * rank whilst performing the calculation
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  calculateWidestRank(graph, model2) {
    let y = -this.interRankCellSpacing;
    let lastRankMaxCellHeight = 0;
    this.rankWidths = [];
    this.rankY = [];
    for (let rankValue = model2.maxRank; rankValue >= 0; rankValue -= 1) {
      let maxCellHeight = 0;
      const ranks = model2.ranks;
      const rank = ranks[rankValue];
      let localX = this.initialX;
      let boundsWarning = false;
      for (let i2 = 0; i2 < rank.length; i2 += 1) {
        const node2 = rank[i2];
        if (node2.isVertex()) {
          const bounds = this.layout.getVertexBounds(node2.cell);
          if (bounds != null) {
            if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
              node2.width = bounds.width;
              node2.height = bounds.height;
            } else {
              node2.width = bounds.height;
              node2.height = bounds.width;
            }
          } else {
            boundsWarning = true;
          }
          maxCellHeight = Math.max(maxCellHeight, node2.height);
        } else if (node2.isEdge()) {
          let numEdges = 1;
          if (node2.edges != null) {
            numEdges = node2.edges.length;
          } else {
            GlobalConfig.logger.warn("edge.edges is null");
          }
          node2.width = (numEdges - 1) * this.parallelEdgeSpacing;
        }
        localX += node2.width / 2;
        node2.setX(rankValue, localX);
        node2.setGeneralPurposeVariable(rankValue, localX);
        localX += node2.width / 2;
        localX += this.intraCellSpacing;
        if (localX > this.widestRankValue) {
          this.widestRankValue = localX;
          this.widestRank = rankValue;
        }
        this.rankWidths[rankValue] = localX;
      }
      if (boundsWarning) {
        GlobalConfig.logger.warn("At least one cell has no bounds");
      }
      this.rankY[rankValue] = y;
      const distanceToNextRank = maxCellHeight / 2 + lastRankMaxCellHeight / 2 + this.interRankCellSpacing;
      lastRankMaxCellHeight = maxCellHeight;
      if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.WEST) {
        y += distanceToNextRank;
      } else {
        y -= distanceToNextRank;
      }
      for (let i2 = 0; i2 < rank.length; i2 += 1) {
        const cell2 = rank[i2];
        cell2.setY(rankValue, y);
      }
    }
  }
  /**
   * Straightens out chains of virtual nodes where possibleacade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the facade describing the input graph
   * @param model an internal model of the hierarchical layout
   */
  minPath(graph, model2) {
    const edges = model2.edgeMapper.getValues();
    for (let j = 0; j < edges.length; j++) {
      const cell2 = edges[j];
      if (cell2.maxRank - cell2.minRank - 1 < 1) {
        continue;
      }
      let referenceX = cell2.getGeneralPurposeVariable(cell2.minRank + 1);
      let edgeStraight = true;
      let refSegCount = 0;
      for (let i2 = cell2.minRank + 2; i2 < cell2.maxRank; i2 += 1) {
        const x = cell2.getGeneralPurposeVariable(i2);
        if (referenceX !== x) {
          edgeStraight = false;
          referenceX = x;
        } else {
          refSegCount += 1;
        }
      }
      if (!edgeStraight) {
        let upSegCount = 0;
        let downSegCount = 0;
        const upXPositions = [];
        const downXPositions = [];
        let i2 = 0;
        let currentX = cell2.getGeneralPurposeVariable(cell2.minRank + 1);
        for (i2 = cell2.minRank + 1; i2 < cell2.maxRank - 1; i2 += 1) {
          const nextX = cell2.getX(i2 + 1);
          if (currentX === nextX) {
            upXPositions[i2 - cell2.minRank - 1] = currentX;
            upSegCount += 1;
          } else if (this.repositionValid(model2, cell2, i2 + 1, currentX)) {
            upXPositions[i2 - cell2.minRank - 1] = currentX;
            upSegCount += 1;
          } else {
            upXPositions[i2 - cell2.minRank - 1] = nextX;
            currentX = nextX;
          }
        }
        currentX = cell2.getX(i2);
        for (let i3 = cell2.maxRank - 1; i3 > cell2.minRank + 1; i3--) {
          const nextX = cell2.getX(i3 - 1);
          if (currentX === nextX) {
            downXPositions[i3 - cell2.minRank - 2] = currentX;
            downSegCount += 1;
          } else if (this.repositionValid(model2, cell2, i3 - 1, currentX)) {
            downXPositions[i3 - cell2.minRank - 2] = currentX;
            downSegCount += 1;
          } else {
            downXPositions[i3 - cell2.minRank - 2] = cell2.getX(i3 - 1);
            currentX = nextX;
          }
        }
        if (downSegCount > refSegCount || upSegCount > refSegCount) {
          if (downSegCount >= upSegCount) {
            for (let i3 = cell2.maxRank - 2; i3 > cell2.minRank; i3--) {
              cell2.setX(i3, downXPositions[i3 - cell2.minRank - 1]);
            }
          } else if (upSegCount > downSegCount) {
            for (let i3 = cell2.minRank + 2; i3 < cell2.maxRank; i3 += 1) {
              cell2.setX(i3, upXPositions[i3 - cell2.minRank - 2]);
            }
          } else {
          }
        }
      }
    }
  }
  /**
   * Determines whether or not a node may be moved to the specified x
   * position on the specified rank
   *
   * @param model the layout model
   * @param cell the cell being analysed
   * @param rank the layer of the cell
   * @param position the x position being sought
   */
  repositionValid(model2, cell2, rank, position) {
    const ranks = model2.ranks;
    const rankArray = ranks[rank];
    let rankIndex = -1;
    for (let i2 = 0; i2 < rankArray.length; i2 += 1) {
      if (cell2 === rankArray[i2]) {
        rankIndex = i2;
        break;
      }
    }
    if (rankIndex < 0) {
      return false;
    }
    const currentX = cell2.getGeneralPurposeVariable(rank);
    if (position < currentX) {
      if (rankIndex === 0) {
        return true;
      }
      const leftCell = rankArray[rankIndex - 1];
      let leftLimit = leftCell.getGeneralPurposeVariable(rank);
      leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell2.width / 2;
      return leftLimit <= position;
    }
    if (position > currentX) {
      if (rankIndex === rankArray.length - 1) {
        return true;
      }
      const rightCell = rankArray[rankIndex + 1];
      let rightLimit = rightCell.getGeneralPurposeVariable(rank);
      rightLimit = rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell2.width / 2;
      return rightLimit >= position;
    }
    return true;
  }
  /**
   * Sets the cell locations in the facade to those stored after this layout
   * processing step has completed.
   *
   * @param graph the input graph
   * @param model the layout model
   */
  setCellLocations(graph, model2) {
    this.rankTopY = [];
    this.rankBottomY = [];
    const ranks = model2.ranks;
    for (let i2 = 0; i2 < ranks.length; i2 += 1) {
      this.rankTopY[i2] = Number.MAX_VALUE;
      this.rankBottomY[i2] = -Number.MAX_VALUE;
    }
    const vertices = model2.vertexMapper.getValues();
    for (let i2 = 0; i2 < vertices.length; i2 += 1) {
      this.setVertexLocation(vertices[i2]);
    }
    if (this.layout.edgeStyle === HierarchicalEdgeStyle_default.ORTHOGONAL || this.layout.edgeStyle === HierarchicalEdgeStyle_default.POLYLINE || this.layout.edgeStyle === HierarchicalEdgeStyle_default.CURVE) {
      this.localEdgeProcessing(model2);
    }
    const edges = model2.edgeMapper.getValues();
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      this.setEdgePosition(edges[i2]);
    }
  }
  /**
   * Separates the x position of edges as they connect to vertices
   *
   * @param model the layout model
   */
  localEdgeProcessing(model2) {
    const ranks = model2.ranks;
    for (let rankIndex = 0; rankIndex < ranks.length; rankIndex += 1) {
      const rank = ranks[rankIndex];
      for (let cellIndex = 0; cellIndex < rank.length; cellIndex += 1) {
        const cell2 = rank[cellIndex];
        if (cell2.isVertex()) {
          let currentCells = cell2.getPreviousLayerConnectedCells(rankIndex);
          let currentRank = rankIndex - 1;
          for (let k = 0; k < 2; k += 1) {
            if (currentRank > -1 && currentRank < ranks.length && currentCells != null && currentCells.length > 0) {
              const sortedCells = [];
              for (let j = 0; j < currentCells.length; j++) {
                const sorter = new WeightedCellSorter_default(currentCells[j], currentCells[j].getX(currentRank));
                sortedCells.push(sorter);
              }
              sortedCells.sort(WeightedCellSorter_default.compare);
              let leftLimit = cell2.x[0] - cell2.width / 2;
              let rightLimit = leftLimit + cell2.width;
              let connectedEdgeCount = 0;
              let connectedEdgeGroupCount = 0;
              const connectedEdges = [];
              for (let j = 0; j < sortedCells.length; j++) {
                const innerCell = sortedCells[j].cell;
                let connections;
                if (innerCell.isVertex()) {
                  if (k === 0) {
                    connections = cell2.connectsAsSource;
                  } else {
                    connections = cell2.connectsAsTarget;
                  }
                  for (let connIndex = 0; connIndex < connections.length; connIndex += 1) {
                    if (connections[connIndex].source === innerCell || connections[connIndex].target === innerCell) {
                      connectedEdgeCount += connections[connIndex].edges.length;
                      connectedEdgeGroupCount += 1;
                      connectedEdges.push(connections[connIndex]);
                    }
                  }
                } else {
                  connectedEdgeCount += innerCell.edges.length;
                  connectedEdgeGroupCount += 1;
                  connectedEdges.push(innerCell);
                }
              }
              const requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;
              if (cell2.width > requiredWidth + 2 * this.prefHozEdgeSep) {
                leftLimit += this.prefHozEdgeSep;
                rightLimit -= this.prefHozEdgeSep;
              }
              const availableWidth = rightLimit - leftLimit;
              const edgeSpacing = availableWidth / connectedEdgeCount;
              let currentX = leftLimit + edgeSpacing / 2;
              let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;
              let maxYOffset = 0;
              for (let j = 0; j < connectedEdges.length; j++) {
                const numActualEdges = connectedEdges[j].edges.length;
                const jettyPositions = this.jettyPositions;
                let pos = jettyPositions[connectedEdges[j].ids[0]];
                if (pos == null) {
                  pos = [];
                  jettyPositions[connectedEdges[j].ids[0]] = pos;
                }
                if (j < connectedEdgeCount / 2) {
                  currentYOffset += this.prefVertEdgeOff;
                } else if (j > connectedEdgeCount / 2) {
                  currentYOffset -= this.prefVertEdgeOff;
                }
                for (let m = 0; m < numActualEdges; m += 1) {
                  pos[m * 4 + k * 2] = currentX;
                  currentX += edgeSpacing;
                  pos[m * 4 + k * 2 + 1] = currentYOffset;
                }
                maxYOffset = Math.max(maxYOffset, currentYOffset);
              }
            }
            currentCells = cell2.getNextLayerConnectedCells(rankIndex);
            currentRank = rankIndex + 1;
          }
        }
      }
    }
  }
  /**
   * Fixes the control points
   */
  setEdgePosition(cell2) {
    let offsetX = 0;
    if (cell2.temp[0] !== 101207) {
      let { maxRank } = cell2;
      let { minRank } = cell2;
      if (maxRank === minRank) {
        maxRank = cell2.source.maxRank;
        minRank = cell2.target.minRank;
      }
      let parallelEdgeCount = 0;
      const jettyPositions = this.jettyPositions;
      const jettys = jettyPositions[cell2.ids[0]];
      const source2 = cell2.isReversed ? cell2.target.cell : cell2.source.cell;
      const { graph } = this.layout;
      const layoutReversed = this.orientation === DIRECTION.EAST || this.orientation === DIRECTION.SOUTH;
      for (let i2 = 0; i2 < cell2.edges.length; i2 += 1) {
        const realEdge = cell2.edges[i2];
        const realSource = this.layout.getVisibleTerminal(realEdge, true);
        const newPoints = [];
        let reversed = cell2.isReversed;
        if (realSource !== source2) {
          reversed = !reversed;
        }
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankBottomY = this.rankBottomY;
          const rankTopY = this.rankTopY;
          let y = reversed ? layoutReversed ? rankBottomY[minRank] : rankTopY[minRank] : layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank];
          let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];
          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }
          y += jetty;
          let x = jettys[parallelEdgeCount * 4 + arrayOffset];
          const modelSource = realEdge.getTerminal(true);
          if (this.layout.isPort(modelSource) && modelSource.getParent() === realSource) {
            const state2 = graph.view.getState(modelSource);
            if (state2 != null) {
              x = state2.x;
            } else {
              x = realSource.geometry.x + cell2.source.width * modelSource.geometry.x;
            }
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            newPoints.push(new Point_default(x, y));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle_default.CURVE) {
              newPoints.push(new Point_default(x, y + jetty));
            }
          } else {
            newPoints.push(new Point_default(y, x));
            if (this.layout.edgeStyle === HierarchicalEdgeStyle_default.CURVE) {
              newPoints.push(new Point_default(y + jetty, x));
            }
          }
        }
        let loopStart = cell2.x.length - 1;
        let loopLimit = -1;
        let loopDelta = -1;
        let currentRank = cell2.maxRank - 1;
        if (reversed) {
          loopStart = 0;
          loopLimit = cell2.x.length;
          loopDelta = 1;
          currentRank = cell2.minRank + 1;
        }
        for (let j = loopStart; cell2.maxRank !== cell2.minRank && j !== loopLimit; j += loopDelta) {
          const positionX = cell2.x[j] + offsetX;
          const rankTopY = this.rankTopY;
          const rankBottomY = this.rankBottomY;
          let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2;
          let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2;
          if (reversed) {
            const tmp2 = topChannelY;
            topChannelY = bottomChannelY;
            bottomChannelY = tmp2;
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            newPoints.push(new Point_default(positionX, topChannelY));
            newPoints.push(new Point_default(positionX, bottomChannelY));
          } else {
            newPoints.push(new Point_default(topChannelY, positionX));
            newPoints.push(new Point_default(bottomChannelY, positionX));
          }
          this.limitX = Math.max(this.limitX, positionX);
          currentRank += loopDelta;
        }
        if (jettys != null) {
          const arrayOffset = reversed ? 2 : 0;
          const rankTopY = this.rankTopY;
          const rankBottomY = this.rankBottomY;
          const rankY = reversed ? layoutReversed ? rankTopY[maxRank] : rankBottomY[maxRank] : layoutReversed ? rankBottomY[minRank] : rankTopY[minRank];
          let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];
          if (reversed !== layoutReversed) {
            jetty = -jetty;
          }
          const y = rankY - jetty;
          let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];
          const modelTarget = realEdge.getTerminal(false);
          const realTarget = this.layout.getVisibleTerminal(realEdge, false);
          if (this.layout.isPort(modelTarget) && modelTarget.getParent() === realTarget) {
            const state2 = graph.view.getState(modelTarget);
            if (state2 != null) {
              x = state2.x;
            } else {
              x = realTarget.geometry.x + cell2.target.width * modelTarget.geometry.x;
            }
          }
          if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle_default.CURVE) {
              newPoints.push(new Point_default(x, y - jetty));
            }
            newPoints.push(new Point_default(x, y));
          } else {
            if (this.layout.edgeStyle === HierarchicalEdgeStyle_default.CURVE) {
              newPoints.push(new Point_default(y - jetty, x));
            }
            newPoints.push(new Point_default(y, x));
          }
        }
        if (cell2.isReversed) {
          this.processReversedEdge(cell2, realEdge);
        }
        this.layout.setEdgePoints(realEdge, newPoints);
        if (offsetX === 0) {
          offsetX = this.parallelEdgeSpacing;
        } else if (offsetX > 0) {
          offsetX = -offsetX;
        } else {
          offsetX = -offsetX + this.parallelEdgeSpacing;
        }
        parallelEdgeCount++;
      }
      cell2.temp[0] = 101207;
    }
  }
  /**
   * Fixes the position of the specified vertex.
   *
   * @param cell the vertex to position
   */
  setVertexLocation(cell2) {
    const realCell = cell2.cell;
    const positionX = cell2.x[0] - cell2.width / 2;
    const positionY = cell2.y[0] - cell2.height / 2;
    const rankTopY = this.rankTopY;
    const rankBottomY = this.rankBottomY;
    rankTopY[cell2.minRank] = Math.min(rankTopY[cell2.minRank], positionY);
    rankBottomY[cell2.minRank] = Math.max(rankBottomY[cell2.minRank], positionY + cell2.height);
    if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {
      this.layout.setVertexLocation(realCell, positionX, positionY);
    } else {
      this.layout.setVertexLocation(realCell, positionY, positionX);
    }
    this.limitX = Math.max(this.limitX, positionX + cell2.width);
  }
  /**
   * Hook to add additional processing
   *
   * @param edge the hierarchical model edge
   * @param realEdge the real edge in the graph
   */
  processReversedEdge(edge2, realEdge) {
  }
};
var CoordinateAssignment_default = CoordinateAssignment;

// node_modules/@maxgraph/core/lib/view/layout/HierarchicalLayout.js
var HierarchicalLayout = class extends GraphLayout_default {
  /**
   * Constructs a new hierarchical layout algorithm.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION.NORTH}.
   * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.
   */
  constructor(graph, orientation = DIRECTION.NORTH, deterministic = true) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.roots = null;
    this.resizeParent = false;
    this.maintainParentLocation = false;
    this.moveParent = false;
    this.parentBorder = 0;
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.interHierarchySpacing = 60;
    this.parallelEdgeSpacing = 10;
    this.orientation = DIRECTION.NORTH;
    this.fineTuning = true;
    this.tightenToSource = true;
    this.disableEdgeStyle = true;
    this.traverseAncestors = true;
    this.model = null;
    this.edgesCache = new Dictionary_default();
    this.edgeSourceTermCache = new Dictionary_default();
    this.edgesTargetTermCache = new Dictionary_default();
    this.edgeStyle = HierarchicalEdgeStyle_default.POLYLINE;
    this.orientation = orientation;
    this.deterministic = deterministic;
  }
  /**
   * Returns the internal <GraphHierarchyModel> for this layout algorithm.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Executes the layout for the children of the specified parent.
   *
   * @param parent Parent <Cell> that contains the children to be laid out.
   * @param roots Optional starting roots of the layout.
   */
  execute(parent2, roots = null) {
    this.parent = parent2;
    this.edgesCache = new Dictionary_default();
    this.edgeSourceTermCache = new Dictionary_default();
    this.edgesTargetTermCache = new Dictionary_default();
    if (roots != null && !(roots instanceof Array)) {
      roots = [roots];
    }
    if (roots == null && parent2 == null) {
      return;
    }
    this.parentX = null;
    this.parentY = null;
    if (parent2 !== this.graph.getDataModel().root && parent2.isVertex() != null && this.maintainParentLocation) {
      const geo = parent2.getGeometry();
      if (geo != null) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    if (roots != null) {
      const rootsCopy = [];
      for (let i2 = 0; i2 < roots.length; i2 += 1) {
        const ancestor = parent2 != null ? parent2.isAncestor(roots[i2]) : true;
        if (ancestor && roots[i2].isVertex()) {
          rootsCopy.push(roots[i2]);
        }
      }
      this.roots = rootsCopy;
    }
    const { model: model2 } = this.graph;
    model2.batchUpdate(() => {
      this.run(parent2);
      if (this.resizeParent && !parent2.isCollapsed()) {
        this.graph.updateGroupBounds([parent2], this.parentBorder, this.moveParent);
      }
      if (this.parentX != null && this.parentY != null) {
        let geo = parent2.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.x = this.parentX;
          geo.y = this.parentY;
          model2.setGeometry(parent2, geo);
        }
      }
    });
  }
  /**
   * Returns all visible children in the given parent which do not have
   * incoming edges. If the result is empty then the children with the
   * maximum difference between incoming and outgoing edges are returned.
   * This takes into account edges that are being promoted to the given
   * root due to invisible children or collapsed cells.
   *
   * @param parent <Cell> whose children should be checked.
   * @param vertices array of vertices to limit search to
   */
  findRoots(parent2, vertices) {
    const roots = [];
    if (parent2 != null && vertices != null) {
      const { model: model2 } = this.graph;
      let best = null;
      let maxDiff = -1e5;
      for (const i2 in vertices) {
        const cell2 = vertices[i2];
        if (cell2.isVertex() && cell2.isVisible()) {
          const conns = this.getEdges(cell2);
          let fanOut = 0;
          let fanIn = 0;
          for (let k = 0; k < conns.length; k++) {
            const src = this.getVisibleTerminal(conns[k], true);
            if (src === cell2) {
              fanOut++;
            } else {
              fanIn++;
            }
          }
          if (fanIn === 0 && fanOut > 0) {
            roots.push(cell2);
          }
          const diff = fanOut - fanIn;
          if (diff > maxDiff) {
            maxDiff = diff;
            best = cell2;
          }
        }
      }
      if (roots.length === 0 && best != null) {
        roots.push(best);
      }
    }
    return roots;
  }
  /**
   * Returns the connected edges for the given cell.
   *
   * @param cell <Cell> whose edges should be returned.
   */
  getEdges(cell2) {
    const cachedEdges = this.edgesCache.get(cell2);
    if (cachedEdges != null) {
      return cachedEdges;
    }
    const { model: model2 } = this.graph;
    let edges = [];
    const isCollapsed = cell2.isCollapsed();
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      if (this.isPort(child2)) {
        edges = edges.concat(child2.getEdges(true, true));
      } else if (isCollapsed || !child2.isVisible()) {
        edges = edges.concat(child2.getEdges(true, true));
      }
    }
    edges = edges.concat(cell2.getEdges(true, true));
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const source2 = this.getVisibleTerminal(edges[i2], true);
      const target2 = this.getVisibleTerminal(edges[i2], false);
      if (source2 === target2 || source2 !== target2 && (target2 === cell2 && (this.parent == null || this.isAncestor(this.parent, source2, this.traverseAncestors)) || source2 === cell2 && (this.parent == null || this.isAncestor(this.parent, target2, this.traverseAncestors)))) {
        result2.push(edges[i2]);
      }
    }
    this.edgesCache.put(cell2, result2);
    return result2;
  }
  /**
   * Helper function to return visible terminal for edge allowing for ports
   *
   * @param edge <Cell> whose edges should be returned.
   * @param source Boolean that specifies whether the source or target terminal is to be returned
   */
  getVisibleTerminal(edge2, source2) {
    let terminalCache;
    if (source2) {
      terminalCache = this.edgeSourceTermCache;
    } else {
      terminalCache = this.edgesTargetTermCache;
    }
    const term = terminalCache.get(edge2);
    if (term != null) {
      return term;
    }
    const state2 = this.graph.view.getState(edge2);
    let terminal = state2 != null ? state2.getVisibleTerminal(source2) : this.graph.view.getVisibleTerminal(edge2, source2);
    if (terminal == null) {
      terminal = state2 != null ? state2.getVisibleTerminal(source2) : this.graph.view.getVisibleTerminal(edge2, source2);
    }
    if (terminal != null) {
      if (this.isPort(terminal)) {
        terminal = terminal.getParent();
      }
      terminalCache.put(edge2, terminal);
    }
    return terminal;
  }
  /**
   * The API method used to exercise the layout upon the graph description
   * and produce a separate description of the vertex position and edge
   * routing changes made. It runs each stage of the layout that has been
   * created.
   */
  run(parent2) {
    const hierarchyVertices = [];
    const allVertexSet = {};
    if (this.roots == null && parent2 != null) {
      const filledVertexSet = Object();
      this.filterDescendants(parent2, filledVertexSet);
      this.roots = [];
      let filledVertexSetEmpty = true;
      for (const key2 in filledVertexSet) {
        if (filledVertexSet[key2] != null) {
          filledVertexSetEmpty = false;
          break;
        }
      }
      while (!filledVertexSetEmpty) {
        const candidateRoots = this.findRoots(parent2, filledVertexSet);
        for (let i2 = 0; i2 < candidateRoots.length; i2 += 1) {
          const vertexSet = Object();
          hierarchyVertices.push(vertexSet);
          this.traverse({
            vertex: candidateRoots[i2],
            directed: true,
            edge: null,
            allVertices: allVertexSet,
            currentComp: vertexSet,
            hierarchyVertices,
            filledVertexSet,
            func: null,
            visited: null
          });
        }
        for (let i2 = 0; i2 < candidateRoots.length; i2 += 1) {
          this.roots.push(candidateRoots[i2]);
        }
        filledVertexSetEmpty = true;
        for (const key2 in filledVertexSet) {
          if (filledVertexSet[key2] != null) {
            filledVertexSetEmpty = false;
            break;
          }
        }
      }
    } else {
      const roots = this.roots;
      for (let i2 = 0; i2 < roots.length; i2 += 1) {
        const vertexSet = Object();
        hierarchyVertices.push(vertexSet);
        this.traverse({
          vertex: roots[i2],
          directed: true,
          edge: null,
          allVertices: allVertexSet,
          currentComp: vertexSet,
          hierarchyVertices,
          filledVertexSet: null,
          func: null,
          visited: null
        });
      }
    }
    let initialX = 0;
    for (let i2 = 0; i2 < hierarchyVertices.length; i2 += 1) {
      const vertexSet = hierarchyVertices[i2];
      const tmp2 = [];
      for (const key2 in vertexSet) {
        tmp2.push(vertexSet[key2]);
      }
      this.model = new GraphHierarchyModel_default(this, tmp2, this.roots, parent2, this.tightenToSource);
      this.cycleStage(parent2);
      this.layeringStage();
      this.crossingStage(parent2);
      initialX = this.placementStage(initialX, parent2);
    }
  }
  /**
   * Creates an array of descendant cells
   */
  filterDescendants(cell2, result2) {
    const { model: model2 } = this.graph;
    if (cell2.isVertex() && cell2 !== this.parent && cell2.isVisible()) {
      result2[ObjectIdentity_default.get(cell2)] = cell2;
    }
    if (this.traverseAncestors || cell2 === this.parent && cell2.isVisible()) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = cell2.getChildAt(i2);
        if (!this.isPort(child2)) {
          this.filterDescendants(child2, result2);
        }
      }
    }
  }
  /**
   * Returns true if the given cell is a "port", that is, when connecting to
   * it, its parent is the connecting vertex in terms of graph traversal
   *
   * @param cell <Cell> that represents the port.
   */
  isPort(cell2) {
    if (cell2 != null && cell2.geometry != null) {
      return cell2.geometry.relative;
    }
    return false;
  }
  /**
   * Returns the edges between the given source and target. This takes into
   * account collapsed and invisible cells and ports.
   *
   * source -
   * target -
   * directed -
   */
  getEdgesBetween(source2, target2, directed) {
    directed = directed != null ? directed : false;
    const edges = this.getEdges(source2);
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const src = this.getVisibleTerminal(edges[i2], true);
      const trg = this.getVisibleTerminal(edges[i2], false);
      if (src === source2 && trg === target2 || !directed && src === target2 && trg === source2) {
        result2.push(edges[i2]);
      }
    }
    return result2;
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * @param vertex <Cell> that represents the vertex where the traversal starts.
   * @param directed boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param edge Optional <Cell> that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param allVertices Array of cell paths for the visited cells.
   */
  traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet }) {
    if (vertex != null && allVertices != null) {
      const vertexID = ObjectIdentity_default.get(vertex);
      if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
        if (currentComp[vertexID] == null) {
          currentComp[vertexID] = vertex;
        }
        if (allVertices[vertexID] == null) {
          allVertices[vertexID] = vertex;
        }
        if (filledVertexSet !== null) {
          delete filledVertexSet[vertexID];
        }
        const edges = this.getEdges(vertex);
        const edgeIsSource = [];
        for (let i2 = 0; i2 < edges.length; i2 += 1) {
          edgeIsSource[i2] = this.getVisibleTerminal(edges[i2], true) == vertex;
        }
        for (let i2 = 0; i2 < edges.length; i2 += 1) {
          if (!directed || edgeIsSource[i2]) {
            const next = this.getVisibleTerminal(edges[i2], !edgeIsSource[i2]);
            let netCount = 1;
            for (let j = 0; j < edges.length; j++) {
              if (j !== i2) {
                const isSource2 = edgeIsSource[j];
                const otherTerm = this.getVisibleTerminal(edges[j], !isSource2);
                if (otherTerm === next) {
                  if (isSource2) {
                    netCount++;
                  } else {
                    netCount--;
                  }
                }
              }
            }
            if (netCount >= 0) {
              currentComp = this.traverse({
                vertex: next,
                directed,
                edge: edges[i2],
                allVertices,
                currentComp,
                hierarchyVertices,
                filledVertexSet,
                func: null,
                visited: null
              });
            }
          }
        }
      } else if (currentComp[vertexID] == null) {
        for (let i2 = 0; i2 < hierarchyVertices.length; i2 += 1) {
          const comp = hierarchyVertices[i2];
          if (comp[vertexID] != null) {
            for (const key2 in comp) {
              currentComp[key2] = comp[key2];
            }
            hierarchyVertices.splice(i2, 1);
            return currentComp;
          }
        }
      }
    }
    return currentComp;
  }
  /**
   * Executes the cycle stage using mxMinimumCycleRemover.
   */
  cycleStage(parent2) {
    const cycleStage = new MinimumCycleRemover_default(this);
    cycleStage.execute(parent2);
  }
  /**
   * Implements first stage of a Sugiyama layout.
   */
  layeringStage() {
    const model2 = this.model;
    model2.initialRank();
    model2.fixRanks();
  }
  /**
   * Executes the crossing stage using mxMedianHybridCrossingReduction.
   */
  crossingStage(parent2) {
    const crossingStage = new MedianHybridCrossingReduction_default(this);
    crossingStage.execute(parent2);
  }
  /**
   * Executes the placement stage using mxCoordinateAssignment.
   */
  placementStage(initialX, parent2) {
    const placementStage = new CoordinateAssignment_default(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
    placementStage.fineTuning = this.fineTuning;
    placementStage.execute(parent2);
    return placementStage.limitX + this.interHierarchySpacing;
  }
};
var HierarchicalLayout_default = HierarchicalLayout;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/SwimlaneModel.js
var SwimlaneModel = class {
  /**
   * Creates an internal ordered graph model using the vertices passed in. If
   * there are any, leftward edge need to be inverted in the internal model.
   *
   * @param layout
   * @param vertices the vertices for this hierarchy
   * @param roots
   * @param parent
   * @param tightenToSource whether or not to tighten vertices towards the sources
   */
  constructor(layout, vertices, roots, parent2, tightenToSource) {
    this.ranks = [];
    this.dfsCount = 0;
    this.SOURCESCANSTARTRANK = 1e8;
    this.tightenToSource = false;
    this.ranksPerGroup = null;
    const graph = layout.getGraph();
    this.tightenToSource = tightenToSource;
    this.roots = roots;
    this.parent = parent2;
    this.vertexMapper = new Dictionary_default();
    this.edgeMapper = new Dictionary_default();
    this.maxRank = 0;
    const internalVertices = [];
    if (vertices == null) {
      vertices = graph.getChildVertices(parent2);
    }
    this.maxRank = this.SOURCESCANSTARTRANK;
    this.createInternalCells(layout, vertices, internalVertices);
    for (let i2 = 0; i2 < vertices.length; i2 += 1) {
      const edges = internalVertices[i2].connectsAsSource;
      for (let j = 0; j < edges.length; j++) {
        const internalEdge = edges[j];
        const realEdges = internalEdge.edges;
        if (realEdges != null && realEdges.length > 0) {
          const realEdge = realEdges[0];
          let targetCell = layout.getVisibleTerminal(realEdge, false);
          let internalTargetCell = this.vertexMapper.get(targetCell);
          if (internalVertices[i2] == internalTargetCell) {
            targetCell = layout.getVisibleTerminal(realEdge, true);
            internalTargetCell = this.vertexMapper.get(targetCell);
          }
          if (internalTargetCell != null && internalVertices[i2] !== internalTargetCell) {
            internalEdge.target = internalTargetCell;
            if (internalTargetCell.connectsAsTarget.length == 0) {
              internalTargetCell.connectsAsTarget = [];
            }
            if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {
              internalTargetCell.connectsAsTarget.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i2].temp[0] = 1;
    }
  }
  /**
   * Creates all edges in the internal model
   *
   * @param layout Reference to the <HierarchicalLayout> algorithm.
   * @param vertices Array of {@link Cells} that represent the vertices whom are to
   * have an internal representation created.
   * @param internalVertices The array of {@link GraphHierarchyNodes} to have their
   * information filled in using the real vertices.
   */
  createInternalCells(layout, vertices, internalVertices) {
    const graph = layout.getGraph();
    const swimlanes = layout.swimlanes;
    for (let i2 = 0; i2 < vertices.length; i2 += 1) {
      internalVertices[i2] = new GraphHierarchyNode_default(vertices[i2]);
      this.vertexMapper.put(vertices[i2], internalVertices[i2]);
      internalVertices[i2].swimlaneIndex = -1;
      for (let ii = 0; ii < swimlanes.length; ii += 1) {
        if (vertices[i2].getParent() === swimlanes[ii]) {
          internalVertices[i2].swimlaneIndex = ii;
          break;
        }
      }
      const conns = layout.getEdges(vertices[i2]);
      internalVertices[i2].connectsAsSource = [];
      for (let j = 0; j < conns.length; j += 1) {
        const cell2 = layout.getVisibleTerminal(conns[j], false);
        if (cell2 !== vertices[i2] && cell2.isVertex() && !layout.isVertexIgnored(cell2)) {
          const undirectedEdges = layout.getEdgesBetween(vertices[i2], cell2, false);
          const directedEdges = layout.getEdgesBetween(vertices[i2], cell2, true);
          if (undirectedEdges != null && undirectedEdges.length > 0 && this.edgeMapper.get(undirectedEdges[0]) == null && directedEdges.length * 2 >= undirectedEdges.length) {
            const internalEdge = new GraphHierarchyEdge_default(undirectedEdges);
            for (let k = 0; k < undirectedEdges.length; k += 1) {
              const edge2 = undirectedEdges[k];
              this.edgeMapper.put(edge2, internalEdge);
              graph.resetEdge(edge2);
              if (layout.disableEdgeStyle) {
                layout.setEdgeStyleEnabled(edge2, false);
                layout.setOrthogonalEdge(edge2, true);
              }
            }
            internalEdge.source = internalVertices[i2];
            if (internalVertices[i2].connectsAsSource.indexOf(internalEdge) < 0) {
              internalVertices[i2].connectsAsSource.push(internalEdge);
            }
          }
        }
      }
      internalVertices[i2].temp[0] = 0;
    }
  }
  /**
   * Basic determination of minimum layer ranking by working from from sources
   * or sinks and working through each node in the relevant edge direction.
   * Starting at the sinks is basically a longest path layering algorithm.
   */
  initialRank() {
    this.ranksPerGroup = [];
    const startNodes = [];
    const seen = {};
    if (this.roots != null) {
      for (let i2 = 0; i2 < this.roots.length; i2 += 1) {
        const internalNode = this.vertexMapper.get(this.roots[i2]);
        this.maxChainDfs(null, internalNode, null, seen, 0);
        if (internalNode != null) {
          startNodes.push(internalNode);
        }
      }
    }
    const lowerRank = {};
    const upperRank = {};
    for (let i2 = this.ranksPerGroup.length - 1; i2 >= 0; i2--) {
      if (i2 === this.ranksPerGroup.length - 1) {
        lowerRank[i2] = 0;
      } else {
        lowerRank[i2] = upperRank[i2 + 1] + 1;
      }
      upperRank[i2] = lowerRank[i2] + this.ranksPerGroup[i2];
    }
    this.maxRank = upperRank[0];
    const internalNodes = this.vertexMapper.getValues();
    for (let i2 = 0; i2 < internalNodes.length; i2 += 1) {
      internalNodes[i2].temp[0] = -1;
    }
    const startNodesCopy = startNodes.slice();
    while (startNodes.length > 0) {
      const internalNode = startNodes[0];
      const layerDeterminingEdges = internalNode.connectsAsTarget;
      const edgesToBeMarked = internalNode.connectsAsSource;
      let allEdgesScanned = true;
      let minimumLayer = upperRank[0];
      for (let i2 = 0; i2 < layerDeterminingEdges.length; i2 += 1) {
        const internalEdge = layerDeterminingEdges[i2];
        if (internalEdge.temp[0] === 5270620) {
          const otherNode = internalEdge.source;
          minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);
        } else {
          allEdgesScanned = false;
          break;
        }
      }
      if (allEdgesScanned) {
        if (minimumLayer > upperRank[internalNode.swimlaneIndex]) {
          minimumLayer = upperRank[internalNode.swimlaneIndex];
        }
        internalNode.temp[0] = minimumLayer;
        if (edgesToBeMarked != null) {
          for (let i2 = 0; i2 < edgesToBeMarked.length; i2 += 1) {
            const internalEdge = edgesToBeMarked[i2];
            internalEdge.temp[0] = 5270620;
            const otherNode = internalEdge.target;
            if (otherNode.temp[0] === -1) {
              startNodes.push(otherNode);
              otherNode.temp[0] = -2;
            }
          }
        }
        startNodes.shift();
      } else {
        const removedCell = startNodes.shift();
        startNodes.push(internalNode);
        if (removedCell === internalNode && startNodes.length === 1) {
          break;
        }
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of chains within groups.
   * Any cycles should be removed prior to running, but previously seen cells
   * are ignored.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param seen a set of all nodes seen by this dfs
   * @param chainCount the number of edges in the chain of vertices going through
   * the current swimlane
   */
  maxChainDfs(parent2, root, connectingEdge, seen, chainCount) {
    if (root != null) {
      const rootId = CellPath_default.create(root.cell);
      if (seen[rootId] == null) {
        seen[rootId] = root;
        const slIndex = root.swimlaneIndex;
        const ranksPerGroup = this.ranksPerGroup;
        if (ranksPerGroup[slIndex] == null || ranksPerGroup[slIndex] < chainCount) {
          ranksPerGroup[slIndex] = chainCount;
        }
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i2 = 0; i2 < outgoingEdges.length; i2 += 1) {
          const internalEdge = outgoingEdges[i2];
          const targetNode = internalEdge.target;
          if (root.swimlaneIndex < targetNode.swimlaneIndex) {
            this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), 0);
          } else if (root.swimlaneIndex === targetNode.swimlaneIndex) {
            this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), chainCount + 1);
          }
        }
      }
    }
  }
  /**
   * Fixes the layer assignments to the values stored in the nodes. Also needs
   * to create dummy nodes for edges that cross layers.
   */
  fixRanks() {
    const rankList = [];
    this.ranks = [];
    for (let i2 = 0; i2 < this.maxRank + 1; i2 += 1) {
      rankList[i2] = [];
      this.ranks[i2] = rankList[i2];
    }
    let rootsArray = null;
    if (this.roots != null) {
      const oldRootsArray = this.roots;
      rootsArray = [];
      for (let i2 = 0; i2 < oldRootsArray.length; i2 += 1) {
        const cell2 = oldRootsArray[i2];
        const internalNode = this.vertexMapper.get(cell2);
        rootsArray[i2] = internalNode;
      }
    }
    this.visit((parent2, node2, edge2, layer, seen) => {
      if (seen === 0 && node2.maxRank < 0 && node2.minRank < 0) {
        rankList[node2.temp[0]].push(node2);
        node2.maxRank = node2.temp[0];
        node2.minRank = node2.temp[0];
        node2.temp[0] = rankList[node2.maxRank].length - 1;
      }
      if (parent2 != null && edge2 != null) {
        const parentToCellRankDifference = parent2.maxRank - node2.maxRank;
        if (parentToCellRankDifference > 1) {
          edge2.maxRank = parent2.maxRank;
          edge2.minRank = node2.maxRank;
          edge2.temp = [];
          edge2.x = [];
          edge2.y = [];
          for (let i2 = edge2.minRank + 1; i2 < edge2.maxRank; i2 += 1) {
            rankList[i2].push(edge2);
            edge2.setGeneralPurposeVariable(i2, rankList[i2].length - 1);
          }
        }
      }
    }, rootsArray, false, null);
  }
  /**
   * A depth first search through the internal heirarchy model.
   *
   * @param visitor The visitor function pattern to be called for each node.
   * @param trackAncestors Whether or not the search is to keep track all nodes
   * directly above this one in the search path.
   */
  visit(visitor, dfsRoots, trackAncestors, seenNodes) {
    if (dfsRoots != null) {
      for (let i2 = 0; i2 < dfsRoots.length; i2 += 1) {
        const internalNode = dfsRoots[i2];
        if (internalNode != null) {
          if (seenNodes == null) {
            seenNodes = {};
          }
          if (trackAncestors) {
            internalNode.hashCode = [];
            internalNode.hashCode[0] = this.dfsCount;
            internalNode.hashCode[1] = i2;
            this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i2, 0);
          } else {
            this.dfs(null, internalNode, null, visitor, seenNodes, 0);
          }
        }
      }
      this.dfsCount += 1;
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs a set of all of the
   * ancestor node of the current node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  dfs(parent2, root, connectingEdge, visitor, seen, layer) {
    if (root != null) {
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent2, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        for (let i2 = 0; i2 < outgoingEdges.length; i2 += 1) {
          const internalEdge = outgoingEdges[i2];
          const targetNode = internalEdge.target;
          this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);
        }
      } else {
        visitor(parent2, root, connectingEdge, layer, 1);
      }
    }
  }
  /**
   * Performs a depth first search on the internal hierarchy model. This dfs
   * extends the default version by keeping track of cells ancestors, but it
   * should be only used when necessary because of it can be computationally
   * intensive for deep searches.
   *
   * @param parent the parent internal node of the current internal node
   * @param root the current internal node
   * @param connectingEdge the internal edge connecting the internal node and the parent
   * internal node, if any
   * @param visitor the visitor pattern to be called for each node
   * @param seen a set of all nodes seen by this dfs
   * @param ancestors the parent hash code
   * @param childHash the new hash code for this node
   * @param layer the layer on the dfs tree ( not the same as the model ranks )
   */
  extendedDfs(parent2, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {
    if (root != null) {
      if (parent2 != null) {
        if (root.hashCode == null || root.hashCode[0] !== parent2.hashCode[0]) {
          const hashCodeLength = parent2.hashCode.length + 1;
          root.hashCode = parent2.hashCode.slice();
          root.hashCode[hashCodeLength - 1] = childHash;
        }
      }
      const rootId = root.id;
      if (seen[rootId] == null) {
        seen[rootId] = root;
        visitor(parent2, root, connectingEdge, layer, 0);
        const outgoingEdges = root.connectsAsSource.slice();
        const incomingEdges = root.connectsAsTarget.slice();
        for (let i2 = 0; i2 < outgoingEdges.length; i2 += 1) {
          const internalEdge = outgoingEdges[i2];
          const targetNode = internalEdge.target;
          if (root.swimlaneIndex <= targetNode.swimlaneIndex) {
            this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i2, layer + 1);
          }
        }
        for (let i2 = 0; i2 < incomingEdges.length; i2 += 1) {
          const internalEdge = incomingEdges[i2];
          const targetNode = internalEdge.source;
          if (root.swimlaneIndex < targetNode.swimlaneIndex) {
            this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i2, layer + 1);
          }
        }
      } else {
        visitor(parent2, root, connectingEdge, layer, 1);
      }
    }
  }
};
var SwimlaneModel_default = SwimlaneModel;

// node_modules/@maxgraph/core/lib/view/layout/hierarchical/SwimlaneOrdering.js
var SwimlaneOrdering = class extends HierarchicalLayoutStage_default {
  /**
   * Creates a cycle remover for the given internal model.
   */
  constructor(layout) {
    super();
    this.layout = layout;
  }
  /**
   * Takes the graph detail and configuration information within the facade
   * and creates the resulting laid out graph within that facade for further
   * use.
   */
  execute(parent2) {
    const model2 = this.layout.getDataModel();
    const seenNodes = {};
    const unseenNodes = clone(model2.vertexMapper, null, true);
    let rootsArray = null;
    if (model2.roots != null) {
      const modelRoots = model2.roots;
      rootsArray = [];
      for (let i2 = 0; i2 < modelRoots.length; i2 += 1) {
        rootsArray[i2] = model2.vertexMapper.get(modelRoots[i2]);
      }
    }
    model2.visit((parent3, node2, connectingEdge, layer, seen) => {
      const isAncestor = parent3 != null && parent3.swimlaneIndex === node2.swimlaneIndex && node2.isAncestor(parent3);
      const reversedOverSwimlane = parent3 != null && connectingEdge != null && parent3.swimlaneIndex < node2.swimlaneIndex && connectingEdge.source === node2;
      if (isAncestor) {
        connectingEdge.invert();
        remove(connectingEdge, parent3.connectsAsSource);
        node2.connectsAsSource.push(connectingEdge);
        parent3.connectsAsTarget.push(connectingEdge);
        remove(connectingEdge, node2.connectsAsTarget);
      } else if (reversedOverSwimlane) {
        connectingEdge.invert();
        remove(connectingEdge, parent3.connectsAsTarget);
        node2.connectsAsTarget.push(connectingEdge);
        parent3.connectsAsSource.push(connectingEdge);
        remove(connectingEdge, node2.connectsAsSource);
      }
      const cellId = CellPath_default.create(node2.cell);
      seenNodes[cellId] = node2;
      delete unseenNodes[cellId];
    }, rootsArray, true, null);
  }
};
var SwimlaneOrdering_default = SwimlaneOrdering;

// node_modules/@maxgraph/core/lib/view/layout/SwimlaneLayout.js
var SwimlaneLayout = class extends GraphLayout_default {
  /**
   * Constructs a new hierarchical layout algorithm.
   *
   * @param graph Reference to the enclosing {@link Graph}.
   * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION_NORTH}.
   * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.
   */
  constructor(graph, orientation, deterministic = true) {
    super(graph);
    this.parentX = null;
    this.parentY = null;
    this.roots = null;
    this.swimlanes = null;
    this.dummyVertexWidth = 50;
    this.resizeParent = false;
    this.maintainParentLocation = false;
    this.moveParent = false;
    this.parentBorder = 30;
    this.intraCellSpacing = 30;
    this.interRankCellSpacing = 100;
    this.interHierarchySpacing = 60;
    this.parallelEdgeSpacing = 10;
    this.orientation = DIRECTION.NORTH;
    this.fineTuning = true;
    this.tightenToSource = true;
    this.disableEdgeStyle = true;
    this.traverseAncestors = true;
    this.model = null;
    this.edgesCache = new Dictionary_default();
    this.edgeSourceTermCache = new Dictionary_default();
    this.edgesTargetTermCache = new Dictionary_default();
    this.edgeStyle = HierarchicalEdgeStyle_default.POLYLINE;
    this.orientation = orientation != null ? orientation : DIRECTION.NORTH;
    this.deterministic = deterministic != null ? deterministic : true;
  }
  /**
   * Returns the internal {@link SwimlaneModel} for this layout algorithm.
   */
  getDataModel() {
    return this.model;
  }
  /**
   * Executes the layout for the children of the specified parent.
   *
   * @param parent Parent <Cell> that contains the children to be laid out.
   * @param swimlanes Ordered array of swimlanes to be laid out
   */
  execute(parent2, swimlanes = null) {
    this.parent = parent2;
    const { model: model2 } = this.graph;
    this.edgesCache = new Dictionary_default();
    this.edgeSourceTermCache = new Dictionary_default();
    this.edgesTargetTermCache = new Dictionary_default();
    if (swimlanes == null || swimlanes.length < 1) {
      return;
    }
    if (parent2 == null) {
      parent2 = swimlanes[0].getParent();
    }
    this.parentX = null;
    this.parentY = null;
    if (parent2 !== this.graph.getDataModel().root && parent2.isVertex() != null && this.maintainParentLocation) {
      const geo = parent2.getGeometry();
      if (geo != null) {
        this.parentX = geo.x;
        this.parentY = geo.y;
      }
    }
    this.swimlanes = swimlanes;
    const dummyVertices = [];
    for (let i2 = 0; i2 < swimlanes.length; i2 += 1) {
      const children = this.graph.getChildCells(swimlanes[i2]);
      if (children == null || children.length === 0) {
        const vertex = this.graph.insertVertex(swimlanes[i2], null, null, 0, 0, this.dummyVertexWidth, 0);
        dummyVertices.push(vertex);
      }
    }
    model2.beginUpdate();
    try {
      this.run(parent2);
      if (this.resizeParent && !parent2.isCollapsed()) {
        this.graph.updateGroupBounds([parent2], this.parentBorder, this.moveParent);
      }
      if (this.parentX != null && this.parentY != null) {
        let geo = parent2.getGeometry();
        if (geo != null) {
          geo = geo.clone();
          geo.x = this.parentX;
          geo.y = this.parentY;
          model2.setGeometry(parent2, geo);
        }
      }
      this.graph.removeCells(dummyVertices);
    } finally {
      model2.endUpdate();
    }
  }
  /**
   * Updates the bounds of the given array of groups so that it includes
   * all child vertices.
   *
   */
  updateGroupBounds() {
    const cells = [];
    const model2 = this.model;
    for (const key2 in model2.edgeMapper) {
      const edge2 = model2.edgeMapper[key2];
      for (let i2 = 0; i2 < edge2.edges.length; i2 += 1) {
        cells.push(edge2.edges[i2]);
      }
    }
    let layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);
    const childBounds = [];
    const swimlanes = this.swimlanes;
    for (let i2 = 0; i2 < swimlanes.length; i2 += 1) {
      const lane = swimlanes[i2];
      const geo = lane.getGeometry();
      if (geo != null) {
        const children = this.graph.getChildCells(lane);
        const size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new Rectangle_default();
        const bounds = this.graph.getBoundingBoxFromGeometry(children);
        childBounds[i2] = bounds;
        const childrenY = bounds.y + geo.y - size.height - this.parentBorder;
        const maxChildrenY = bounds.y + geo.y + bounds.height;
        if (layoutBounds == null) {
          layoutBounds = new Rectangle_default(0, childrenY, 0, maxChildrenY - childrenY);
        } else {
          layoutBounds.y = Math.min(layoutBounds.y, childrenY);
          const maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);
          layoutBounds.height = maxY - layoutBounds.y;
        }
      }
    }
    for (let i2 = 0; i2 < swimlanes.length; i2 += 1) {
      const lane = swimlanes[i2];
      const geo = lane.getGeometry();
      if (geo != null) {
        const children = this.graph.getChildCells(lane);
        const size = this.graph.isSwimlane(lane) ? this.graph.getStartSize(lane) : new Rectangle_default();
        const newGeo = geo.clone();
        const leftGroupBorder = i2 === 0 ? this.parentBorder : this.interRankCellSpacing / 2;
        const w = size.width + leftGroupBorder;
        const x = childBounds[i2].x - w;
        const y = layoutBounds.y - this.parentBorder;
        newGeo.x += x;
        newGeo.y = y;
        newGeo.width = childBounds[i2].width + w + this.interRankCellSpacing / 2;
        newGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;
        this.graph.model.setGeometry(lane, newGeo);
        this.graph.moveCells(children, -x, geo.y - y);
      }
    }
  }
  /**
   * Returns all visible children in the given parent which do not have
   * incoming edges. If the result is empty then the children with the
   * maximum difference between incoming and outgoing edges are returned.
   * This takes into account edges that are being promoted to the given
   * root due to invisible children or collapsed cells.
   *
   * @param parent <Cell> whose children should be checked.
   * @param vertices array of vertices to limit search to
   */
  findRoots(parent2, vertices) {
    const roots = [];
    if (parent2 != null && vertices != null) {
      const { model: model2 } = this.graph;
      let best = null;
      let maxDiff = -1e5;
      for (const i2 in vertices) {
        const cell2 = vertices[i2];
        if (cell2 != null && cell2.isVertex() && cell2.isVisible() && parent2.isAncestor(cell2)) {
          const conns = this.getEdges(cell2);
          let fanOut = 0;
          let fanIn = 0;
          for (let k = 0; k < conns.length; k++) {
            const src = this.getVisibleTerminal(conns[k], true);
            if (src === cell2) {
              const other = this.getVisibleTerminal(conns[k], false);
              if (parent2.isAncestor(other)) {
                fanOut += 1;
              }
            } else if (parent2.isAncestor(src)) {
              fanIn += 1;
            }
          }
          if (fanIn === 0 && fanOut > 0) {
            roots.push(cell2);
          }
          const diff = fanOut - fanIn;
          if (diff > maxDiff) {
            maxDiff = diff;
            best = cell2;
          }
        }
      }
      if (roots.length === 0 && best != null) {
        roots.push(best);
      }
    }
    return roots;
  }
  /**
   * Returns the connected edges for the given cell.
   *
   * @param cell <Cell> whose edges should be returned.
   */
  getEdges(cell2) {
    const cachedEdges = this.edgesCache.get(cell2);
    if (cachedEdges != null) {
      return cachedEdges;
    }
    let edges = [];
    const isCollapsed = cell2.isCollapsed();
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      if (this.isPort(child2)) {
        edges = edges.concat(child2.getEdges(true, true));
      } else if (isCollapsed || !child2.isVisible()) {
        edges = edges.concat(child2.getEdges(true, true));
      }
    }
    edges = edges.concat(cell2.getEdges(true, true));
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const source2 = this.getVisibleTerminal(edges[i2], true);
      const target2 = this.getVisibleTerminal(edges[i2], false);
      if (source2 === target2 || source2 !== target2 && (target2 === cell2 && (this.parent == null || this.graph.isValidAncestor(source2, this.parent, this.traverseAncestors)) || source2 === cell2 && (this.parent == null || this.graph.isValidAncestor(target2, this.parent, this.traverseAncestors)))) {
        result2.push(edges[i2]);
      }
    }
    this.edgesCache.put(cell2, result2);
    return result2;
  }
  /**
   * Helper function to return visible terminal for edge allowing for ports
   *
   * @param edge <Cell> whose edges should be returned.
   * @param source Boolean that specifies whether the source or target terminal is to be returned
   */
  getVisibleTerminal(edge2, source2) {
    let terminalCache = this.edgesTargetTermCache;
    if (source2) {
      terminalCache = this.edgeSourceTermCache;
    }
    const term = terminalCache.get(edge2);
    if (term != null) {
      return term;
    }
    const state2 = this.graph.view.getState(edge2);
    let terminal = state2 != null ? state2.getVisibleTerminal(source2) : this.graph.view.getVisibleTerminal(edge2, source2);
    if (terminal == null) {
      terminal = state2 != null ? state2.getVisibleTerminal(source2) : this.graph.view.getVisibleTerminal(edge2, source2);
    }
    if (terminal != null) {
      if (this.isPort(terminal)) {
        terminal = terminal.getParent();
      }
      terminalCache.put(edge2, terminal);
    }
    return terminal;
  }
  /**
   * The API method used to exercise the layout upon the graph description
   * and produce a separate description of the vertex position and edge
   * routing changes made. It runs each stage of the layout that has been
   * created.
   */
  run(parent2) {
    const hierarchyVertices = [];
    const allVertexSet = {};
    if (this.swimlanes != null && this.swimlanes.length > 0 && parent2 != null) {
      const filledVertexSet = {};
      for (let i2 = 0; i2 < this.swimlanes.length; i2 += 1) {
        this.filterDescendants(this.swimlanes[i2], filledVertexSet);
      }
      this.roots = [];
      let filledVertexSetEmpty = true;
      for (const key2 in filledVertexSet) {
        if (filledVertexSet[key2] != null) {
          filledVertexSetEmpty = false;
          break;
        }
      }
      let laneCounter = 0;
      while (!filledVertexSetEmpty && laneCounter < this.swimlanes.length) {
        const candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);
        if (candidateRoots.length === 0) {
          laneCounter++;
          continue;
        }
        for (let i2 = 0; i2 < candidateRoots.length; i2 += 1) {
          const vertexSet = Object();
          hierarchyVertices.push(vertexSet);
          this.traverse({
            vertex: candidateRoots[i2],
            directed: true,
            edge: null,
            allVertices: allVertexSet,
            currentComp: vertexSet,
            hierarchyVertices,
            filledVertexSet,
            swimlaneIndex: laneCounter,
            func: null,
            visited: null
          });
        }
        for (let i2 = 0; i2 < candidateRoots.length; i2 += 1) {
          this.roots.push(candidateRoots[i2]);
        }
        filledVertexSetEmpty = true;
        for (const key2 in filledVertexSet) {
          if (filledVertexSet[key2] != null) {
            filledVertexSetEmpty = false;
            break;
          }
        }
      }
    } else {
      const roots = this.roots;
      for (let i2 = 0; i2 < roots.length; i2 += 1) {
        const vertexSet = Object();
        hierarchyVertices.push(vertexSet);
        this.traverse({
          vertex: roots[i2],
          directed: true,
          edge: null,
          allVertices: allVertexSet,
          currentComp: vertexSet,
          hierarchyVertices,
          filledVertexSet: null,
          swimlaneIndex: i2,
          func: null,
          visited: null
        });
      }
    }
    const tmp2 = [];
    for (const key2 in allVertexSet) {
      tmp2.push(allVertexSet[key2]);
    }
    this.model = new SwimlaneModel_default(this, tmp2, this.roots, parent2, this.tightenToSource);
    this.cycleStage(parent2);
    this.layeringStage();
    this.crossingStage(parent2);
    this.placementStage(0, parent2);
  }
  /**
   * Creates an array of descendant cells
   */
  filterDescendants(cell2, result2) {
    const { model: model2 } = this.graph;
    if (cell2.isVertex() && cell2 !== this.parent && cell2.getParent() !== this.parent && cell2.isVisible()) {
      result2[ObjectIdentity_default.get(cell2)] = cell2;
    }
    if (this.traverseAncestors || cell2 === this.parent && cell2.isVisible()) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const child2 = cell2.getChildAt(i2);
        if (!this.isPort(child2)) {
          this.filterDescendants(child2, result2);
        }
      }
    }
  }
  /**
   * Returns true if the given cell is a "port", that is, when connecting to
   * it, its parent is the connecting vertex in terms of graph traversal
   *
   * @param cell <Cell> that represents the port.
   */
  isPort(cell2) {
    if (cell2.geometry.relative) {
      return true;
    }
    return false;
  }
  /**
   * Returns the edges between the given source and target. This takes into
   * account collapsed and invisible cells and ports.
   *
   * source -
   * target -
   * directed -
   */
  getEdgesBetween(source2, target2, directed = false) {
    const edges = this.getEdges(source2);
    const result2 = [];
    for (let i2 = 0; i2 < edges.length; i2 += 1) {
      const src = this.getVisibleTerminal(edges[i2], true);
      const trg = this.getVisibleTerminal(edges[i2], false);
      if (src === source2 && trg === target2 || !directed && src === target2 && trg === source2) {
        result2.push(edges[i2]);
      }
    }
    return result2;
  }
  /**
   * Traverses the (directed) graph invoking the given function for each
   * visited vertex and edge. The function is invoked with the current vertex
   * and the incoming edge as a parameter. This implementation makes sure
   * each vertex is only visited once. The function may return false if the
   * traversal should stop at the given vertex.
   *
   * @param vertex <Cell> that represents the vertex where the traversal starts.
   * @param directed boolean indicating if edges should only be traversed
   * from source to target. Default is true.
   * @param edge Optional <Cell> that represents the incoming edge. This is
   * null for the first step of the traversal.
   * @param allVertices Array of cell paths for the visited cells.
   * @param swimlaneIndex the laid out order index of the swimlane vertex is contained in
   */
  traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet, swimlaneIndex }) {
    if (vertex != null && allVertices != null) {
      const vertexID = ObjectIdentity_default.get(vertex);
      if (allVertices[vertexID] == null && (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {
        if (currentComp[vertexID] == null) {
          currentComp[vertexID] = vertex;
        }
        if (allVertices[vertexID] == null) {
          allVertices[vertexID] = vertex;
        }
        if (filledVertexSet !== null) {
          delete filledVertexSet[vertexID];
        }
        const edges = this.getEdges(vertex);
        for (let i2 = 0; i2 < edges.length; i2 += 1) {
          let otherVertex = this.getVisibleTerminal(edges[i2], true);
          const isSource = otherVertex === vertex;
          if (isSource) {
            otherVertex = this.getVisibleTerminal(edges[i2], false);
          }
          let otherIndex = 0;
          for (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++) {
            if (this.swimlanes[otherIndex].isAncestor(otherVertex)) {
              break;
            }
          }
          if (otherIndex >= this.swimlanes.length) {
            continue;
          }
          if (otherIndex > swimlaneIndex || (!directed || isSource) && otherIndex === swimlaneIndex) {
            currentComp = this.traverse({
              vertex: otherVertex,
              directed,
              edge: edges[i2],
              allVertices,
              currentComp,
              hierarchyVertices,
              filledVertexSet,
              swimlaneIndex: otherIndex,
              func: null,
              visited: null
            });
          }
        }
      } else if (currentComp[vertexID] == null) {
        for (let i2 = 0; i2 < hierarchyVertices.length; i2 += 1) {
          const comp = hierarchyVertices[i2];
          if (comp[vertexID] != null) {
            for (const key2 in comp) {
              currentComp[key2] = comp[key2];
            }
            hierarchyVertices.splice(i2, 1);
            return currentComp;
          }
        }
      }
    }
    return currentComp;
  }
  /**
   * Executes the cycle stage using mxMinimumCycleRemover.
   */
  cycleStage(parent2) {
    const cycleStage = new SwimlaneOrdering_default(this);
    cycleStage.execute(parent2);
  }
  /**
   * Implements first stage of a Sugiyama layout.
   */
  layeringStage() {
    const model2 = this.model;
    model2.initialRank();
    model2.fixRanks();
  }
  /**
   * Executes the crossing stage using mxMedianHybridCrossingReduction.
   */
  crossingStage(parent2) {
    const crossingStage = new MedianHybridCrossingReduction_default(this);
    crossingStage.execute(parent2);
  }
  /**
   * Executes the placement stage using mxCoordinateAssignment.
   */
  placementStage(initialX, parent2) {
    const placementStage = new CoordinateAssignment_default(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);
    placementStage.fineTuning = this.fineTuning;
    placementStage.execute(parent2);
    return placementStage.limitX + this.interHierarchySpacing;
  }
};
var SwimlaneLayout_default = SwimlaneLayout;

// node_modules/@maxgraph/core/lib/view/geometry/node/StencilShape.js
var StencilShapeConfig = {
  /**
   * Specifies if the use of eval is allowed for evaluating text content and images.
   * Set this to `true` if stencils can not contain user input.
   * @default false
   */
  allowEval: false,
  /**
   * Specifies the default value for the localized attribute of the text element.
   * @default false
   */
  defaultLocalized: false
};
var StencilShape = class extends Shape_default {
  constructor(desc) {
    super();
    this.constraints = [];
    this.aspect = "auto";
    this.w0 = 100;
    this.h0 = 100;
    this.bgNode = null;
    this.fgNode = null;
    this.strokeWidthValue = null;
    this.desc = desc;
    this.parseDescription();
    this.parseConstraints();
  }
  /**
   * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.
   */
  parseDescription() {
    this.fgNode = this.desc.getElementsByTagName("foreground")[0];
    this.bgNode = this.desc.getElementsByTagName("background")[0];
    this.w0 = Number(this.desc.getAttribute("w") || 100);
    this.h0 = Number(this.desc.getAttribute("h") || 100);
    const aspect = this.desc.getAttribute("aspect");
    this.aspect = aspect ?? "variable";
    const sw = this.desc.getAttribute("strokewidth");
    this.strokeWidthValue = isNotNullish(sw) ? sw : "1";
  }
  /**
   * Reads the constraints from {@link desc} into {@link constraints} using {@link parseConstraint}.
   */
  parseConstraints() {
    const conns = this.desc.getElementsByTagName("connections")[0];
    if (conns) {
      const tmp2 = getChildNodes(conns);
      if (tmp2.length > 0) {
        this.constraints = [];
        for (let i2 = 0; i2 < tmp2.length; i2 += 1) {
          this.constraints.push(this.parseConstraint(tmp2[i2]));
        }
      }
    }
  }
  /**
   * Parses the given XML node and returns its {@link ConnectionConstraint}.
   */
  parseConstraint(node2) {
    const x = Number(node2.getAttribute("x"));
    const y = Number(node2.getAttribute("y"));
    const perimeter2 = node2.getAttribute("perimeter") === "1";
    const name2 = node2.getAttribute("name");
    return new ConnectionConstraint_default(new Point_default(x, y), perimeter2, name2);
  }
  /**
   * Gets the given attribute as a text. The return value from <evaluateAttribute>
   * is used as a key to {@link Resources#get} if the localized attribute in the text
   * node is 1 or if <defaultLocalized> is true.
   */
  evaluateTextAttribute(node2, attribute2, shape2) {
    let result2 = this.evaluateAttribute(node2, attribute2, shape2);
    const loc = node2.getAttribute("localized");
    if (StencilShapeConfig.defaultLocalized && !loc || loc === "1") {
      result2 = Translations_default.get(result2);
    }
    return result2;
  }
  /**
   * Gets the attribute for the given name from the given node. If the attribute
   * does not exist then the text content of the node is evaluated and if it is
   * a function it is invoked with <shape> as the only argument and the return
   * value is used as the attribute value to be returned.
   */
  evaluateAttribute(node, attribute, shape) {
    let result = node.getAttribute(attribute);
    if (!result) {
      const text = getTextContent(node);
      if (text && StencilShapeConfig.allowEval) {
        const funct = eval(text);
        if (typeof funct === "function") {
          result = funct(shape);
        }
      }
    }
    return result;
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawShape(canvas, shape2, x, y, w, h) {
    var _a2;
    const stack = canvas.states.slice();
    const direction = getValue(shape2.style, "direction", null);
    const aspect = this.computeAspect(shape2, x, y, w, h, direction);
    const minScale = Math.min(aspect.width, aspect.height);
    const sw = this.strokeWidthValue === "inherit" ? Number(getNumber(shape2.style, "strokeWidth", 1)) : Number(this.strokeWidthValue) * minScale;
    canvas.setStrokeWidth(sw);
    if (((_a2 = shape2.style) == null ? void 0 : _a2.pointerEvents) ?? false) {
      canvas.setStrokeColor(NONE);
      canvas.rect(x, y, w, h);
      canvas.stroke();
      canvas.setStrokeColor(shape2.stroke);
    }
    this.drawChildren(canvas, shape2, x, y, w, h, this.bgNode, aspect, false, true);
    this.drawChildren(canvas, shape2, x, y, w, h, this.fgNode, aspect, true, !shape2.outline || shape2.style == null || !(shape2.style.backgroundOutline ?? false));
    if (canvas.states.length != stack.length) {
      canvas.states = stack;
    }
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawChildren(canvas, shape2, x, y, w, h, node2, aspect, disableShadow, paint) {
    if (node2 && w > 0 && h > 0) {
      let tmp2 = node2.firstChild;
      while (tmp2) {
        if (tmp2.nodeType === NODETYPE.ELEMENT) {
          this.drawNode(canvas, shape2, tmp2, aspect, disableShadow, paint);
        }
        tmp2 = tmp2.nextSibling;
      }
    }
  }
  /**
   * Returns a rectangle that contains the offset in x and y and the horizontal
   * and vertical scale in width and height used to draw this shape inside the
   * given {@link Rectangle}.
   *
   * @param shape {@link Shape} to be drawn.
   * @param bounds {@link Rectangle} that should contain the stencil.
   * @param direction Optional direction of the shape to be darwn.
   */
  computeAspect(shape2 = null, x, y, w, h, direction) {
    let x0 = x;
    let y0 = y;
    let sx = w / this.w0;
    let sy = h / this.h0;
    const inverse = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;
    if (inverse) {
      sy = w / this.h0;
      sx = h / this.w0;
      const delta = (w - h) / 2;
      x0 += delta;
      y0 -= delta;
    }
    if (this.aspect === "fixed") {
      sy = Math.min(sx, sy);
      sx = sy;
      if (inverse) {
        x0 += (h - this.w0 * sx) / 2;
        y0 += (w - this.h0 * sy) / 2;
      } else {
        x0 += (w - this.w0 * sx) / 2;
        y0 += (h - this.h0 * sy) / 2;
      }
    }
    return new Rectangle_default(x0, y0, sx, sy);
  }
  /**
   * Draws this stencil inside the given bounds.
   */
  drawNode(canvas, shape2, node2, aspect, disableShadow, paint) {
    const name2 = node2.nodeName;
    const x0 = aspect.x;
    const y0 = aspect.y;
    const sx = aspect.width;
    const sy = aspect.height;
    const minScale = Math.min(sx, sy);
    if (name2 === "save") {
      canvas.save();
    } else if (name2 === "restore") {
      canvas.restore();
    } else if (paint) {
      if (name2 === "path") {
        canvas.begin();
        let parseRegularly = true;
        if (node2.getAttribute("rounded") == "1") {
          parseRegularly = false;
          const arcSize = Number(node2.getAttribute("arcSize"));
          let pointCount = 0;
          const segs = [];
          let childNode = node2.firstChild;
          while (childNode != null) {
            if (childNode.nodeType === NODETYPE.ELEMENT) {
              const childName = childNode.nodeName;
              if (childName === "move" || childName === "line") {
                if (childName === "move" || segs.length === 0) {
                  segs.push([]);
                }
                segs[segs.length - 1].push(new Point_default(x0 + Number(childNode.getAttribute("x")) * sx, y0 + Number(childNode.getAttribute("y")) * sy));
                pointCount++;
              } else {
                parseRegularly = true;
                break;
              }
            }
            childNode = childNode.nextSibling;
          }
          if (!parseRegularly && pointCount > 0) {
            for (let i2 = 0; i2 < segs.length; i2 += 1) {
              let close = false;
              const ps = segs[i2][0];
              const pe = segs[i2][segs[i2].length - 1];
              if (ps.x === pe.x && ps.y === pe.y) {
                segs[i2].pop();
                close = true;
              }
              this.addPoints(canvas, segs[i2], true, arcSize, close);
            }
          } else {
            parseRegularly = true;
          }
        }
        if (parseRegularly) {
          let childNode = node2.firstChild;
          while (childNode) {
            if (childNode.nodeType === NODETYPE.ELEMENT) {
              this.drawNode(canvas, shape2, childNode, aspect, disableShadow, paint);
            }
            childNode = childNode.nextSibling;
          }
        }
      } else if (name2 === "close") {
        canvas.close();
      } else if (name2 === "move") {
        canvas.moveTo(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy);
      } else if (name2 === "line") {
        canvas.lineTo(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy);
      } else if (name2 === "quad") {
        canvas.quadTo(x0 + Number(node2.getAttribute("x1")) * sx, y0 + Number(node2.getAttribute("y1")) * sy, x0 + Number(node2.getAttribute("x2")) * sx, y0 + Number(node2.getAttribute("y2")) * sy);
      } else if (name2 === "curve") {
        canvas.curveTo(x0 + Number(node2.getAttribute("x1")) * sx, y0 + Number(node2.getAttribute("y1")) * sy, x0 + Number(node2.getAttribute("x2")) * sx, y0 + Number(node2.getAttribute("y2")) * sy, x0 + Number(node2.getAttribute("x3")) * sx, y0 + Number(node2.getAttribute("y3")) * sy);
      } else if (name2 === "arc") {
        canvas.arcTo(Number(node2.getAttribute("rx")) * sx, Number(node2.getAttribute("ry")) * sy, Number(node2.getAttribute("x-axis-rotation")), Boolean(node2.getAttribute("large-arc-flag")), Boolean(node2.getAttribute("sweep-flag")), x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy);
      } else if (name2 === "rect") {
        canvas.rect(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy, Number(node2.getAttribute("w")) * sx, Number(node2.getAttribute("h")) * sy);
      } else if (name2 === "roundrect") {
        let arcsize = Number(node2.getAttribute("arcsize"));
        if (arcsize === 0) {
          arcsize = RECTANGLE_ROUNDING_FACTOR * 100;
        }
        const w = Number(node2.getAttribute("w")) * sx;
        const h = Number(node2.getAttribute("h")) * sy;
        const factor = Number(arcsize) / 100;
        const r = Math.min(w * factor, h * factor);
        canvas.roundrect(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy, w, h, r, r);
      } else if (name2 === "ellipse") {
        canvas.ellipse(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy, Number(node2.getAttribute("w")) * sx, Number(node2.getAttribute("h")) * sy);
      } else if (name2 === "image") {
        if (!shape2.outline) {
          const src = this.evaluateAttribute(node2, "src", shape2);
          canvas.image(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy, Number(node2.getAttribute("w")) * sx, Number(node2.getAttribute("h")) * sy, src, false, node2.getAttribute("flipH") === "1", node2.getAttribute("flipV") === "1");
        }
      } else if (name2 === "text") {
        if (!shape2.outline) {
          const str = this.evaluateTextAttribute(node2, "str", shape2);
          let rotation = node2.getAttribute("vertical") == "1" ? -90 : 0;
          if (node2.getAttribute("align-shape") === "0") {
            const dr = shape2.rotation;
            const flipH = getValue(shape2.style, "flipH", 0) == 1;
            const flipV = getValue(shape2.style, "flipV", 0) == 1;
            if (flipH && flipV) {
              rotation -= dr;
            } else if (flipH || flipV) {
              rotation += dr;
            } else {
              rotation -= dr;
            }
          }
          rotation -= Number(node2.getAttribute("rotation"));
          canvas.text(x0 + Number(node2.getAttribute("x")) * sx, y0 + Number(node2.getAttribute("y")) * sy, 0, 0, str, node2.getAttribute("align") || ALIGN.LEFT, node2.getAttribute("valign") || ALIGN.TOP, false, "", "auto", false, rotation, TEXT_DIRECTION.AUTO);
        }
      } else if (name2 === "include-shape") {
        const stencil = StencilShapeRegistry_default.getStencil(node2.getAttribute("name"));
        if (stencil) {
          const x = x0 + Number(node2.getAttribute("x")) * sx;
          const y = y0 + Number(node2.getAttribute("y")) * sy;
          const w = Number(node2.getAttribute("w")) * sx;
          const h = Number(node2.getAttribute("h")) * sy;
          stencil.drawShape(canvas, shape2, x, y, w, h);
        }
      } else if (name2 === "fillstroke") {
        canvas.fillAndStroke();
      } else if (name2 === "fill") {
        canvas.fill();
      } else if (name2 === "stroke") {
        canvas.stroke();
      } else if (name2 === "strokewidth") {
        const s = node2.getAttribute("fixed") === "1" ? 1 : minScale;
        canvas.setStrokeWidth(Number(node2.getAttribute("width")) * s);
      } else if (name2 === "dashed") {
        canvas.setDashed(node2.getAttribute("dashed") === "1");
      } else if (name2 === "dashpattern") {
        let value2 = node2.getAttribute("pattern");
        if (value2 != null) {
          const tmp2 = value2.split(" ");
          const pat = [];
          for (let i2 = 0; i2 < tmp2.length; i2 += 1) {
            if (tmp2[i2].length > 0) {
              pat.push(Number(tmp2[i2]) * minScale);
            }
          }
          value2 = pat.join(" ");
          canvas.setDashPattern(value2);
        }
      } else if (name2 === "strokecolor") {
        canvas.setStrokeColor(node2.getAttribute("color"));
      } else if (name2 === "linecap") {
        canvas.setLineCap(node2.getAttribute("cap"));
      } else if (name2 === "linejoin") {
        canvas.setLineJoin(node2.getAttribute("join"));
      } else if (name2 === "miterlimit") {
        canvas.setMiterLimit(Number(node2.getAttribute("limit")));
      } else if (name2 === "fillcolor") {
        canvas.setFillColor(node2.getAttribute("color"));
      } else if (name2 === "alpha") {
        canvas.setAlpha(Number(node2.getAttribute("alpha")));
      } else if (name2 === "fillalpha") {
        canvas.setAlpha(Number(node2.getAttribute("alpha")));
      } else if (name2 === "strokealpha") {
        canvas.setAlpha(Number(node2.getAttribute("alpha")));
      } else if (name2 === "fontcolor") {
        canvas.setFontColor(node2.getAttribute("color"));
      } else if (name2 === "fontstyle") {
        canvas.setFontStyle(Number(node2.getAttribute("style")));
      } else if (name2 === "fontfamily") {
        canvas.setFontFamily(node2.getAttribute("family"));
      } else if (name2 === "fontsize") {
        canvas.setFontSize(Number(node2.getAttribute("size")) * minScale);
      }
      if (disableShadow && (name2 === "fillstroke" || name2 === "fill" || name2 === "stroke")) {
        disableShadow = false;
        canvas.setShadow(false);
      }
    }
  }
};
var StencilShape_default = StencilShape;

// node_modules/@maxgraph/core/lib/view/animate/Animation.js
var Animation = class extends EventSource_default {
  constructor(delay = 20) {
    super();
    this.thread = null;
    this.delay = delay;
  }
  /**
   * Returns true if the animation is running.
   */
  isRunning() {
    return this.thread != null;
  }
  /**
   * Starts the animation by repeatedly invoking updateAnimation.
   */
  startAnimation() {
    if (this.thread == null) {
      this.thread = window.setInterval(this.updateAnimation.bind(this), this.delay);
    }
  }
  /**
   * Hook for subclassers to implement the animation. Invoke stopAnimation
   * when finished, startAnimation to resume. This is called whenever the
   * timer fires and fires an mxEvent.EXECUTE event with no properties.
   */
  updateAnimation() {
    this.fireEvent(new EventObject_default(InternalEvent_default.EXECUTE));
  }
  /**
   * Stops the animation by deleting the timer and fires an {@link Event#DONE}.
   */
  stopAnimation() {
    if (this.thread != null) {
      window.clearInterval(this.thread);
      this.thread = null;
      this.fireEvent(new EventObject_default(InternalEvent_default.DONE));
    }
  }
};
var Animation_default = Animation;

// node_modules/@maxgraph/core/lib/view/animate/Effects.js
var Effects = class _Effects {
  /**
   * Asynchronous animated move operation. See also: <Morphing>.
   *
   * @example
   * ```javascript
   * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)
   * {
   *   var changes = evt.getProperty('edit').changes;
   *
   *   if (changes.length < 10)
   *   {
   *     Effects.animateChanges(graph, changes);
   *   }
   * });
   * ```
   *
   * @param graph - {@link Graph} that received the changes.
   * @param changes - Array of changes to be animated.
   * @param done - Optional function argument that is invoked after the
   * last step of the animation.
   */
  static animateChanges(graph, changes, done) {
    const maxStep = 10;
    let step = 0;
    const animate = () => {
      let isRequired = false;
      for (let i2 = 0; i2 < changes.length; i2 += 1) {
        const change = changes[i2];
        if (change instanceof GeometryChange_default || change instanceof TerminalChange_default || change instanceof ValueChange_default || change instanceof ChildChange_default || change instanceof StyleChange_default) {
          const state2 = graph.getView().getState(change.cell || change.child, false);
          if (state2 != null) {
            isRequired = true;
            if (change.constructor !== GeometryChange_default || change.cell.isEdge()) {
              setOpacity(state2.shape.node, 100 * step / maxStep);
            } else {
              const { scale } = graph.getView();
              const geometry = change.geometry;
              const previous = change.previous;
              const dx = (geometry.x - previous.x) * scale;
              const dy = (geometry.y - previous.y) * scale;
              const sx = (geometry.width - previous.width) * scale;
              const sy = (geometry.height - previous.height) * scale;
              if (step === 0) {
                state2.x -= dx;
                state2.y -= dy;
                state2.width -= sx;
                state2.height -= sy;
              } else {
                state2.x += dx / maxStep;
                state2.y += dy / maxStep;
                state2.width += sx / maxStep;
                state2.height += sy / maxStep;
              }
              graph.cellRenderer.redraw(state2);
              _Effects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);
            }
          }
        }
      }
      if (step < maxStep && isRequired) {
        step++;
        window.setTimeout(animate, delay);
      } else if (done != null) {
        done();
      }
    };
    const delay = 30;
    animate();
  }
  /**
   * Sets the opacity on the given cell and its descendants.
   *
   * @param graph - {@link Graph} that contains the cells.
   * @param cell - <Cell> to set the opacity for.
   * @param opacity - New value for the opacity in %.
   */
  static cascadeOpacity(graph, cell2, opacity) {
    const childCount2 = cell2.getChildCount();
    for (let i2 = 0; i2 < childCount2; i2 += 1) {
      const child2 = cell2.getChildAt(i2);
      const childState = graph.getView().getState(child2);
      if (childState != null) {
        setOpacity(childState.shape.node, opacity);
        _Effects.cascadeOpacity(graph, child2, opacity);
      }
    }
    const edges = cell2.getEdges();
    if (edges != null) {
      for (let i2 = 0; i2 < edges.length; i2 += 1) {
        const edgeState = graph.getView().getState(edges[i2]);
        if (edgeState != null) {
          setOpacity(edgeState.shape.node, opacity);
        }
      }
    }
  }
  /**
   * Asynchronous fade-out operation.
   */
  static fadeOut(node2, from, remove2, step, delay, isEnabled) {
    step = step || 40;
    delay = delay || 30;
    let opacity = from || 100;
    setOpacity(node2, opacity);
    if (isEnabled || isEnabled == null) {
      const f = () => {
        opacity = Math.max(opacity - step, 0);
        setOpacity(node2, opacity);
        if (opacity > 0) {
          window.setTimeout(f, delay);
        } else {
          node2.style.visibility = "hidden";
          if (remove2 && node2.parentNode) {
            node2.parentNode.removeChild(node2);
          }
        }
      };
      window.setTimeout(f, delay);
    } else {
      node2.style.visibility = "hidden";
      if (remove2 && node2.parentNode) {
        node2.parentNode.removeChild(node2);
      }
    }
  }
};
var Effects_default = Effects;

// node_modules/@maxgraph/core/lib/view/cell/CellStatePreview.js
var CellStatePreview = class {
  constructor(graph) {
    this.count = 0;
    this.deltas = new Dictionary_default();
    this.graph = graph;
  }
  /**
   * Returns true if this contains no entries.
   */
  isEmpty() {
    return this.count === 0;
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @param {boolean} add
   * @param {boolean} includeEdges
   * @return {*}  {mxPoint}
   * @memberof mxCellStatePreview
   */
  moveState(state2, dx, dy, add = true, includeEdges = true) {
    let delta = this.deltas.get(state2.cell);
    if (delta == null) {
      delta = { point: new Point_default(dx, dy), state: state2 };
      this.deltas.put(state2.cell, delta);
      this.count++;
    } else if (add) {
      delta.point.x += dx;
      delta.point.y += dy;
    } else {
      delta.point.x = dx;
      delta.point.y = dy;
    }
    if (includeEdges) {
      this.addEdges(state2);
    }
    return delta.point;
  }
  /**
   *
   * @param {Function} visitor
   * @memberof mxCellStatePreview
   */
  show(visitor = null) {
    this.deltas.visit((key2, delta) => {
      this.translateState(delta.state, delta.point.x, delta.point.y);
    });
    this.deltas.visit((key2, delta) => {
      this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);
    });
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @memberof mxCellStatePreview
   */
  translateState(state2, dx, dy) {
    if (state2 != null) {
      if (state2.cell.isVertex()) {
        state2.view.updateCellState(state2);
        const geo = state2.cell.getGeometry();
        if ((dx !== 0 || dy !== 0) && geo != null && (!geo.relative || this.deltas.get(state2.cell) != null)) {
          state2.x += dx;
          state2.y += dy;
        }
      }
      for (const child2 of state2.cell.getChildren()) {
        this.translateState(state2.view.getState(child2), dx, dy);
      }
    }
  }
  /**
   *
   * @param {CellState} state
   * @param {number} dx
   * @param {number} dy
   * @param {Function} visitor
   * @memberof mxCellStatePreview
   */
  revalidateState(state2, dx, dy, visitor = null) {
    if (state2.cell.isEdge()) {
      state2.view.updateCellState(state2);
    }
    const geo = state2.cell.getGeometry();
    const pState = state2.view.getState(state2.cell.getParent());
    if ((dx !== 0 || dy !== 0) && geo != null && geo.relative && state2.cell.isVertex() && (pState == null || pState.cell.isVertex() || this.deltas.get(state2.cell) != null)) {
      state2.x += dx;
      state2.y += dy;
    }
    this.graph.cellRenderer.redraw(state2);
    if (visitor != null) {
      visitor(state2);
    }
    for (const child2 of state2.cell.getChildren()) {
      this.revalidateState(this.graph.view.getState(child2), dx, dy, visitor);
    }
  }
  /**
   *
   * @param {CellState} state
   * @memberof mxCellStatePreview
   */
  addEdges(state2) {
    const edgeCount = state2.cell.getEdgeCount();
    for (let i2 = 0; i2 < edgeCount; i2 += 1) {
      const s = state2.view.getState(state2.cell.getEdgeAt(i2));
      if (s != null) {
        this.moveState(s, 0, 0);
      }
    }
  }
};
var CellStatePreview_default = CellStatePreview;

// node_modules/@maxgraph/core/lib/view/animate/Morphing.js
var Morphing = class extends Animation_default {
  constructor(graph, steps = 6, ease = 1.5, delay) {
    super(delay);
    this.step = 0;
    this.cells = null;
    this.graph = graph;
    this.steps = steps;
    this.ease = ease;
  }
  /**
   * Animation step.
   */
  updateAnimation() {
    super.updateAnimation();
    const move = new CellStatePreview_default(this.graph);
    if (this.cells != null) {
      for (const cell2 of this.cells) {
        this.animateCell(cell2, move, false);
      }
    } else {
      this.animateCell(this.graph.getDataModel().getRoot(), move, true);
    }
    this.show(move);
    if (move.isEmpty() || this.step++ >= this.steps) {
      this.stopAnimation();
    }
  }
  /**
   * Shows the changes in the given <CellStatePreview>.
   */
  show(move) {
    move.show();
  }
  /**
   * Animates the given cell state using <CellStatePreview.moveState>.
   */
  animateCell(cell2, move, recurse = false) {
    const state2 = this.graph.getView().getState(cell2);
    let delta = null;
    if (state2 != null) {
      delta = this.getDelta(state2);
      if (cell2.isVertex() && (delta.x != 0 || delta.y != 0)) {
        const translate = this.graph.view.getTranslate();
        const scale = this.graph.view.getScale();
        delta.x += translate.x * scale;
        delta.y += translate.y * scale;
        move.moveState(state2, -delta.x / this.ease, -delta.y / this.ease);
      }
    }
    if (recurse && !this.stopRecursion(state2, delta)) {
      const childCount2 = cell2.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        this.animateCell(cell2.getChildAt(i2), move, recurse);
      }
    }
  }
  /**
   * Returns true if the animation should not recursively find more
   * deltas for children if the given parent state has been animated.
   */
  stopRecursion(state2 = null, delta = null) {
    return delta != null && (delta.x != 0 || delta.y != 0);
  }
  /**
   * Returns the vector between the current rendered state and the future
   * location of the state after the display will be updated.
   */
  getDelta(state2) {
    const origin = this.getOriginForCell(state2.cell);
    const translate = this.graph.getView().getTranslate();
    const scale = this.graph.getView().getScale();
    const x = state2.x / scale - translate.x;
    const y = state2.y / scale - translate.y;
    return new Point_default((origin.x - x) * scale, (origin.y - y) * scale);
  }
  /**
   * Returns the top, left corner of the given cell. TODO: Improve performance
   * by using caching inside this method as the result per cell never changes
   * during the lifecycle of this object.
   */
  getOriginForCell(cell2 = null) {
    let result2 = null;
    if (cell2 != null) {
      const parent2 = cell2.getParent();
      const geo = cell2.getGeometry();
      result2 = this.getOriginForCell(parent2);
      if (geo != null && parent2 != null) {
        if (geo.relative) {
          const pgeo = parent2.getGeometry();
          if (pgeo != null) {
            result2.x += geo.x * pgeo.width;
            result2.y += geo.y * pgeo.height;
          }
        } else {
          result2.x += geo.x;
          result2.y += geo.y;
        }
      }
    }
    if (result2 == null) {
      const t = this.graph.view.getTranslate();
      result2 = new Point_default(-t.x, -t.y);
    }
    return result2;
  }
};
var Morphing_default = Morphing;

// node_modules/@maxgraph/core/lib/view/canvas/XmlCanvas2D.js
var XmlCanvas2D = class extends AbstractCanvas2D_default {
  constructor(root) {
    super();
    this.textEnabled = true;
    this.compressed = true;
    this.root = root;
    this.writeDefaults();
  }
  /**
   * Writes the rendering defaults to {@link root}:
   */
  writeDefaults() {
    let elem;
    elem = this.createElement("fontfamily");
    elem.setAttribute("family", DEFAULT_FONTFAMILY);
    this.root.appendChild(elem);
    elem = this.createElement("fontsize");
    elem.setAttribute("size", String(DEFAULT_FONTSIZE));
    this.root.appendChild(elem);
    elem = this.createElement("shadowcolor");
    elem.setAttribute("color", SHADOWCOLOR);
    this.root.appendChild(elem);
    elem = this.createElement("shadowalpha");
    elem.setAttribute("alpha", String(SHADOW_OPACITY));
    this.root.appendChild(elem);
    elem = this.createElement("shadowoffset");
    elem.setAttribute("dx", String(SHADOW_OFFSET_X));
    elem.setAttribute("dy", String(SHADOW_OFFSET_Y));
    this.root.appendChild(elem);
  }
  /**
   * Returns a formatted number with 2 decimal places.
   */
  format(value2) {
    if (typeof value2 === "string") {
      return parseFloat(parseFloat(value2).toFixed(2));
    } else {
      return parseFloat(value2.toFixed(2));
    }
  }
  /**
   * Creates the given element using the owner document of {@link root}.
   */
  createElement(name2) {
    return this.root.ownerDocument.createElement(name2);
  }
  /**
   * Saves the drawing state.
   */
  save() {
    if (this.compressed) {
      super.save();
    }
    this.root.appendChild(this.createElement("save"));
  }
  /**
   * Restores the drawing state.
   */
  restore() {
    if (this.compressed) {
      super.restore();
    }
    this.root.appendChild(this.createElement("restore"));
  }
  /**
   * Scales the output.
   *
   * @param scale Number that represents the scale where 1 is equal to 100%.
   */
  scale(value2) {
    const elem = this.createElement("scale");
    elem.setAttribute("scale", String(value2));
    this.root.appendChild(elem);
  }
  /**
   * Translates the output.
   *
   * @param dx Number that specifies the horizontal translation.
   * @param dy Number that specifies the vertical translation.
   */
  translate(dx, dy) {
    const elem = this.createElement("translate");
    elem.setAttribute("dx", String(this.format(dx)));
    elem.setAttribute("dy", String(this.format(dy)));
    this.root.appendChild(elem);
  }
  /**
   * Rotates and/or flips the output around a given center. (Note: Due to
   * limitations in VML, the rotation cannot be concatenated.)
   *
   * @param theta Number that represents the angle of the rotation (in degrees).
   * @param flipH Boolean indicating if the output should be flipped horizontally.
   * @param flipV Boolean indicating if the output should be flipped vertically.
   * @param cx Number that represents the x-coordinate of the rotation center.
   * @param cy Number that represents the y-coordinate of the rotation center.
   */
  rotate(theta, flipH, flipV, cx, cy) {
    const elem = this.createElement("rotate");
    if (theta !== 0 || flipH || flipV) {
      elem.setAttribute("theta", String(this.format(theta)));
      elem.setAttribute("flipH", flipH ? "1" : "0");
      elem.setAttribute("flipV", flipV ? "1" : "0");
      elem.setAttribute("cx", String(this.format(cx)));
      elem.setAttribute("cy", String(this.format(cy)));
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current alpha.
   *
   * @param value Number that represents the new alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setAlpha(value2) {
    if (this.compressed) {
      if (this.state.alpha === value2) {
        return;
      }
      super.setAlpha(value2);
    }
    const elem = this.createElement("alpha");
    elem.setAttribute("alpha", String(this.format(value2)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current fill alpha.
   *
   * @param value Number that represents the new fill alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setFillAlpha(value2) {
    if (this.compressed) {
      if (this.state.fillAlpha === value2) {
        return;
      }
      super.setFillAlpha(value2);
    }
    const elem = this.createElement("fillalpha");
    elem.setAttribute("alpha", String(this.format(value2)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current stroke alpha.
   *
   * @param value Number that represents the new stroke alpha. Possible values are between
   * 1 (opaque) and 0 (transparent).
   */
  setStrokeAlpha(value2) {
    if (this.compressed) {
      if (this.state.strokeAlpha === value2) {
        return;
      }
      super.setStrokeAlpha(value2);
    }
    const elem = this.createElement("strokealpha");
    elem.setAttribute("alpha", String(this.format(value2)));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current fill color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFillColor(value2 = null) {
    if (value2 === NONE) {
      value2 = null;
    }
    if (this.compressed) {
      if (this.state.fillColor === value2) {
        return;
      }
      super.setFillColor(value2);
    }
    const elem = this.createElement("fillcolor");
    elem.setAttribute("color", value2 != null ? value2 : NONE);
    this.root.appendChild(elem);
  }
  /**
   * Sets the gradient. Note that the coordinates may be ignored by some implementations.
   *
   * @param color1 Hexadecimal representation of the start color.
   * @param color2 Hexadecimal representation of the end color.
   * @param x X-coordinate of the gradient region.
   * @param y y-coordinate of the gradient region.
   * @param w Width of the gradient region.
   * @param h Height of the gradient region.
   * @param direction One of {@link Constants#DIRECTION_NORTH}, {@link Constants#DIRECTION_EAST},
   * {@link Constants#DIRECTION_SOUTH} or {@link Constants#DIRECTION_WEST}.
   * @param alpha1 Optional alpha of the start color. Default is 1. Possible values
   * are between 1 (opaque) and 0 (transparent).
   * @param alpha2 Optional alpha of the end color. Default is 1. Possible values
   * are between 1 (opaque) and 0 (transparent).
   */
  setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {
    if (color1 != null && color2 != null) {
      super.setGradient(color1, color2, x, y, w, h, direction, alpha1, alpha2);
      const elem = this.createElement("gradient");
      elem.setAttribute("c1", color1);
      elem.setAttribute("c2", color2);
      elem.setAttribute("x", String(this.format(x)));
      elem.setAttribute("y", String(this.format(y)));
      elem.setAttribute("w", String(this.format(w)));
      elem.setAttribute("h", String(this.format(h)));
      if (direction != null) {
        elem.setAttribute("direction", direction);
      }
      if (alpha1 != null) {
        elem.setAttribute("alpha1", String(alpha1));
      }
      if (alpha2 != null) {
        elem.setAttribute("alpha2", String(alpha2));
      }
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current stroke color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setStrokeColor(value2 = null) {
    if (value2 === NONE) {
      value2 = null;
    }
    if (this.compressed) {
      if (this.state.strokeColor === value2) {
        return;
      }
      super.setStrokeColor(value2);
    }
    const elem = this.createElement("strokecolor");
    elem.setAttribute("color", value2 != null ? value2 : NONE);
    this.root.appendChild(elem);
  }
  /**
   * Sets the current stroke width.
   *
   * @param value Numeric representation of the stroke width.
   */
  setStrokeWidth(value2) {
    if (this.compressed) {
      if (this.state.strokeWidth === value2) {
        return;
      }
      super.setStrokeWidth(value2);
    }
    const elem = this.createElement("strokewidth");
    elem.setAttribute("width", String(this.format(value2)));
    this.root.appendChild(elem);
  }
  /**
   * Enables or disables dashed lines.
   *
   * @param value Boolean that specifies if dashed lines should be enabled.
   * @param value Boolean that specifies if the stroke width should be ignored
   * for the dash pattern.
   * @default false
   */
  setDashed(value2, fixDash) {
    if (this.compressed) {
      if (this.state.dashed === value2) {
        return;
      }
      super.setDashed(value2, fixDash);
    }
    const elem = this.createElement("dashed");
    elem.setAttribute("dashed", value2 ? "1" : "0");
    if (fixDash != null) {
      elem.setAttribute("fixDash", fixDash ? "1" : "0");
    }
    this.root.appendChild(elem);
  }
  /**
   * Sets the current dash pattern.
   * @default '3 3'
   *
   * @param value String that represents the dash pattern, which is a sequence of
   * numbers defining the length of the dashes and the length of the spaces
   * between the dashes. The lengths are relative to the line width - a length
   * of 1 is equals to the line width.
   */
  setDashPattern(value2) {
    if (this.compressed) {
      if (this.state.dashPattern === value2) {
        return;
      }
      super.setDashPattern(value2);
    }
    const elem = this.createElement("dashpattern");
    elem.setAttribute("pattern", value2);
    this.root.appendChild(elem);
  }
  /**
   * Sets the line cap.
   * @default 'flat' which corresponds to 'butt' in SVG
   *
   * @param value String that represents the line cap. Possible values are flat, round
   * and square.
   */
  setLineCap(value2) {
    if (this.compressed) {
      if (this.state.lineCap === value2) {
        return;
      }
      super.setLineCap(value2);
    }
    const elem = this.createElement("linecap");
    elem.setAttribute("cap", value2);
    this.root.appendChild(elem);
  }
  /**
   * Sets the line join.
   * @default 'miter'
   *
   * @param value String that represents the line join. Possible values are miter,
   * round and bevel.
   */
  setLineJoin(value2) {
    if (this.compressed) {
      if (this.state.lineJoin === value2) {
        return;
      }
      super.setLineJoin(value2);
    }
    const elem = this.createElement("linejoin");
    elem.setAttribute("join", value2);
    this.root.appendChild(elem);
  }
  /**
   * Sets the miter limit.
   * @default 10
   *
   * @param value Number that represents the miter limit.
   */
  setMiterLimit(value2) {
    if (this.compressed) {
      if (this.state.miterLimit === value2) {
        return;
      }
      super.setMiterLimit(value2);
    }
    const elem = this.createElement("miterlimit");
    elem.setAttribute("limit", String(value2));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current font color.
   * @default '#000000'
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontColor(value2 = null) {
    if (this.textEnabled) {
      if (value2 === NONE) {
        value2 = null;
      }
      if (this.compressed) {
        if (this.state.fontColor === value2) {
          return;
        }
        super.setFontColor(value2);
      }
      const elem = this.createElement("fontcolor");
      elem.setAttribute("color", value2 != null ? value2 : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font background color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontBackgroundColor(value2 = null) {
    if (this.textEnabled) {
      if (value2 === NONE) {
        value2 = null;
      }
      if (this.compressed) {
        if (this.state.fontBackgroundColor === value2) {
          return;
        }
        super.setFontBackgroundColor(value2);
      }
      const elem = this.createElement("fontbackgroundcolor");
      elem.setAttribute("color", value2 != null ? value2 : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font border color.
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setFontBorderColor(value2 = null) {
    if (this.textEnabled) {
      if (value2 === NONE) {
        value2 = null;
      }
      if (this.compressed) {
        if (this.state.fontBorderColor === value2) {
          return;
        }
        super.setFontBorderColor(value2);
      }
      const elem = this.createElement("fontbordercolor");
      elem.setAttribute("color", value2 != null ? value2 : NONE);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font size.
   * @default {@link mxConstants.DEFAULT_FONTSIZE}
   *
   * @param value Numeric representation of the font size.
   */
  setFontSize(value2) {
    if (this.textEnabled) {
      if (this.compressed) {
        if (this.state.fontSize === value2) {
          return;
        }
        super.setFontSize(value2);
      }
      const elem = this.createElement("fontsize");
      elem.setAttribute("size", String(value2));
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font family.
   * @default {@link mxConstants.DEFAULT_FONTFAMILY}
   *
   * @param value String representation of the font family. This handles the same
   * values as the CSS font-family property.
   */
  setFontFamily(value2) {
    if (this.textEnabled) {
      if (this.compressed) {
        if (this.state.fontFamily === value2) {
          return;
        }
        super.setFontFamily(value2);
      }
      const elem = this.createElement("fontfamily");
      elem.setAttribute("family", value2);
      this.root.appendChild(elem);
    }
  }
  /**
   * Sets the current font style.
   *
   * @param value Numeric representation of the font family. This is the sum of the
   * font styles from {@link mxConstants}.
   */
  setFontStyle(value2 = 0) {
    if (this.textEnabled) {
      if (value2 == null) {
        value2 = 0;
      }
      if (this.compressed) {
        if (this.state.fontStyle === value2) {
          return;
        }
        super.setFontStyle(value2);
      }
      const elem = this.createElement("fontstyle");
      elem.setAttribute("style", String(value2));
      this.root.appendChild(elem);
    }
  }
  /**
   * Enables or disables shadows.
   *
   * @param value Boolean that specifies if shadows should be enabled.
   */
  setShadow(value2) {
    if (this.compressed) {
      if (this.state.shadow === value2) {
        return;
      }
      super.setShadow(value2);
    }
    const elem = this.createElement("shadow");
    elem.setAttribute("enabled", value2 ? "1" : "0");
    this.root.appendChild(elem);
  }
  /**
   * Sets the current shadow color. Default {@link mxConstants.SHADOWCOLOR}
   *
   *
   * @param value Hexadecimal representation of the color or 'none'.
   */
  setShadowColor(value2 = null) {
    if (this.compressed) {
      if (value2 === NONE) {
        value2 = null;
      }
      if (this.state.shadowColor === value2) {
        return;
      }
      super.setShadowColor(value2);
    }
    const elem = this.createElement("shadowcolor");
    elem.setAttribute("color", value2 != null ? value2 : NONE);
    this.root.appendChild(elem);
  }
  /**
   * Sets the current shadows alpha. Default is {@link mxConstants.SHADOW_OPACITY}
   *
   * @param value Number that represents the new alpha. Possible values are between 1 (opaque) and 0 (transparent).
   */
  setShadowAlpha(value2) {
    if (this.compressed) {
      if (this.state.shadowAlpha === value2) {
        return;
      }
      super.setShadowAlpha(value2);
    }
    const elem = this.createElement("shadowalpha");
    elem.setAttribute("alpha", String(value2));
    this.root.appendChild(elem);
  }
  /**
   * Sets the current shadow offset.
   *
   * @param dx Number that represents the horizontal offset of the shadow.
   * @param dy Number that represents the vertical offset of the shadow.
   */
  setShadowOffset(dx, dy) {
    if (this.compressed) {
      if (this.state.shadowDx === dx && this.state.shadowDy === dy) {
        return;
      }
      super.setShadowOffset(dx, dy);
    }
    const elem = this.createElement("shadowoffset");
    elem.setAttribute("dx", String(dx));
    elem.setAttribute("dy", String(dy));
    this.root.appendChild(elem);
  }
  /**
   * Puts a rectangle into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the rectangle.
   * @param y Number that represents the y-coordinate of the rectangle.
   * @param w Number that represents the width of the rectangle.
   * @param h Number that represents the height of the rectangle.
   */
  rect(x, y, w, h) {
    const elem = this.createElement("rect");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    this.root.appendChild(elem);
  }
  /**
   * Puts a rounded rectangle into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the rectangle.
   * @param y Number that represents the y-coordinate of the rectangle.
   * @param w Number that represents the width of the rectangle.
   * @param h Number that represents the height of the rectangle.
   * @param dx Number that represents the horizontal rounding.
   * @param dy Number that represents the vertical rounding.
   */
  roundrect(x, y, w, h, dx, dy) {
    const elem = this.createElement("roundrect");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    elem.setAttribute("dx", String(this.format(dx)));
    elem.setAttribute("dy", String(this.format(dy)));
    this.root.appendChild(elem);
  }
  /**
   * Puts an ellipse into the drawing buffer.
   *
   * @param x Number that represents the x-coordinate of the ellipse.
   * @param y Number that represents the y-coordinate of the ellipse.
   * @param w Number that represents the width of the ellipse.
   * @param h Number that represents the height of the ellipse.
   */
  ellipse(x, y, w, h) {
    const elem = this.createElement("ellipse");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    this.root.appendChild(elem);
  }
  /**
   * Paints an image.
   *
   * @param x Number that represents the x-coordinate of the image.
   * @param y Number that represents the y-coordinate of the image.
   * @param w Number that represents the width of the image.
   * @param h Number that represents the height of the image.
   * @param src String that specifies the URL of the image.
   * @param aspect Boolean indicating if the aspect of the image should be preserved.
   * @param flipH Boolean indicating if the image should be flipped horizontally.
   * @param flipV Boolean indicating if the image should be flipped vertically.
   */
  image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {
    src = this.converter.convert(src);
    const elem = this.createElement("image");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    elem.setAttribute("w", String(this.format(w)));
    elem.setAttribute("h", String(this.format(h)));
    elem.setAttribute("src", src);
    elem.setAttribute("aspect", aspect ? "1" : "0");
    elem.setAttribute("flipH", flipH ? "1" : "0");
    elem.setAttribute("flipV", flipV ? "1" : "0");
    this.root.appendChild(elem);
  }
  updateText() {
    return;
  }
  /**
   * Starts a new path and puts it into the drawing buffer.
   */
  begin() {
    this.root.appendChild(this.createElement("begin"));
    this.lastX = 0;
    this.lastY = 0;
  }
  end() {
    return;
  }
  /**
   * Moves the current path the given point.
   *
   * @param x Number that represents the x-coordinate of the point.
   * @param y Number that represents the y-coordinate of the point.
   */
  moveTo(x, y) {
    const elem = this.createElement("move");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    this.root.appendChild(elem);
    this.lastX = x;
    this.lastY = y;
  }
  /**
   * Draws a line to the given coordinates.
   *
   * @param x Number that represents the x-coordinate of the endpoint.
   * @param y Number that represents the y-coordinate of the endpoint.
   */
  lineTo(x, y) {
    const elem = this.createElement("line");
    elem.setAttribute("x", String(this.format(x)));
    elem.setAttribute("y", String(this.format(y)));
    this.root.appendChild(elem);
    this.lastX = x;
    this.lastY = y;
  }
  /**
   * Adds a quadratic curve to the current path.
   *
   * @param x1 Number that represents the x-coordinate of the control point.
   * @param y1 Number that represents the y-coordinate of the control point.
   * @param x2 Number that represents the x-coordinate of the endpoint.
   * @param y2 Number that represents the y-coordinate of the endpoint.
   */
  quadTo(x1, y1, x2, y2) {
    const elem = this.createElement("quad");
    elem.setAttribute("x1", String(this.format(x1)));
    elem.setAttribute("y1", String(this.format(y1)));
    elem.setAttribute("x2", String(this.format(x2)));
    elem.setAttribute("y2", String(this.format(y2)));
    this.root.appendChild(elem);
    this.lastX = x2;
    this.lastY = y2;
  }
  /**
   * Adds a bezier curve to the current path.
   *
   * @param x1 Number that represents the x-coordinate of the first control point.
   * @param y1 Number that represents the y-coordinate of the first control point.
   * @param x2 Number that represents the x-coordinate of the second control point.
   * @param y2 Number that represents the y-coordinate of the second control point.
   * @param x3 Number that represents the x-coordinate of the endpoint.
   * @param y3 Number that represents the y-coordinate of the endpoint.
   */
  curveTo(x1, y1, x2, y2, x3, y3) {
    const elem = this.createElement("curve");
    elem.setAttribute("x1", String(this.format(x1)));
    elem.setAttribute("y1", String(this.format(y1)));
    elem.setAttribute("x2", String(this.format(x2)));
    elem.setAttribute("y2", String(this.format(y2)));
    elem.setAttribute("x3", String(this.format(x3)));
    elem.setAttribute("y3", String(this.format(y3)));
    this.root.appendChild(elem);
    this.lastX = x3;
    this.lastY = y3;
  }
  /**
   * Closes the current path.
   */
  close() {
    this.root.appendChild(this.createElement("close"));
  }
  /**
   * Paints the given text. Possible values for format are empty string for
   * plain text and html for HTML markup. Background and border color as well
   * as clipping is not available in plain text labels for VML. HTML labels
   * are not available as part of shapes with no foreignObject support in SVG
   * (eg. IE9, IE10).
   *
   * @param x Number that represents the x-coordinate of the text.
   * @param y Number that represents the y-coordinate of the text.
   * @param w Number that represents the available width for the text or 0 for automatic width.
   * @param h Number that represents the available height for the text or 0 for automatic height.
   * @param str String that specifies the text to be painted.
   * @param align String that represents the horizontal alignment.
   * @param valign String that represents the vertical alignment.
   * @param wrap Boolean that specifies if word-wrapping is enabled. Requires w > 0.
   * @param format Empty string for plain text or 'html' for HTML markup.
   * @param overflow Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.
   * @param clip Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.
   * @param rotation Number that specifies the angle of the rotation around the anchor point of the text.
   * @param dir Optional string that specifies the text direction. Possible values are rtl and ltr.
   */
  text(x, y, w, h, str, align = null, valign = null, wrap = null, format = null, overflow = null, clip = null, rotation = null, dir = null) {
    if (this.textEnabled && str != null) {
      if (isNode(str)) {
        str = getOuterHtml(str);
      }
      const elem = this.createElement("text");
      elem.setAttribute("x", String(this.format(x)));
      elem.setAttribute("y", String(this.format(y)));
      elem.setAttribute("w", String(this.format(w)));
      elem.setAttribute("h", String(this.format(h)));
      elem.setAttribute("str", str);
      if (align != null) {
        elem.setAttribute("align", align);
      }
      if (valign != null) {
        elem.setAttribute("valign", valign);
      }
      elem.setAttribute("wrap", wrap ? "1" : "0");
      if (format == null) {
        format = "";
      }
      elem.setAttribute("format", format);
      if (overflow != null) {
        elem.setAttribute("overflow", overflow);
      }
      if (clip != null) {
        elem.setAttribute("clip", clip ? "1" : "0");
      }
      if (rotation != null) {
        elem.setAttribute("rotation", String(rotation));
      }
      if (dir != null) {
        elem.setAttribute("dir", dir);
      }
      this.root.appendChild(elem);
    }
  }
  /**
   * Paints the outline of the current drawing buffer.
   */
  stroke() {
    this.root.appendChild(this.createElement("stroke"));
  }
  /**
   * Fills the current drawing buffer.
   */
  fill() {
    this.root.appendChild(this.createElement("fill"));
  }
  /**
   * Fills the current drawing buffer and its outline.
   */
  fillAndStroke() {
    this.root.appendChild(this.createElement("fillstroke"));
  }
};
var XmlCanvas2D_default = XmlCanvas2D;

// node_modules/@maxgraph/core/lib/util/domHelpers.js
var domHelpers_exports = {};
__export(domHelpers_exports, {
  button: () => button,
  link: () => link,
  linkAction: () => linkAction,
  linkInvoke: () => linkInvoke
});
var linkAction = (parent2, text2, editor2, action2, pad = 0) => {
  return link(parent2, text2, () => {
    editor2.execute(action2);
  }, pad);
};
var linkInvoke = (parent2, text2, editor2, functName, arg, pad = 0) => {
  return link(parent2, text2, () => {
    editor2[functName](arg);
  }, pad);
};
var link = (parent2, text2, funct2, pad = 0) => {
  const a = document.createElement("span");
  a.style.color = "blue";
  a.style.textDecoration = "underline";
  a.style.cursor = "pointer";
  a.style.paddingLeft = `${pad}px`;
  InternalEvent_default.addListener(a, "click", funct2);
  write(a, text2);
  if (parent2 != null) {
    parent2.appendChild(a);
  }
  return a;
};
var button = (label, funct2, doc = null) => {
  doc = doc != null ? doc : document;
  const button2 = doc.createElement("button");
  write(button2, label);
  InternalEvent_default.addListener(button2, "click", (evt2) => {
    funct2(evt2);
  });
  return button2;
};

// node_modules/@maxgraph/core/lib/gui/MaxLogAsLogger.js
var MaxLogAsLogger = class {
  enter(message) {
    return MaxLog_default.enter(message);
  }
  leave(message, baseTimestamp) {
    MaxLog_default.leave(message, baseTimestamp);
  }
  show() {
    MaxLog_default.show();
  }
  info(message) {
    MaxLog_default.writeln(message);
  }
  debug(message) {
    MaxLog_default.debug(message);
  }
  error(message, ...optionalParams) {
    const args = optionalParams == null ? void 0 : optionalParams.map((param) => String(param));
    MaxLog_default.writeln(`[ERROR] ${message}`, ...args);
  }
  trace(message) {
    MaxLog_default.trace(message);
  }
  warn(message) {
    MaxLog_default.warn(message);
  }
};

// node_modules/@maxgraph/core/lib/view/image/ImageBundle.js
var ImageBundle = class {
  constructor(alt = false) {
    this.images = {};
    this.alt = alt;
  }
  /**
   * Adds the specified entry to the map. The entry is an object with a value and
   * fallback property as specified in the arguments.
   */
  putImage(key2, value2, fallback) {
    this.images[key2] = { value: value2, fallback };
  }
  /**
   * Returns the value for the given key. This returns the value
   * or fallback, depending on <alt>. The fallback is returned if
   * <alt> is true, the value is returned otherwise.
   */
  getImage(key2) {
    let result2 = null;
    if (key2) {
      const img = this.images[key2];
      if (img) {
        result2 = this.alt ? img.fallback : img.value;
      }
    }
    return result2;
  }
};
var ImageBundle_default = ImageBundle;

// node_modules/@maxgraph/core/lib/view/image/ImageExport.js
var ImageExport = class {
  constructor() {
    this.includeOverlays = false;
  }
  /**
   * Draws the given state and all its descendants to the given canvas.
   */
  drawState(state2, canvas) {
    if (state2) {
      this.visitStatesRecursive(state2, canvas, this.drawCellState.bind(this));
      if (this.includeOverlays) {
        this.visitStatesRecursive(state2, canvas, this.drawOverlays.bind(this));
      }
    }
  }
  /**
   * Visits the given state and all its descendants to the given canvas recursively.
   */
  visitStatesRecursive(state2, canvas, visitor) {
    if (state2) {
      visitor(state2, canvas);
      const graph = state2.view.graph;
      const childCount2 = state2.cell.getChildCount();
      for (let i2 = 0; i2 < childCount2; i2 += 1) {
        const childState = graph.view.getState(state2.cell.getChildAt(i2));
        if (childState)
          this.visitStatesRecursive(childState, canvas, visitor);
      }
    }
  }
  /**
   * Returns the link for the given cell state and canvas. This returns null.
   */
  getLinkForCellState(_state, _canvas) {
    return null;
  }
  /**
   * Draws the given state to the given canvas.
   */
  drawCellState(state2, canvas) {
    const link2 = this.getLinkForCellState(state2, canvas);
    if (link2) {
      canvas.setLink(link2);
    }
    this.drawShape(state2, canvas);
    this.drawText(state2, canvas);
    if (link2) {
      canvas.setLink(null);
    }
  }
  /**
   * Draws the shape of the given state.
   */
  drawShape(state2, canvas) {
    if (state2.shape instanceof Shape_default && state2.shape.checkBounds()) {
      canvas.save();
      state2.shape.beforePaint(canvas);
      state2.shape.paint(canvas);
      state2.shape.afterPaint(canvas);
      canvas.restore();
    }
  }
  /**
   * Draws the text of the given state.
   */
  drawText(state2, canvas) {
    if (state2.text && state2.text.checkBounds()) {
      canvas.save();
      state2.text.beforePaint(canvas);
      state2.text.paint(canvas);
      state2.text.afterPaint(canvas);
      canvas.restore();
    }
  }
  /**
   * Draws the overlays for the given state. This is called if <includeOverlays>
   * is true.
   */
  drawOverlays(state2, canvas) {
    if (state2.overlays != null) {
      state2.overlays.visit((_id, shape2) => {
        if (shape2 instanceof Shape_default) {
          shape2.paint(canvas);
        }
      });
    }
  }
};
var ImageExport_default = ImageExport;

// node_modules/@maxgraph/core/lib/view/other/AutoSaveManager.js
var AutoSaveManager = class extends EventSource_default {
  constructor(graph) {
    super();
    this.graph = null;
    this.autoSaveDelay = 10;
    this.autoSaveThrottle = 2;
    this.autoSaveThreshold = 5;
    this.ignoredChanges = 0;
    this.lastSnapshot = 0;
    this.enabled = true;
    this.changeHandler = (sender, evt2) => {
      if (this.isEnabled()) {
        this.graphModelChanged(evt2.getProperty("edit").changes);
      }
    };
    this.setGraph(graph);
  }
  /**
   * Returns true if events are handled. This implementation
   * returns <enabled>.
   */
  isEnabled() {
    return this.enabled;
  }
  /**
   * Enables or disables event handling. This implementation
   * updates <enabled>.
   *
   * @param enabled - Boolean that specifies the new enabled state.
   */
  setEnabled(value2) {
    this.enabled = value2;
  }
  /**
   * Sets the graph that the layouts operate on.
   */
  setGraph(graph) {
    if (this.graph != null) {
      this.graph.getDataModel().removeListener(this.changeHandler);
    }
    this.graph = graph;
    if (this.graph != null) {
      this.graph.getDataModel().addListener(InternalEvent_default.CHANGE, this.changeHandler);
    }
  }
  /**
   * Empty hook that is called if the graph should be saved.
   */
  save() {
  }
  /**
   * Invoked when the graph model has changed.
   */
  graphModelChanged(changes) {
    const now = (/* @__PURE__ */ new Date()).getTime();
    const dt = (now - this.lastSnapshot) / 1e3;
    if (dt > this.autoSaveDelay || this.ignoredChanges >= this.autoSaveThreshold && dt > this.autoSaveThrottle) {
      this.save();
      this.reset();
    } else {
      this.ignoredChanges++;
    }
  }
  /**
   * Resets all counters.
   */
  reset() {
    this.lastSnapshot = (/* @__PURE__ */ new Date()).getTime();
    this.ignoredChanges = 0;
  }
  /**
   * Removes all handlers from the <graph> and deletes the reference to it.
   */
  destroy() {
    this.setGraph(null);
  }
};
var AutoSaveManager_default = AutoSaveManager;

// node_modules/@maxgraph/core/lib/view/other/Multiplicity.js
var Multiplicity = class {
  constructor(source2, type, attr, value2, min, max, validNeighbors, countError, typeError, validNeighborsAllowed = true) {
    this.validNeighborsAllowed = true;
    this.source = source2;
    this.type = type;
    this.attr = attr;
    this.value = value2;
    this.min = min ?? 0;
    this.max = max ?? Number.MAX_VALUE;
    this.validNeighbors = validNeighbors;
    this.countError = Translations_default.get(countError) || countError;
    this.typeError = Translations_default.get(typeError) || typeError;
    this.validNeighborsAllowed = validNeighborsAllowed;
  }
  /**
   * Checks the multiplicity for the given arguments and returns the error
   * for the given connection or null if the multiplicity does not apply.
   *
   * @param graph Reference to the enclosing {@link graph} instance.
   * @param edge {@link mxCell} that represents the edge to validate.
   * @param source {@link mxCell} that represents the source terminal.
   * @param target {@link mxCell} that represents the target terminal.
   * @param sourceOut Number of outgoing edges from the source terminal.
   * @param targetIn Number of incoming edges for the target terminal.
   */
  check(graph, edge2, source2, target2, sourceOut, targetIn) {
    let error2 = "";
    if (this.source && this.checkTerminal(graph, source2, edge2) || !this.source && this.checkTerminal(graph, target2, edge2)) {
      if (this.countError != null && (this.source && (this.max === 0 || sourceOut >= this.max) || !this.source && (this.max === 0 || targetIn >= this.max))) {
        error2 += `${this.countError}
`;
      }
      if (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0) {
        const isValid = this.checkNeighbors(graph, edge2, source2, target2);
        if (!isValid) {
          error2 += `${this.typeError}
`;
        }
      }
    }
    return error2.length > 0 ? error2 : null;
  }
  /**
   * Checks if there are any valid neighbours in {@link validNeighbors}. This is only
   * called if {@link validNeighbors} is a non-empty array.
   */
  checkNeighbors(graph, edge2, source2, target2) {
    const sourceValue = source2.getValue();
    const targetValue = target2.getValue();
    let isValid = !this.validNeighborsAllowed;
    const valid = this.validNeighbors;
    for (let j = 0; j < valid.length; j++) {
      if (this.source && this.checkType(graph, targetValue, valid[j])) {
        isValid = this.validNeighborsAllowed;
        break;
      } else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {
        isValid = this.validNeighborsAllowed;
        break;
      }
    }
    return isValid;
  }
  /**
   * Checks the given terminal cell and returns true if this rule applies. The
   * given cell is the source or target of the given edge, depending on
   * {@link source}. This implementation uses {@link checkType} on the terminal's value.
   */
  checkTerminal(graph, edge2, terminal) {
    const value2 = (terminal == null ? void 0 : terminal.getValue()) ?? null;
    return this.checkType(graph, value2, this.type, this.attr, this.value);
  }
  /**
   * Checks the type of the given value.
   */
  checkType(graph, value2, type, attr, attrValue) {
    if (value2 != null) {
      if (typeof value2 !== "string" && "nodeType" in value2 && !Number.isNaN(value2.nodeType)) {
        return isNode(value2, type, attr, attrValue);
      }
      return value2 === type;
    }
    return false;
  }
};
var Multiplicity_default = Multiplicity;
export {
  AbstractCanvas2D_default as AbstractCanvas2D,
  ActorShape_default as ActorShape,
  Animation_default as Animation,
  ArrowConnectorShape_default as ArrowConnectorShape,
  ArrowShape_default as ArrowShape,
  AutoSaveManager_default as AutoSaveManager,
  Cell,
  CellAttributeChange_default as CellAttributeChange,
  CellCodec,
  CellEditorHandler_default as CellEditorHandler,
  CellHighlight_default as CellHighlight,
  CellMarker_default as CellMarker,
  CellOverlay_default as CellOverlay,
  CellPath_default as CellPath,
  CellRenderer_default as CellRenderer,
  CellState_default as CellState,
  CellStatePreview_default as CellStatePreview,
  CellTracker_default as CellTracker,
  ChildChange,
  ChildChangeCodec,
  CircleLayout_default as CircleLayout,
  Client_default as Client,
  Clipboard_default as Clipboard,
  CloudShape_default as CloudShape,
  Codec_default as Codec,
  CodecRegistry_default as CodecRegistry,
  CollapseChange_default as CollapseChange,
  CompactTreeLayout_default as CompactTreeLayout,
  CompositeLayout_default as CompositeLayout,
  ConnectionConstraint_default as ConnectionConstraint,
  ConnectionHandler_default as ConnectionHandler,
  ConnectorShape_default as ConnectorShape,
  ConsoleLogger,
  ConstraintHandler_default as ConstraintHandler,
  CoordinateAssignment_default as CoordinateAssignment,
  CurrentRootChange_default as CurrentRootChange,
  CylinderShape_default as CylinderShape,
  Dictionary_default as Dictionary,
  domHelpers_exports as DomHelpers,
  DoubleEllipseShape_default as DoubleEllipseShape,
  DragSource_default as DragSource,
  EdgeHandler_default as EdgeHandler,
  EdgeLabelLayout_default as EdgeLabelLayout,
  EdgeSegmentHandler_default as EdgeSegmentHandler,
  EdgeStyle_default as EdgeStyle,
  Editor,
  EditorCodec,
  EditorKeyHandler,
  EditorKeyHandlerCodec,
  EditorPopupMenu,
  EditorPopupMenuCodec,
  EditorToolbar,
  EditorToolbarCodec,
  Effects_default as Effects,
  ElbowEdgeHandler_default as ElbowEdgeHandler,
  EllipseShape_default as EllipseShape,
  EventObject_default as EventObject,
  EventSource_default as EventSource,
  FastOrganicLayout_default as FastOrganicLayout,
  GenericChangeCodec,
  Geometry_default as Geometry,
  GeometryChange_default as GeometryChange,
  GlobalConfig,
  Graph,
  GraphAbstractHierarchyCell_default as GraphAbstractHierarchyCell,
  GraphCodec,
  GraphDataModel,
  GraphHierarchyEdge_default as GraphHierarchyEdge,
  GraphHierarchyModel_default as GraphHierarchyModel,
  GraphHierarchyNode_default as GraphHierarchyNode,
  GraphLayout_default as GraphLayout,
  GraphView,
  GraphViewCodec,
  Guide_default as Guide,
  HexagonShape_default as HexagonShape,
  HierarchicalEdgeStyle_default as HierarchicalEdgeStyle,
  HierarchicalLayout_default as HierarchicalLayout,
  HierarchicalLayoutStage_default as HierarchicalLayoutStage,
  ImageBox_default as ImageBox,
  ImageBundle_default as ImageBundle,
  ImageExport_default as ImageExport,
  ImageShape_default as ImageShape,
  InternalEvent_default as InternalEvent,
  InternalMouseEvent_default as InternalMouseEvent,
  KeyHandler_default as KeyHandler,
  LabelShape_default as LabelShape,
  LayoutManager_default as LayoutManager,
  LineShape_default as LineShape,
  MarkerShape_default as MarkerShape,
  MaxForm_default as MaxForm,
  MaxLog_default as MaxLog,
  MaxLogAsLogger,
  MaxPopupMenu_default as MaxPopupMenu,
  MaxToolbar_default as MaxToolbar,
  MaxWindow_default as MaxWindow,
  MaxXmlRequest_default as MaxXmlRequest,
  MedianHybridCrossingReduction_default as MedianHybridCrossingReduction,
  MinimumCycleRemover_default as MinimumCycleRemover,
  ModelCodec,
  ModelXmlSerializer,
  Morphing_default as Morphing,
  Multiplicity_default as Multiplicity,
  NoOpLogger,
  ObjectCodec_default as ObjectCodec,
  ObjectIdentity_default as ObjectIdentity,
  Outline_default as Outline,
  PanningHandler_default as PanningHandler,
  PanningManager_default as PanningManager,
  ParallelEdgeLayout_default as ParallelEdgeLayout,
  PartitionLayout_default as PartitionLayout,
  Perimeter_default as Perimeter,
  Point_default as Point,
  PolylineShape_default as PolylineShape,
  PopupMenuHandler_default as PopupMenuHandler,
  PrintPreview_default as PrintPreview,
  RadialTreeLayout_default as RadialTreeLayout,
  Rectangle_default as Rectangle,
  RectangleShape_default as RectangleShape,
  RhombusShape_default as RhombusShape,
  RootChange,
  RootChangeCodec,
  RubberBandHandler_default as RubberBandHandler,
  SelectionCellsHandler_default as SelectionCellsHandler,
  SelectionChange_default as SelectionChange,
  SelectionHandler_default as SelectionHandler,
  Shape_default as Shape,
  StackLayout_default as StackLayout,
  StencilShape_default as StencilShape,
  StencilShapeConfig,
  StencilShapeRegistry_default as StencilShapeRegistry,
  StyleChange_default as StyleChange,
  StyleRegistry_default as StyleRegistry,
  Stylesheet,
  StylesheetCodec,
  SvgCanvas2D_default as SvgCanvas2D,
  SwimlaneLayout_default as SwimlaneLayout,
  SwimlaneManager_default as SwimlaneManager,
  SwimlaneModel_default as SwimlaneModel,
  SwimlaneOrdering_default as SwimlaneOrdering,
  SwimlaneShape_default as SwimlaneShape,
  TemporaryCellStates_default as TemporaryCellStates,
  TerminalChange,
  TerminalChangeCodec,
  TextShape_default as TextShape,
  TooltipHandler_default as TooltipHandler,
  Translations_default as Translations,
  TriangleShape_default as TriangleShape,
  UndoManager_default as UndoManager,
  UndoableEdit_default as UndoableEdit,
  UrlConverter_default as UrlConverter,
  ValueChange_default as ValueChange,
  VertexHandle_default as VertexHandle,
  VertexHandler_default as VertexHandler,
  VertexHandlerConfig,
  VisibleChange_default as VisibleChange,
  XmlCanvas2D_default as XmlCanvas2D,
  cellArrayUtils_exports as cellArrayUtils,
  cloneUtils_exports as cloneUtils,
  Constants_exports as constants,
  domUtils_exports as domUtils,
  error,
  EventUtils_exports as eventUtils,
  gestureUtils_exports as gestureUtils,
  get,
  getAll,
  getDefaultPlugins,
  load,
  mathUtils_exports as mathUtils,
  mxCellCodec,
  mxGeometryCodec,
  popup,
  post,
  printUtils_exports as printUtils,
  registerAllCodecs,
  registerCoreCodecs,
  registerEditorCodecs,
  registerModelCodecs,
  StringUtils_exports as stringUtils,
  styleUtils_exports as styleUtils,
  submit,
  Utils_exports as utils,
  xmlUtils_exports as xmlUtils
};
//# sourceMappingURL=@maxgraph_core.js.map
