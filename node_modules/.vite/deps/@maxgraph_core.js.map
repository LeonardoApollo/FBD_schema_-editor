{
  "version": 3,
  "sources": ["../../@maxgraph/core/lib/view/image/ImageBox.js", "../../@maxgraph/core/lib/view/event/EventObject.js", "../../@maxgraph/core/lib/view/event/EventSource.js", "../../@maxgraph/core/lib/util/EventUtils.js", "../../@maxgraph/core/lib/Client.js", "../../@maxgraph/core/lib/util/domUtils.js", "../../@maxgraph/core/lib/util/Constants.js", "../../@maxgraph/core/lib/view/event/InternalMouseEvent.js", "../../@maxgraph/core/lib/view/event/InternalEvent.js", "../../@maxgraph/core/lib/view/geometry/Point.js", "../../@maxgraph/core/lib/view/geometry/Rectangle.js", "../../@maxgraph/core/lib/util/StringUtils.js", "../../@maxgraph/core/lib/util/ObjectIdentity.js", "../../@maxgraph/core/lib/util/Dictionary.js", "../../@maxgraph/core/lib/util/Utils.js", "../../@maxgraph/core/lib/util/logger.js", "../../@maxgraph/core/lib/util/config.js", "../../@maxgraph/core/lib/util/mathUtils.js", "../../@maxgraph/core/lib/util/styleUtils.js", "../../@maxgraph/core/lib/view/cell/CellPath.js", "../../@maxgraph/core/lib/util/UrlConverter.js", "../../@maxgraph/core/lib/util/cloneUtils.js", "../../@maxgraph/core/lib/view/canvas/AbstractCanvas2D.js", "../../@maxgraph/core/lib/util/xmlUtils.js", "../../@maxgraph/core/lib/view/cell/TemporaryCellStates.js", "../../@maxgraph/core/lib/util/arrayUtils.js", "../../@maxgraph/core/lib/view/geometry/Geometry.js", "../../@maxgraph/core/lib/util/MaxXmlRequest.js", "../../@maxgraph/core/lib/serialization/ObjectCodec.js", "../../@maxgraph/core/lib/serialization/CodecRegistry.js", "../../@maxgraph/core/lib/view/cell/Cell.js", "../../@maxgraph/core/lib/serialization/Codec.js", "../../@maxgraph/core/lib/view/canvas/SvgCanvas2D.js", "../../@maxgraph/core/lib/view/geometry/Shape.js", "../../@maxgraph/core/lib/view/geometry/node/RectangleShape.js", "../../@maxgraph/core/lib/view/cell/CellState.js", "../../@maxgraph/core/lib/view/undoable_changes/UndoableEdit.js", "../../@maxgraph/core/lib/view/geometry/node/ImageShape.js", "../../@maxgraph/core/lib/view/undoable_changes/CurrentRootChange.js", "../../@maxgraph/core/lib/view/style/StyleRegistry.js", "../../@maxgraph/core/lib/view/GraphView.js", "../../@maxgraph/core/lib/view/geometry/edge/PolylineShape.js", "../../@maxgraph/core/lib/view/geometry/edge/MarkerShape.js", "../../@maxgraph/core/lib/view/geometry/edge/ConnectorShape.js", "../../@maxgraph/core/lib/view/geometry/node/TextShape.js", "../../@maxgraph/core/lib/view/geometry/node/StencilShapeRegistry.js", "../../@maxgraph/core/lib/view/cell/CellRenderer.js", "../../@maxgraph/core/lib/view/undoable_changes/ChildChange.js", "../../@maxgraph/core/lib/view/undoable_changes/CollapseChange.js", "../../@maxgraph/core/lib/view/undoable_changes/GeometryChange.js", "../../@maxgraph/core/lib/view/undoable_changes/RootChange.js", "../../@maxgraph/core/lib/view/undoable_changes/StyleChange.js", "../../@maxgraph/core/lib/view/undoable_changes/TerminalChange.js", "../../@maxgraph/core/lib/view/undoable_changes/ValueChange.js", "../../@maxgraph/core/lib/view/undoable_changes/VisibleChange.js", "../../@maxgraph/core/lib/util/cellArrayUtils.js", "../../@maxgraph/core/lib/view/GraphDataModel.js", "../../@maxgraph/core/lib/view/style/Stylesheet.js", "../../@maxgraph/core/lib/view/style/edge/shared.js", "../../@maxgraph/core/lib/view/style/edge/SideToSide.js", "../../@maxgraph/core/lib/view/style/edge/TopToBottom.js", "../../@maxgraph/core/lib/view/style/edge/Elbow.js", "../../@maxgraph/core/lib/view/style/edge/EntityRelation.js", "../../@maxgraph/core/lib/view/style/edge/Loop.js", "../../@maxgraph/core/lib/view/style/edge/Segment.js", "../../@maxgraph/core/lib/view/style/EdgeStyle.js", "../../@maxgraph/core/lib/view/cell/CellHighlight.js", "../../@maxgraph/core/lib/view/cell/CellMarker.js", "../../@maxgraph/core/lib/view/other/ConnectionConstraint.js", "../../@maxgraph/core/lib/view/handler/ConstraintHandler.js", "../../@maxgraph/core/lib/view/handler/EdgeHandler.js", "../../@maxgraph/core/lib/view/geometry/node/EllipseShape.js", "../../@maxgraph/core/lib/view/handler/config.js", "../../@maxgraph/core/lib/view/handler/VertexHandler.js", "../../@maxgraph/core/lib/util/Translations.js", "../../@maxgraph/core/lib/view/handler/ElbowEdgeHandler.js", "../../@maxgraph/core/lib/view/handler/EdgeSegmentHandler.js", "../../@maxgraph/core/lib/view/undoable_changes/SelectionChange.js", "../../@maxgraph/core/lib/view/GraphSelectionModel.js", "../../@maxgraph/core/lib/view/geometry/node/RhombusShape.js", "../../@maxgraph/core/lib/view/geometry/node/CylinderShape.js", "../../@maxgraph/core/lib/view/geometry/ActorShape.js", "../../@maxgraph/core/lib/view/geometry/node/TriangleShape.js", "../../@maxgraph/core/lib/view/geometry/node/HexagonShape.js", "../../@maxgraph/core/lib/view/geometry/node/CloudShape.js", "../../@maxgraph/core/lib/view/geometry/edge/LineShape.js", "../../@maxgraph/core/lib/view/geometry/edge/ArrowShape.js", "../../@maxgraph/core/lib/view/geometry/edge/ArrowConnectorShape.js", "../../@maxgraph/core/lib/view/geometry/node/DoubleEllipseShape.js", "../../@maxgraph/core/lib/view/geometry/node/SwimlaneShape.js", "../../@maxgraph/core/lib/view/geometry/node/LabelShape.js", "../../@maxgraph/core/lib/view/cell/register-shapes.js", "../../@maxgraph/core/lib/view/style/perimeter/EllipsePerimeter.js", "../../@maxgraph/core/lib/view/style/perimeter/HexagonPerimeter.js", "../../@maxgraph/core/lib/view/style/perimeter/RectanglePerimeter.js", "../../@maxgraph/core/lib/view/style/perimeter/RhombusPerimeter.js", "../../@maxgraph/core/lib/view/style/perimeter/TrianglePerimeter.js", "../../@maxgraph/core/lib/view/style/Perimeter.js", "../../@maxgraph/core/lib/view/style/register.js", "../../@maxgraph/core/lib/view/mixins/CellsMixin.js", "../../@maxgraph/core/lib/view/mixins/ConnectionsMixin.js", "../../@maxgraph/core/lib/view/mixins/DragDropMixin.js", "../../@maxgraph/core/lib/view/mixins/EdgeMixin.js", "../../@maxgraph/core/lib/view/mixins/EditingMixin.js", "../../@maxgraph/core/lib/view/mixins/EventsMixin.js", "../../@maxgraph/core/lib/view/mixins/FoldingMixin.js", "../../@maxgraph/core/lib/view/mixins/GroupingMixin.js", "../../@maxgraph/core/lib/view/mixins/ImageMixin.js", "../../@maxgraph/core/lib/view/mixins/LabelMixin.js", "../../@maxgraph/core/lib/view/mixins/OrderMixin.js", "../../@maxgraph/core/lib/view/cell/CellOverlay.js", "../../@maxgraph/core/lib/view/mixins/OverlaysMixin.js", "../../@maxgraph/core/lib/view/mixins/PageBreaksMixin.js", "../../@maxgraph/core/lib/view/mixins/PanningMixin.js", "../../@maxgraph/core/lib/view/mixins/PortsMixin.js", "../../@maxgraph/core/lib/view/mixins/SelectionMixin.js", "../../@maxgraph/core/lib/view/mixins/SnapMixin.js", "../../@maxgraph/core/lib/view/mixins/SwimlaneMixin.js", "../../@maxgraph/core/lib/view/mixins/TerminalMixin.js", "../../@maxgraph/core/lib/view/mixins/TooltipMixin.js", "../../@maxgraph/core/lib/view/mixins/ValidationMixin.js", "../../@maxgraph/core/lib/view/mixins/VertexMixin.js", "../../@maxgraph/core/lib/view/mixins/ZoomMixin.js", "../../@maxgraph/core/lib/view/mixins/_graph-mixins-apply.js", "../../@maxgraph/core/lib/view/handler/CellEditorHandler.js", "../../@maxgraph/core/lib/view/handler/TooltipHandler.js", "../../@maxgraph/core/lib/view/handler/SelectionCellsHandler.js", "../../@maxgraph/core/lib/gui/MaxPopupMenu.js", "../../@maxgraph/core/lib/view/handler/PopupMenuHandler.js", "../../@maxgraph/core/lib/view/handler/ConnectionHandler.js", "../../@maxgraph/core/lib/view/other/Guide.js", "../../@maxgraph/core/lib/view/handler/SelectionHandler.js", "../../@maxgraph/core/lib/view/other/PanningManager.js", "../../@maxgraph/core/lib/view/handler/PanningHandler.js", "../../@maxgraph/core/lib/view/plugins/index.js", "../../@maxgraph/core/lib/view/Graph.js", "../../@maxgraph/core/lib/view/layout/LayoutManager.js", "../../@maxgraph/core/lib/view/other/Outline.js", "../../@maxgraph/core/lib/view/other/PrintPreview.js", "../../@maxgraph/core/lib/view/layout/SwimlaneManager.js", "../../@maxgraph/core/lib/view/undoable_changes/CellAttributeChange.js", "../../@maxgraph/core/lib/view/handler/KeyHandler.js", "../../@maxgraph/core/lib/editor/EditorKeyHandler.js", "../../@maxgraph/core/lib/editor/EditorPopupMenu.js", "../../@maxgraph/core/lib/gui/MaxToolbar.js", "../../@maxgraph/core/lib/util/gestureUtils.js", "../../@maxgraph/core/lib/view/other/DragSource.js", "../../@maxgraph/core/lib/editor/EditorToolbar.js", "../../@maxgraph/core/lib/view/undoable_changes/UndoManager.js", "../../@maxgraph/core/lib/view/layout/GraphLayout.js", "../../@maxgraph/core/lib/view/layout/util/WeightedCellSorter.js", "../../@maxgraph/core/lib/util/treeTraversal.js", "../../@maxgraph/core/lib/view/layout/CompactTreeLayout.js", "../../@maxgraph/core/lib/view/layout/StackLayout.js", "../../@maxgraph/core/lib/gui/MaxWindow.js", "../../@maxgraph/core/lib/serialization/codecs/editor/EditorCodec.js", "../../@maxgraph/core/lib/serialization/codecs/editor/EditorKeyHandlerCodec.js", "../../@maxgraph/core/lib/serialization/codecs/editor/EditorPopupMenuCodec.js", "../../@maxgraph/core/lib/serialization/codecs/editor/EditorToolbarCodec.js", "../../@maxgraph/core/lib/serialization/codecs/CellCodec.js", "../../@maxgraph/core/lib/serialization/codecs/ChildChangeCodec.js", "../../@maxgraph/core/lib/serialization/codecs/GenericChangeCodec.js", "../../@maxgraph/core/lib/serialization/codecs/GraphCodec.js", "../../@maxgraph/core/lib/serialization/codecs/GraphViewCodec.js", "../../@maxgraph/core/lib/serialization/codecs/ModelCodec.js", "../../@maxgraph/core/lib/serialization/codecs/RootChangeCodec.js", "../../@maxgraph/core/lib/serialization/codecs/StylesheetCodec.js", "../../@maxgraph/core/lib/serialization/codecs/TerminalChangeCodec.js", "../../@maxgraph/core/lib/serialization/codecs/mxGraph/utils.js", "../../@maxgraph/core/lib/serialization/codecs/mxGraph/mxCellCodec.js", "../../@maxgraph/core/lib/serialization/codecs/mxGraph/mxGeometryCodec.js", "../../@maxgraph/core/lib/serialization/register.js", "../../@maxgraph/core/lib/serialization/ModelXmlSerializer.js", "../../@maxgraph/core/lib/gui/MaxForm.js", "../../@maxgraph/core/lib/util/Clipboard.js", "../../@maxgraph/core/lib/gui/MaxLog.js", "../../@maxgraph/core/lib/view/handler/RubberBandHandler.js", "../../@maxgraph/core/lib/util/printUtils.js", "../../@maxgraph/core/lib/editor/Editor.js", "../../@maxgraph/core/lib/view/cell/CellTracker.js", "../../@maxgraph/core/lib/view/cell/VertexHandle.js", "../../@maxgraph/core/lib/view/layout/CircleLayout.js", "../../@maxgraph/core/lib/view/layout/CompositeLayout.js", "../../@maxgraph/core/lib/view/layout/EdgeLabelLayout.js", "../../@maxgraph/core/lib/view/layout/FastOrganicLayout.js", "../../@maxgraph/core/lib/view/layout/ParallelEdgeLayout.js", "../../@maxgraph/core/lib/view/layout/PartitionLayout.js", "../../@maxgraph/core/lib/view/layout/RadialTreeLayout.js", "../../@maxgraph/core/lib/view/layout/datatypes/HierarchicalEdgeStyle.js", "../../@maxgraph/core/lib/view/layout/datatypes/GraphAbstractHierarchyCell.js", "../../@maxgraph/core/lib/view/layout/datatypes/GraphHierarchyNode.js", "../../@maxgraph/core/lib/view/layout/datatypes/GraphHierarchyEdge.js", "../../@maxgraph/core/lib/view/layout/hierarchical/GraphHierarchyModel.js", "../../@maxgraph/core/lib/view/layout/hierarchical/HierarchicalLayoutStage.js", "../../@maxgraph/core/lib/view/layout/hierarchical/MinimumCycleRemover.js", "../../@maxgraph/core/lib/view/layout/util/MedianCellSorter.js", "../../@maxgraph/core/lib/view/layout/hierarchical/MedianHybridCrossingReduction.js", "../../@maxgraph/core/lib/view/layout/hierarchical/CoordinateAssignment.js", "../../@maxgraph/core/lib/view/layout/HierarchicalLayout.js", "../../@maxgraph/core/lib/view/layout/hierarchical/SwimlaneModel.js", "../../@maxgraph/core/lib/view/layout/hierarchical/SwimlaneOrdering.js", "../../@maxgraph/core/lib/view/layout/SwimlaneLayout.js", "../../@maxgraph/core/lib/view/geometry/node/StencilShape.js", "../../@maxgraph/core/lib/view/animate/Animation.js", "../../@maxgraph/core/lib/view/animate/Effects.js", "../../@maxgraph/core/lib/view/cell/CellStatePreview.js", "../../@maxgraph/core/lib/view/animate/Morphing.js", "../../@maxgraph/core/lib/view/canvas/XmlCanvas2D.js", "../../@maxgraph/core/lib/util/domHelpers.js", "../../@maxgraph/core/lib/gui/MaxLogAsLogger.js", "../../@maxgraph/core/lib/view/image/ImageBundle.js", "../../@maxgraph/core/lib/view/image/ImageExport.js", "../../@maxgraph/core/lib/view/other/AutoSaveManager.js", "../../@maxgraph/core/lib/view/other/Multiplicity.js"],
  "sourcesContent": ["/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Encapsulates the URL, width and height of an image.\n *\n * Constructor: mxImage\n *\n * Constructs a new image.\n */\nclass ImageBox {\n    constructor(src, width, height) {\n        this.src = src;\n        this.width = width;\n        this.height = height;\n    }\n}\nexport default ImageBox;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * The mxEventObject is a wrapper for all properties of a single event.\n * Additionally, it also offers functions to consume the event and check if it\n * was consumed as follows:\n *\n * ```javascript\n * evt.consume();\n * INV: evt.isConsumed() == true\n * ```\n *\n * Constructor: mxEventObject\n *\n * Constructs a new event object with the specified name. An optional\n * sequence of key, value pairs can be appended to define properties.\n *\n * Example:\n *\n * ```javascript\n * new mxEventObject(\"eventName\", key1, val1, .., keyN, valN)\n * ```\n */\nclass EventObject {\n    constructor(name = '', ...args) {\n        /**\n         * Holds the consumed state. Default is false.\n         */\n        this.consumed = false;\n        this.name = name;\n        this.properties = {};\n        if (!!args[0] && args[0].constructor === Object) {\n            // A literal object ({})\n            for (const [key, value] of Object.entries(args[0])) {\n                this.properties[key] = value;\n            }\n        }\n        else {\n            // two-values [key, value, key, value, ...]\n            for (let i = 0; i < args.length; i += 2) {\n                if (args[i + 1] !== null) {\n                    this.properties[args[i]] = args[i + 1];\n                }\n            }\n        }\n    }\n    /**\n     * Returns <name>.\n     */\n    getName() {\n        return this.name;\n    }\n    /**\n     * Returns <properties>.\n     */\n    getProperties() {\n        return this.properties;\n    }\n    /**\n     * Returns the property for the given key.\n     */\n    getProperty(key) {\n        return this.properties[key];\n    }\n    /**\n     * Returns true if the event has been consumed.\n     */\n    isConsumed() {\n        return this.consumed;\n    }\n    /**\n     * Consumes the event.\n     */\n    consume() {\n        this.consumed = true;\n    }\n}\nexport default EventObject;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventObject from './EventObject';\n/**\n * Base class for objects that dispatch named events. To create a subclass that\n * inherits from mxEventSource, the following code is used.\n *\n * ```javascript\n * function MyClass() { };\n *\n * MyClass.prototype = new mxEventSource();\n * constructor = MyClass;\n * ```\n *\n * Known Subclasses:\n *\n * <Transactions>, {@link Graph}, {@link GraphView}, <Editor>, <CellOverlay>,\n * <MaxToolbar>, <MaxWindow>\n *\n * Constructor: mxEventSource\n *\n * Constructs a new event source.\n */\nclass EventSource {\n    constructor(eventSource = null) {\n        /**\n         * Holds the event names and associated listeners in an array. The array\n         * contains the event name followed by the respective listener for each\n         * registered listener.\n         */\n        this.eventListeners = [];\n        /**\n         * Specifies if events can be fired. Default is true.\n         */\n        this.eventsEnabled = true;\n        /**\n         * Optional source for events. Default is null.\n         */\n        this.eventSource = null;\n        this.eventSource = eventSource;\n    }\n    /**\n     * Returns <eventsEnabled>.\n     */\n    isEventsEnabled() {\n        return this.eventsEnabled;\n    }\n    /**\n     * Sets <eventsEnabled>.\n     */\n    setEventsEnabled(value) {\n        this.eventsEnabled = value;\n    }\n    /**\n     * Returns <eventSource>.\n     */\n    getEventSource() {\n        return this.eventSource;\n    }\n    /**\n     * Sets <eventSource>.\n     */\n    setEventSource(value) {\n        this.eventSource = value;\n    }\n    /**\n     * Binds the specified function to the given event name. If no event name\n     * is given, then the listener is registered for all events.\n     *\n     * The parameters of the listener are the sender and an {@link EventObject}.\n     */\n    addListener(name, funct) {\n        this.eventListeners.push({ name, funct });\n    }\n    /**\n     * Removes all occurrences of the given listener from <eventListeners>.\n     */\n    removeListener(funct) {\n        let i = 0;\n        while (i < this.eventListeners.length) {\n            if (this.eventListeners[i].funct === funct) {\n                this.eventListeners.splice(i, 1);\n            }\n            else {\n                i += 1;\n            }\n        }\n    }\n    /**\n     * Dispatches the given event to the listeners which are registered for\n     * the event. The sender argument is optional. The current execution scope\n     * (\"this\") is used for the listener invocation (see {@link Utils#bind}).\n     *\n     * Example:\n     *\n     * ```javascript\n     * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))\n     * ```\n     *\n     * @param evt {@link EventObject} that represents the event.\n     * @param sender Optional sender to be passed to the listener. Default value is\n     * the return value of <getEventSource>.\n     */\n    fireEvent(evt, sender = null) {\n        if (this.isEventsEnabled()) {\n            if (!evt) {\n                evt = new EventObject('');\n            }\n            if (!sender) {\n                sender = this.getEventSource();\n            }\n            if (!sender) {\n                sender = this;\n            }\n            for (const eventListener of this.eventListeners) {\n                if (eventListener.name === null || eventListener.name === evt.getName()) {\n                    eventListener.funct.apply(this, [sender, evt]);\n                }\n            }\n        }\n    }\n}\nexport default EventSource;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\n/**\n * Returns the touch or mouse event that contains the mouse coordinates.\n */\nexport const getMainEvent = (evt) => {\n    let t = evt;\n    if ((t.type === 'touchstart' || t.type === 'touchmove') && t.touches && t.touches[0]) {\n        t = t.touches[0];\n    }\n    else if (t.type === 'touchend' && t.changedTouches && t.changedTouches[0]) {\n        t = t.changedTouches[0];\n    }\n    return t;\n};\n/**\n * Returns true if the meta key is pressed for the given event.\n */\nexport const getClientX = (evt) => {\n    return getMainEvent(evt).clientX;\n};\n/**\n * Returns true if the meta key is pressed for the given event.\n */\n// static getClientY(e: TouchEvent | MouseEvent): number;\nexport const getClientY = (evt) => {\n    return getMainEvent(evt).clientY;\n};\n/**\n * Returns the event's target or srcElement depending on the browser.\n */\nexport const getSource = (evt) => {\n    return evt.target;\n};\n/**\n * Returns true if the event has been consumed using {@link consume}.\n */\nexport const isConsumed = (evt) => {\n    const t = evt;\n    return t.isConsumed !== undefined && t.isConsumed;\n};\n/**\n * Returns true if the event was generated using a touch device (not a pen or mouse).\n */\nexport const isTouchEvent = (evt) => {\n    const t = evt;\n    return t.pointerType\n        ? t.pointerType === 'touch' || t.pointerType === t.MSPOINTER_TYPE_TOUCH\n        : t.mozInputSource !== undefined\n            ? t.mozInputSource === 5\n            : t.type.indexOf('touch') === 0;\n};\n/**\n * Returns true if the event was generated using a pen (not a touch device or mouse).\n */\nexport const isPenEvent = (evt) => {\n    const t = evt;\n    return t.pointerType\n        ? t.pointerType == 'pen' || t.pointerType === t.MSPOINTER_TYPE_PEN\n        : t.mozInputSource !== undefined\n            ? t.mozInputSource === 2\n            : t.type.indexOf('pen') === 0;\n};\n/**\n * Returns true if the event was generated using a touch device (not a pen or mouse).\n */\nexport const isMultiTouchEvent = (evt) => {\n    const t = evt;\n    return (t.type &&\n        t.type.indexOf('touch') == 0 &&\n        t.touches !== undefined &&\n        t.touches.length > 1);\n};\n/**\n * Returns true if the event was generated using a mouse (not a pen or touch device).\n */\nexport const isMouseEvent = (evt) => {\n    const t = evt;\n    return t.pointerType\n        ? t.pointerType == 'mouse' || t.pointerType === t.MSPOINTER_TYPE_MOUSE\n        : t.mozInputSource !== undefined\n            ? t.mozInputSource === 1\n            : t.type.indexOf('mouse') === 0;\n};\n/**\n * Returns true if the left mouse button is pressed for the given event.\n * To check if a button is pressed during a mouseMove you should use the\n * {@link mxGraph.isMouseDown} property. Note that this returns true in Firefox\n * for control+left-click on the Mac.\n */\n// static isLeftMouseButton(evt: MouseEvent): boolean;\nexport const isLeftMouseButton = (evt) => {\n    // Special case for mousemove and mousedown we check the buttons\n    // if it exists because which is 0 even if no button is pressed\n    if ('buttons' in evt && (evt.type === 'mousedown' || evt.type === 'mousemove')) {\n        return evt.buttons === 1;\n    }\n    if (evt.which !== undefined) {\n        return evt.which === 1;\n    }\n    return evt.button === 1;\n};\n/**\n * Returns true if the middle mouse button is pressed for the given event.\n * To check if a button is pressed during a mouseMove you should use the\n * {@link mxGraph.isMouseDown} property.\n */\nexport const isMiddleMouseButton = (evt) => {\n    return evt.button === 4;\n};\n/**\n * Returns true if the right mouse button was pressed. Note that this\n * button might not be available on some systems. For handling a popup\n * trigger {@link isPopupTrigger} should be used.\n */\nexport const isRightMouseButton = (evt) => {\n    return evt.button === 2;\n};\n/**\n * Returns true if the event is a popup trigger. This implementation\n * returns true if the right button or the left button and control was\n * pressed on a Mac.\n */\nexport const isPopupTrigger = (evt) => {\n    return (isRightMouseButton(evt) ||\n        (Client.IS_MAC &&\n            isControlDown(evt) &&\n            !isShiftDown(evt) &&\n            !isMetaDown(evt) &&\n            !isAltDown(evt)));\n};\n/**\n * Returns true if the shift key is pressed for the given event.\n */\nexport const isShiftDown = (evt) => {\n    return evt.shiftKey;\n};\n/**\n * Returns true if the alt key is pressed for the given event.\n */\nexport const isAltDown = (evt) => {\n    return evt.altKey;\n};\n/**\n * Returns true if the control key is pressed for the given event.\n */\nexport const isControlDown = (evt) => {\n    return evt.ctrlKey;\n};\n/**\n * Returns true if the meta key is pressed for the given event.\n */\nexport const isMetaDown = (evt) => {\n    return evt.metaKey;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nclass Client {\n}\n/**\n * The version of the `maxGraph` library.\n */\nClient.VERSION = '0.13.1';\n/**\n * Base path for all URLs in the core without trailing slash.\n *\n * When using a relative path, the path is relative to the URL of the page that contains the assignment. Trailing slashes are automatically removed.\n * @default '.'\n */\nClient.basePath = '.';\nClient.setBasePath = (value) => {\n    if (typeof value !== 'undefined' && value.length > 0) {\n        // Adds a trailing slash if required\n        if (value.substring(value.length - 1) === '/') {\n            value = value.substring(0, value.length - 1);\n        }\n        Client.basePath = value;\n    }\n    else {\n        Client.basePath = '.';\n    }\n};\n/**\n * Base path for all images URLs in the core without trailing slash.\n *\n * When using a relative path, the path is relative to the URL of the page that\n * contains the assignment. Trailing slashes are automatically removed.\n * @default '.'\n */\nClient.imageBasePath = '.';\nClient.setImageBasePath = (value) => {\n    if (typeof value !== 'undefined' && value.length > 0) {\n        // Adds a trailing slash if required\n        if (value.substring(value.length - 1) === '/') {\n            value = value.substring(0, value.length - 1);\n        }\n        Client.imageBasePath = value;\n    }\n    else {\n        Client.imageBasePath = `${Client.basePath}/images`;\n    }\n};\n/**\n * Defines the language of the client, eg. `en` for english, `de` for german etc.\n * The special value `none` will disable all built-in internationalization and\n * resource loading. See {@link Resources#getSpecialBundle} for handling identifiers\n * with and without a dash.\n *\n * If internationalization is disabled, then the following variables should be\n * overridden to reflect the current language of the system. These variables are\n * cleared when i18n is disabled.\n * {@link Editor.askZoomResource}, {@link Editor.lastSavedResource},\n * {@link Editor.currentFileResource}, {@link Editor.propertiesResource},\n * {@link Editor.tasksResource}, {@link Editor.helpResource}, {@link Editor.outlineResource},\n * {@link ElbowEdgeHandler#doubleClickOrientationResource}, {@link Utils#errorResource},\n * {@link Utils#closeResource}, {@link GraphSelectionModel#doneResource},\n * {@link GraphSelectionModel#updatingSelectionResource}, {@link GraphView#doneResource},\n * {@link GraphView#updatingDocumentResource}, {@link CellRenderer#collapseExpandResource},\n * {@link Graph#containsValidationErrorsResource} and\n * {@link Graph#alreadyConnectedResource}.\n */\nClient.language = typeof window !== 'undefined' ? navigator.language : 'en';\nClient.setLanguage = (value) => {\n    if (typeof value !== 'undefined' && value != null) {\n        Client.language = value;\n    }\n    else {\n        Client.language = navigator.language;\n    }\n};\n/**\n * Defines the default language which is used in the common resource files. Any\n * resources for this language will only load the common resource file, but not\n * the language-specific resource file.\n * @default 'en'\n */\nClient.defaultLanguage = 'en';\nClient.setDefaultLanguage = (value) => {\n    if (typeof value !== 'undefined' && value != null) {\n        Client.defaultLanguage = value;\n    }\n    else {\n        Client.defaultLanguage = 'en';\n    }\n};\n/**\n * Defines the optional array of all supported language extensions. The default\n * language does not have to be part of this list. See\n * {@link Translations#isLanguageSupported}.\n *\n * This is used to avoid unnecessary requests to language files, ie. if a 404\n * will be returned.\n * @default null\n */\nClient.languages = null;\nClient.setLanguages = (value) => {\n    if (typeof value !== 'undefined' && value != null) {\n        Client.languages = value;\n    }\n};\n/**\n * True if the current browser is Microsoft Edge.\n */\nClient.IS_EDGE = typeof window !== 'undefined' &&\n    navigator.userAgent != null &&\n    !!navigator.userAgent.match(/Edge\\//);\n/**\n * True if the current browser is Netscape (including Firefox).\n */\nClient.IS_NS = typeof window !== 'undefined' &&\n    navigator.userAgent != null &&\n    navigator.userAgent.indexOf('Mozilla/') >= 0 &&\n    navigator.userAgent.indexOf('MSIE') < 0 &&\n    navigator.userAgent.indexOf('Edge/') < 0;\n/**\n * True if the current browser is Safari.\n */\nClient.IS_SF = typeof window !== 'undefined' && /Apple Computer, Inc/.test(navigator.vendor);\n/**\n * Returns true if the user agent contains Android.\n */\nClient.IS_ANDROID = typeof window !== 'undefined' && navigator.appVersion.indexOf('Android') >= 0;\n/**\n * Returns true if the user agent is an iPad, iPhone or iPod.\n */\nClient.IS_IOS = typeof window !== 'undefined' && /iP(hone|od|ad)/.test(navigator.platform);\n/**\n * True if the current browser is Google Chrome.\n */\nClient.IS_GC = typeof window !== 'undefined' && /Google Inc/.test(navigator.vendor);\n/**\n * True if the this is running inside a Chrome App.\n */\nClient.IS_CHROMEAPP = typeof window !== 'undefined' &&\n    // @ts-ignore\n    window.chrome != null &&\n    // @ts-ignore\n    chrome.app != null &&\n    // @ts-ignore\n    chrome.app.runtime != null;\n/**\n * True if the current browser is Firefox.\n */\nClient.IS_FF = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n/**\n * True if -moz-transform is available as a CSS style. This is the case\n * for all Firefox-based browsers newer than or equal 3, such as Camino,\n * Iceweasel, Seamonkey and Iceape.\n */\nClient.IS_MT = typeof window !== 'undefined' &&\n    ((navigator.userAgent.indexOf('Firefox/') >= 0 &&\n        navigator.userAgent.indexOf('Firefox/1.') < 0 &&\n        navigator.userAgent.indexOf('Firefox/2.') < 0) ||\n        (navigator.userAgent.indexOf('Iceweasel/') >= 0 &&\n            navigator.userAgent.indexOf('Iceweasel/1.') < 0 &&\n            navigator.userAgent.indexOf('Iceweasel/2.') < 0) ||\n        (navigator.userAgent.indexOf('SeaMonkey/') >= 0 &&\n            navigator.userAgent.indexOf('SeaMonkey/1.') < 0) ||\n        (navigator.userAgent.indexOf('Iceape/') >= 0 &&\n            navigator.userAgent.indexOf('Iceape/1.') < 0));\n/**\n * True if the browser supports SVG.\n */\nClient.IS_SVG = typeof window !== 'undefined' &&\n    navigator.appName.toUpperCase() !== 'MICROSOFT INTERNET EXPLORER';\n/**\n * True if foreignObject support is not available. This is the case for\n * Opera, older SVG-based browsers and all versions of IE.\n */\nClient.NO_FO = typeof window !== 'undefined' &&\n    (!document.createElementNS ||\n        document\n            .createElementNS('http://www.w3.org/2000/svg', 'foreignObject')\n            .toString() !== '[object SVGForeignObjectElement]' ||\n        navigator.userAgent.indexOf('Opera/') >= 0);\n/**\n * True if the client is a Windows.\n */\nClient.IS_WIN = typeof window !== 'undefined' && navigator.appVersion.indexOf('Win') > 0;\n/**\n * True if the client is a Mac.\n */\nClient.IS_MAC = typeof window !== 'undefined' && navigator.appVersion.indexOf('Mac') > 0;\n/**\n * True if the client is a Chrome OS.\n */\nClient.IS_CHROMEOS = typeof window !== 'undefined' && /\\bCrOS\\b/.test(navigator.appVersion);\n/**\n * True if this device supports touchstart/-move/-end events (Apple iOS,\n * Android, Chromebook and Chrome Browser on touch-enabled devices).\n */\nClient.IS_TOUCH = typeof window !== 'undefined' && 'ontouchstart' in document.documentElement;\n/**\n * True if this device supports Microsoft pointer events (always false on Macs).\n */\nClient.IS_POINTER = typeof window !== 'undefined' &&\n    window.PointerEvent != null &&\n    !(navigator.appVersion.indexOf('Mac') > 0);\n/**\n * True if the documents location does not start with http:// or https://.\n */\nClient.IS_LOCAL = typeof window !== 'undefined' &&\n    document.location.href.indexOf('http://') < 0 &&\n    document.location.href.indexOf('https://') < 0;\n/**\n * Returns true if the current browser is supported, that is, if\n * <Client.IS_SVG> is true.\n *\n * Example:\n *\n * ```javascript\n * if (!Client.isBrowserSupported())\n * {\n *   mxUtils.error('Browser is not supported!', 200, false);\n * }\n * ```\n */\nClient.isBrowserSupported = () => {\n    return Client.IS_SVG;\n};\nexport default Client;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NODETYPE } from './Constants';\n/**\n * Returns the text content of the specified node.\n *\n * @param elems DOM nodes to return the text for.\n */\nexport const extractTextWithWhitespace = (elems) => {\n    // Known block elements for handling linefeeds (list is not complete)\n    const blocks = [\n        'BLOCKQUOTE',\n        'DIV',\n        'H1',\n        'H2',\n        'H3',\n        'H4',\n        'H5',\n        'H6',\n        'OL',\n        'P',\n        'PRE',\n        'TABLE',\n        'UL',\n    ];\n    const ret = [];\n    function doExtract(elts) {\n        // Single break should be ignored\n        if (elts.length == 1 && (elts[0].nodeName == 'BR' || elts[0].innerHTML == '\\n')) {\n            return;\n        }\n        for (let i = 0; i < elts.length; i += 1) {\n            const elem = elts[i];\n            // DIV with a br or linefeed forces a linefeed\n            if (elem.nodeName == 'BR' ||\n                elem.innerHTML == '\\n' ||\n                ((elts.length == 1 || i == 0) &&\n                    elem.nodeName == 'DIV' &&\n                    elem.innerHTML.toLowerCase() == '<br>')) {\n                ret.push('\\n');\n            }\n            else {\n                if (elem.nodeType === 3 || elem.nodeType === 4) {\n                    if (elem.nodeValue && elem.nodeValue.length > 0) {\n                        ret.push(elem.nodeValue);\n                    }\n                }\n                else if (elem.nodeType !== 8 && elem.childNodes.length > 0) {\n                    doExtract(Array.from(elem.childNodes));\n                }\n                if (i < elts.length - 1 && blocks.indexOf(elts[i + 1].nodeName) >= 0) {\n                    ret.push('\\n');\n                }\n            }\n        }\n    }\n    doExtract(elems);\n    return ret.join('');\n};\n/**\n * Returns the text content of the specified node.\n *\n * @param node DOM node to return the text content for.\n */\nexport const getTextContent = (node) => {\n    return node != null && node.textContent ? node.textContent : '';\n};\n/**\n * Sets the text content of the specified node.\n *\n * @param node DOM node to set the text content for.\n * @param text String that represents the text content.\n */\nexport const setTextContent = (node, text) => {\n    if ('innerText' in node) {\n        node.innerText = text;\n    }\n    else {\n        node.textContent = text;\n    }\n};\n/**\n * Returns the inner HTML for the given node as a string or an empty string\n * if no node was specified. The inner HTML is the text representing all\n * children of the node, but not the node itself.\n *\n * @param node DOM node to return the inner HTML for.\n */\nexport const getInnerHtml = (node) => {\n    if (node != null) {\n        const serializer = new XMLSerializer();\n        return serializer.serializeToString(node);\n    }\n    return '';\n};\n/**\n * Returns the outer HTML for the given node as a string or an empty\n * string if no node was specified. The outer HTML is the text representing\n * all children of the node including the node itself.\n *\n * @param node DOM node to return the outer HTML for.\n */\nexport const getOuterHtml = (node) => {\n    if (node != null) {\n        const serializer = new XMLSerializer();\n        return serializer.serializeToString(node);\n    }\n    return '';\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const write = (parent, text) => {\n    const doc = parent.ownerDocument;\n    const node = doc.createTextNode(text);\n    if (parent != null) {\n        parent.appendChild(node);\n    }\n    return node;\n};\n/**\n * Creates a text node for the given string and appends it to the given\n * parent with an additional linefeed. Returns the text node.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text to be added.\n */\nexport const writeln = (parent, text) => {\n    const doc = parent.ownerDocument;\n    const node = doc.createTextNode(text);\n    if (parent != null) {\n        parent.appendChild(node);\n        parent.appendChild(document.createElement('br'));\n    }\n    return node;\n};\n/**\n * Appends a linebreak to the given parent and returns the linebreak.\n *\n * @param parent DOM node to append the linebreak to.\n */\nexport const br = (parent, count = 1) => {\n    let br = null;\n    for (let i = 0; i < count; i += 1) {\n        if (parent != null) {\n            br = parent.ownerDocument.createElement('br');\n            parent.appendChild(br);\n        }\n    }\n    return br;\n};\n/**\n * Appends a new paragraph with the given text to the specified parent and\n * returns the paragraph.\n *\n * @param parent DOM node to append the text node to.\n * @param text String representing the text for the new paragraph.\n */\nexport const para = (parent, text) => {\n    const p = document.createElement('p');\n    write(p, text);\n    if (parent != null) {\n        parent.appendChild(p);\n    }\n    return p;\n};\n/**\n * Returns true if the given value is an XML node with the node name\n * and if the optional attribute has the specified value.\n *\n * This implementation assumes that the given value is a DOM node if the\n * nodeType property is numeric, that is, if isNaN returns false for\n * value.nodeType.\n *\n * @param value Object that should be examined as a node.\n * @param nodeName String that specifies the node name.\n * @param attributeName Optional attribute name to check.\n * @param attributeValue Optional attribute value to check.\n */\nexport const isNode = (value, nodeName = null, attributeName, attributeValue) => {\n    if (value != null &&\n        !isNaN(value.nodeType) &&\n        (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {\n        return attributeName == null || value.getAttribute(attributeName) == attributeValue;\n    }\n    return false;\n};\n/**\n * Returns true if the given ancestor is an ancestor of the\n * given DOM node in the DOM. This also returns true if the\n * child is the ancestor.\n *\n * @param ancestor DOM node that represents the ancestor.\n * @param child DOM node that represents the child.\n */\nexport const isAncestorNode = (ancestor, child) => {\n    let parent = child;\n    while (parent != null) {\n        if (parent === ancestor) {\n            return true;\n        }\n        parent = parent.parentNode;\n    }\n    return false;\n};\n/**\n * Returns an array of child nodes that are of the given node type.\n *\n * @param node Parent DOM node to return the children from.\n * @param nodeType Optional node type to return. Default is\n * {@link Constants#NODETYPE_ELEMENT}.\n */\nexport const getChildNodes = (node, nodeType = NODETYPE.ELEMENT) => {\n    nodeType = nodeType || NODETYPE.ELEMENT;\n    const children = [];\n    let tmp = node.firstChild;\n    while (tmp != null) {\n        if (tmp.nodeType === nodeType) {\n            children.push(tmp);\n        }\n        tmp = tmp.nextSibling;\n    }\n    return children;\n};\n/**\n * Cross browser implementation for document.importNode. Uses document.importNode\n * in all browsers but IE, where the node is cloned by creating a new node and\n * copying all attributes and children into it using importNode, recursively.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNode = (doc, node, allChildren) => {\n    return doc.importNode(node, allChildren);\n};\n/**\n * Full DOM API implementation for importNode without using importNode API call.\n *\n * @param doc Document to import the node into.\n * @param node Node to be imported.\n * @param allChildren If all children should be imported.\n */\nexport const importNodeImplementation = (doc, node, allChildren) => {\n    switch (node.nodeType) {\n        case 1 /* element */: {\n            const newNode = doc.createElement(node.nodeName);\n            if (node.attributes && node.attributes.length > 0) {\n                for (let i = 0; i < node.attributes.length; i += 1) {\n                    newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));\n                }\n            }\n            if (allChildren && node.childNodes && node.childNodes.length > 0) {\n                for (let i = 0; i < node.childNodes.length; i += 1) {\n                    newNode.appendChild(importNodeImplementation(doc, node.childNodes[i], allChildren));\n                }\n            }\n            return newNode;\n            break;\n        }\n        case 3: /* text */\n        case 4: /* cdata-section */\n        case 8 /* comment */: {\n            return doc.createTextNode(node.nodeValue || '');\n            break;\n        }\n    }\n};\n/**\n * Clears the current selection in the page.\n */\nexport const clearSelection = () => {\n    // @ts-ignore\n    const sel = window.getSelection ? window.getSelection() : document.selection;\n    if (sel) {\n        if (sel.removeAllRanges) {\n            sel.removeAllRanges();\n        }\n        else if (sel.empty) {\n            sel.empty();\n        }\n    }\n};\n/**\n * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\n * quirks mode.\n *\n * @param src URL that points to the image to be displayed.\n */\nexport const createImage = (src) => {\n    let imageNode = null;\n    imageNode = document.createElement('img');\n    imageNode.setAttribute('src', src);\n    imageNode.setAttribute('border', '0');\n    return imageNode;\n};\n/**\n * Adds a link node to the head of the document.\n *\n * The charset is hardcoded to `UTF-8` and the type is `text/css`.\n *\n * @param rel String that represents the rel attribute of the link node.\n * @param href String that represents the href attribute of the link node.\n * @param doc Optional parent document of the link node.\n * @param id unique id for the link element to check if it already exists\n */\nexport const addLinkToHead = (rel, href, doc = null, id = null) => {\n    doc = doc || document;\n    // Workaround for Operation Aborted in IE6 if base tag is used in head\n    const link = doc.createElement('link');\n    link.setAttribute('rel', rel);\n    link.setAttribute('href', href);\n    link.setAttribute('charset', 'UTF-8');\n    link.setAttribute('type', 'text/css');\n    if (id) {\n        link.setAttribute('id', id);\n    }\n    const head = doc.getElementsByTagName('head')[0];\n    head.appendChild(link);\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Defines the portion of the cell which is to be used as a connectable\n * region. Default is 0.3. Possible values are 0 < x <= 1.\n */\nexport const DEFAULT_HOTSPOT = 0.3;\n/**\n * Defines the minimum size in pixels of the portion of the cell which is\n * to be used as a connectable region. Default is 8.\n */\nexport const MIN_HOTSPOT_SIZE = 8;\n/**\n * Defines the maximum size in pixels of the portion of the cell which is\n * to be used as a connectable region. Use 0 for no maximum. Default is 0.\n */\nexport const MAX_HOTSPOT_SIZE = 0;\nexport var RENDERING_HINT;\n(function (RENDERING_HINT) {\n    RENDERING_HINT[\"EXACT\"] = \"exact\";\n    RENDERING_HINT[\"FASTER\"] = \"faster\";\n    RENDERING_HINT[\"FASTEST\"] = \"fastest\";\n})(RENDERING_HINT || (RENDERING_HINT = {}));\nexport var DIALECT;\n(function (DIALECT) {\n    /** the SVG display dialect name. */\n    DIALECT[\"SVG\"] = \"svg\";\n    /** the mixed HTML display dialect name. */\n    DIALECT[\"MIXEDHTML\"] = \"mixedHtml\";\n    /** the preferred HTML display dialect name. */\n    DIALECT[\"PREFERHTML\"] = \"preferHtml\";\n    /** the strict HTML display dialect name. */\n    DIALECT[\"STRICTHTML\"] = \"strictHtml\";\n})(DIALECT || (DIALECT = {}));\n/**\n * Name of the field to be used to store the object ID. Default is\n * <code>mxObjectId</code>.\n */\nexport const IDENTITY_FIELD_NAME = 'mxObjectId';\n/**\n * Defines the SVG namespace.\n */\nexport const NS_SVG = 'http://www.w3.org/2000/svg';\n/**\n * Defines the XLink namespace.\n */\nexport const NS_XLINK = 'http://www.w3.org/1999/xlink';\n/**\n * Defines the color to be used to draw shadows in shapes and windows.\n * Default is gray.\n */\nexport const SHADOWCOLOR = 'gray';\n/**\n * Specifies the x-offset of the shadow. Default is 2.\n */\nexport const SHADOW_OFFSET_X = 2;\n/**\n * Specifies the y-offset of the shadow. Default is 3.\n */\nexport const SHADOW_OFFSET_Y = 3;\n/**\n * Defines the opacity for shadows. Default is 1.\n */\nexport const SHADOW_OPACITY = 1;\nexport var NODETYPE;\n(function (NODETYPE) {\n    NODETYPE[NODETYPE[\"ELEMENT\"] = 1] = \"ELEMENT\";\n    NODETYPE[NODETYPE[\"ATTRIBUTE\"] = 2] = \"ATTRIBUTE\";\n    NODETYPE[NODETYPE[\"TEXT\"] = 3] = \"TEXT\";\n    NODETYPE[NODETYPE[\"CDATA\"] = 4] = \"CDATA\";\n    NODETYPE[NODETYPE[\"ENTITY_REFERENCE\"] = 5] = \"ENTITY_REFERENCE\";\n    NODETYPE[NODETYPE[\"ENTITY\"] = 6] = \"ENTITY\";\n    NODETYPE[NODETYPE[\"PROCESSING_INSTRUCTION\"] = 7] = \"PROCESSING_INSTRUCTION\";\n    NODETYPE[NODETYPE[\"COMMENT\"] = 8] = \"COMMENT\";\n    NODETYPE[NODETYPE[\"DOCUMENT\"] = 9] = \"DOCUMENT\";\n    NODETYPE[NODETYPE[\"DOCUMENTTYPE\"] = 10] = \"DOCUMENTTYPE\";\n    NODETYPE[NODETYPE[\"DOCUMENT_FRAGMENT\"] = 11] = \"DOCUMENT_FRAGMENT\";\n    NODETYPE[NODETYPE[\"NOTATION\"] = 12] = \"NOTATION\";\n})(NODETYPE || (NODETYPE = {}));\n/**\n * Defines the vertical offset for the tooltip.\n * Default is 16.\n */\nexport const TOOLTIP_VERTICAL_OFFSET = 16;\n/**\n * Specifies the default valid color. Default is #0000FF.\n */\nexport const DEFAULT_VALID_COLOR = '#00FF00';\n/**\n * Specifies the default invalid color. Default is #FF0000.\n */\nexport const DEFAULT_INVALID_COLOR = '#FF0000';\n/**\n * Specifies the default highlight color for shape outlines.\n * Default is #0000FF. This is used in {@link EdgeHandler}.\n */\nexport const OUTLINE_HIGHLIGHT_COLOR = '#00FF00';\n/**\n * Defines the strokewidth to be used for shape outlines.\n * Default is 5. This is used in {@link EdgeHandler}.\n */\nexport const OUTLINE_HIGHLIGHT_STROKEWIDTH = 5;\n/**\n * Defines the strokewidth to be used for the highlights.\n * Default is 3.\n */\nexport const HIGHLIGHT_STROKEWIDTH = 3;\n/**\n * Size of the constraint highlight (in px). Default is 2.\n */\nexport const HIGHLIGHT_SIZE = 2;\n/**\n * Opacity (in %) used for the highlights (including outline).\n * Default is 100.\n */\nexport const HIGHLIGHT_OPACITY = 100;\nexport var CURSOR;\n(function (CURSOR) {\n    /** Defines the cursor for a movable vertex. */\n    CURSOR[\"MOVABLE_VERTEX\"] = \"move\";\n    /** Defines the cursor for a movable edge. */\n    CURSOR[\"MOVABLE_EDGE\"] = \"move\";\n    /** Defines the cursor for a movable label. */\n    CURSOR[\"LABEL_HANDLE\"] = \"default\";\n    /** Defines the cursor for a terminal handle. */\n    CURSOR[\"TERMINAL_HANDLE\"] = \"pointer\";\n    /** Defines the cursor for a movable bend. */\n    CURSOR[\"BEND_HANDLE\"] = \"crosshair\";\n    /** Defines the cursor for a movable bend. */\n    CURSOR[\"VIRTUAL_BEND_HANDLE\"] = \"crosshair\";\n    /** Defines the cursor for a connectable state. */\n    CURSOR[\"CONNECT\"] = \"pointer\";\n})(CURSOR || (CURSOR = {}));\n/**\n * Defines the color to be used for the cell highlighting.\n * Use 'none' for no color. Default is #00FF00.\n */\nexport const HIGHLIGHT_COLOR = '#00FF00';\n/**\n * Defines the color to be used for highlighting a target cell for a new\n * or changed connection. Note that this may be either a source or\n * target terminal in the graph. Use 'none' for no color.\n * Default is #0000FF.\n */\nexport const CONNECT_TARGET_COLOR = '#0000FF';\n/**\n * Defines the color to be used for highlighting a invalid target cells\n * for a new or changed connections. Note that this may be either a source\n * or target terminal in the graph. Use 'none' for no color. Default is\n * #FF0000.\n */\nexport const INVALID_CONNECT_TARGET_COLOR = '#FF0000';\n/**\n * Defines the color to be used for the highlighting target parent cells\n * (for drag and drop). Use 'none' for no color. Default is #0000FF.\n */\nexport const DROP_TARGET_COLOR = '#0000FF';\n/**\n * Defines the color to be used for the coloring valid connection\n * previews. Use 'none' for no color. Default is #FF0000.\n */\nexport const VALID_COLOR = '#00FF00';\n/**\n * Defines the color to be used for the coloring invalid connection\n * previews. Use 'none' for no color. Default is #FF0000.\n */\nexport const INVALID_COLOR = '#FF0000';\n/**\n * Defines the color to be used for the selection border of edges. Use\n * 'none' for no color. Default is #00FF00.\n */\nexport const EDGE_SELECTION_COLOR = '#00FF00';\n/**\n * Defines the color to be used for the selection border of vertices. Use\n * 'none' for no color. Default is #00FF00.\n */\nexport const VERTEX_SELECTION_COLOR = '#00FF00';\n/**\n * Defines the strokewidth to be used for vertex selections.\n * Default is 1.\n */\nexport const VERTEX_SELECTION_STROKEWIDTH = 1;\n/**\n * Defines the strokewidth to be used for edge selections.\n * Default is 1.\n */\nexport const EDGE_SELECTION_STROKEWIDTH = 1;\n/**\n * Defines the dashed state to be used for the vertex selection\n * border. Default is true.\n */\nexport const VERTEX_SELECTION_DASHED = true;\n/**\n * Defines the dashed state to be used for the edge selection\n * border. Default is true.\n */\nexport const EDGE_SELECTION_DASHED = true;\n/**\n * Defines the color to be used for the guidelines in `Guide`.\n * @default #FF0000.\n */\nexport const GUIDE_COLOR = '#FF0000';\n/**\n * Defines the strokewidth to be used for the guidelines in `Guide`.\n * @default 1.\n */\nexport const GUIDE_STROKEWIDTH = 1;\n/**\n * Defines the color to be used for the outline rectangle\n * border.  Use 'none' for no color. Default is #0099FF.\n */\nexport const OUTLINE_COLOR = '#0099FF';\n/**\n * Defines the strokewidth to be used for the outline rectangle\n * stroke width. Default is 3.\n */\nexport const OUTLINE_STROKEWIDTH = 3;\n/**\n * Defines the default size for handles. Default is 6.\n */\nexport const HANDLE_SIZE = 6;\n/**\n * Defines the default size for label handles. Default is 4.\n */\nexport const LABEL_HANDLE_SIZE = 4;\n/**\n * Defines the color to be used for the handle fill color. Use 'none' for\n * no color. Default is #00FF00 (green).\n */\nexport const HANDLE_FILLCOLOR = '#00FF00';\n/**\n * Defines the color to be used for the handle stroke color. Use 'none' for\n * no color. Default is black.\n */\nexport const HANDLE_STROKECOLOR = 'black';\n/**\n * Defines the color to be used for the label handle fill color. Use 'none'\n * for no color. Default is yellow.\n */\nexport const LABEL_HANDLE_FILLCOLOR = 'yellow';\n/**\n * Defines the color to be used for the connect handle fill color. Use\n * 'none' for no color. Default is #0000FF (blue).\n */\nexport const CONNECT_HANDLE_FILLCOLOR = '#0000FF';\n/**\n * Defines the color to be used for the locked handle fill color. Use\n * 'none' for no color. Default is #FF0000 (red).\n */\nexport const LOCKED_HANDLE_FILLCOLOR = '#FF0000';\n/**\n * Defines the color to be used for the outline sizer fill color. Use\n * 'none' for no color. Default is #00FFFF.\n */\nexport const OUTLINE_HANDLE_FILLCOLOR = '#00FFFF';\n/**\n * Defines the color to be used for the outline sizer stroke color. Use\n * 'none' for no color. Default is #0033FF.\n */\nexport const OUTLINE_HANDLE_STROKECOLOR = '#0033FF';\n/**\n * Defines the default family for all fonts. Default is Arial,Helvetica.\n */\nexport const DEFAULT_FONTFAMILY = 'Arial,Helvetica';\n/**\n * Defines the default size (in px). Default is 11.\n */\nexport const DEFAULT_FONTSIZE = 11;\n/**\n * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is\n * defined for it in the style. Default value is an empty string which means\n * the default system setting is used and no direction is set.\n */\nexport const DEFAULT_TEXT_DIRECTION = '';\n/**\n * Defines the default line height for text labels. Default is 1.2.\n */\nexport const LINE_HEIGHT = 1.2;\n/**\n * Defines the CSS value for the word-wrap property. Default is \"normal\".\n * Change this to \"break-word\" to allow long words to be able to be broken\n * and wrap onto the next line.\n */\nexport const WORD_WRAP = 'normal';\n/**\n * Specifies if absolute line heights should be used (px) in CSS. Default\n * is false. Set this to true for backwards compatibility.\n */\nexport const ABSOLUTE_LINE_HEIGHT = false;\n/**\n * Defines the default style for all fonts. Default is 0. This can be set\n * to any combination of font styles as follows.\n *\n * ```javascript\n * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;\n * ```\n */\nexport const DEFAULT_FONTSTYLE = 0;\n/**\n * Defines the default start size for swimlanes. Default is 40.\n */\nexport const DEFAULT_STARTSIZE = 40;\n/**\n * Defines the default size for all markers. Default is 6.\n */\nexport const DEFAULT_MARKERSIZE = 6;\n/**\n * Defines the default width and height for images used in the\n * label shape. Default is 24.\n */\nexport const DEFAULT_IMAGESIZE = 24;\n/**\n * Defines the length of the horizontal segment of an `Entity Relation`.\n * This can be overridden using {@link CellStateStyle.segment} style.\n */\nexport const ENTITY_SEGMENT = 30;\n/**\n * Defines the default rounding factor for the rounded vertices in percent between\n * `0` and `1`. Values should be smaller than `0.5`.\n * See {@link CellStateStyle.arcSize}.\n */\nexport const RECTANGLE_ROUNDING_FACTOR = 0.15;\n/**\n * Defines the default size in pixels of the arcs for the rounded edges.\n * See {@link CellStateStyle.arcSize}.\n */\nexport const LINE_ARCSIZE = 20;\n/**\n * Defines the spacing between the arrow shape and its terminals. Default is 0.\n */\nexport const ARROW_SPACING = 0;\n/**\n * Defines the width of the arrow shape. Default is 30.\n */\nexport const ARROW_WIDTH = 30;\n/**\n * Defines the size of the arrowhead in the arrow shape. Default is 30.\n */\nexport const ARROW_SIZE = 30;\n/**\n * Defines the rectangle for the A4 portrait page format. The dimensions\n * of this page format are 826x1169 pixels.\n */\nexport const PAGE_FORMAT_A4_PORTRAIT = [0, 0, 827, 1169];\n/**\n * Defines the rectangle for the A4 portrait page format. The dimensions\n * of this page format are 826x1169 pixels.\n */\nexport const PAGE_FORMAT_A4_LANDSCAPE = [0, 0, 1169, 827];\n/**\n * Defines the rectangle for the Letter portrait page format. The\n * dimensions of this page format are 850x1100 pixels.\n */\nexport const PAGE_FORMAT_LETTER_PORTRAIT = [0, 0, 850, 1100];\n/**\n * Defines the rectangle for the Letter portrait page format. The dimensions\n * of this page format are 850x1100 pixels.\n */\nexport const PAGE_FORMAT_LETTER_LANDSCAPE = [0, 0, 1100, 850];\n/**\n * Defines the value for none. Default is \"none\".\n */\nexport const NONE = 'none';\nexport var FONT;\n(function (FONT) {\n    /** for bold fonts. */\n    FONT[FONT[\"BOLD\"] = 1] = \"BOLD\";\n    /** for italic fonts. */\n    FONT[FONT[\"ITALIC\"] = 2] = \"ITALIC\";\n    /** for underlined fonts. */\n    FONT[FONT[\"UNDERLINE\"] = 4] = \"UNDERLINE\";\n    /** for strikethrough fonts. */\n    FONT[FONT[\"STRIKETHROUGH\"] = 8] = \"STRIKETHROUGH\";\n})(FONT || (FONT = {}));\nexport var ARROW;\n(function (ARROW) {\n    /** for classic arrow markers. */\n    ARROW[\"CLASSIC\"] = \"classic\";\n    /** for thin classic arrow markers. */\n    ARROW[\"CLASSIC_THIN\"] = \"classicThin\";\n    /** for block arrow markers. */\n    ARROW[\"BLOCK\"] = \"block\";\n    /** for thin block arrow markers. */\n    ARROW[\"BLOCK_THIN\"] = \"blockThin\";\n    /** for open arrow markers. */\n    ARROW[\"OPEN\"] = \"open\";\n    /** for thin open arrow markers. */\n    ARROW[\"OPEN_THIN\"] = \"openThin\";\n    /** for oval arrow markers. */\n    ARROW[\"OVAL\"] = \"oval\";\n    /** for diamond arrow markers. */\n    ARROW[\"DIAMOND\"] = \"diamond\";\n    /** for thin diamond arrow markers. */\n    ARROW[\"DIAMOND_THIN\"] = \"diamondThin\";\n})(ARROW || (ARROW = {}));\nexport var ALIGN;\n(function (ALIGN) {\n    /** left horizontal alignment. */\n    ALIGN[\"LEFT\"] = \"left\";\n    /** center horizontal alignment. */\n    ALIGN[\"CENTER\"] = \"center\";\n    /** right horizontal alignment. */\n    ALIGN[\"RIGHT\"] = \"right\";\n    /** top vertical alignment. */\n    ALIGN[\"TOP\"] = \"top\";\n    /** middle vertical alignment. */\n    ALIGN[\"MIDDLE\"] = \"middle\";\n    /** bottom vertical alignment. */\n    ALIGN[\"BOTTOM\"] = \"bottom\";\n})(ALIGN || (ALIGN = {}));\nexport var DIRECTION;\n(function (DIRECTION) {\n    DIRECTION[\"NORTH\"] = \"north\";\n    DIRECTION[\"SOUTH\"] = \"south\";\n    DIRECTION[\"EAST\"] = \"east\";\n    DIRECTION[\"WEST\"] = \"west\";\n})(DIRECTION || (DIRECTION = {}));\nexport var TEXT_DIRECTION;\n(function (TEXT_DIRECTION) {\n    /**\n     * Use this value to use the default text direction of the operating system. */\n    TEXT_DIRECTION[\"DEFAULT\"] = \"\";\n    /** Use this value to find the direction for a given text with {@link Text#getAutoDirection}. */\n    TEXT_DIRECTION[\"AUTO\"] = \"auto\";\n    /** Use this value for left to right text direction. */\n    TEXT_DIRECTION[\"LTR\"] = \"ltr\";\n    /** Use this value for right to left text direction. */\n    TEXT_DIRECTION[\"RTL\"] = \"rtl\";\n})(TEXT_DIRECTION || (TEXT_DIRECTION = {}));\n/**\n * - DIRECTION_MASK_NONE: Constant for no direction.\n *\n * - DIRECTION_MASK_WEST: Bitwise mask for west direction.\n *\n * - DIRECTION_MASK_NORTH: Bitwise mask for north direction.\n *\n * - DIRECTION_MASK_SOUTH: Bitwise mask for south direction.\n *\n * - DIRECTION_MASK_EAST: Bitwise mask for east direction.\n *\n * - DIRECTION_MASK_ALL: Bitwise mask for all directions.\n */\nexport const DIRECTION_MASK = {\n    NONE: 0,\n    WEST: 1,\n    NORTH: 2,\n    SOUTH: 4,\n    EAST: 8,\n    ALL: 15,\n};\n/**\n * Default is horizontal.\n */\nexport var ELBOW;\n(function (ELBOW) {\n    ELBOW[\"VERTICAL\"] = \"vertical\";\n    ELBOW[\"HORIZONTAL\"] = \"horizontal\";\n})(ELBOW || (ELBOW = {}));\n/**\n * Can be used as a string value for the STYLE_EDGE style.\n */\nexport var EDGESTYLE;\n(function (EDGESTYLE) {\n    EDGESTYLE[\"ELBOW\"] = \"elbowEdgeStyle\";\n    EDGESTYLE[\"ENTITY_RELATION\"] = \"entityRelationEdgeStyle\";\n    EDGESTYLE[\"LOOP\"] = \"loopEdgeStyle\";\n    EDGESTYLE[\"SIDETOSIDE\"] = \"sideToSideEdgeStyle\";\n    EDGESTYLE[\"TOPTOBOTTOM\"] = \"topToBottomEdgeStyle\";\n    EDGESTYLE[\"ORTHOGONAL\"] = \"orthogonalEdgeStyle\";\n    EDGESTYLE[\"SEGMENT\"] = \"segmentEdgeStyle\";\n    EDGESTYLE[\"MANHATTAN\"] = \"manhattanEdgeStyle\";\n})(EDGESTYLE || (EDGESTYLE = {}));\n/**\n * Can be used as a string value for the STYLE_PERIMETER style.\n */\nexport var PERIMETER;\n(function (PERIMETER) {\n    PERIMETER[\"ELLIPSE\"] = \"ellipsePerimeter\";\n    PERIMETER[\"RECTANGLE\"] = \"rectanglePerimeter\";\n    PERIMETER[\"RHOMBUS\"] = \"rhombusPerimeter\";\n    PERIMETER[\"HEXAGON\"] = \"hexagonPerimeter\";\n    PERIMETER[\"TRIANGLE\"] = \"trianglePerimeter\";\n})(PERIMETER || (PERIMETER = {}));\nexport var SHAPE;\n(function (SHAPE) {\n    /**\n     * Name under which {@link RectangleShape} is registered in {@link CellRenderer}.\n     * Default is rectangle.\n     */\n    SHAPE[\"RECTANGLE\"] = \"rectangle\";\n    /**\n     * Name under which {@link Ellipse} is registered in {@link CellRenderer}.\n     * Default is ellipse.\n     */\n    SHAPE[\"ELLIPSE\"] = \"ellipse\";\n    /**\n     * Name under which {@link DoubleEllipse} is registered in {@link CellRenderer}.\n     * Default is doubleEllipse.\n     */\n    SHAPE[\"DOUBLE_ELLIPSE\"] = \"doubleEllipse\";\n    /**\n     * Name under which {@link Rhombus} is registered in {@link CellRenderer}.\n     * Default is rhombus.\n     */\n    SHAPE[\"RHOMBUS\"] = \"rhombus\";\n    /**\n     * Name under which {@link LineShape} is registered in {@link CellRenderer} by default.\n     */\n    SHAPE[\"LINE\"] = \"line\";\n    /**\n     * Name under which {@link ImageShape} is registered in {@link CellRenderer}.\n     * Default is image.\n     */\n    SHAPE[\"IMAGE\"] = \"image\";\n    /**\n     * Name under which {@link ArrowShape} is registered in {@link CellRenderer} by default.\n     */\n    SHAPE[\"ARROW\"] = \"arrow\";\n    /**\n     * Name under which {@link ArrowConnectorShape} is registered in {@link CellRenderer} by default.\n     */\n    SHAPE[\"ARROW_CONNECTOR\"] = \"arrowConnector\";\n    /**\n     * Name under which {@link Label} is registered in {@link CellRenderer}.\n     * Default is label.\n     */\n    SHAPE[\"LABEL\"] = \"label\";\n    /**\n     * Name under which {@link Cylinder} is registered in {@link CellRenderer}.\n     * Default is cylinder.\n     */\n    SHAPE[\"CYLINDER\"] = \"cylinder\";\n    /**\n     * Name under which {@link Swimlane} is registered in {@link CellRenderer}.\n     * Default is swimlane.\n     */\n    SHAPE[\"SWIMLANE\"] = \"swimlane\";\n    /**\n     * Name under which {@link ConnectorShape} is registered in {@link CellRenderer} by default.\n     */\n    SHAPE[\"CONNECTOR\"] = \"connector\";\n    /**\n     * Name under which {@link Actor} is registered in {@link CellRenderer}.\n     * Default is actor.\n     */\n    SHAPE[\"ACTOR\"] = \"actor\";\n    /**\n     * Name under which {@link Cloud} is registered in {@link CellRenderer}.\n     * Default is cloud.\n     */\n    SHAPE[\"CLOUD\"] = \"cloud\";\n    /**\n     * Name under which {@link Triangle} is registered in {@link CellRenderer}.\n     * Default is triangle.\n     */\n    SHAPE[\"TRIANGLE\"] = \"triangle\";\n    /**\n     * Name under which {@link Hexagon} is registered in {@link CellRenderer}.\n     * Default is hexagon.\n     */\n    SHAPE[\"HEXAGON\"] = \"hexagon\";\n})(SHAPE || (SHAPE = {}));\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getClientX, getClientY, getSource, isMouseEvent, isPopupTrigger, } from '../../util/EventUtils';\nimport { isAncestorNode } from '../../util/domUtils';\n/**\n * Base class for all mouse events in mxGraph. A listener for this event should\n * implement the following methods:\n *\n * ```javascript\n * graph.addMouseListener(\n * {\n *   mouseDown: (sender, evt)=>\n *   {\n *     GlobalConfig.logger.debug('mouseDown');\n *   },\n *   mouseMove: (sender, evt)=>\n *   {\n *     GlobalConfig.logger.debug('mouseMove');\n *   },\n *   mouseUp: (sender, evt)=>\n *   {\n *     GlobalConfig.logger.debug('mouseUp');\n *   }\n * });\n * ```\n *\n * Constructor: mxMouseEvent\n *\n * Constructs a new event object for the given arguments.\n *\n * @param evt Native mouse event.\n * @param state Optional <CellState> under the mouse.\n */\nclass InternalMouseEvent {\n    constructor(evt, state = null) {\n        /**\n         * Holds the consumed state of this event.\n         */\n        this.consumed = false;\n        this.evt = evt;\n        this.state = state;\n        this.sourceState = state;\n        // graphX and graphY are updated right after this constructor is executed,\n        // so let them default to 0 and make them not nullable.\n        this.graphX = 0;\n        this.graphY = 0;\n    }\n    /**\n     * Returns <evt>.\n     */\n    getEvent() {\n        return this.evt;\n    }\n    /**\n     * Returns the target DOM element using {@link Event#getSource} for <evt>.\n     */\n    getSource() {\n        return getSource(this.evt);\n    }\n    /**\n     * Returns true if the given {@link Shape} is the source of <evt>.\n     */\n    isSource(shape) {\n        return shape ? isAncestorNode(shape.node, this.getSource()) : false;\n    }\n    /**\n     * Returns <evt.clientX>.\n     */\n    getX() {\n        return getClientX(this.getEvent());\n    }\n    /**\n     * Returns <evt.clientY>.\n     */\n    getY() {\n        return getClientY(this.getEvent());\n    }\n    /**\n     * Returns <graphX>.\n     */\n    getGraphX() {\n        return this.graphX;\n    }\n    /**\n     * Returns <graphY>.\n     */\n    getGraphY() {\n        return this.graphY;\n    }\n    /**\n     * Returns <state>.\n     */\n    getState() {\n        return this.state;\n    }\n    /**\n     * Returns the <Cell> in <state> is not null.\n     */\n    getCell() {\n        const state = this.getState();\n        return state ? state.cell : null;\n    }\n    /**\n     * Returns true if the event is a popup trigger.\n     */\n    isPopupTrigger() {\n        return isPopupTrigger(this.getEvent());\n    }\n    /**\n     * Returns <consumed>.\n     */\n    isConsumed() {\n        return this.consumed;\n    }\n    /**\n     * Sets <consumed> to true and invokes preventDefault on the native event\n     * if such a method is defined. This is used mainly to avoid the cursor from\n     * being changed to a text cursor in Webkit. You can use the preventDefault\n     * flag to disable this functionality.\n     *\n     * @param preventDefault Specifies if the native event should be canceled. Default\n     * is true.\n     */\n    consume(preventDefault) {\n        preventDefault = preventDefault\n            ? preventDefault\n            : (window.TouchEvent && this.evt instanceof TouchEvent) || isMouseEvent(this.evt);\n        if (preventDefault && this.evt.preventDefault) {\n            this.evt.preventDefault();\n        }\n        // Sets local consumed state\n        this.consumed = true;\n    }\n}\nexport default InternalMouseEvent;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from './InternalMouseEvent';\nimport Client from '../../Client';\nimport { isConsumed, isMouseEvent } from '../../util/EventUtils';\n// Checks if passive event listeners are supported\n// see https://github.com/Modernizr/Modernizr/issues/1894\nlet supportsPassive = false;\ntry {\n    document.addEventListener('test', () => {\n        return;\n    }, Object.defineProperty &&\n        Object.defineProperty({}, 'passive', {\n            get: () => {\n                supportsPassive = true;\n            },\n        }));\n}\ncatch (e) {\n    // ignore\n}\n/**\n * @class InternalEvent\n *\n * Cross-browser DOM event support. For internal event handling,\n * {@link mxEventSource} and the graph event dispatch loop in {@link graph} are used.\n *\n * ### Memory Leaks:\n *\n * Use this class for adding and removing listeners to/from DOM nodes. The\n * {@link removeAllListeners} function is provided to remove all listeners that\n * have been added using {@link addListener}. The function should be invoked when\n * the last reference is removed in the JavaScript code, typically when the\n * referenced DOM node is removed from the DOM.\n */\nclass InternalEvent {\n    /**\n     * Binds the function to the specified event on the given element. Use\n     * {@link mxUtils.bind} in order to bind the \"this\" keyword inside the function\n     * to a given execution scope.\n     */\n    static addListener(element, eventName, funct) {\n        element.addEventListener(eventName, funct, supportsPassive ? { passive: false } : false);\n        if (!element.mxListenerList) {\n            element.mxListenerList = [];\n        }\n        const entry = { name: eventName, f: funct };\n        element.mxListenerList.push(entry);\n    }\n    /**\n     * Removes the specified listener from the given element.\n     */\n    static removeListener(element, eventName, funct) {\n        element.removeEventListener(eventName, funct, false);\n        if (element.mxListenerList) {\n            const listenerCount = element.mxListenerList.length;\n            for (let i = 0; i < listenerCount; i += 1) {\n                const entry = element.mxListenerList[i];\n                if (entry.f === funct) {\n                    element.mxListenerList.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Removes all listeners from the given element.\n     */\n    static removeAllListeners(element) {\n        const list = element.mxListenerList;\n        if (list) {\n            while (list.length > 0) {\n                const entry = list[0];\n                InternalEvent.removeListener(element, entry.name, entry.f);\n            }\n        }\n    }\n    /**\n     * Adds the given listeners for touch, mouse and/or pointer events. If\n     * <Client.IS_POINTER> is true then pointer events will be registered,\n     * else the respective mouse events will be registered. If <Client.IS_POINTER>\n     * is false and <Client.IS_TOUCH> is true then the respective touch events\n     * will be registered as well as the mouse events.\n     */\n    static addGestureListeners(node, startListener = null, moveListener = null, endListener = null) {\n        if (startListener) {\n            InternalEvent.addListener(node, Client.IS_POINTER ? 'pointerdown' : 'mousedown', startListener);\n        }\n        if (moveListener) {\n            InternalEvent.addListener(node, Client.IS_POINTER ? 'pointermove' : 'mousemove', moveListener);\n        }\n        if (endListener) {\n            InternalEvent.addListener(node, Client.IS_POINTER ? 'pointerup' : 'mouseup', endListener);\n        }\n        if (!Client.IS_POINTER && Client.IS_TOUCH) {\n            if (startListener) {\n                InternalEvent.addListener(node, 'touchstart', startListener);\n            }\n            if (moveListener) {\n                InternalEvent.addListener(node, 'touchmove', moveListener);\n            }\n            if (endListener) {\n                InternalEvent.addListener(node, 'touchend', endListener);\n            }\n        }\n    }\n    /**\n     * Removes the given listeners from mousedown, mousemove, mouseup and the\n     * respective touch events if <Client.IS_TOUCH> is true.\n     */\n    static removeGestureListeners(node, startListener, moveListener, endListener) {\n        if (startListener) {\n            InternalEvent.removeListener(node, Client.IS_POINTER ? 'pointerdown' : 'mousedown', startListener);\n        }\n        if (moveListener) {\n            InternalEvent.removeListener(node, Client.IS_POINTER ? 'pointermove' : 'mousemove', moveListener);\n        }\n        if (endListener) {\n            InternalEvent.removeListener(node, Client.IS_POINTER ? 'pointerup' : 'mouseup', endListener);\n        }\n        if (!Client.IS_POINTER && Client.IS_TOUCH) {\n            if (startListener) {\n                InternalEvent.removeListener(node, 'touchstart', startListener);\n            }\n            if (moveListener) {\n                InternalEvent.removeListener(node, 'touchmove', moveListener);\n            }\n            if (endListener) {\n                InternalEvent.removeListener(node, 'touchend', endListener);\n            }\n        }\n    }\n    /**\n     * Redirects the mouse events from the given DOM node to the graph dispatch\n     * loop using the event and given state as event arguments. State can\n     * either be an instance of <CellState> or a function that returns an\n     * <CellState>. The down, move, up and dblClick arguments are optional\n     * functions that take the trigger event as arguments and replace the\n     * default behaviour.\n     */\n    static redirectMouseEvents(node, graph, state = null, down = null, move = null, up = null, dblClick = null) {\n        const getState = (evt) => {\n            return typeof state === 'function' ? state(evt) : state;\n        };\n        InternalEvent.addGestureListeners(node, (evt) => {\n            if (down) {\n                down(evt);\n            }\n            else if (!isConsumed(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState(evt)));\n            }\n        }, (evt) => {\n            if (move) {\n                move(evt);\n            }\n            else if (!isConsumed(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n            }\n        }, (evt) => {\n            if (up) {\n                up(evt);\n            }\n            else if (!isConsumed(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n            }\n        });\n        InternalEvent.addListener(node, 'dblclick', (evt) => {\n            if (dblClick) {\n                dblClick(evt);\n            }\n            else if (!isConsumed(evt)) {\n                const tmp = getState(evt);\n                graph.dblClick(evt, tmp?.cell);\n            }\n        });\n    }\n    /**\n     * Removes the known listeners from the given DOM node and its descendants.\n     *\n     * @param element DOM node to remove the listeners from.\n     */\n    static release(element) {\n        try {\n            InternalEvent.removeAllListeners(element);\n            // @ts-ignore\n            const children = element.childNodes;\n            if (children !== undefined) {\n                const childCount = children.length;\n                for (let i = 0; i < childCount; i += 1) {\n                    InternalEvent.release(children[i]);\n                }\n            }\n        }\n        catch (e) {\n            // ignores errors as this is typically called in cleanup code\n        }\n    }\n    /**\n     * Installs the given function as a handler for mouse wheel events. The\n     * function has two arguments: the mouse event and a boolean that specifies\n     * if the wheel was moved up or down.\n     *\n     * This has been tested with IE 6 and 7, Firefox (all versions), Opera and\n     * Safari. It does currently not work on Safari for Mac.\n     *\n     * ### Example\n     *\n     * @example\n     * ```javascript\n     * mxEvent.addMouseWheelListener(function (evt, up)\n     * {\n     *   GlobalConfig.logger.show();\n     *   GlobalConfig.logger.debug('mouseWheel: up='+up);\n     * });\n     * ```\n     *\n     * @param funct Handler function that takes the event argument and a boolean up\n     * argument for the mousewheel direction.\n     * @param target Target for installing the listener in Google Chrome. See\n     * https://www.chromestatus.com/features/6662647093133312.\n     */\n    static addMouseWheelListener(funct, target) {\n        if (funct != null) {\n            const wheelHandler = (evt) => {\n                // To prevent window zoom on trackpad pinch\n                if (evt.ctrlKey) {\n                    evt.preventDefault();\n                }\n                // Handles the event using the given function\n                if (Math.abs(evt.deltaX) > 0.5 || Math.abs(evt.deltaY) > 0.5) {\n                    funct(evt, evt.deltaY == 0 ? -evt.deltaX > 0 : -evt.deltaY > 0);\n                }\n            };\n            target = target != null ? target : window;\n            if (Client.IS_SF && !Client.IS_TOUCH) {\n                let scale = 1;\n                InternalEvent.addListener(target, 'gesturestart', (evt) => {\n                    InternalEvent.consume(evt);\n                    scale = 1;\n                });\n                InternalEvent.addListener(target, 'gesturechange', ((evt) => {\n                    InternalEvent.consume(evt);\n                    if (typeof evt.scale === 'number') {\n                        const diff = scale - evt.scale;\n                        if (Math.abs(diff) > 0.2) {\n                            funct(evt, diff < 0, true);\n                            scale = evt.scale;\n                        }\n                    }\n                }));\n                InternalEvent.addListener(target, 'gestureend', (evt) => {\n                    InternalEvent.consume(evt);\n                });\n            }\n            else {\n                let evtCache = [];\n                let dx0 = 0;\n                let dy0 = 0;\n                // Adds basic listeners for graph event dispatching\n                InternalEvent.addGestureListeners(target, ((evt) => {\n                    if (!isMouseEvent(evt) && evt.pointerId != null) {\n                        evtCache.push(evt);\n                    }\n                }), ((evt) => {\n                    if (!isMouseEvent(evt) && evtCache.length == 2) {\n                        // Find this event in the cache and update its record with this event\n                        for (let i = 0; i < evtCache.length; i += 1) {\n                            if (evt.pointerId == evtCache[i].pointerId) {\n                                evtCache[i] = evt;\n                                break;\n                            }\n                        }\n                        // Calculate the distance between the two pointers\n                        const dx = Math.abs(evtCache[0].clientX - evtCache[1].clientX);\n                        const dy = Math.abs(evtCache[0].clientY - evtCache[1].clientY);\n                        const tx = Math.abs(dx - dx0);\n                        const ty = Math.abs(dy - dy0);\n                        if (tx > InternalEvent.PINCH_THRESHOLD ||\n                            ty > InternalEvent.PINCH_THRESHOLD) {\n                            const cx = evtCache[0].clientX + (evtCache[1].clientX - evtCache[0].clientX) / 2;\n                            const cy = evtCache[0].clientY + (evtCache[1].clientY - evtCache[0].clientY) / 2;\n                            funct(evtCache[0], tx > ty ? dx > dx0 : dy > dy0, true, cx, cy);\n                            // Cache the distance for the next move event\n                            dx0 = dx;\n                            dy0 = dy;\n                        }\n                    }\n                }), (evt) => {\n                    evtCache = [];\n                    dx0 = 0;\n                    dy0 = 0;\n                });\n            }\n            InternalEvent.addListener(target, 'wheel', wheelHandler);\n        }\n    }\n    /**\n     * Disables the context menu for the given element.\n     */\n    static disableContextMenu(element) {\n        InternalEvent.addListener(element, 'contextmenu', (evt) => {\n            if (evt.preventDefault) {\n                evt.preventDefault();\n            }\n            return false;\n        });\n    }\n    /**\n     * Consumes the given event.\n     *\n     * @param evt Native event to be consumed.\n     * @param {boolean} [preventDefault=true] Optional boolean to prevent the default for the event.\n     * Default is true.\n     * @param {boolean} [stopPropagation=true] Option boolean to stop event propagation. Default is\n     * true.\n     */\n    static consume(evt, preventDefault = true, stopPropagation = true) {\n        if (preventDefault) {\n            if (evt.preventDefault) {\n                if (stopPropagation) {\n                    evt.stopPropagation();\n                }\n                evt.preventDefault();\n            }\n            else if (stopPropagation) {\n                evt.cancelBubble = true;\n            }\n        }\n        // Opera\n        // @ts-ignore This is a non-standard property.\n        evt.isConsumed = true;\n        // Other browsers\n        if (!evt.preventDefault) {\n            evt.returnValue = false;\n        }\n    }\n}\n//\n// Special handles in mouse events\n//\n/**\n * Index for the label handle in an mxMouseEvent. This should be a negative\n * value that does not interfere with any possible handle indices.\n * @default -1\n */\nInternalEvent.LABEL_HANDLE = -1;\n/**\n * Index for the rotation handle in an mxMouseEvent. This should be a\n * negative value that does not interfere with any possible handle indices.\n * @default -2\n */\nInternalEvent.ROTATION_HANDLE = -2;\n/**\n * Start index for the custom handles in an mxMouseEvent. This should be a\n * negative value and is the start index which is decremented for each\n * custom handle.\n * @default -100\n */\nInternalEvent.CUSTOM_HANDLE = -100;\n/**\n * Start index for the virtual handles in an mxMouseEvent. This should be a\n * negative value and is the start index which is decremented for each\n * virtual handle.\n * This assumes that there are no more\n * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.\n *\n * @default -100000\n */\nInternalEvent.VIRTUAL_HANDLE = -100000;\n//\n// Event names\n//\n/**\n * Specifies the event name for mouseDown.\n */\nInternalEvent.MOUSE_DOWN = 'mouseDown';\n/**\n * Specifies the event name for mouseMove.\n */\nInternalEvent.MOUSE_MOVE = 'mouseMove';\n/**\n * Specifies the event name for mouseUp.\n */\nInternalEvent.MOUSE_UP = 'mouseUp';\n/**\n * Specifies the event name for activate.\n */\nInternalEvent.ACTIVATE = 'activate';\n/**\n * Specifies the event name for resizeStart.\n */\nInternalEvent.RESIZE_START = 'resizeStart';\n/**\n * Specifies the event name for resize.\n */\nInternalEvent.RESIZE = 'resize';\n/**\n * Specifies the event name for resizeEnd.\n */\nInternalEvent.RESIZE_END = 'resizeEnd';\n/**\n * Specifies the event name for moveStart.\n */\nInternalEvent.MOVE_START = 'moveStart';\n/**\n * Specifies the event name for move.\n */\nInternalEvent.MOVE = 'move';\n/**\n * Specifies the event name for moveEnd.\n */\nInternalEvent.MOVE_END = 'moveEnd';\n/**\n * Specifies the event name for panStart.\n */\nInternalEvent.PAN_START = 'panStart';\n/**\n * Specifies the event name for pan.\n */\nInternalEvent.PAN = 'pan';\n/**\n * Specifies the event name for panEnd.\n */\nInternalEvent.PAN_END = 'panEnd';\n/**\n * Specifies the event name for minimize.\n */\nInternalEvent.MINIMIZE = 'minimize';\n/**\n * Specifies the event name for normalize.\n */\nInternalEvent.NORMALIZE = 'normalize';\n/**\n * Specifies the event name for maximize.\n */\nInternalEvent.MAXIMIZE = 'maximize';\n/**\n * Specifies the event name for hide.\n */\nInternalEvent.HIDE = 'hide';\n/**\n * Specifies the event name for show.\n */\nInternalEvent.SHOW = 'show';\n/**\n * Specifies the event name for close.\n */\nInternalEvent.CLOSE = 'close';\n/**\n * Specifies the event name for destroy.\n */\nInternalEvent.DESTROY = 'destroy';\n/**\n * Specifies the event name for refresh.\n */\nInternalEvent.REFRESH = 'refresh';\n/**\n * Specifies the event name for size.\n */\nInternalEvent.SIZE = 'size';\n/**\n * Specifies the event name for select.\n */\nInternalEvent.SELECT = 'select';\n/**\n * Specifies the event name for fired.\n */\nInternalEvent.FIRED = 'fired';\n/**\n * Specifies the event name for fireMouseEvent.\n */\nInternalEvent.FIRE_MOUSE_EVENT = 'fireMouseEvent';\n/**\n * Specifies the event name for gesture.\n */\nInternalEvent.GESTURE = 'gesture';\n/**\n * Specifies the event name for tapAndHold.\n */\nInternalEvent.TAP_AND_HOLD = 'tapAndHold';\n/**\n * Specifies the event name for get.\n */\nInternalEvent.GET = 'get';\n/**\n * Specifies the event name for receive.\n */\nInternalEvent.RECEIVE = 'receive';\n/**\n * Specifies the event name for connect.\n */\nInternalEvent.CONNECT = 'connect';\n/**\n * Specifies the event name for disconnect.\n */\nInternalEvent.DISCONNECT = 'disconnect';\n/**\n * Specifies the event name for suspend.\n */\nInternalEvent.SUSPEND = 'suspend';\n/**\n * Specifies the event name for suspend.\n */\nInternalEvent.RESUME = 'resume';\n/**\n * Specifies the event name for mark.\n */\nInternalEvent.MARK = 'mark';\n/**\n * Specifies the event name for root.\n */\nInternalEvent.ROOT = 'root';\n/**\n * Specifies the event name for post.\n */\nInternalEvent.POST = 'post';\n/**\n * Specifies the event name for open.\n */\nInternalEvent.OPEN = 'open';\n/**\n * Specifies the event name for open.\n */\nInternalEvent.SAVE = 'save';\n/**\n * Specifies the event name for beforeAddVertex.\n */\nInternalEvent.BEFORE_ADD_VERTEX = 'beforeAddVertex';\n/**\n * Specifies the event name for addVertex.\n */\nInternalEvent.ADD_VERTEX = 'addVertex';\n/**\n * Specifies the event name for afterAddVertex.\n */\nInternalEvent.AFTER_ADD_VERTEX = 'afterAddVertex';\n/**\n * Specifies the event name for done.\n */\nInternalEvent.DONE = 'done';\n/**\n * Specifies the event name for execute.\n */\nInternalEvent.EXECUTE = 'execute';\n/**\n * Specifies the event name for executed.\n */\nInternalEvent.EXECUTED = 'executed';\n/**\n * Specifies the event name for beginUpdate.\n */\nInternalEvent.BEGIN_UPDATE = 'beginUpdate';\n/**\n * Specifies the event name for startEdit.\n */\nInternalEvent.START_EDIT = 'startEdit';\n/**\n * Specifies the event name for endUpdate.\n */\nInternalEvent.END_UPDATE = 'endUpdate';\n/**\n * Specifies the event name for endEdit.\n */\nInternalEvent.END_EDIT = 'endEdit';\n/**\n * Specifies the event name for beforeUndo.\n */\nInternalEvent.BEFORE_UNDO = 'beforeUndo';\n/**\n * Specifies the event name for undo.\n */\nInternalEvent.UNDO = 'undo';\n/**\n * Specifies the event name for redo.\n */\nInternalEvent.REDO = 'redo';\n/**\n * Specifies the event name for change.\n */\nInternalEvent.CHANGE = 'change';\n/**\n * Specifies the event name for notify.\n */\nInternalEvent.NOTIFY = 'notify';\n/**\n * Specifies the event name for layoutCells.\n */\nInternalEvent.LAYOUT_CELLS = 'layoutCells';\n/**\n * Specifies the event name for click.\n */\nInternalEvent.CLICK = 'click';\n/**\n * Specifies the event name for scale.\n */\nInternalEvent.SCALE = 'scale';\n/**\n * Specifies the event name for translate.\n */\nInternalEvent.TRANSLATE = 'translate';\n/**\n * Specifies the event name for scaleAndTranslate.\n */\nInternalEvent.SCALE_AND_TRANSLATE = 'scaleAndTranslate';\n/**\n * Specifies the event name for up.\n */\nInternalEvent.UP = 'up';\n/**\n * Specifies the event name for down.\n */\nInternalEvent.DOWN = 'down';\n/**\n * Specifies the event name for add.\n */\nInternalEvent.ADD = 'add';\n/**\n * Specifies the event name for remove.\n */\nInternalEvent.REMOVE = 'remove';\n/**\n * Specifies the event name for clear.\n */\nInternalEvent.CLEAR = 'clear';\n/**\n * Specifies the event name for addCells.\n */\nInternalEvent.ADD_CELLS = 'addCells';\n/**\n * Specifies the event name for cellsAdded.\n */\nInternalEvent.CELLS_ADDED = 'cellsAdded';\n/**\n * Specifies the event name for moveCells.\n */\nInternalEvent.MOVE_CELLS = 'moveCells';\n/**\n * Specifies the event name for cellsMoved.\n */\nInternalEvent.CELLS_MOVED = 'cellsMoved';\n/**\n * Specifies the event name for resizeCells.\n */\nInternalEvent.RESIZE_CELLS = 'resizeCells';\n/**\n * Specifies the event name for cellsResized.\n */\nInternalEvent.CELLS_RESIZED = 'cellsResized';\n/**\n * Specifies the event name for toggleCells.\n */\nInternalEvent.TOGGLE_CELLS = 'toggleCells';\n/**\n * Specifies the event name for cellsToggled.\n */\nInternalEvent.CELLS_TOGGLED = 'cellsToggled';\n/**\n * Specifies the event name for orderCells.\n */\nInternalEvent.ORDER_CELLS = 'orderCells';\n/**\n * Specifies the event name for cellsOrdered.\n */\nInternalEvent.CELLS_ORDERED = 'cellsOrdered';\n/**\n * Specifies the event name for removeCells.\n */\nInternalEvent.REMOVE_CELLS = 'removeCells';\n/**\n * Specifies the event name for cellsRemoved.\n */\nInternalEvent.CELLS_REMOVED = 'cellsRemoved';\n/**\n * Specifies the event name for groupCells.\n */\nInternalEvent.GROUP_CELLS = 'groupCells';\n/**\n * Specifies the event name for ungroupCells.\n */\nInternalEvent.UNGROUP_CELLS = 'ungroupCells';\n/**\n * Specifies the event name for removeCellsFromParent.\n */\nInternalEvent.REMOVE_CELLS_FROM_PARENT = 'removeCellsFromParent';\n/**\n * Specifies the event name for foldCells.\n */\nInternalEvent.FOLD_CELLS = 'foldCells';\n/**\n * Specifies the event name for cellsFolded.\n */\nInternalEvent.CELLS_FOLDED = 'cellsFolded';\n/**\n * Specifies the event name for alignCells.\n */\nInternalEvent.ALIGN_CELLS = 'alignCells';\n/**\n * Specifies the event name for labelChanged.\n */\nInternalEvent.LABEL_CHANGED = 'labelChanged';\n/**\n * Specifies the event name for connectCell.\n */\nInternalEvent.CONNECT_CELL = 'connectCell';\n/**\n * Specifies the event name for cellConnected.\n */\nInternalEvent.CELL_CONNECTED = 'cellConnected';\n/**\n * Specifies the event name for splitEdge.\n */\nInternalEvent.SPLIT_EDGE = 'splitEdge';\n/**\n * Specifies the event name for flipEdge.\n */\nInternalEvent.FLIP_EDGE = 'flipEdge';\n/**\n * Specifies the event name for startEditing.\n */\nInternalEvent.START_EDITING = 'startEditing';\n/**\n * Specifies the event name for editingStarted.\n */\nInternalEvent.EDITING_STARTED = 'editingStarted';\n/**\n * Specifies the event name for editingStopped.\n */\nInternalEvent.EDITING_STOPPED = 'editingStopped';\n/**\n * Specifies the event name for addOverlay.\n */\nInternalEvent.ADD_OVERLAY = 'addOverlay';\n/**\n * Specifies the event name for removeOverlay.\n */\nInternalEvent.REMOVE_OVERLAY = 'removeOverlay';\n/**\n * Specifies the event name for updateCellSize.\n */\nInternalEvent.UPDATE_CELL_SIZE = 'updateCellSize';\n/**\n * Specifies the event name for escape.\n */\nInternalEvent.ESCAPE = 'escape';\n/**\n * Specifies the event name for doubleClick.\n */\nInternalEvent.DOUBLE_CLICK = 'doubleClick';\n/**\n * Specifies the event name for start.\n */\nInternalEvent.START = 'start';\n/**\n * Specifies the event name for reset.\n */\nInternalEvent.RESET = 'reset';\n/**\n * Threshold for pinch gestures to fire a mouse wheel event.\n * Default value is 10.\n */\nInternalEvent.PINCH_THRESHOLD = 10;\nexport default InternalEvent;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Implements a 2-dimensional vector with double precision coordinates.\n *\n * Constructor: mxPoint\n *\n * Constructs a new point for the optional x and y coordinates. If no\n * coordinates are given, then the default values for <x> and <y> are used.\n */\nclass Point {\n    constructor(x = 0, y = 0) {\n        /**\n         * Holds the x-coordinate of the point. Default is 0.\n         */\n        this._x = 0;\n        /**\n         * Holds the y-coordinate of the point. Default is 0.\n         */\n        this._y = 0;\n        this.x = x;\n        this.y = y;\n    }\n    get x() {\n        return this._x;\n    }\n    set x(x) {\n        if (Number.isNaN(x))\n            throw new Error('Invalid x supplied.');\n        this._x = x;\n    }\n    get y() {\n        return this._y;\n    }\n    set y(y) {\n        if (Number.isNaN(y))\n            throw new Error('Invalid y supplied.');\n        this._y = y;\n    }\n    /**\n     * Returns true if the given object equals this point.\n     */\n    equals(p) {\n        if (!p)\n            return false;\n        return p.x === this.x && p.y === this.y;\n    }\n    /**\n     * Returns a clone of this {@link Point}.\n     */\n    clone() {\n        return new Point(this.x, this.y);\n    }\n}\nexport default Point;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\n/**\n * Extends {@link Point} to implement a 2-dimensional rectangle with double\n * precision coordinates.\n *\n * Constructor: mxRectangle\n *\n * Constructs a new rectangle for the optional parameters. If no parameters\n * are given then the respective default values are used.\n */\nclass Rectangle extends Point {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y);\n        /**\n         * Holds the width of the rectangle.\n         * @default 0\n         */\n        this._width = 0;\n        /**\n         * Holds the height of the rectangle.\n         * @default 0\n         */\n        this._height = 0;\n        this.width = width;\n        this.height = height;\n    }\n    get width() {\n        return this._width;\n    }\n    set width(width) {\n        if (Number.isNaN(width))\n            throw new Error('Invalid width supplied.');\n        this._width = width;\n    }\n    get height() {\n        return this._height;\n    }\n    set height(height) {\n        if (Number.isNaN(height))\n            throw new Error('Invalid height supplied.');\n        this._height = height;\n    }\n    /**\n     * Sets this rectangle to the specified values\n     */\n    setRect(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * Returns the x-coordinate of the center point.\n     */\n    getCenterX() {\n        return this.x + this.width / 2;\n    }\n    /**\n     * Returns the y-coordinate of the center point.\n     */\n    getCenterY() {\n        return this.y + this.height / 2;\n    }\n    /**\n     * Adds the given rectangle to this rectangle.\n     */\n    add(rect) {\n        const minX = Math.min(this.x, rect.x);\n        const minY = Math.min(this.y, rect.y);\n        const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n        const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n        this.x = minX;\n        this.y = minY;\n        this.width = maxX - minX;\n        this.height = maxY - minY;\n    }\n    /**\n     * Changes this rectangle to where it overlaps with the given rectangle.\n     */\n    intersect(rect) {\n        const r1 = this.x + this.width;\n        const r2 = rect.x + rect.width;\n        const b1 = this.y + this.height;\n        const b2 = rect.y + rect.height;\n        this.x = Math.max(this.x, rect.x);\n        this.y = Math.max(this.y, rect.y);\n        this.width = Math.min(r1, r2) - this.x;\n        this.height = Math.min(b1, b2) - this.y;\n    }\n    /**\n     * Grows the rectangle by the given amount, that is, this method subtracts\n     * the given amount from the x- and y-coordinates and adds twice the amount\n     * to the width and height.\n     */\n    grow(amount) {\n        this.x -= amount;\n        this.y -= amount;\n        this.width += 2 * amount;\n        this.height += 2 * amount;\n    }\n    /**\n     * Returns the top, left corner as a new {@link Point}.\n     */\n    getPoint() {\n        return new Point(this.x, this.y);\n    }\n    /**\n     * Rotates this rectangle by 90 degree around its center point.\n     */\n    rotate90() {\n        const t = (this.width - this.height) / 2;\n        this.x += t;\n        this.y -= t;\n        const tmp = this.width;\n        this.width = this.height;\n        this.height = tmp;\n    }\n    /**\n     * Returns true if the given object equals this rectangle.\n     */\n    equals(rect) {\n        if (!rect)\n            return false;\n        return (rect.x === this.x &&\n            rect.y === this.y &&\n            rect.width === this.width &&\n            rect.height === this.height);\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n}\n/**\n * Returns a new {@link Rectangle} which is a copy of the given rectangle.\n */\nRectangle.fromRectangle = (rect) => {\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n};\nexport default Rectangle;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NODETYPE, NONE } from './Constants';\nimport { getTextContent } from './domUtils';\n/**\n * Strips all whitespaces from the beginning of the string. Without the\n * second parameter, this will trim these characters:\n *\n * - \" \" (ASCII 32 (0x20)), an ordinary space\n * - \"\\t\" (ASCII 9 (0x09)), a tab\n * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n */\nexport const ltrim = (str, chars = '\\\\s') => str != null ? str.replace(new RegExp(`^[${chars}]+`, 'g'), '') : null;\n/**\n * Strips all whitespaces from the end of the string. Without the second\n * parameter, this will trim these characters:\n *\n * - \" \" (ASCII 32 (0x20)), an ordinary space\n * - \"\\t\" (ASCII 9 (0x09)), a tab\n * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n */\nexport const rtrim = (str, chars = '\\\\s') => str != null ? str.replace(new RegExp(`[${chars}]+$`, 'g'), '') : null;\n/**\n * Strips all whitespaces from both end of the string.\n * Without the second parameter, Javascript function will trim these\n * characters:\n *\n * - \" \" (ASCII 32 (0x20)), an ordinary space\n * - \"\\t\" (ASCII 9 (0x09)), a tab\n * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n */\nexport const trim = (str, chars) => ltrim(rtrim(str, chars), chars);\n/**\n * Returns the name for the given function.\n *\n * @param f JavaScript object that represents a function.\n */\nexport const getFunctionName = (f) => {\n    let str = null;\n    if (f != null) {\n        if (f.name != null) {\n            str = f.name;\n        }\n        else {\n            str = trim(f.toString());\n            if (str !== null && /^function\\s/.test(str)) {\n                str = ltrim(str.substring(9));\n                if (str !== null) {\n                    const idx2 = str.indexOf('(');\n                    if (idx2 > 0) {\n                        str = str.substring(0, idx2);\n                    }\n                }\n            }\n        }\n    }\n    return str;\n};\n/**\n * Replaces each trailing newline with the given pattern.\n */\nexport const replaceTrailingNewlines = (str, pattern) => {\n    // LATER: Check is this can be done with a regular expression\n    let postfix = '';\n    while (str.length > 0 && str.charAt(str.length - 1) == '\\n') {\n        str = str.substring(0, str.length - 1);\n        postfix += pattern;\n    }\n    return str + postfix;\n};\n/**\n * Removes the sibling text nodes for the given node that only consists\n * of tabs, newlines and spaces.\n *\n * @param node DOM node whose siblings should be removed.\n * @param before Optional boolean that specifies the direction of the traversal.\n */\nexport const removeWhitespace = (node, before) => {\n    let tmp = before ? node.previousSibling : node.nextSibling;\n    while (tmp != null && tmp.nodeType === NODETYPE.TEXT) {\n        const next = before ? tmp.previousSibling : tmp.nextSibling;\n        const text = getTextContent(tmp);\n        if (trim(text)?.length === 0) {\n            tmp.parentNode?.removeChild(tmp);\n        }\n        tmp = next;\n    }\n};\n/**\n * Replaces characters (less than, greater than, newlines and quotes) with\n * their HTML entities in the given string and returns the result.\n *\n * @param s String that contains the characters to be converted.\n * @param newline If newlines should be replaced. Default is `true`.\n */\nexport const htmlEntities = (s, newline = true) => {\n    s = String(s || '');\n    s = s.replace(/&/g, '&amp;'); // 38 26\n    s = s.replace(/\"/g, '&quot;'); // 34 22\n    s = s.replace(/'/g, '&#39;'); // 39 27\n    s = s.replace(/</g, '&lt;'); // 60 3C\n    s = s.replace(/>/g, '&gt;'); // 62 3E\n    if (newline) {\n        s = s.replace(/\\n/g, '&#xa;');\n    }\n    return s;\n};\nexport const getStringValue = (array, key, defaultValue) => {\n    let value = array != null ? array[key] : null;\n    if (value == null) {\n        value = defaultValue;\n    }\n    return value == null ? null : String(value);\n};\n/**\n * Returns the numeric value for the given key in the given associative\n * array or the given default value (or 0) if the value is null. The value\n * is converted to a numeric value using the Number function.\n *\n * @param array Associative array that contains the value for the key.\n * @param key Key whose value should be returned.\n * @param defaultValue Value to be returned if the value for the given\n * key is null. Default is 0.\n */\nexport const getNumber = (array, key, defaultValue) => {\n    let value = array != null ? array[key] : null;\n    if (value == null) {\n        value = defaultValue || 0;\n    }\n    return Number(value);\n};\n/**\n * Returns the color value for the given key in the given associative\n * array or the given default value if the value is null. If the value\n * is {@link Constants#NONE} then null is returned.\n *\n * @param array Associative array that contains the value for the key.\n * @param key Key whose value should be returned.\n * @param defaultValue Value to be returned if the value for the given\n * key is null. Default is null.\n */\nexport const getColor = (array, key, defaultValue) => {\n    let value = array != null ? array[key] : null;\n    if (value == null) {\n        value = defaultValue;\n    }\n    else if (value === NONE) {\n        value = null;\n    }\n    return value;\n};\n/**\n * Returns a textual representation of the specified object.\n *\n * @param obj Object to return the string representation for.\n */\nexport const toString = (obj) => {\n    let output = '';\n    for (const i in obj) {\n        try {\n            if (obj[i] == null) {\n                output += `${i} = [null]\\n`;\n            }\n            else if (typeof obj[i] === 'function') {\n                output += `${i} => [Function]\\n`;\n            }\n            else if (typeof obj[i] === 'object') {\n                const ctor = getFunctionName(obj[i].constructor);\n                output += `${i} => [${ctor}]\\n`;\n            }\n            else {\n                output += `${i} = ${obj[i]}\\n`;\n            }\n        }\n        catch (e) {\n            output += `${i}=${e.message}`;\n        }\n    }\n    return output;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { IDENTITY_FIELD_NAME } from './Constants';\nimport { getFunctionName } from './StringUtils';\n/**\n * @class\n *\n * Identity for JavaScript objects and functions. This is implemented using\n * a simple incrementing counter which is stored in each object under\n * {@link FIELD_NAME}.\n *\n * The identity for an object does not change during its lifecycle.\n */\nclass ObjectIdentity {\n    /**\n     * Returns the ID for the given object or function.\n     */\n    static get(obj) {\n        if (obj) {\n            if (obj[IDENTITY_FIELD_NAME] === null || obj[IDENTITY_FIELD_NAME] === undefined) {\n                if (typeof obj === 'object') {\n                    const ctor = getFunctionName(obj.constructor);\n                    obj[IDENTITY_FIELD_NAME] = `${ctor}#${ObjectIdentity.counter++}`;\n                }\n                else if (typeof obj === 'function') {\n                    obj[IDENTITY_FIELD_NAME] = `Function#${ObjectIdentity.counter++}`;\n                }\n            }\n            return obj[IDENTITY_FIELD_NAME];\n        }\n        return null;\n    }\n    /**\n     * Deletes the ID from the given object or function.\n     */\n    static clear(obj) {\n        delete obj[IDENTITY_FIELD_NAME];\n    }\n}\n/**\n * Name of the field to be used to store the object ID. Default is\n * <code>mxObjectId</code>.\n */\nObjectIdentity.FIELD_NAME = IDENTITY_FIELD_NAME;\n/**\n * Current counter.\n */\nObjectIdentity.counter = 0;\nexport default ObjectIdentity;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from './ObjectIdentity';\n/**\n * A wrapper class for an associative array with object keys.\n *\n * Note: This implementation uses {@link ObjectIdentity} to turn object keys into strings.\n *\n */\nclass Dictionary {\n    constructor() {\n        /**\n         * Stores the (key, value) pairs in this dictionary.\n         */\n        this.map = {};\n        this.clear();\n    }\n    /**\n     * Clears the dictionary.\n     */\n    clear() {\n        this.map = {};\n    }\n    /**\n     * Returns the value for the given key.\n     */\n    get(key) {\n        const id = ObjectIdentity.get(key);\n        return this.map[id] ?? null;\n    }\n    /**\n     * Stores the value under the given key and returns the previous\n     * value for that key.\n     */\n    put(key, value) {\n        const id = ObjectIdentity.get(key);\n        const previous = this.map[id];\n        this.map[id] = value;\n        return previous ?? null;\n    }\n    /**\n     * Removes the value for the given key and returns the value that\n     * has been removed.\n     */\n    remove(key) {\n        const id = ObjectIdentity.get(key);\n        const previous = this.map[id];\n        delete this.map[id];\n        return previous ?? null;\n    }\n    /**\n     * Returns all keys as an array.\n     */\n    getKeys() {\n        const result = [];\n        for (const key in this.map) {\n            result.push(key);\n        }\n        return result;\n    }\n    /**\n     * Returns all values as an array.\n     */\n    getValues() {\n        const result = [];\n        for (const key in this.map) {\n            result.push(this.map[key]);\n        }\n        return result;\n    }\n    /**\n     * Visits all entries in the dictionary using the given function with the\n     * following signature: (key, value)=> where key is a string and\n     * value is an object.\n     *\n     * @param visitor A function that takes the key and value as arguments.\n     */\n    visit(visitor) {\n        for (const key in this.map) {\n            visitor(key, this.map[key]);\n        }\n    }\n}\nexport default Dictionary;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { GlobalConfig } from './config';\n/**\n * A singleton class that provides cross-browser helper methods.\n * This is a global functionality. To access the functions in this\n * class, use the global classname appended by the functionname.\n * You may have to load chrome://global/content/contentAreaUtils.js\n * to disable certain security restrictions in Mozilla for the <open>,\n * <save>, <saveAs> and <copy> function.\n *\n * For example, the following code displays an error message:\n *\n * ```javascript\n * mxUtils.error('Browser is not supported!', 200, false);\n * ```\n */\nexport const utils = {\n    /*\n     * Specifies the resource key for the title of the error window. If the\n     * resource for this key does not exist then the value is used as\n     * the title. Default is 'error'.\n     */\n    errorResource: 'error',\n    /**\n     * Specifies the resource key for the label of the close button. If the\n     * resource for this key does not exist then the value is used as\n     * the label. Default is 'close'.\n     */\n    closeResource: 'close',\n    /**\n     * Defines the image used for error dialogs.\n     */\n    errorImage: `${Client.imageBasePath}/error.gif`,\n};\nexport const isNullish = (v) => v === null || v === undefined;\nexport const isNotNullish = (v) => !isNullish(v);\n/**\n * Merge a mixin into the destination\n * @param dest the destination class\n *\n * @private not part of the public API, can be removed or changed without prior notice\n */\nexport const mixInto = (dest) => (mixin) => {\n    const keys = Reflect.ownKeys(mixin);\n    try {\n        for (const key of keys) {\n            Object.defineProperty(dest.prototype, key, {\n                value: mixin[key],\n                writable: true,\n            });\n        }\n    }\n    catch (e) {\n        GlobalConfig.logger.error('Error while mixing', e);\n    }\n};\n/**\n * Returns the value for the given key in the given associative array or\n * the given default value if the value is null.\n *\n * @param array Associative array that contains the value for the key.\n * @param key Key whose value should be returned.\n * @param defaultValue Value to be returned if the value for the given\n * key is null.\n */\nexport const getValue = (array, key, defaultValue) => {\n    let value = array != null ? array[key] : null;\n    if (value == null) {\n        value = defaultValue;\n    }\n    return value;\n};\nexport const copyTextToClipboard = (text) => {\n    // Credit: https://stackoverflow.com/questions/400212/how-do-i-copy-to-the-clipboard-in-javascript\n    if (!navigator.clipboard) {\n        fallbackCopyTextToClipboard(text);\n        return;\n    }\n    navigator.clipboard.writeText(text).then(function () {\n        GlobalConfig.logger.info('Async: Copying to clipboard was successful!');\n    }, function (err) {\n        GlobalConfig.logger.error('Async: Could not copy text: ', err);\n    });\n};\nconst fallbackCopyTextToClipboard = (text) => {\n    const textArea = document.createElement('textarea');\n    textArea.value = text;\n    // Avoid scrolling to bottom\n    textArea.style.top = '0';\n    textArea.style.left = '0';\n    textArea.style.position = 'fixed';\n    document.body.appendChild(textArea);\n    textArea.focus();\n    textArea.select();\n    try {\n        const successful = document.execCommand('copy');\n        const msg = successful ? 'successful' : 'unsuccessful';\n        GlobalConfig.logger.info(`Fallback: Copying text command was ${msg}`);\n    }\n    catch (err) {\n        GlobalConfig.logger.error('Fallback: Oops, unable to copy', err);\n    }\n    document.body.removeChild(textArea);\n};\n/**\n * If `baseTimestamp` is provided and not zero, returns a message describing the elapsed milliseconds since this value.\n * Otherwise, returns an empty string.\n * @param baseTimestamp the base timestamp to compute the elapsed milliseconds from\n *\n * @private not part of the public API, can be removed or changed without prior notice\n */\nexport const getElapseMillisecondsMessage = (baseTimestamp) => baseTimestamp ? ` (${new Date().getTime() - baseTimestamp} ms)` : '';\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getElapseMillisecondsMessage } from './Utils';\n/**\n * A {@link Logger} that does nothing.\n *\n * @experimental subject to change or removal. The logging system may be modified in the future without prior notice.\n * @since 0.11.0\n * @category Logging\n */\nexport class NoOpLogger {\n    debug(_message) { }\n    enter(_message) {\n        return undefined;\n    }\n    error(_message, ..._optionalParams) { }\n    info(_message) { }\n    leave(_message, _baseTimestamp) { }\n    show() { }\n    trace(_message) { }\n    warn(_message) { }\n}\n/**\n * A {@link Logger} that directs logs to the browser console.\n *\n * @experimental subject to change or removal. The logging system may be modified in the future without prior notice.\n * @since 0.11.0\n * @category Logging\n */\nexport class ConsoleLogger {\n    constructor() {\n        this.debugEnabled = false;\n        this.infoEnabled = false;\n        this.traceEnabled = false;\n    }\n    /* eslint-disable no-console -- we must use \"console\" to direct logs to the browser console */\n    enter(message) {\n        if (this.traceEnabled) {\n            console.trace(`Entering ${message}`);\n            return new Date().getTime();\n        }\n    }\n    leave(message, baseTimestamp) {\n        if (this.traceEnabled) {\n            const dt = getElapseMillisecondsMessage(baseTimestamp);\n            console.trace(`Leaving ${message}${dt}`);\n        }\n    }\n    show() { }\n    trace(message) {\n        if (this.traceEnabled) {\n            console.trace(message);\n        }\n    }\n    debug(message) {\n        if (this.debugEnabled) {\n            console.debug(message);\n        }\n    }\n    info(message) {\n        if (this.infoEnabled) {\n            console.info(message);\n        }\n    }\n    warn(message) {\n        console.warn(message);\n    }\n    error(message, ...optionalParams) {\n        console.error(message, ...optionalParams);\n    }\n}\n/* eslint-enable no-console */\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NoOpLogger } from './logger';\n/**\n * Global configuration for maxGraph.\n *\n * @experimental subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.11.0\n * @category Configuration\n */\nexport const GlobalConfig = {\n    /**\n     * Configure the logger to use for all log messages.\n     *\n     * Available implementations provided by maxGraph are:\n     * * {@link ConsoleLogger} - Directs logs to the browser console.\n     * * {@link NoOpLogger} - Default implementation that does nothing.\n     * * {@link MaxLogAsLogger} - Directs logs to {@link MaxLog}.\n     *\n     * To change the logger, set this property to an instance of the desired logger:\n     * ```js\n     * // To direct logs to the browser console\n     * GlobalConfig.logger = new ConsoleLogger();\n     * // To direct logs to MaxLog\n     * GlobalConfig.logger = new MaxLogAsLogger();\n     * ```\n     *\n     * @default `NoOpLogger`\n     */\n    logger: new NoOpLogger(),\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIRECTION, DIRECTION_MASK } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Rectangle from '../view/geometry/Rectangle';\nimport { getValue, isNullish } from './Utils';\n/**\n * Converts the given degree to radians.\n */\nexport const toRadians = (deg) => {\n    return (Math.PI * deg) / 180;\n};\n/**\n * Converts the given radians to degree.\n */\nexport const toDegree = (rad) => {\n    return (rad * 180) / Math.PI;\n};\n/**\n * Converts the given arc to a series of curves.\n */\nexport const arcToCurves = (x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) => {\n    x -= x0;\n    y -= y0;\n    if (r1 === 0 || r2 === 0) {\n        return [];\n    }\n    const fS = sweepFlag;\n    const psai = angle;\n    r1 = Math.abs(r1);\n    r2 = Math.abs(r2);\n    const ctx = -x / 2;\n    const cty = -y / 2;\n    const cpsi = Math.cos((psai * Math.PI) / 180);\n    const spsi = Math.sin((psai * Math.PI) / 180);\n    const rxd = cpsi * ctx + spsi * cty;\n    const ryd = -1 * spsi * ctx + cpsi * cty;\n    const rxdd = rxd * rxd;\n    const rydd = ryd * ryd;\n    const r1x = r1 * r1;\n    const r2y = r2 * r2;\n    const lamda = rxdd / r1x + rydd / r2y;\n    let sds;\n    if (lamda > 1) {\n        r1 = Math.sqrt(lamda) * r1;\n        r2 = Math.sqrt(lamda) * r2;\n        sds = 0;\n    }\n    else {\n        let seif = 1;\n        if (largeArcFlag === fS) {\n            seif = -1;\n        }\n        sds =\n            seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n    }\n    const txd = (sds * r1 * ryd) / r2;\n    const tyd = (-1 * sds * r2 * rxd) / r1;\n    const tx = cpsi * txd - spsi * tyd + x / 2;\n    const ty = spsi * txd + cpsi * tyd + y / 2;\n    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n    rad =\n        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -\n            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n    if (!fS && dr > 0) {\n        dr -= 2 * Math.PI;\n    }\n    else if (fS && dr < 0) {\n        dr += 2 * Math.PI;\n    }\n    const sse = (dr * 2) / Math.PI;\n    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n    const segr = dr / seg;\n    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);\n    const cpsir1 = cpsi * r1;\n    const cpsir2 = cpsi * r2;\n    const spsir1 = spsi * r1;\n    const spsir2 = spsi * r2;\n    let mc = Math.cos(s1);\n    let ms = Math.sin(s1);\n    let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n    let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n    let x3 = 0;\n    let y3 = 0;\n    const result = [];\n    for (let n = 0; n < seg; ++n) {\n        s1 += segr;\n        mc = Math.cos(s1);\n        ms = Math.sin(s1);\n        x3 = cpsir1 * mc - spsir2 * ms + tx;\n        y3 = spsir1 * mc + cpsir2 * ms + ty;\n        const dx = -t * (cpsir1 * ms + spsir2 * mc);\n        const dy = -t * (spsir1 * ms - cpsir2 * mc);\n        // CurveTo updates x0, y0 so need to restore it\n        const index = n * 6;\n        result[index] = Number(x2 + x0);\n        result[index + 1] = Number(y2 + y0);\n        result[index + 2] = Number(x3 - dx + x0);\n        result[index + 3] = Number(y3 - dy + y0);\n        result[index + 4] = Number(x3 + x0);\n        result[index + 5] = Number(y3 + y0);\n        x2 = x3 + dx;\n        y2 = y3 + dy;\n    }\n    return result;\n};\n/**\n * Returns the bounding box for the rotated rectangle.\n *\n * @param rect {@link Rectangle} to be rotated.\n * @param angle Number that represents the angle (in degrees).\n * @param cx Optional {@link Point} that represents the rotation center. If no\n * rotation center is given then the center of rect is used.\n */\nexport const getBoundingBox = (rect, rotation, cx = null) => {\n    let result = null;\n    if (rect && rotation !== 0) {\n        const rad = toRadians(rotation);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        cx = cx != null ? cx : new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);\n        let p1 = new Point(rect.x, rect.y);\n        let p2 = new Point(rect.x + rect.width, rect.y);\n        let p3 = new Point(p2.x, rect.y + rect.height);\n        let p4 = new Point(rect.x, p3.y);\n        p1 = getRotatedPoint(p1, cos, sin, cx);\n        p2 = getRotatedPoint(p2, cos, sin, cx);\n        p3 = getRotatedPoint(p3, cos, sin, cx);\n        p4 = getRotatedPoint(p4, cos, sin, cx);\n        result = new Rectangle(p1.x, p1.y, 0, 0);\n        result.add(new Rectangle(p2.x, p2.y, 0, 0));\n        result.add(new Rectangle(p3.x, p3.y, 0, 0));\n        result.add(new Rectangle(p4.x, p4.y, 0, 0));\n    }\n    return result;\n};\n/**\n * Rotates the given point by the given cos and sin.\n */\nexport const getRotatedPoint = (pt, cos, sin, c = new Point()) => {\n    const x = pt.x - c.x;\n    const y = pt.y - c.y;\n    const x1 = x * cos - y * sin;\n    const y1 = y * cos + x * sin;\n    return new Point(x1 + c.x, y1 + c.y);\n};\n/**\n * Returns an integer mask of the port constraints of the given map\n *\n * @param terminal {@link CelState} that represents the terminal.\n * @param edge {@link CelState} that represents the edge.\n * @param source Boolean that specifies if the terminal is the source terminal.\n * @param defaultValue Default value to be returned if no port constraint is defined in the terminal.\n * @return the mask of port constraint directions\n */\nexport const getPortConstraints = (terminal, edge, source, defaultValue) => {\n    const value = getValue(terminal.style, 'portConstraint', getValue(edge.style, source ? 'sourcePortConstraint' : 'targetPortConstraint', null));\n    if (isNullish(value)) {\n        return defaultValue;\n    }\n    const directions = value.toString();\n    let returnValue = DIRECTION_MASK.NONE;\n    const constraintRotationEnabled = terminal.style.portConstraintRotation ?? false;\n    let rotation = 0;\n    if (constraintRotationEnabled) {\n        rotation = terminal.style.rotation ?? 0;\n    }\n    let quad = 0;\n    if (rotation > 45) {\n        quad = 1;\n        if (rotation >= 135) {\n            quad = 2;\n        }\n    }\n    else if (rotation < -45) {\n        quad = 3;\n        if (rotation <= -135) {\n            quad = 2;\n        }\n    }\n    if (directions.indexOf(DIRECTION.NORTH) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.WEST) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.SOUTH) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n        }\n    }\n    if (directions.indexOf(DIRECTION.EAST) >= 0) {\n        switch (quad) {\n            case 0:\n                returnValue |= DIRECTION_MASK.EAST;\n                break;\n            case 1:\n                returnValue |= DIRECTION_MASK.SOUTH;\n                break;\n            case 2:\n                returnValue |= DIRECTION_MASK.WEST;\n                break;\n            case 3:\n                returnValue |= DIRECTION_MASK.NORTH;\n                break;\n        }\n    }\n    return returnValue;\n};\n/**\n * Reverse the port constraint bitmask. For example, north | east\n * becomes south | west\n */\nexport const reversePortConstraints = (constraint) => {\n    let result = 0;\n    result = (constraint & DIRECTION_MASK.WEST) << 3;\n    result |= (constraint & DIRECTION_MASK.NORTH) << 1;\n    result |= (constraint & DIRECTION_MASK.SOUTH) >> 1;\n    result |= (constraint & DIRECTION_MASK.EAST) >> 3;\n    return result;\n};\n/**\n * Finds the index of the nearest segment on the given cell state for\n * the specified coordinate pair.\n */\nexport const findNearestSegment = (state, x, y) => {\n    let index = -1;\n    if (state.absolutePoints.length > 0) {\n        let last = state.absolutePoints[0];\n        let min = null;\n        for (let i = 1; i < state.absolutePoints.length; i += 1) {\n            const current = state.absolutePoints[i];\n            if (!last || !current)\n                continue;\n            const dist = ptSegDistSq(last.x, last.y, current.x, current.y, x, y);\n            if (min == null || dist < min) {\n                min = dist;\n                index = i - 1;\n            }\n            last = current;\n        }\n    }\n    return index;\n};\n/**\n * Adds the given margins to the given rectangle and rotates and flips the\n * rectangle according to the respective styles in style.\n */\nexport const getDirectedBounds = (rect, m, style, flipH, flipV) => {\n    const d = getValue(style, 'direction', DIRECTION.EAST);\n    flipH = flipH != null ? flipH : getValue(style, 'flipH', false);\n    flipV = flipV != null ? flipV : getValue(style, 'flipV', false);\n    m.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));\n    m.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));\n    m.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));\n    m.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));\n    if ((flipV && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH)) ||\n        (flipH && (d === DIRECTION.EAST || d === DIRECTION.WEST))) {\n        const tmp = m.x;\n        m.x = m.width;\n        m.width = tmp;\n    }\n    if ((flipH && (d === DIRECTION.SOUTH || d === DIRECTION.NORTH)) ||\n        (flipV && (d === DIRECTION.EAST || d === DIRECTION.WEST))) {\n        const tmp = m.y;\n        m.y = m.height;\n        m.height = tmp;\n    }\n    const m2 = Rectangle.fromRectangle(m);\n    if (d === DIRECTION.SOUTH) {\n        m2.y = m.x;\n        m2.x = m.height;\n        m2.width = m.y;\n        m2.height = m.width;\n    }\n    else if (d === DIRECTION.WEST) {\n        m2.y = m.height;\n        m2.x = m.width;\n        m2.width = m.x;\n        m2.height = m.y;\n    }\n    else if (d === DIRECTION.NORTH) {\n        m2.y = m.width;\n        m2.x = m.y;\n        m2.width = m.height;\n        m2.height = m.x;\n    }\n    return new Rectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);\n};\n/**\n * Returns the intersection between the polygon defined by the array of\n * points and the line between center and point.\n */\nexport const getPerimeterPoint = (pts, center, point) => {\n    let min = null;\n    for (let i = 0; i < pts.length - 1; i += 1) {\n        const pt = intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, center.x, center.y, point.x, point.y);\n        if (pt != null) {\n            const dx = point.x - pt.x;\n            const dy = point.y - pt.y;\n            const ip = { p: pt, distSq: dy * dy + dx * dx };\n            if (ip != null && (min == null || min.distSq > ip.distSq)) {\n                min = ip;\n            }\n        }\n    }\n    return min != null ? min.p : null;\n};\n/**\n * Returns true if the given rectangle intersects the given segment.\n *\n * @param bounds {@link Rectangle} that represents the rectangle.\n * @param p1 {@link Point} that represents the first point of the segment.\n * @param p2 {@link Point} that represents the second point of the segment.\n */\nexport const rectangleIntersectsSegment = (bounds, p1, p2) => {\n    const top = bounds.y;\n    const left = bounds.x;\n    const bottom = top + bounds.height;\n    const right = left + bounds.width;\n    // Find min and max X for the segment\n    let minX = p1.x;\n    let maxX = p2.x;\n    if (p1.x > p2.x) {\n        minX = p2.x;\n        maxX = p1.x;\n    }\n    // Find the intersection of the segment's and rectangle's x-projections\n    if (maxX > right) {\n        maxX = right;\n    }\n    if (minX < left) {\n        minX = left;\n    }\n    if (minX > maxX) {\n        // If their projections do not intersect return false\n        return false;\n    }\n    // Find corresponding min and max Y for min and max X we found before\n    let minY = p1.y;\n    let maxY = p2.y;\n    const dx = p2.x - p1.x;\n    if (Math.abs(dx) > 0.0000001) {\n        const a = (p2.y - p1.y) / dx;\n        const b = p1.y - a * p1.x;\n        minY = a * minX + b;\n        maxY = a * maxX + b;\n    }\n    if (minY > maxY) {\n        const tmp = maxY;\n        maxY = minY;\n        minY = tmp;\n    }\n    // Find the intersection of the segment's and rectangle's y-projections\n    if (maxY > bottom) {\n        maxY = bottom;\n    }\n    if (minY < top) {\n        minY = top;\n    }\n    if (minY > maxY) {\n        // If Y-projections do not intersect return false\n        return false;\n    }\n    return true;\n};\n/**\n * Returns true if the specified point (x, y) is contained in the given rectangle.\n *\n * @param bounds {@link Rectangle} that represents the area.\n * @param x X-coordinate of the point.\n * @param y Y-coordinate of the point.\n */\nexport const contains = (bounds, x, y) => {\n    return (bounds.x <= x &&\n        bounds.x + bounds.width >= x &&\n        bounds.y <= y &&\n        bounds.y + bounds.height >= y);\n};\n/**\n * Returns true if the two rectangles intersect.\n *\n * @param a {@link Rectangle} to be checked for intersection.\n * @param b {@link Rectangle} to be checked for intersection.\n */\nexport const intersects = (a, b) => {\n    let tw = a.width;\n    let th = a.height;\n    let rw = b.width;\n    let rh = b.height;\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\n        return false;\n    }\n    const tx = a.x;\n    const ty = a.y;\n    const rx = b.x;\n    const ry = b.y;\n    rw += rx;\n    rh += ry;\n    tw += tx;\n    th += ty;\n    return ((rw < rx || rw > tx) &&\n        (rh < ry || rh > ty) &&\n        (tw < tx || tw > rx) &&\n        (th < ty || th > ry));\n};\n/**\n * Returns true if the state and the hotspot intersect.\n *\n * @param state <CellState>\n * @param x X-coordinate.\n * @param y Y-coordinate.\n * @param hotspot Optional size of the hostpot.\n * @param min Optional min size of the hostpot.\n * @param max Optional max size of the hostpot.\n */\nexport const intersectsHotspot = (state, x, y, hotspot, min, max) => {\n    hotspot = hotspot != null ? hotspot : 1;\n    min = min != null ? min : 0;\n    max = max != null ? max : 0;\n    if (hotspot > 0) {\n        let cx = state.getCenterX();\n        let cy = state.getCenterY();\n        let w = state.width;\n        let h = state.height;\n        const start = getValue(state.style, 'startSize') * state.view.scale;\n        if (start > 0) {\n            if (getValue(state.style, 'horizontal', true)) {\n                cy = state.y + start / 2;\n                h = start;\n            }\n            else {\n                cx = state.x + start / 2;\n                w = start;\n            }\n        }\n        w = Math.max(min, w * hotspot);\n        h = Math.max(min, h * hotspot);\n        if (max > 0) {\n            w = Math.min(w, max);\n            h = Math.min(h, max);\n        }\n        const rect = new Rectangle(cx - w / 2, cy - h / 2, w, h);\n        const alpha = toRadians(getValue(state.style, 'rotation') || 0);\n        if (alpha != 0) {\n            const cos = Math.cos(-alpha);\n            const sin = Math.sin(-alpha);\n            const cx = new Point(state.getCenterX(), state.getCenterY());\n            const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);\n            x = pt.x;\n            y = pt.y;\n        }\n        return contains(rect, x, y);\n    }\n    return true;\n};\n/**\n * Returns true if the specified value is numeric, that is, if it is not\n * null, not an empty string, not a HEX number and isNaN returns false.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isNumeric = (n) => {\n    return (!Number.isNaN(parseFloat(n)) &&\n        isFinite(+n) &&\n        (typeof n !== 'string' || n.toLowerCase().indexOf('0x') < 0));\n};\n/**\n * Returns true if the given value is an valid integer number.\n *\n * @param n String representing the possibly numeric value.\n */\nexport const isInteger = (n) => {\n    return String(parseInt(n)) === String(n);\n};\n/**\n * Returns the remainder of division of n by m. You should use this instead\n * of the built-in operation as the built-in operation does not properly\n * handle negative numbers.\n */\nexport const mod = (n, m) => {\n    return ((n % m) + m) % m;\n};\n/**\n * Returns the intersection of two lines as an {@link Point}.\n *\n * @param x0 X-coordinate of the first line's startpoint.\n * @param y0 X-coordinate of the first line's startpoint.\n * @param x1 X-coordinate of the first line's endpoint.\n * @param y1 Y-coordinate of the first line's endpoint.\n * @param x2 X-coordinate of the second line's startpoint.\n * @param y2 Y-coordinate of the second line's startpoint.\n * @param x3 X-coordinate of the second line's endpoint.\n * @param y3 Y-coordinate of the second line's endpoint.\n */\nexport const intersection = (x0, y0, x1, y1, x2, y2, x3, y3) => {\n    const denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);\n    const nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);\n    const nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);\n    const ua = nume_a / denom;\n    const ub = nume_b / denom;\n    if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n        // Get the intersection point\n        const x = x0 + ua * (x1 - x0);\n        const y = y0 + ua * (y1 - y0);\n        return new Point(x, y);\n    }\n    // No intersection\n    return null;\n};\n/**\n * Returns the square distance between a segment and a point. To get the\n * distance between a point and a line (with infinite length) use\n * {@link Utils#ptLineDist}.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptSegDistSq = (x1, y1, x2, y2, px, py) => {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    let dotprod = px * x2 + py * y2;\n    let projlenSq;\n    if (dotprod <= 0.0) {\n        projlenSq = 0.0;\n    }\n    else {\n        px = x2 - px;\n        py = y2 - py;\n        dotprod = px * x2 + py * y2;\n        if (dotprod <= 0.0) {\n            projlenSq = 0.0;\n        }\n        else {\n            projlenSq = (dotprod * dotprod) / (x2 * x2 + y2 * y2);\n        }\n    }\n    let lenSq = px * px + py * py - projlenSq;\n    if (lenSq < 0) {\n        lenSq = 0;\n    }\n    return lenSq;\n};\n/**\n * Returns the distance between a line defined by two points and a point.\n * To get the distance between a point and a segment (with a specific\n * length) use {@link Utils#ptSeqDistSq}.\n *\n * @param x1 X-coordinate of point 1 of the line.\n * @param y1 Y-coordinate of point 1 of the line.\n * @param x2 X-coordinate of point 1 of the line.\n * @param y2 Y-coordinate of point 1 of the line.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const ptLineDist = (x1, y1, x2, y2, px, py) => {\n    return (Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) /\n        Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1)));\n};\n/**\n * Returns 1 if the given point on the right side of the segment, 0 if its\n * on the segment, and -1 if the point is on the left side of the segment.\n *\n * @param x1 X-coordinate of the startpoint of the segment.\n * @param y1 Y-coordinate of the startpoint of the segment.\n * @param x2 X-coordinate of the endpoint of the segment.\n * @param y2 Y-coordinate of the endpoint of the segment.\n * @param px X-coordinate of the point.\n * @param py Y-coordinate of the point.\n */\nexport const relativeCcw = (x1, y1, x2, y2, px, py) => {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    let ccw = px * y2 - py * x2;\n    if (ccw == 0.0) {\n        ccw = px * x2 + py * y2;\n        if (ccw > 0.0) {\n            px -= x2;\n            py -= y2;\n            ccw = px * x2 + py * y2;\n            if (ccw < 0.0) {\n                ccw = 0.0;\n            }\n        }\n    }\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, FONT, LINE_HEIGHT, } from './Constants';\nimport Point from '../view/geometry/Point';\nimport Dictionary from './Dictionary';\nimport CellPath from '../view/cell/CellPath';\nimport Rectangle from '../view/geometry/Rectangle';\n/**\n * Removes the cursors from the style of the given DOM node and its\n * descendants.\n *\n * @param element DOM node to remove the cursor style from.\n */\nexport const removeCursors = (element) => {\n    if (element.style) {\n        element.style.cursor = '';\n    }\n    const children = element.children;\n    if (children) {\n        const childCount = children.length;\n        for (let i = 0; i < childCount; i += 1) {\n            removeCursors(children[i]);\n        }\n    }\n};\n/**\n * Returns the current style of the specified element.\n *\n * @param element DOM node whose current style should be returned.\n */\nexport const getCurrentStyle = (element) => {\n    return !element || element.toString() === '[object ShadowRoot]'\n        ? null\n        : window.getComputedStyle(element, '');\n};\n/**\n * Function: parseCssNumber\n *\n * Parses the given CSS numeric value adding handling for the values thin,\n * medium and thick (2, 4 and 6).\n */\nexport const parseCssNumber = (value) => {\n    if (value === 'thin') {\n        value = '2';\n    }\n    else if (value === 'medium') {\n        value = '4';\n    }\n    else if (value === 'thick') {\n        value = '6';\n    }\n    let n = parseFloat(value);\n    if (Number.isNaN(n)) {\n        n = 0;\n    }\n    return n;\n};\n/**\n * Function: setPrefixedStyle\n *\n * Adds the given style with the standard name and an optional vendor prefix for the current\n * browser.\n *\n * ```javascript\n * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\n * ```\n */\nexport const setPrefixedStyle = (style, name, value) => {\n    let prefix = null;\n    if (Client.IS_SF || Client.IS_GC) {\n        prefix = 'Webkit';\n    }\n    else if (Client.IS_MT) {\n        prefix = 'Moz';\n    }\n    style.setProperty(name, value);\n    if (prefix !== null && name.length > 0) {\n        name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n        style.setProperty(name, value);\n    }\n};\n/**\n * Function: hasScrollbars\n *\n * Returns true if the overflow CSS property of the given node is either\n * scroll or auto.\n *\n * @param node DOM node whose style should be checked for scrollbars.\n */\nexport const hasScrollbars = (node) => {\n    const style = getCurrentStyle(node);\n    return !!style && (style.overflow === 'scroll' || style.overflow === 'auto');\n};\n/**\n * Returns the client size for the current document as an {@link Rectangle}.\n */\nexport const getDocumentSize = () => {\n    const b = document.body;\n    const d = document.documentElement;\n    try {\n        return new Rectangle(0, 0, b.clientWidth ?? d.clientWidth, Math.max(b.clientHeight ?? 0, d.clientHeight));\n    }\n    catch (e) {\n        return new Rectangle();\n    }\n};\n/**\n * Makes sure the given node is inside the visible area of the window. This\n * is done by setting the left and top in the style.\n */\nexport const fit = (node) => {\n    const ds = getDocumentSize();\n    const left = node.offsetLeft;\n    const width = node.offsetWidth;\n    const offset = getDocumentScrollOrigin(node.ownerDocument);\n    const sl = offset.x;\n    const st = offset.y;\n    const right = sl + ds.width;\n    if (left + width > right) {\n        node.style.left = `${Math.max(sl, right - width)}px`;\n    }\n    const top = node.offsetTop;\n    const height = node.offsetHeight;\n    const bottom = st + ds.height;\n    if (top + height > bottom) {\n        node.style.top = `${Math.max(st, bottom - height)}px`;\n    }\n};\n/**\n * Returns the offset for the specified container as an {@link Point}. The\n * offset is the distance from the top left corner of the container to the\n * top left corner of the document.\n *\n * @param container DOM node to return the offset for.\n * @param scollOffset Optional boolean to add the scroll offset of the document.\n * Default is false.\n */\nexport const getOffset = (container, scrollOffset = false) => {\n    let offsetLeft = 0;\n    let offsetTop = 0;\n    // Ignores document scroll origin for fixed elements\n    let fixed = false;\n    let node = container;\n    const b = document.body;\n    const d = document.documentElement;\n    while (node != null && node != b && node != d && !fixed) {\n        const style = getCurrentStyle(node);\n        if (style != null) {\n            fixed = fixed || style.position == 'fixed';\n        }\n        node = node.parentNode;\n    }\n    if (!scrollOffset && !fixed) {\n        const offset = getDocumentScrollOrigin(container.ownerDocument);\n        offsetLeft += offset.x;\n        offsetTop += offset.y;\n    }\n    const r = container.getBoundingClientRect();\n    if (r != null) {\n        offsetLeft += r.left;\n        offsetTop += r.top;\n    }\n    return new Point(offsetLeft, offsetTop);\n};\n/**\n * Returns the scroll origin of the given document or the current document\n * if no document is given.\n */\nexport const getDocumentScrollOrigin = (doc) => {\n    // @ts-ignore 'parentWindow' is an unknown property.\n    const wnd = doc.defaultView || doc.parentWindow;\n    const x = wnd != null && window.pageXOffset !== undefined\n        ? window.pageXOffset\n        : (document.documentElement || document.body.parentNode || document.body)\n            .scrollLeft;\n    const y = wnd != null && window.pageYOffset !== undefined\n        ? window.pageYOffset\n        : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n    return new Point(x, y);\n};\n/**\n * Returns the top, left corner of the viewrect as an {@link Point}.\n *\n * @param node DOM node whose scroll origin should be returned.\n * @param includeAncestors Whether the scroll origin of the ancestors should be\n * included. Default is false.\n * @param includeDocument Whether the scroll origin of the document should be\n * included. Default is true.\n */\nexport const getScrollOrigin = (node = null, includeAncestors = false, includeDocument = true) => {\n    const doc = node != null ? node.ownerDocument : document;\n    const b = doc.body;\n    const d = doc.documentElement;\n    const result = new Point();\n    let fixed = false;\n    while (node != null && node != b && node != d) {\n        if (!Number.isNaN(node.scrollLeft) && !Number.isNaN(node.scrollTop)) {\n            result.x += node.scrollLeft;\n            result.y += node.scrollTop;\n        }\n        const style = getCurrentStyle(node);\n        if (style != null) {\n            fixed = fixed || style.position == 'fixed';\n        }\n        node = includeAncestors ? node.parentNode : null;\n    }\n    if (!fixed && includeDocument) {\n        const origin = getDocumentScrollOrigin(doc);\n        result.x += origin.x;\n        result.y += origin.y;\n    }\n    return result;\n};\n/**\n * Converts the specified point (x, y) using the offset of the specified\n * container and returns a new {@link Point} with the result.\n *\n * ```javascript\n * let pt = mxUtils.convertPoint(graph.container,\n *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n * ```\n *\n * @param container DOM node to use for the offset.\n * @param x X-coordinate of the point to be converted.\n * @param y Y-coordinate of the point to be converted.\n */\nexport const convertPoint = (container, x, y) => {\n    const origin = getScrollOrigin(container, false);\n    const offset = getOffset(container);\n    offset.x -= origin.x;\n    offset.y -= origin.y;\n    return new Point(x - offset.x, y - offset.y);\n};\n/**\n * Assigns the value for the given key in the styles of the given cells, or\n * removes the key from the styles if the value is null.\n *\n * @param model <Transactions> to execute the transaction in.\n * @param cells Array of {@link Cell}s to be updated.\n * @param key Key of the style to be changed.\n * @param value New value for the given key.\n */\nexport const setCellStyles = (model, cells, key, value) => {\n    if (cells.length > 0) {\n        model.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                if (cell) {\n                    // Currently, the style object must be cloned, otherwise model.setStyle does not trigger the change event and the cell state in the view is not updated\n                    const style = cell.getClonedStyle();\n                    style[key] = value;\n                    model.setStyle(cell, style);\n                }\n            }\n        });\n    }\n};\n/**\n * Sets or toggles the flag bit for the given key in the cell's styles.\n * If the `value` parameter is not set, then the flag is toggled.\n *\n * Example that toggles the bold font style:\n *\n * ```javascript\n * const cells = graph.getSelectionCells();\n * setCellStyleFlags(graph.model,\n *       cells,\n *       'fontStyle',\n *       constants.FONT.BOLD);\n * ```\n *\n * @param model <Transactions> that contains the cells.\n * @param cells Array of {@link Cell}s to change the style for.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the flag.\n */\nexport const setCellStyleFlags = (model, cells, key, flag, value) => {\n    if (cells.length > 0) {\n        model.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                if (cell) {\n                    // Currently, the style object must be cloned, otherwise model.setStyle does not trigger the change event and the cell state in the view is not updated\n                    const style = setStyleFlag(cell.getClonedStyle(), key, flag, value);\n                    model.setStyle(cell, style);\n                }\n            }\n        });\n    }\n};\n/**\n * Sets or toggles the flag bit for the given key in the cell's style.\n * If the `value` parameter is not set, then the flag is toggled.\n *\n * @param style The style of the Cell.\n * @param key Key of the style to be changed.\n * @param flag Integer for the bit to be changed.\n * @param value Optional boolean value for the given flag.\n */\nexport const setStyleFlag = (style, key, flag, value) => {\n    const v = style[key];\n    if (v === undefined) {\n        style[key] = value === undefined || value ? flag : 0;\n    }\n    else {\n        if (value === undefined) {\n            style[key] = v ^ flag;\n        }\n        else if (value) {\n            style[key] = v | flag;\n        }\n        else {\n            style[key] = v & ~flag;\n        }\n    }\n    return style;\n};\n/**\n * Sets the opacity of the specified DOM node to the given value in %.\n *\n * @param node DOM node to set the opacity for.\n * @param value Opacity in %. Possible values are between 0 and 100.\n */\nexport const setOpacity = (node, value) => {\n    node.style.opacity = String(value / 100);\n};\n/**\n * @param value the value to check.\n * @param mask the binary mask to apply.\n * @returns `true` if the value matches the binary mask.\n * @private Subject to change prior being part of the public API.\n */\nexport const matchBinaryMask = (value, mask) => {\n    return (value & mask) === mask;\n};\n/**\n * Returns an {@link Rectangle} with the size (width and height in pixels) of\n * the given string. The string may contain HTML markup. Newlines should be\n * converted to <br> before calling this method. The caller is responsible\n * for sanitizing the HTML markup.\n *\n * Example:\n *\n * ```javascript\n * let label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\n * let size = graph.getSizeForString(label);\n * ```\n *\n * @param text String whose size should be returned.\n * @param fontSize Integer that specifies the font size in pixels. Default is\n * {@link Constants#DEFAULT_FONTSIZE}.\n * @param fontFamily String that specifies the name of the font family. Default\n * is {@link Constants#DEFAULT_FONTFAMILY}.\n * @param textWidth Optional width for text wrapping.\n * @param fontStyle Optional font style.\n */\nexport const getSizeForString = (text, fontSize = DEFAULT_FONTSIZE, fontFamily = DEFAULT_FONTFAMILY, textWidth = null, fontStyle = null) => {\n    const div = document.createElement('div');\n    // Sets the font size and family\n    div.style.fontFamily = fontFamily;\n    div.style.fontSize = `${Math.round(fontSize)}px`;\n    div.style.lineHeight = `${Math.round(fontSize * LINE_HEIGHT)}px`;\n    // Sets the font style\n    if (fontStyle !== null) {\n        matchBinaryMask(fontStyle, FONT.BOLD) && (div.style.fontWeight = 'bold');\n        matchBinaryMask(fontStyle, FONT.ITALIC) && (div.style.fontWeight = 'italic');\n        const txtDecor = [];\n        matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (div.style.textDecoration = txtDecor.join(' '));\n    }\n    // Disables block layout and outside wrapping and hides the div\n    div.style.position = 'absolute';\n    div.style.visibility = 'hidden';\n    div.style.display = 'inline-block';\n    if (textWidth !== null) {\n        div.style.width = `${textWidth}px`;\n        div.style.whiteSpace = 'normal';\n    }\n    else {\n        div.style.whiteSpace = 'nowrap';\n    }\n    // Adds the text and inserts into DOM for updating of size\n    div.innerHTML = text;\n    document.body.appendChild(div);\n    // Gets the size and removes from DOM\n    const size = new Rectangle(0, 0, div.offsetWidth, div.offsetHeight);\n    document.body.removeChild(div);\n    return size;\n};\n/**\n * Sorts the given cells according to the order in the cell hierarchy.\n * Ascending is optional and defaults to true.\n */\nexport const sortCells = (cells, ascending = true) => {\n    const lookup = new Dictionary();\n    cells.sort((o1, o2) => {\n        let p1 = lookup.get(o1);\n        if (p1 == null) {\n            p1 = CellPath.create(o1).split(CellPath.PATH_SEPARATOR);\n            lookup.put(o1, p1);\n        }\n        let p2 = lookup.get(o2);\n        if (p2 == null) {\n            p2 = CellPath.create(o2).split(CellPath.PATH_SEPARATOR);\n            lookup.put(o2, p2);\n        }\n        const comp = CellPath.compare(p1, p2);\n        return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;\n    });\n    return cells;\n};\n/**\n * Returns an {@link Point} that represents the horizontal and vertical alignment\n * for numeric computations. X is -0.5 for center, -1 for right and 0 for\n * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\n * alignment. Default values for missing arguments is top, left.\n */\nexport const getAlignmentAsPoint = (align, valign) => {\n    let dx = -0.5;\n    let dy = -0.5;\n    // Horizontal alignment\n    if (align === ALIGN.LEFT) {\n        dx = 0;\n    }\n    else if (align === ALIGN.RIGHT) {\n        dx = -1;\n    }\n    // Vertical alignment\n    if (valign === ALIGN.TOP) {\n        dy = 0;\n    }\n    else if (valign === ALIGN.BOTTOM) {\n        dy = -1;\n    }\n    return new Point(dx, dy);\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Implements a mechanism for temporary cell Ids.\n * @class CellPath\n */\nclass CellPath {\n    constructor() {\n        throw new Error(\"Static class can't be instantiated!\");\n    }\n    /**\n     * Creates the cell path for the given cell. The cell path is a\n     * concatenation of the indices of all ancestors on the (finite) path to\n     * the root, eg. \"0.0.0.1\".\n     *\n     * @param cell Cell whose path should be returned.\n     */\n    static create(cell) {\n        let result = '';\n        let parent = cell.getParent();\n        while (parent) {\n            const index = parent.getIndex(cell);\n            result = index + CellPath.PATH_SEPARATOR + result;\n            cell = parent;\n            parent = cell.getParent();\n        }\n        // Remove trailing separator\n        const n = result.length;\n        if (n > 1) {\n            result = result.substring(0, n - 1);\n        }\n        return result;\n    }\n    /**\n     * Returns the path for the parent of the cell represented by the given\n     * path. Returns null if the given path has no parent.\n     *\n     * @param path Path whose parent path should be returned.\n     */\n    static getParentPath(path) {\n        const index = path.lastIndexOf(CellPath.PATH_SEPARATOR);\n        if (index >= 0) {\n            return path.substring(0, index);\n        }\n        if (path.length > 0) {\n            return '';\n        }\n        return null;\n    }\n    /**\n     * Returns the cell for the specified cell path using the given root as the\n     * root of the path.\n     *\n     * @param root Root cell of the path to be resolved.\n     * @param path String that defines the path.\n     */\n    static resolve(root, path) {\n        let parent = root;\n        const tokens = path.split(CellPath.PATH_SEPARATOR);\n        for (let i = 0; i < tokens.length; i += 1) {\n            parent = parent.getChildAt(parseInt(tokens[i]));\n        }\n        return parent;\n    }\n    /**\n     * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n     * p1 is equal and 1 if p1 is greater than p2.\n     */\n    static compare(p1, p2) {\n        const min = Math.min(p1.length, p2.length);\n        let comp = 0;\n        for (let i = 0; i < min; i += 1) {\n            if (p1[i] !== p2[i]) {\n                if (p1[i].length === 0 || p2[i].length === 0) {\n                    comp = p1[i] === p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;\n                }\n                else {\n                    const t1 = parseInt(p1[i]);\n                    const t2 = parseInt(p2[i]);\n                    comp = t1 === t2 ? 0 : t1 > t2 ? 1 : -1;\n                }\n                break;\n            }\n        }\n        // Compares path length if both paths are equal to this point\n        if (comp === 0) {\n            const t1 = p1.length;\n            const t2 = p2.length;\n            if (t1 !== t2) {\n                comp = t1 > t2 ? 1 : -1;\n            }\n        }\n        return comp;\n    }\n}\n/**\n * Defines the separator between the path components. Default is \".\".\n */\nCellPath.PATH_SEPARATOR = '.';\nexport default CellPath;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Converts relative and absolute URLs to absolute URLs with protocol and domain.\n */\nclass UrlConverter {\n    constructor() {\n        /**\n         * Specifies if the converter is enabled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies the base URL to be used as a prefix for relative URLs.\n         */\n        this.baseUrl = null;\n        /**\n         * Specifies the base domain to be used as a prefix for absolute URLs.\n         */\n        this.baseDomain = null;\n        // Empty constructor\n    }\n    /**\n     * Private helper function to update the base URL.\n     */\n    updateBaseUrl() {\n        this.baseDomain = `${location.protocol}//${location.host}`;\n        this.baseUrl = this.baseDomain + location.pathname;\n        const tmp = this.baseUrl.lastIndexOf('/');\n        // Strips filename etc\n        if (tmp > 0) {\n            this.baseUrl = this.baseUrl.substring(0, tmp + 1);\n        }\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns <baseUrl>.\n     */\n    getBaseUrl() {\n        return this.baseUrl;\n    }\n    /**\n     * Sets <baseUrl>.\n     */\n    setBaseUrl(value) {\n        this.baseUrl = value;\n    }\n    /**\n     * Returns <baseDomain>.\n     */\n    getBaseDomain() {\n        return this.baseDomain;\n    }\n    /**\n     * Sets <baseDomain>.\n     */\n    setBaseDomain(value) {\n        this.baseDomain = value;\n    }\n    /**\n     * Returns true if the given URL is relative.\n     */\n    isRelativeUrl(url) {\n        return (url &&\n            url.substring(0, 2) !== '//' &&\n            url.substring(0, 7) !== 'http://' &&\n            url.substring(0, 8) !== 'https://' &&\n            url.substring(0, 10) !== 'data:image' &&\n            url.substring(0, 7) !== 'file://');\n    }\n    /**\n     * Converts the given URL to an absolute URL with protol and domain.\n     * Relative URLs are first converted to absolute URLs.\n     */\n    convert(url) {\n        if (this.isEnabled() && this.isRelativeUrl(url)) {\n            if (!this.getBaseUrl()) {\n                this.updateBaseUrl();\n            }\n            if (url.charAt(0) === '/') {\n                url = this.getBaseDomain() + url;\n            }\n            else {\n                url = this.getBaseUrl() + url;\n            }\n        }\n        return url;\n    }\n}\nexport default UrlConverter;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from './ObjectIdentity';\n/**\n * Recursively clones the specified object ignoring all fieldnames in the\n * given array of transient fields. {@link ObjectIdentity#FIELD_NAME} is always\n * ignored by this function.\n *\n * @param obj Object to be cloned.\n * @param transients Optional array of strings representing the fieldname to be\n * ignored.\n * @param shallow Optional boolean argument to specify if a shallow clone should\n * be created, that is, one where all object references are not cloned or,\n * in other words, one where only atomic (strings, numbers) values are\n * cloned. Default is false.\n */\nexport const clone = function _clone(obj, transients = null, shallow = false) {\n    shallow = shallow != null ? shallow : false;\n    let clone = null;\n    if (obj != null && typeof obj.constructor === 'function') {\n        clone = new obj.constructor();\n        for (const i in obj) {\n            if (i != ObjectIdentity.FIELD_NAME &&\n                (transients == null || transients.indexOf(i) < 0)) {\n                if (!shallow && typeof obj[i] === 'object') {\n                    clone[i] = _clone(obj[i]);\n                }\n                else {\n                    clone[i] = obj[i];\n                }\n            }\n        }\n    }\n    return clone;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { arcToCurves, getRotatedPoint } from '../../util/mathUtils';\nimport { DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DIRECTION, NONE, SHADOWCOLOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y, SHADOW_OPACITY, } from '../../util/Constants';\nimport UrlConverter from '../../util/UrlConverter';\nimport Point from '../geometry/Point';\nimport { clone } from '../../util/cloneUtils';\n/**\n * Base class for all canvases. A description of the public API is available in <mxXmlCanvas2D>.\n * All color values of {@link Constants#NONE} will be converted to null in the state.\n *\n * Constructor: D\n *\n * Constructs a new abstract canvas.\n */\nclass AbstractCanvas2D {\n    constructor() {\n        /**\n         * Holds the current state.\n         */\n        this.state = this.createState();\n        /**\n         * Stack of states.\n         */\n        this.states = [];\n        /**\n         * Holds the current path as an array.\n         */\n        this.path = [];\n        /**\n         * Switch for rotation of HTML. Default is false.\n         */\n        this.rotateHtml = true;\n        /**\n         * Holds the last x coordinate.\n         */\n        this.lastX = 0;\n        /**\n         * Holds the last y coordinate.\n         */\n        this.lastY = 0;\n        /**\n         * Contains the string used for moving in paths. Default is 'M'.\n         */\n        this.moveOp = 'M';\n        /**\n         * Contains the string used for moving in paths. Default is 'L'.\n         */\n        this.lineOp = 'L';\n        /**\n         * Contains the string used for quadratic paths. Default is 'Q'.\n         */\n        this.quadOp = 'Q';\n        /**\n         * Contains the string used for bezier curves. Default is 'C'.\n         */\n        this.curveOp = 'C';\n        /**\n         * Holds the operator for closing curves. Default is 'Z'.\n         */\n        this.closeOp = 'Z';\n        /**\n         * Boolean value that specifies if events should be handled. Default is false.\n         */\n        this.pointerEvents = false;\n        // from Polyline (maybe from other shapes also)\n        this.pointerEventsValue = null;\n        /**\n         * Adds the given operation to the path.\n         */\n        this.addOp = (op, ...args) => {\n            this.path.push(op);\n            if (args.length > 1) {\n                const s = this.state;\n                for (let i = 1; i < args.length; i += 2) {\n                    this.lastX = args[i - 1];\n                    this.lastY = args[i];\n                    this.path.push(this.format((this.lastX + s.dx) * s.scale));\n                    this.path.push(this.format((this.lastY + s.dy) * s.scale));\n                }\n            }\n        };\n        this.converter = this.createUrlConverter();\n        this.reset();\n    }\n    /**\n     * Create a new <UrlConverter> and returns it.\n     */\n    createUrlConverter() {\n        return new UrlConverter();\n    }\n    /**\n     * Resets the state of this canvas.\n     */\n    reset() {\n        this.state = this.createState();\n        this.states = [];\n    }\n    /**\n     * Creates the state of the this canvas.\n     */\n    createState() {\n        return {\n            dx: 0,\n            dy: 0,\n            scale: 1,\n            alpha: 1,\n            fillAlpha: 1,\n            strokeAlpha: 1,\n            fillColor: NONE,\n            gradientFillAlpha: 1,\n            gradientColor: NONE,\n            gradientAlpha: 1,\n            gradientDirection: DIRECTION.EAST,\n            strokeColor: NONE,\n            strokeWidth: 1,\n            dashed: false,\n            dashPattern: '3 3',\n            fixDash: false,\n            lineCap: 'flat',\n            lineJoin: 'miter',\n            miterLimit: 10,\n            fontColor: '#000000',\n            fontBackgroundColor: NONE,\n            fontBorderColor: NONE,\n            fontSize: DEFAULT_FONTSIZE,\n            fontFamily: DEFAULT_FONTFAMILY,\n            fontStyle: 0,\n            shadow: false,\n            shadowColor: SHADOWCOLOR,\n            shadowAlpha: SHADOW_OPACITY,\n            shadowDx: SHADOW_OFFSET_X,\n            shadowDy: SHADOW_OFFSET_Y,\n            rotation: 0,\n            rotationCx: 0,\n            rotationCy: 0,\n        };\n    }\n    /**\n     * Rounds all numbers to integers.\n     */\n    format(value) {\n        return Math.round(value);\n    }\n    /**\n     * Rotates the given point and returns the result as an {@link Point}.\n     */\n    rotatePoint(x, y, theta, cx, cy) {\n        const rad = theta * (Math.PI / 180);\n        return getRotatedPoint(new Point(x, y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));\n    }\n    /**\n     * Saves the current state.\n     */\n    save() {\n        this.states.push(this.state);\n        this.state = clone(this.state);\n    }\n    /**\n     * Restores the current state.\n     */\n    restore() {\n        const state = this.states.pop();\n        if (state)\n            this.state = state;\n    }\n    /**\n     * Sets the current link. Hook for subclassers.\n     */\n    setLink(link) {\n        // nop\n    }\n    /**\n     * Scales the current state.\n     */\n    scale(value) {\n        this.state.scale *= value;\n        if (this.state.strokeWidth !== null)\n            this.state.strokeWidth *= value;\n    }\n    /**\n     * Translates the current state.\n     */\n    translate(dx, dy) {\n        this.state.dx += dx;\n        this.state.dy += dy;\n    }\n    /**\n     * Rotates the current state.\n     */\n    rotate(theta, flipH, flipV, cx, cy) {\n        // nop\n    }\n    /**\n     * Sets the current alpha.\n     */\n    setAlpha(value) {\n        this.state.alpha = value;\n    }\n    /**\n     * Sets the current solid fill alpha.\n     */\n    setFillAlpha(value) {\n        this.state.fillAlpha = value;\n    }\n    /**\n     * Sets the current stroke alpha.\n     */\n    setStrokeAlpha(value) {\n        this.state.strokeAlpha = value;\n    }\n    /**\n     * Sets the current fill color.\n     */\n    setFillColor(value) {\n        this.state.fillColor = value ?? NONE;\n        this.state.gradientColor = NONE;\n    }\n    /**\n     * Sets the current gradient.\n     */\n    setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1, alpha2 = 1) {\n        const s = this.state;\n        s.fillColor = color1;\n        s.gradientFillAlpha = alpha1;\n        s.gradientColor = color2;\n        s.gradientAlpha = alpha2;\n        s.gradientDirection = direction;\n    }\n    /**\n     * Sets the current stroke color.\n     */\n    setStrokeColor(value) {\n        this.state.strokeColor = value ?? NONE;\n    }\n    /**\n     * Sets the current stroke width.\n     */\n    setStrokeWidth(value) {\n        this.state.strokeWidth = value;\n    }\n    /**\n     * Enables or disables dashed lines.\n     */\n    setDashed(value, fixDash = false) {\n        this.state.dashed = value;\n        this.state.fixDash = fixDash;\n    }\n    /**\n     * Sets the current dash pattern.\n     */\n    setDashPattern(value) {\n        this.state.dashPattern = value;\n    }\n    /**\n     * Sets the current line cap.\n     */\n    setLineCap(value) {\n        this.state.lineCap = value;\n    }\n    /**\n     * Sets the current line join.\n     */\n    setLineJoin(value) {\n        this.state.lineJoin = value;\n    }\n    /**\n     * Sets the current miter limit.\n     */\n    setMiterLimit(value) {\n        this.state.miterLimit = value;\n    }\n    /**\n     * Sets the current font color.\n     */\n    setFontColor(value) {\n        this.state.fontColor = value ?? NONE;\n    }\n    /**\n     * Sets the current font background color.\n     */\n    setFontBackgroundColor(value) {\n        this.state.fontBackgroundColor = value ?? NONE;\n    }\n    /**\n     * Sets the current font border color.\n     */\n    setFontBorderColor(value) {\n        this.state.fontBorderColor = value ?? NONE;\n    }\n    /**\n     * Sets the current font size.\n     */\n    setFontSize(value) {\n        this.state.fontSize = value;\n    }\n    /**\n     * Sets the current font family.\n     */\n    setFontFamily(value) {\n        this.state.fontFamily = value;\n    }\n    /**\n     * Sets the current font style.\n     */\n    setFontStyle(value) {\n        this.state.fontStyle = value;\n    }\n    /**\n     * Enables or disables and configures the current shadow.\n     */\n    setShadow(enabled) {\n        this.state.shadow = enabled;\n    }\n    /**\n     * Enables or disables and configures the current shadow.\n     */\n    setShadowColor(value) {\n        this.state.shadowColor = value ?? NONE;\n    }\n    /**\n     * Enables or disables and configures the current shadow.\n     */\n    setShadowAlpha(value) {\n        this.state.shadowAlpha = value;\n    }\n    /**\n     * Enables or disables and configures the current shadow.\n     */\n    setShadowOffset(dx, dy) {\n        this.state.shadowDx = dx;\n        this.state.shadowDy = dy;\n    }\n    /**\n     * Starts a new path.\n     */\n    begin() {\n        this.lastX = 0;\n        this.lastY = 0;\n        this.path = [];\n    }\n    /**\n     *  Moves the current path the given coordinates.\n     */\n    moveTo(x, y) {\n        this.addOp(this.moveOp, x, y);\n    }\n    /**\n     * Draws a line to the given coordinates. Uses moveTo with the op argument.\n     */\n    lineTo(x, y) {\n        this.addOp(this.lineOp, x, y);\n    }\n    /**\n     * Adds a quadratic curve to the current path.\n     */\n    quadTo(x1, y1, x2, y2) {\n        this.addOp(this.quadOp, x1, y1, x2, y2);\n    }\n    /**\n     * Adds a bezier curve to the current path.\n     */\n    curveTo(x1, y1, x2, y2, x3, y3) {\n        this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);\n    }\n    /**\n     * Adds the given arc to the current path. This is a synthetic operation that\n     * is broken down into curves.\n     * @param rx: The x distance between the current position\n     *            and the center of the ellipse around which to arc\n     * @param ry: The y distance between the current position\n     *            and the center of the ellipse around which to arc\n     * @param x: The x position of the end point of the arc\n     * @param y: The y position of the end point of the arc\n     */\n    arcTo(rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n        const curves = arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);\n        if (curves != null) {\n            for (let i = 0; i < curves.length; i += 6) {\n                this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);\n            }\n        }\n    }\n    /**\n     * Closes the current path.\n     */\n    close(x1, y1, x2, y2, x3, y3) {\n        this.addOp(this.closeOp);\n    }\n}\nexport default AbstractCanvas2D;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIALECT, NODETYPE, NS_SVG } from './Constants';\nimport Point from '../view/geometry/Point';\nimport { htmlEntities, trim } from './StringUtils';\nimport TemporaryCellStates from '../view/cell/TemporaryCellStates';\nimport { getTextContent } from './domUtils';\nimport Codec from '../serialization/Codec';\n/**\n * Returns a new, empty XML document.\n */\nexport const createXmlDocument = () => {\n    return document.implementation.createDocument('', '', null);\n};\nexport const parseXml = (xmlString) => {\n    return new DOMParser().parseFromString(xmlString, 'text/xml');\n};\nexport const getViewXml = (graph, scale = 1, cells = null, x0 = 0, y0 = 0) => {\n    if (cells == null) {\n        const model = graph.getDataModel();\n        cells = [model.getRoot()];\n    }\n    const view = graph.getView();\n    let result = null;\n    // Disables events on the view\n    const eventsEnabled = view.isEventsEnabled();\n    view.setEventsEnabled(false);\n    // Workaround for label bounds not taken into account for image export.\n    // Creates a temporary draw pane which is used for rendering the text.\n    // Text rendering is required for finding the bounds of the labels.\n    const { drawPane } = view;\n    const { overlayPane } = view;\n    if (graph.dialect === DIALECT.SVG) {\n        view.drawPane = document.createElementNS(NS_SVG, 'g');\n        view.canvas.appendChild(view.drawPane);\n        // Redirects cell overlays into temporary container\n        view.overlayPane = document.createElementNS(NS_SVG, 'g');\n        view.canvas.appendChild(view.overlayPane);\n    }\n    else {\n        view.drawPane = view.drawPane.cloneNode(false);\n        view.canvas.appendChild(view.drawPane);\n        // Redirects cell overlays into temporary container\n        view.overlayPane = view.overlayPane.cloneNode(false);\n        view.canvas.appendChild(view.overlayPane);\n    }\n    // Resets the translation\n    const translate = view.getTranslate();\n    view.translate = new Point(x0, y0);\n    // Creates the temporary cell states in the view\n    const temp = new TemporaryCellStates(graph.getView(), scale, cells);\n    try {\n        const enc = new Codec();\n        result = enc.encode(graph.getView());\n    }\n    finally {\n        temp.destroy();\n        view.translate = translate;\n        view.canvas.removeChild(view.drawPane);\n        view.canvas.removeChild(view.overlayPane);\n        view.drawPane = drawPane;\n        view.overlayPane = overlayPane;\n        view.setEventsEnabled(eventsEnabled);\n    }\n    return result;\n};\n/**\n * Returns the XML content of the specified node.\n *\n * All `\\n` are then replaced with the linefeed parameter value.\n *\n * @param node DOM node to return the XML for.\n * @param linefeed Optional string that linefeed are converted into. Default is `&#xa;`.\n */\nexport const getXml = (node, linefeed = '&#xa;') => {\n    const xmlSerializer = new XMLSerializer();\n    let xml = xmlSerializer.serializeToString(node);\n    // Replaces linefeed with HTML Entities.\n    xml = xml.replace(/\\n/g, linefeed);\n    return xml;\n};\n/**\n * Returns a pretty printed string that represents the XML tree for the\n * given node. This method should only be used to print XML for reading,\n * use <getXml> instead to obtain a string for processing.\n *\n * @param node DOM node to return the XML for.\n * @param tab Optional string that specifies the indentation for one level.\n * @param indent Optional string that represents the current indentation.\n * @param newline Optional string that represents a linefeed.\n * @param ns Optional string that represents the target namespace URI.\n */\nexport const getPrettyXml = (node, tab = '  ', indent = '', newline = '\\n', ns = null) => {\n    const result = [];\n    if (node != null) {\n        if (node.namespaceURI != null && node.namespaceURI !== ns) {\n            ns = node.namespaceURI;\n            if (node.getAttribute('xmlns') == null) {\n                node.setAttribute('xmlns', node.namespaceURI);\n            }\n        }\n        if (node.nodeType === NODETYPE.DOCUMENT) {\n            result.push(getPrettyXml(node.documentElement, tab, indent, newline, ns));\n        }\n        else if (node.nodeType === NODETYPE.DOCUMENT_FRAGMENT) {\n            let tmp = node.firstChild;\n            if (tmp != null) {\n                while (tmp != null) {\n                    result.push(getPrettyXml(tmp, tab, indent, newline, ns));\n                    tmp = tmp.nextSibling;\n                }\n            }\n        }\n        else if (node.nodeType === NODETYPE.COMMENT) {\n            const value = getTextContent(node);\n            if (value.length > 0) {\n                result.push(`${indent}<!--${value}-->${newline}`);\n            }\n        }\n        else if (node.nodeType === NODETYPE.TEXT) {\n            const value = trim(getTextContent(node));\n            if (value && value.length > 0) {\n                result.push(indent + htmlEntities(value, false) + newline);\n            }\n        }\n        else if (node.nodeType === NODETYPE.CDATA) {\n            const value = getTextContent(node);\n            if (value.length > 0) {\n                result.push(`${indent}<![CDATA[${value}]]${newline}`);\n            }\n        }\n        else {\n            result.push(`${indent}<${node.nodeName}`);\n            // Creates the string with the node attributes\n            // and converts all HTML entities in the values\n            const attrs = node.attributes;\n            if (attrs != null) {\n                for (let i = 0; i < attrs.length; i += 1) {\n                    const val = htmlEntities(attrs[i].value);\n                    result.push(` ${attrs[i].nodeName}=\"${val}\"`);\n                }\n            }\n            // Recursively creates the XML string for each child\n            // node and appends it here with an indentation\n            let tmp = node.firstChild;\n            if (tmp != null) {\n                result.push(`>${newline}`);\n                while (tmp != null) {\n                    result.push(getPrettyXml(tmp, tab, indent + tab, newline, ns));\n                    tmp = tmp.nextSibling;\n                }\n                result.push(`${indent}</${node.nodeName}>${newline}`);\n            }\n            else {\n                result.push(` />${newline}`);\n            }\n        }\n    }\n    return result.join('');\n};\n/**\n * Returns the first node where attr equals value.\n * This implementation does not use XPath.\n */\nexport const findNode = (node, attr, value) => {\n    if (node.nodeType === NODETYPE.ELEMENT) {\n        const tmp = node.getAttribute(attr);\n        if (tmp && tmp === value) {\n            return node;\n        }\n    }\n    node = node.firstChild;\n    while (node) {\n        const result = findNode(node, attr, value);\n        if (result) {\n            return result;\n        }\n        node = node.nextSibling;\n    }\n    return null;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\n/**\n * Creates a temporary set of cell states.\n */\nclass TemporaryCellStates {\n    constructor(view, scale = 1, cells, isCellVisibleFn = null, getLinkForCellState = null) {\n        this.view = view;\n        // Stores the previous state\n        this.oldValidateCellState = view.validateCellState;\n        this.oldBounds = view.getGraphBounds();\n        this.oldStates = view.getStates();\n        this.oldScale = view.getScale();\n        this.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;\n        // Overrides doRedrawShape and paint shape to add links on shapes\n        if (getLinkForCellState != null) {\n            view.graph.cellRenderer.doRedrawShape = (state) => {\n                const shape = state?.shape;\n                const oldPaint = shape.paint;\n                shape.paint = (c) => {\n                    const link = getLinkForCellState(state);\n                    if (link != null) {\n                        c.setLink(link);\n                    }\n                    oldPaint.apply(shape, [c]);\n                    if (link != null) {\n                        c.setLink(null);\n                    }\n                };\n                this.oldDoRedrawShape.apply(view.graph.cellRenderer, [state]);\n                shape.paint = oldPaint;\n            };\n        }\n        // Overrides validateCellState to ignore invisible cells\n        view.validateCellState = (cell, recurse) => {\n            if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {\n                return this.oldValidateCellState.apply(view, [cell, recurse]);\n            }\n            return null;\n        };\n        // Creates space for new states\n        view.setStates(new Dictionary());\n        view.setScale(scale);\n        view.resetValidationState();\n        let bbox = null;\n        // Validates the vertices and edges without adding them to\n        // the model so that the original cells are not modified\n        for (const cell of cells) {\n            const bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cell)));\n            if (bbox == null) {\n                bbox = bounds;\n            }\n            else {\n                bbox.add(bounds);\n            }\n        }\n        view.setGraphBounds(bbox || new Rectangle());\n    }\n    destroy() {\n        const view = this.view;\n        view.setScale(this.oldScale);\n        view.setStates(this.oldStates);\n        view.setGraphBounds(this.oldBounds);\n        view.validateCellState = this.oldValidateCellState;\n        view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;\n    }\n}\nexport default TemporaryCellStates;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from './Dictionary';\n/**\n * Removes all occurrences of the given object in the given array or\n * object. If there are multiple occurrences of the object, be they\n * associative or as an array entry, all occurrences are removed from\n * the array or deleted from the object. By removing the object from\n * the array, all elements following the removed element are shifted\n * by one step towards the beginning of the array.\n *\n * The length of arrays is not modified inside this function.\n *\n * @param obj Object to find in the given array.\n * @param array Array to check for the given obj.\n */\nexport const remove = (obj, array) => {\n    let result = null;\n    if (typeof array === 'object') {\n        let index = array.indexOf(obj);\n        while (index >= 0) {\n            array.splice(index, 1);\n            result = obj;\n            index = array.indexOf(obj);\n        }\n    }\n    for (const key in array) {\n        if (array[key] == obj) {\n            delete array[key];\n            result = obj;\n        }\n    }\n    return result;\n};\n/**\n * Compares all Point in the given lists.\n *\n * @param a Array of <Point> to be compared.\n * @param b Array of <Point> to be compared.\n */\nexport const equalPoints = (a, b) => {\n    if ((!a && b) || (a && !b) || (a && b && a.length != b.length)) {\n        return false;\n    }\n    if (a && b) {\n        for (let i = 0; i < a.length; i += 1) {\n            const p = a[i];\n            if (!p || (p && !p.equals(b[i])))\n                return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns true if all properties of the given objects are equal. Values\n * with NaN are equal to NaN and unequal to any other value.\n *\n * @param a First object to be compared.\n * @param b Second object to be compared.\n */\nexport const equalEntries = (a, b) => {\n    // Counts keys in b to check if all values have been compared\n    let count = 0;\n    if ((!a && b) || (a && !b) || (a && b && a.length != b.length)) {\n        return false;\n    }\n    if (a && b) {\n        for (const key in b) {\n            count++;\n        }\n        for (const key in a) {\n            count--;\n            if ((!Number.isNaN(a[key]) || !Number.isNaN(b[key])) && a[key] !== b[key]) {\n                return false;\n            }\n        }\n    }\n    return count === 0;\n};\n/**\n * Removes all duplicates from the given array.\n */\nexport const removeDuplicates = (arr) => {\n    const dict = new Dictionary();\n    const result = [];\n    for (let i = 0; i < arr.length; i += 1) {\n        if (!dict.get(arr[i])) {\n            result.push(arr[i]);\n            dict.put(arr[i], true);\n        }\n    }\n    return result;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './Point';\nimport Rectangle from './Rectangle';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { equalPoints } from '../../util/arrayUtils';\nimport { clone } from '../../util/cloneUtils';\n/**\n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the {@link sourcePoint} and {@link targetPoint}\n * variables, respectively.\n *\n * ### Example\n *\n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n *\n * ```javascript\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points: [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * ```\n *\n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's {@link edgeStyle}.\n *\n * To disable automatic reset of control points after a cell has been moved or\n * resized, {@link graph.resetEdgesOnMove} and {@link graph.resetEdgesOnResize} may be used.\n *\n * ### Edge Labels\n *\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the {@link Geometry.offset} is used as an\n * absolute offset vector from the resulting point.\n *\n * This coordinate system is applied if {@link relative} is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for {@link x} and {@link y} are ignored.\n *\n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n *\n * ### Ports\n *\n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n *\n * ### Offsets\n *\n * The {@link offset} field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n */\nclass Geometry extends Rectangle {\n    constructor(x = 0, y = 0, width = 0, height = 0) {\n        super(x, y, width, height);\n        /**\n         * Global switch to translate the points in translate. Default is true.\n         */\n        this.TRANSLATE_CONTROL_POINTS = true;\n        /**\n         * Stores alternate values for x, y, width and height in a rectangle.\n         * See {@link swap} to exchange the values. Default is null.\n         *\n         * @see {@link swap}\n         */\n        this.alternateBounds = null;\n        /**\n         * Defines the source {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a source vertex. Otherwise, it is ignored.\n         * @default null\n         */\n        this.sourcePoint = null;\n        /**\n         * Defines the source {@link Point} of the edge. This is used if the\n         * corresponding edge does not have a target vertex. Otherwise, it is ignored.\n         * @default null\n         */\n        this.targetPoint = null;\n        /**\n         * Array of {@link Point} which specifies the control points along the edge.\n         * These points are the intermediate points on the edge, for the endpoints\n         * use {@link targetPoint} and {@link sourcePoint} or set the terminals of the edge to\n         * a non-null value.\n         * @default null\n         */\n        this.points = null;\n        /**\n         * For edges, this holds the offset (in pixels) from the position defined by {@link x} and {@link y} on the edge.\n         *\n         * For relative geometries (for vertices), this defines the absolute offset from the point defined by the relative\n         * coordinates.\n         *\n         * For absolute geometries (for vertices), this defines the offset for the label.\n         * @default null\n         */\n        this.offset = null;\n        /**\n         * Specifies if the coordinates in the geometry are to be interpreted as relative coordinates.\n         *\n         * For edges, this is used to define the location of the edge label relative to the edge\n         * as rendered on the display.\n         *\n         * For vertices, this specifies the relative location inside the bounds of the parent cell.\n         *\n         * If this is `false`, then the coordinates are relative to the origin of the parent cell or,\n         * for edges, the edge label position is relative to the center of the edge as rendered on screen.\n         *\n         * @default false.\n         */\n        this.relative = false;\n    }\n    setRelative(isRelative) {\n        this.relative = isRelative;\n    }\n    /**\n     * Swaps the x, y, width and height with the values stored in\n     * {@link alternateBounds} and puts the previous values into {@link alternateBounds} as\n     * a rectangle. This operation is carried-out in-place, that is, using the\n     * existing geometry instance. If this operation is called during a graph\n     * model transactional change, then the geometry should be cloned before\n     * calling this method and setting the geometry of the cell using\n     * {@link GraphDataModel.setGeometry}.\n     */\n    swap() {\n        if (this.alternateBounds) {\n            const old = new Rectangle(this.x, this.y, this.width, this.height);\n            this.x = this.alternateBounds.x;\n            this.y = this.alternateBounds.y;\n            this.width = this.alternateBounds.width;\n            this.height = this.alternateBounds.height;\n            this.alternateBounds = old;\n        }\n    }\n    /**\n     * Returns the {@link Point} representing the source or target point of this\n     * edge. This is only used if the edge has no source or target vertex.\n     *\n     * @param {Boolean} isSource that specifies if the source or target point should be returned.\n     */\n    getTerminalPoint(isSource) {\n        return isSource ? this.sourcePoint : this.targetPoint;\n    }\n    /**\n     * Sets the {@link sourcePoint} or {@link targetPoint} to the given {@link Point} and\n     * returns the new point.\n     *\n     * @param {Point} point to be used as the new source or target point.\n     * @param {Boolean} isSource that specifies if the source or target point should be set.\n     */\n    setTerminalPoint(point, isSource) {\n        if (isSource) {\n            this.sourcePoint = point;\n        }\n        else {\n            this.targetPoint = point;\n        }\n        return point;\n    }\n    /**\n     * Rotates the geometry by the given angle around the given center. That is,\n     * {@link x} and {@link y} of the geometry, the {@link sourcePoint}, {@link targetPoint} and all\n     * {@link points} are translated by the given amount. {@link x} and {@link y} are only\n     * translated if {@link relative} is false.\n     *\n     * @param {Number} angle that specifies the rotation angle in degrees.\n     * @param {Point} cx   that specifies the center of the rotation.\n     */\n    rotate(angle, cx) {\n        const rad = toRadians(angle);\n        const cos = Math.cos(rad);\n        const sin = Math.sin(rad);\n        // Rotates the geometry\n        if (!this.relative) {\n            const ct = new Point(this.getCenterX(), this.getCenterY());\n            const pt = getRotatedPoint(ct, cos, sin, cx);\n            this.x = Math.round(pt.x - this.width / 2);\n            this.y = Math.round(pt.y - this.height / 2);\n        }\n        // Rotates the source point\n        if (this.sourcePoint) {\n            const pt = getRotatedPoint(this.sourcePoint, cos, sin, cx);\n            this.sourcePoint.x = Math.round(pt.x);\n            this.sourcePoint.y = Math.round(pt.y);\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            const pt = getRotatedPoint(this.targetPoint, cos, sin, cx);\n            this.targetPoint.x = Math.round(pt.x);\n            this.targetPoint.y = Math.round(pt.y);\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    const pt = getRotatedPoint(this.points[i], cos, sin, cx);\n                    this.points[i].x = Math.round(pt.x);\n                    this.points[i].y = Math.round(pt.y);\n                }\n            }\n        }\n    }\n    /**\n     * Translates the geometry by the specified amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are translated\n     * by the given amount. {@link x} and {@link y} are only translated if {@link relative} is false.\n     * If {@link TRANSLATE_CONTROL_POINTS} is false, then {@link points} are not modified by\n     * this function.\n     *\n     * @param {Number} dx that specifies the x-coordinate of the translation.\n     * @param {Number} dy that specifies the y-coordinate of the translation.\n     */\n    translate(dx, dy) {\n        // Translates the geometry\n        if (!this.relative) {\n            this.x += dx;\n            this.y += dy;\n        }\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x + dx;\n            this.sourcePoint.y = this.sourcePoint.y + dy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x + dx;\n            this.targetPoint.y = this.targetPoint.y + dy;\n        }\n        // Translate the control points\n        if (this.TRANSLATE_CONTROL_POINTS && this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x + dx;\n                    this.points[i].y = this.points[i].y + dy;\n                }\n            }\n        }\n    }\n    /**\n     * Scales the geometry by the given amount. That is, {@link x} and {@link y} of the\n     * geometry, the {@link sourcePoint}, {@link targetPoint} and all {@link points} are scaled\n     * by the given amount. {@link x}, {@link y}, {@link width} and {@link height} are only scaled if\n     * {@link relative} is false. If {@link fixedAspect} is true, then the smaller value\n     * is used to scale the width and the height.\n     *\n     * @param {Number} sx that specifies the horizontal scale factor.\n     * @param {Number} sy that specifies the vertical scale factor.\n     * @param {Optional} fixedAspect boolean to keep the aspect ratio fixed.\n     */\n    scale(sx, sy, fixedAspect) {\n        // Translates the source point\n        if (this.sourcePoint) {\n            this.sourcePoint.x = this.sourcePoint.x * sx;\n            this.sourcePoint.y = this.sourcePoint.y * sy;\n        }\n        // Translates the target point\n        if (this.targetPoint) {\n            this.targetPoint.x = this.targetPoint.x * sx;\n            this.targetPoint.y = this.targetPoint.y * sy;\n        }\n        // Translate the control points\n        if (this.points) {\n            for (let i = 0; i < this.points.length; i += 1) {\n                if (this.points[i]) {\n                    this.points[i].x = this.points[i].x * sx;\n                    this.points[i].y = this.points[i].y * sy;\n                }\n            }\n        }\n        // Translates the geometry\n        if (!this.relative) {\n            this.x *= sx;\n            this.y *= sy;\n            if (fixedAspect) {\n                sy = sx = Math.min(sx, sy);\n            }\n            this.width *= sx;\n            this.height *= sy;\n        }\n    }\n    /**\n     * Returns true if the given object equals this geometry.\n     */\n    equals(geom) {\n        if (!geom)\n            return false;\n        return (super.equals(geom) &&\n            this.relative === geom.relative &&\n            ((this.sourcePoint === null && geom.sourcePoint === null) ||\n                !!this.sourcePoint?.equals(geom.sourcePoint)) &&\n            ((this.targetPoint === null && geom.targetPoint === null) ||\n                !!this.targetPoint?.equals(geom.targetPoint)) &&\n            equalPoints(this.points, geom.points) &&\n            ((this.alternateBounds === null && geom.alternateBounds === null) ||\n                !!this.alternateBounds?.equals(geom.alternateBounds)) &&\n            ((this.offset === null && geom.offset === null) ||\n                !!this.offset?.equals(geom.offset)));\n    }\n    clone() {\n        return clone(this);\n    }\n}\nexport default Geometry;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2020, JGraph Ltd\nCopyright (c) 2006-2020, draw.io AG\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { write } from './domUtils';\n/**\n * XML HTTP request wrapper. See also: {@link mxUtils.get}, {@link mxUtils.post} and\n * {@link mxUtils.load}. This class provides a cross-browser abstraction for Ajax\n * requests.\n *\n * ### Encoding:\n *\n * For encoding parameter values, the built-in encodeURIComponent JavaScript\n * method must be used. For automatic encoding of post data in {@link Editor} the\n * {@link Editor.escapePostData} switch can be set to true (default). The encoding\n * will be carried out using the conte type of the page. That is, the page\n * containting the editor should contain a meta tag in the header, eg.\n * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n *\n * @example\n * ```JavaScript\n * var onload = function(req)\n * {\n *   mxUtils.alert(req.getDocumentElement());\n * }\n *\n * var onerror = function(req)\n * {\n *   mxUtils.alert('Error');\n * }\n * new MaxXmlRequest(url, 'key=value').send(onload, onerror);\n * ```\n *\n * Sends an asynchronous POST request to the specified URL.\n *\n * @example\n * ```JavaScript\n * var req = new MaxXmlRequest(url, 'key=value', 'POST', false);\n * req.send();\n * mxUtils.alert(req.getDocumentElement());\n * ```\n *\n * Sends a synchronous POST request to the specified URL.\n *\n * @example\n * ```JavaScript\n * var encoder = new Codec();\n * var result = encoder.encode(graph.getDataModel());\n * var xml = encodeURIComponent(mxUtils.getXml(result));\n * new MaxXmlRequest(url, 'xml='+xml).send();\n * ```\n *\n * Sends an encoded graph model to the specified URL using xml as the\n * parameter name. The parameter can then be retrieved in C# as follows:\n *\n * ```javascript\n * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\n * ```\n *\n * Or in Java as follows:\n *\n * ```javascript\n * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\n\", \"&#xa;\");\n * ```\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image.\n */\nclass MaxXmlRequest {\n    constructor(url, params = null, method = 'POST', async = true, username = null, password = null) {\n        /**\n         * Boolean indicating if the request is binary. This option is ignored in IE.\n         * In all other browsers the requested mime type is set to\n         * text/plain; charset=x-user-defined. Default is false.\n         *\n         * @default false\n         */\n        this.binary = false;\n        /**\n         * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is false.\n         *\n         * @default false\n         */\n        this.withCredentials = false;\n        /**\n         * Holds the inner, browser-specific request object.\n         */\n        this.request = null;\n        /**\n         * Specifies if request values should be decoded as URIs before setting the\n         * textarea value in {@link simulate}. Defaults to false for backwards compatibility,\n         * to avoid another decode on the server this should be set to true.\n         */\n        this.decodeSimulateValues = false;\n        this.url = url;\n        this.params = params;\n        this.method = method || 'POST';\n        this.async = async;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Returns {@link binary}.\n     */\n    isBinary() {\n        return this.binary;\n    }\n    /**\n     * Sets {@link binary}.\n     *\n     * @param value\n     */\n    setBinary(value) {\n        this.binary = value;\n    }\n    /**\n     * Returns the response as a string.\n     */\n    getText() {\n        return this.request.responseText;\n    }\n    /**\n     * Returns true if the response is ready.\n     */\n    isReady() {\n        return this.request.readyState === 4;\n    }\n    /**\n     * Returns the document element of the response XML document.\n     */\n    getDocumentElement() {\n        const doc = this.getXml();\n        if (doc != null) {\n            return doc.documentElement;\n        }\n        return null;\n    }\n    /**\n     * Returns the response as an XML document. Use {@link getDocumentElement} to get\n     * the document element of the XML document.\n     */\n    getXml() {\n        let xml = this.request.responseXML;\n        // Handles missing response headers in IE, the first condition handles\n        // the case where responseXML is there, but using its nodes leads to\n        // type errors in the CellCodec when putting the nodes into a new\n        // document. This happens in IE9 standards mode and with XML user\n        // objects only, as they are used directly as values in cells.\n        if (xml == null || xml.documentElement == null) {\n            xml = new DOMParser().parseFromString(this.request.responseText, 'text/xml');\n        }\n        return xml;\n    }\n    /**\n     * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".\n     * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.\n     */\n    getStatus() {\n        return this.request != null ? this.request.status : null;\n    }\n    /**\n     * Creates and returns the inner {@link request} object.\n     */\n    create() {\n        const req = new XMLHttpRequest();\n        // TODO: Check for overrideMimeType required here?\n        if (this.isBinary() && req.overrideMimeType) {\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n        }\n        return req;\n    }\n    /**\n     * Send the <request> to the target URL using the specified functions to\n     * process the response asychronously.\n     *\n     * Note: Due to technical limitations, onerror is currently ignored.\n     *\n     * @param onload Function to be invoked if a successful response was received.\n     * @param onerror Function to be called on any error. Unused in this implementation, intended for overriden function.\n     * @param timeout Optional timeout in ms before calling ontimeout.\n     * @param ontimeout Optional function to execute on timeout.\n     */\n    send(onload = null, onerror = null, timeout = null, ontimeout = null) {\n        this.request = this.create();\n        if (this.request != null) {\n            if (onload != null) {\n                this.request.onreadystatechange = () => {\n                    if (this.isReady()) {\n                        onload(this);\n                        this.request.onreadystatechange = null;\n                    }\n                };\n            }\n            this.request.open(this.method, this.url, this.async, this.username, this.password);\n            this.setRequestHeaders(this.request, this.params);\n            if (window.XMLHttpRequest && this.withCredentials) {\n                this.request.withCredentials = 'true';\n            }\n            if (window.XMLHttpRequest && timeout != null && ontimeout != null) {\n                this.request.timeout = timeout;\n                this.request.ontimeout = ontimeout;\n            }\n            this.request.send(this.params);\n        }\n    }\n    /**\n     * Sets the headers for the given request and parameters. This sets the\n     * content-type to application/x-www-form-urlencoded if any params exist.\n     *\n     * @example\n     * ```JavaScript\n     * request.setRequestHeaders = function(request, params)\n     * {\n     *   if (params != null)\n     *   {\n     *     request.setRequestHeader('Content-Type',\n     *             'multipart/form-data');\n     *     request.setRequestHeader('Content-Length',\n     *             params.length);\n     *   }\n     * };\n     * ```\n     *\n     * Use the code above before calling {@link send} if you require a\n     * multipart/form-data request.\n     *\n     * @param request\n     * @param params\n     */\n    setRequestHeaders(request, params) {\n        if (params != null) {\n            request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        }\n    }\n    /**\n     * Creates and posts a request to the given target URL using a dynamically\n     * created form inside the given document.\n     *\n     * @param doc Document that contains the form element.\n     * @param target Target to send the form result to.\n     */\n    simulate(doc, target = null) {\n        doc = doc || document;\n        let old = null;\n        if (doc === document) {\n            old = window.onbeforeunload;\n            window.onbeforeunload = null;\n        }\n        const form = doc.createElement('form');\n        form.setAttribute('method', this.method);\n        form.setAttribute('action', this.url);\n        if (target != null) {\n            form.setAttribute('target', target);\n        }\n        form.style.display = 'none';\n        form.style.visibility = 'hidden';\n        const params = this.params;\n        const pars = params.indexOf('&') > 0 ? params.split('&') : params.split(' ');\n        // Adds the parameters as textareas to the form\n        for (let i = 0; i < pars.length; i += 1) {\n            const pos = pars[i].indexOf('=');\n            if (pos > 0) {\n                const name = pars[i].substring(0, pos);\n                let value = pars[i].substring(pos + 1);\n                if (this.decodeSimulateValues) {\n                    value = decodeURIComponent(value);\n                }\n                const textarea = doc.createElement('textarea');\n                textarea.setAttribute('wrap', 'off');\n                textarea.setAttribute('name', name);\n                write(textarea, value);\n                form.appendChild(textarea);\n            }\n        }\n        doc.body.appendChild(form);\n        form.submit();\n        if (form.parentNode != null) {\n            form.parentNode.removeChild(form);\n        }\n        if (old != null) {\n            window.onbeforeunload = old;\n        }\n    }\n}\n/**\n * Loads the specified URL *synchronously* and returns the <MaxXmlRequest>.\n * Throws an exception if the file cannot be loaded. See {@link Utils#get} for\n * an asynchronous implementation.\n *\n * Example:\n *\n * ```javascript\n * try\n * {\n *   let req = mxUtils.load(filename);\n *   let root = req.getDocumentElement();\n *   // Process XML DOM...\n * }\n * catch (ex)\n * {\n *   mxUtils.alert('Cannot load '+filename+': '+ex);\n * }\n * ```\n *\n * @param url URL to get the data from.\n */\nexport const load = (url) => {\n    const req = new MaxXmlRequest(url, null, 'GET', false);\n    req.send();\n    return req;\n};\n/**\n * Loads the specified URL *asynchronously* and invokes the given functions\n * depending on the request status. Returns the <MaxXmlRequest> in use. Both\n * functions take the <MaxXmlRequest> as the only parameter. See\n * {@link Utils#load} for a synchronous implementation.\n *\n * Example:\n *\n * ```javascript\n * mxUtils.get(url, (req)=>\n * {\n *    let node = req.getDocumentElement();\n *    // Process XML DOM...\n * });\n * ```\n *\n * So for example, to load a diagram into an existing graph model, the\n * following code is used.\n *\n * ```javascript\n * mxUtils.get(url, (req)=>\n * {\n *   let node = req.getDocumentElement();\n *   let dec = new Codec(node.ownerDocument);\n *   dec.decode(node, graph.getDataModel());\n * });\n * ```\n *\n * @param url URL to get the data from.\n * @param onload Optional function to execute for a successful response.\n * @param onerror Optional function to execute on error.\n * @param binary Optional boolean parameter that specifies if the request is\n * binary.\n * @param timeout Optional timeout in ms before calling ontimeout.\n * @param ontimeout Optional function to execute on timeout.\n * @param headers Optional with headers, eg. {'Authorization': 'token xyz'}\n */\nexport const get = (url, onload = null, onerror = null, binary = false, timeout = null, ontimeout = null, headers = null) => {\n    const req = new MaxXmlRequest(url, null, 'GET');\n    const { setRequestHeaders } = req;\n    if (headers) {\n        req.setRequestHeaders = (request, params) => {\n            setRequestHeaders.apply(this, [request, params]);\n            for (const key in headers) {\n                request.setRequestHeader(key, headers[key]);\n            }\n        };\n    }\n    if (binary != null) {\n        req.setBinary(binary);\n    }\n    req.send(onload, onerror, timeout, ontimeout);\n    return req;\n};\n/**\n * Loads the URLs in the given array *asynchronously* and invokes the given function\n * if all requests returned with a valid 2xx status. The error handler is invoked\n * once on the first error or invalid response.\n *\n * @param urls Array of URLs to be loaded.\n * @param onload Callback with array of {@link XmlRequests}.\n * @param onerror Optional function to execute on error.\n */\nexport const getAll = (urls, onload, onerror) => {\n    let remain = urls.length;\n    const result = [];\n    let errors = 0;\n    const err = () => {\n        if (errors == 0 && onerror != null) {\n            onerror();\n        }\n        errors++;\n    };\n    for (let i = 0; i < urls.length; i += 1) {\n        ((url, index) => {\n            get(url, (req) => {\n                const status = req.getStatus();\n                if (status < 200 || status > 299) {\n                    err();\n                }\n                else {\n                    result[index] = req;\n                    remain--;\n                    if (remain == 0) {\n                        onload(result);\n                    }\n                }\n            }, err);\n        })(urls[i], i);\n    }\n    if (remain == 0) {\n        onload(result);\n    }\n};\n/**\n * Posts the specified params to the given URL *asynchronously* and invokes\n * the given functions depending on the request status. Returns the\n * <MaxXmlRequest> in use. Both functions take the <MaxXmlRequest> as the\n * only parameter. Make sure to use encodeURIComponent for the parameter\n * values.\n *\n * Example:\n *\n * ```javascript\n * mxUtils.post(url, 'key=value', (req)=>\n * {\n *   mxUtils.alert('Ready: '+req.isReady()+' Status: '+req.getStatus());\n *  // Process req.getDocumentElement() using DOM API if OK...\n * });\n * ```\n *\n * @param url URL to get the data from.\n * @param params Parameters for the post request.\n * @param onload Optional function to execute for a successful response.\n * @param onerror Optional function to execute on error.\n */\nexport const post = (url, params = null, onload, onerror = null) => {\n    return new MaxXmlRequest(url, params).send(onload, onerror);\n};\n/**\n * Submits the given parameters to the specified URL using\n * <MaxXmlRequest.simulate> and returns the <MaxXmlRequest>.\n * Make sure to use encodeURIComponent for the parameter\n * values.\n *\n * @param url URL to get the data from.\n * @param params Parameters for the form.\n * @param doc Document to create the form in.\n * @param target Target to send the form result to.\n */\nexport const submit = (url, params, doc, target) => {\n    return new MaxXmlRequest(url, params).simulate(doc, target);\n};\nexport default MaxXmlRequest;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../util/ObjectIdentity';\nimport { GlobalConfig } from '../util/config';\nimport Geometry from '../view/geometry/Geometry';\nimport Point from '../view/geometry/Point';\nimport { NODETYPE } from '../util/Constants';\nimport { isInteger, isNumeric } from '../util/mathUtils';\nimport { getTextContent } from '../util/domUtils';\nimport { load } from '../util/MaxXmlRequest';\n/**\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n *\n * ### Atomic Values\n *\n * Consider the following example.\n *\n * ```javascript\n * const obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * ```\n *\n * This object is encoded into an XML node using the following.\n *\n * ```javascript\n * const enc = new Codec();\n * const node = enc.encode(obj);\n * ```\n *\n * The output of the encoding may be viewed using {@link GlobalConfig.logger} as follows.\n *\n * ```javascript\n * GlobalConfig.logger.show();\n * GlobalConfig.logger.debug(mxUtils.getPrettyXml(node));\n * ```\n *\n * Finally, the result of the encoding looks as follows.\n *\n * ```javascript\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * ```\n *\n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * node name.\n *\n * ### Booleans\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n *\n * ### Objects\n *\n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the field name. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * field name.\n *\n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n *\n * ```javascript\n * const obj = {foo: {bar: \"Bar\"}};\n * ```\n *\n * This will be mapped to the following XML structure by ObjectCodec.\n *\n * ```javascript\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * ```\n *\n * In the above output, the inner Object node contains the as-attribute that\n * specifies the field name in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n *\n * ### Arrays\n *\n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the field name, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n *\n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n *\n * ```javascript\n * const obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * ```\n *\n * This array is represented by the following XML nodes.\n *\n * ```javascript\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * ```\n *\n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n *\n * ### References\n *\n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within {@link Codec}. The\n * {@link isReference} function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the field name is in {@link idrefs}, an array of strings that is used to configure\n * the {@link ObjectCodec}.\n *\n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n *\n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n *\n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in {@link isExcluded}, whose default implementation uses the array of excluded\n * fieldnames passed to the ObjectCodec constructor.\n *\n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing {@link Codec.reference}. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, {@link Codec.lookup} may be implemented.\n *\n * ### Expressions\n *\n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of {@link Constants.ALIGN.LEFT}.\n *\n * ```javascript\n * <Object>\n *   <add as=\"foo\">Constants.ALIGN.LEFT</add>\n * </Object>\n * ```\n *\n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n *\n * ```javascript\n * <Object foo=\"left\"/>\n * ```\n *\n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n *\n * Expressions are only evaluated if {@link allowEval} is true.\n *\n * @category Serialization with Codecs\n */\nclass ObjectCodec {\n    constructor(template, exclude = [], idrefs = [], mapping = {}) {\n        this.template = template;\n        this.exclude = exclude;\n        this.idrefs = idrefs;\n        this.mapping = mapping;\n        this.reverse = {};\n        for (const i in this.mapping) {\n            this.reverse[this.mapping[i]] = i;\n        }\n    }\n    /**\n     * Returns the name used for the node names and lookup of the codec when\n     * classes are encoded and nodes are decoded. For classes to work with\n     * this the codec registry automatically adds an alias for the classname\n     * if that is different from what this returns.\n     *\n     * The default implementation returns the classname of the template class if no name is set.\n     */\n    getName() {\n        return this.name ?? this.template.constructor.name;\n    }\n    setName(name) {\n        this.name = name;\n    }\n    /**\n     * Returns a new instance of the template for this codec.\n     */\n    cloneTemplate() {\n        return new this.template.constructor();\n    }\n    /**\n     * Returns the field name for the given attribute name.\n     * Looks up the value in the {@link reverse} mapping or returns\n     * the input if there is no reverse mapping for the\n     * given name.\n     */\n    getFieldName(attributename) {\n        if (attributename != null) {\n            const mapped = this.reverse[attributename];\n            if (mapped != null) {\n                attributename = mapped;\n            }\n        }\n        return attributename;\n    }\n    /**\n     * Returns the attribute name for the given field name.\n     * Looks up the value in the {@link mapping} or returns\n     * the input if there is no mapping for the\n     * given name.\n     */\n    getAttributeName(fieldname) {\n        if (fieldname != null) {\n            const mapped = this.mapping[fieldname];\n            if (mapped != null) {\n                fieldname = mapped;\n            }\n        }\n        return fieldname;\n    }\n    /**\n     * Returns true if the given attribute is to be ignored by the codec. This\n     * implementation returns true if the given field name is in {@link exclude} or\n     * if the field name equals {@link ObjectIdentity.FIELD_NAME}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Fieldname of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isExcluded(obj, attr, value, write) {\n        return attr == ObjectIdentity.FIELD_NAME || this.exclude.indexOf(attr) >= 0;\n    }\n    /**\n     * Returns true if the given field name is to be treated\n     * as a textual reference (ID). This implementation returns\n     * true if the given field name is in {@link idrefs}.\n     *\n     * @param obj Object instance that contains the field.\n     * @param attr Field name of the field.\n     * @param value Value of the field.\n     * @param write Boolean indicating if the field is being encoded or decoded.\n     * Write is true if the field is being encoded, else it is being decoded.\n     */\n    isReference(obj, attr, value, write) {\n        return this.idrefs.indexOf(attr) >= 0;\n    }\n    /**\n     * Encodes the specified object and returns a node\n     * representing then given object. Calls {@link beforeEncode}\n     * after creating the node and {@link afterEncode} with the\n     * resulting node after processing.\n     *\n     * Enc is a reference to the calling encoder. It is used\n     * to encode complex objects and create references.\n     *\n     * This implementation encodes all variables of an\n     * object according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getId}\n     * is used to replace the object with its ID.\n     * - The variable name is mapped using {@link mapping}.\n     * - If obj is an array and the variable name is numeric\n     * (ie. an index) then it is not encoded.\n     * - If the value is an object, then the codec is used to\n     * create a child node with the variable name encoded into\n     * the \"as\" attribute.\n     * - Else, if {@link encodeDefaults} is true or the value differs\n     * from the template value, then ...\n     * - ... if obj is not an array, then the value is mapped to\n     * an attribute.\n     * - ... else if obj is an array, the value is mapped to an\n     * add child with a value attribute or a text child node,\n     * if the value is a function.\n     *\n     * If no ID exists for a variable in {@link idrefs} or if an object\n     * cannot be encoded, a warning is issued using {@link GlobalConfig.logger}.\n     *\n     * Returns the resulting XML node that represents the given\n     * object.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     */\n    encode(enc, obj) {\n        const node = enc.document.createElement(this.getName());\n        obj = this.beforeEncode(enc, obj, node);\n        this.encodeObject(enc, obj, node);\n        return this.afterEncode(enc, obj, node);\n    }\n    /**\n     * Encodes the value of each member in then given obj into the given node using\n     * {@link encodeValue}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeObject(enc, obj, node) {\n        enc.setAttribute(node, 'id', enc.getId(obj));\n        for (const i in obj) {\n            let name = i;\n            const value = obj[name];\n            if (value != null && !this.isExcluded(obj, name, value, true)) {\n                if (isInteger(name)) {\n                    name = null;\n                }\n                this.encodeValue(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Converts the given value according to the mappings\n     * and id-refs in this codec and uses {@link writeAttribute}\n     * to write the attribute into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object whose property is going to be encoded.\n     * @param name XML node that contains the encoded object.\n     * @param value Value of the property to be encoded.\n     * @param node XML node that contains the encoded object.\n     */\n    encodeValue(enc, obj, name, value, node) {\n        if (value != null) {\n            // TODO: What is the case where `name` can be `null`? =========================================================================\n            if (name != null && this.isReference(obj, name, value, true)) {\n                const tmp = enc.getId(value);\n                if (tmp == null) {\n                    GlobalConfig.logger.warn(`ObjectCodec.encode: No ID for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            // Checks if the value is a default value and\n            // the name is correct\n            if (name == null || enc.encodeDefaults || this.template[name] != value) {\n                name = this.getAttributeName(name);\n                this.writeAttribute(enc, obj, name, value, node);\n            }\n        }\n    }\n    /**\n     * Writes the given value into node using {@link writePrimitiveAttribute}\n     * or {@link writeComplexAttribute} depending on the type of the value.\n     */\n    writeAttribute(enc, obj, name, value, node) {\n        if (typeof value !== 'object' /* primitive type */) {\n            this.writePrimitiveAttribute(enc, obj, name, value, node);\n        } /* complex type */\n        else {\n            this.writeComplexAttribute(enc, obj, name, value, node);\n        }\n    }\n    /**\n     * Writes the given value as an attribute of the given node.\n     */\n    writePrimitiveAttribute(enc, obj, name, value, node) {\n        value = this.convertAttributeToXml(enc, obj, name, value, node); // TODO: params don't seem to match - is this a bug? ===================================\n        if (name == null) {\n            const child = enc.document.createElement('add');\n            if (typeof value === 'function') {\n                child.appendChild(enc.document.createTextNode(value));\n            }\n            else {\n                enc.setAttribute(child, 'value', value);\n            }\n            node.appendChild(child);\n        }\n        else if (typeof value !== 'function') {\n            enc.setAttribute(node, name, value);\n        }\n    }\n    /**\n     * Writes the given value as a child node of the given node.\n     */\n    writeComplexAttribute(enc, obj, name, value, node) {\n        const child = enc.encode(value);\n        if (child != null) {\n            if (name != null) {\n                child.setAttribute('as', name);\n            }\n            node.appendChild(child);\n        }\n        else {\n            GlobalConfig.logger.warn(`ObjectCodec.encode: No node for ${this.getName()}.${name}: ${value}`);\n        }\n    }\n    /**\n     * Converts true to \"1\" and false to \"0\" is {@link isBooleanAttribute} returns true.\n     * All other values are not converted.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Objec to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value to be converted.\n     */\n    convertAttributeToXml(enc, obj, name, value, node) {\n        // Makes sure to encode boolean values as numeric values\n        if (this.isBooleanAttribute(enc, obj, name, value)) {\n            // Checks if the value is true (do not use the value as is, because\n            // this would check if the value is not null, so 0 would be true)\n            value = value == true ? '1' : '0';\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given object attribute is a boolean value.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to convert the attribute for.\n     * @param name Name of the attribute to be converted.\n     * @param value Value of the attribute to be converted.\n     */\n    isBooleanAttribute(enc, obj, name, value) {\n        return typeof value.length === 'undefined' && (value == true || value == false);\n    }\n    /**\n     * Converts booleans and numeric values to the respective types. Values are\n     * numeric if {@link isNumericAttribute} returns true.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Objec to convert the attribute for.\n     */\n    convertAttributeFromXml(dec, attr, obj) {\n        let { value } = attr;\n        if (this.isNumericAttribute(dec, attr, obj)) {\n            value = parseFloat(value);\n            if (Number.isNaN(value) || !Number.isFinite(value)) {\n                value = 0;\n            }\n        }\n        return value;\n    }\n    /**\n     * Returns true if the given XML attribute is or should be a numeric value.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be converted.\n     * @param obj Object to convert the attribute for.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        // Handles known numeric attributes for generic objects\n        return ((obj.constructor === Geometry &&\n            (attr.name === 'x' ||\n                attr.name === 'y' ||\n                attr.name === 'width' ||\n                attr.name === 'height')) ||\n            (obj.constructor === Point && (attr.name === 'x' || attr.name === 'y')) ||\n            isNumeric(attr.value));\n    }\n    /**\n     * Hook for subclassers to pre-process the object before\n     * encoding. This returns the input object. The return\n     * value of this function is used in {@link encode} to perform\n     * the default encoding into the given node.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node to encode the object into.\n     */\n    beforeEncode(enc, obj, node) {\n        return obj;\n    }\n    /**\n     * Hook for subclassers to post-process the node\n     * for the given object after encoding and return the\n     * post-processed node. This implementation returns\n     * the input node. The return value of this method\n     * is returned to the encoder from {@link encode}.\n     *\n     * @param enc {@link Codec} that controls the encoding process.\n     * @param obj Object to be encoded.\n     * @param node XML node that represents the default encoding.\n     */\n    afterEncode(enc, obj, node) {\n        return node;\n    }\n    /**\n     * Parses the given node into the object or returns a new object\n     * representing the given node.\n     *\n     * Dec is a reference to the calling decoder. It is used to decode\n     * complex objects and resolve references.\n     *\n     * If a node has an id attribute then the object cache is checked for the\n     * object. If the object is not yet in the cache then it is constructed\n     * using the constructor of {@link template} and cached in {@link Codec.objects}.\n     *\n     * This implementation decodes all attributes and childs of a node\n     * according to the following rules:\n     *\n     * - If the variable name is in {@link exclude} or if the attribute name is \"id\"\n     * or \"as\" then it is ignored.\n     * - If the variable name is in {@link idrefs} then {@link Codec.getObject} is used\n     * to replace the reference with an object.\n     * - The variable name is mapped using a reverse {@link mapping}.\n     * - If the value has a child node, then the codec is used to create a\n     * child object with the variable name taken from the \"as\" attribute.\n     * - If the object is an array and the variable name is empty then the\n     * value or child object is appended to the array.\n     * - If an add child has no value or the object is not an array then\n     * the child text content is evaluated using {@link eval}.\n     *\n     * For add nodes where the object is not an array and the variable name\n     * is defined, the default mechanism is used, allowing to override/add\n     * methods as follows:\n     *\n     * ```javascript\n     * <Object>\n     *   <add as=\"hello\"><![CDATA[\n     *     function(arg1) {\n     *       mxUtils.alert('Hello '+arg1);\n     *     }\n     *   ]]></add>\n     * </Object>\n     * ```\n     *\n     * If no object exists for an ID in {@link idrefs} a warning is issued\n     * using {@link GlobalConfig.logger}.\n     *\n     * Returns the resulting object that represents the given XML node\n     * or the object given to the method as the into parameter.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param into Optional object to encode the node into.\n     */\n    decode(dec, node, into) {\n        const id = node.getAttribute('id');\n        let obj = dec.objects[id];\n        if (obj == null) {\n            obj = into || this.cloneTemplate();\n            if (id != null) {\n                dec.putObject(id, obj);\n            }\n        }\n        const _node = this.beforeDecode(dec, node, obj);\n        this.decodeNode(dec, _node, obj);\n        return this.afterDecode(dec, _node, obj);\n    }\n    /**\n     * Calls {@link decodeAttributes} and {@link decodeChildren} for the given node.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeNode(dec, node, obj) {\n        if (node != null) {\n            this.decodeAttributes(dec, node, obj);\n            this.decodeChildren(dec, node, obj);\n        }\n    }\n    /**\n     * Decodes all attributes of the given node using {@link decodeAttribute}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    decodeAttributes(dec, node, obj) {\n        const attrs = node.attributes;\n        if (attrs != null) {\n            for (let i = 0; i < attrs.length; i += 1) {\n                this.decodeAttribute(dec, attrs[i], obj);\n            }\n        }\n    }\n    /**\n     * Returns true if the given attribute should be ignored. This implementation\n     * returns true if the attribute name is \"as\" or \"id\".\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    isIgnoredAttribute(dec, attr, obj) {\n        return attr.nodeName === 'as' || attr.nodeName === 'id';\n    }\n    /**\n     * Reads the given attribute into the specified object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param attr XML attribute to be decoded.\n     * @param obj Objec to encode the attribute into.\n     */\n    decodeAttribute(dec, attr, obj) {\n        if (!this.isIgnoredAttribute(dec, attr, obj)) {\n            const name = attr.nodeName;\n            // Converts the string true and false to their boolean values.\n            // This may require an additional check on the obj to see if\n            // the existing field is a boolean value or uninitialized, in\n            // which case we may want to convert true and false to a string.\n            let value = this.convertAttributeFromXml(dec, attr, obj);\n            const fieldname = this.getFieldName(name);\n            if (this.isReference(obj, fieldname, value, false)) {\n                const tmp = dec.getObject(value);\n                if (tmp == null) {\n                    GlobalConfig.logger.warn(`ObjectCodec.decode: No object for ${this.getName()}.${name}=${value}`);\n                    return; // exit\n                }\n                value = tmp;\n            }\n            if (!this.isExcluded(obj, name, value, false)) {\n                obj[name] = value;\n            }\n        }\n    }\n    /**\n     * Decodes all children of the given node using {@link decodeChild}.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChildren(dec, node, obj) {\n        let child = node.firstChild;\n        while (child != null) {\n            const tmp = child.nextSibling;\n            if (child.nodeType === NODETYPE.ELEMENT && !this.processInclude(dec, child, obj)) {\n                this.decodeChild(dec, child, obj);\n            }\n            child = tmp;\n        }\n    }\n    /**\n     * Reads the specified child into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param child XML child element to be decoded.\n     * @param obj Objec to encode the node into.\n     */\n    decodeChild(dec, child, obj) {\n        const fieldname = this.getFieldName(child.getAttribute('as'));\n        if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {\n            const template = this.getFieldTemplate(obj, fieldname, child);\n            let value = null;\n            if (child.nodeName === 'add') {\n                value = child.getAttribute('value');\n                if (value == null && ObjectCodec.allowEval) {\n                    value = eval(getTextContent(child));\n                }\n            }\n            else {\n                value = dec.decode(child, template);\n            }\n            try {\n                this.addObjectValue(obj, fieldname, value, template);\n            }\n            catch (e) {\n                throw new Error(`${e.message} for ${child.nodeName}`);\n            }\n        }\n    }\n    /**\n     * Returns the template instance for the given field. This returns the\n     * value of the field, null if the value is an array or an empty collection\n     * if the value is a collection. The value is then used to populate the\n     * field for a new instance. For strongly typed languages it may be\n     * required to override this to return the correct collection instance\n     * based on the encoded child.\n     */\n    getFieldTemplate(obj, fieldname, child) {\n        let template = obj[fieldname];\n        // Non-empty arrays are replaced completely\n        if (template instanceof Array && template.length > 0) {\n            template = null;\n        }\n        return template;\n    }\n    /**\n     * Sets the decoded child node as a value of the given object. If the\n     * object is a map, then the value is added with the given field name as a\n     * key. If the field name is not empty, then setFieldValue is called or\n     * else, if the object is a collection, the value is added to the\n     * collection. For strongly typed languages it may be required to\n     * override this with the correct code to add an entry to an object.\n     */\n    addObjectValue(obj, fieldname, value, template) {\n        if (value != null && value !== template) {\n            if (fieldname != null && fieldname.length > 0) {\n                obj[fieldname] = value;\n            }\n            else {\n                obj.push(value);\n            }\n        }\n    }\n    /**\n     * Returns true if the given node is an include directive and\n     * executes the include by decoding the XML document. Returns\n     * false if the given node is not an include directive.\n     *\n     * @param dec {@link Codec} that controls the encoding/decoding process.\n     * @param node XML node to be checked.\n     * @param into Optional object to pass-thru to the codec.\n     */\n    processInclude(dec, node, into) {\n        if (node.nodeName === 'include') {\n            const name = node.getAttribute('name');\n            if (name != null) {\n                try {\n                    const xml = load(name).getDocumentElement();\n                    if (xml != null) {\n                        dec.decode(xml, into);\n                    }\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Hook for subclassers to pre-process the node for\n     * the specified object and return the node to be\n     * used for further processing by {@link decode}.\n     * The object is created based on the template in the\n     * calling method and is never null. This implementation\n     * returns the input node. The return value of this\n     * function is used in {@link decode} to perform\n     * the default decoding into the given object.\n     *\n     * @param dec {@link Codec} that controls the decoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object to encode the node into.\n     */\n    beforeDecode(dec, node, obj) {\n        return node;\n    }\n    /**\n     * Hook for subclassers to post-process the object after\n     * decoding. This implementation returns the given object\n     * without any changes. The return value of this method\n     * is returned to the decoder from {@link decode}.\n     *\n     * @param dec {@link Codec} that controls the encoding process.\n     * @param node XML node to be decoded.\n     * @param obj Object that represents the default decoding.\n     */\n    afterDecode(dec, node, obj) {\n        return obj;\n    }\n}\n/**\n * Static global switch that specifies if expressions in arrays are allowed.\n *\n * **NOTE**: Enabling this carries a possible security risk.\n * @default false\n */\nObjectCodec.allowEval = false;\nexport default ObjectCodec;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from './ObjectCodec';\n/**\n * Singleton class that acts as a global registry for codecs.\n *\n * ### Adding a Codec\n *\n * 1. Define a default codec with a new instance of the object to be handled.\n *\n *     ```javascript\n *     const codec = new ObjectCodec(new Transactions());\n *     ```\n *\n * 2. Define the functions required for encoding and decoding objects.\n *\n *     ```javascript\n *     codec.encode = function(enc, obj) { ... }\n *     codec.decode = function(dec: Codec, node: Element, into: any): any { ... }\n *     ```\n *\n * 3. Register the codec in the CodecRegistry.\n *\n *     ```javascript\n *     CodecRegistry.register(codec);\n *     ```\n *\n * {@link ObjectCodec.decode} may be used to either create a new instance of an object or to configure an existing instance,\n * in which case the into argument points to the existing object. In this case, we say the codec \"configures\" the object.\n *\n * @category Serialization with Codecs\n */\nclass CodecRegistry {\n    /**\n     * Registers a new codec and associates the name of the codec via {@link ObjectCodec.getName} with the codec object.\n     *\n     * @param codec ObjectCodec to be registered.\n     * @param registerAlias if `true`, register an alias if the codec name doesn't match the name of the constructor of {@link ObjectCodec.template}.\n     */\n    static register(codec, registerAlias = true) {\n        if (codec != null) {\n            const name = codec.getName();\n            CodecRegistry.codecs[name] = codec;\n            const classname = codec.template.constructor.name;\n            if (registerAlias && classname !== name) {\n                CodecRegistry.addAlias(classname, name);\n            }\n        }\n        return codec;\n    }\n    /**\n     * Adds an alias for mapping a classname to a codec name.\n     */\n    static addAlias(classname, codecname) {\n        CodecRegistry.aliases[classname] = codecname;\n    }\n    /**\n     * Returns a codec that handles objects that are constructed using the given constructor or a codec registered under the provided name.\n     *\n     * When passing a name, the method first check if an alias exists for the name, and if so, it uses it to retrieve the codec.\n     *\n     * If there is no registered Codec, the method tries to register a new Codec using the provided constructor.\n     *\n     * @param constructorOrName JavaScript constructor function of the Codec or Codec name.\n     */\n    static getCodec(constructorOrName) {\n        if (constructorOrName == null) {\n            return null;\n        }\n        let codec = null;\n        // Equivalent of calling import { getFunctionName } from '../util/StringUtils';\n        let name = typeof constructorOrName === 'string' ? constructorOrName : constructorOrName.name;\n        const tmp = CodecRegistry.aliases[name];\n        if (tmp != null) {\n            name = tmp;\n        }\n        codec = CodecRegistry.codecs[name] ?? null;\n        // Registers a new default codec for the given constructor if no codec has been previously defined.\n        if (codec == null) {\n            try {\n                codec = new ObjectCodec(new constructorOrName());\n                CodecRegistry.register(codec);\n            }\n            catch (e) {\n                // ignore\n            }\n        }\n        return codec;\n    }\n    /**\n     * First try to get the codec by the name it is registered with. If it doesn't exist, use the alias eventually declared\n     * to get the codec.\n     * @param name the name of the codec that is willing to be retrieved.\n     */\n    static getCodecByName(name) {\n        let codec = CodecRegistry.codecs[name];\n        if (!codec) {\n            const alias = CodecRegistry.aliases[name];\n            if (alias) {\n                codec = CodecRegistry.codecs[alias];\n            }\n        }\n        return codec ?? null;\n    }\n}\nCodecRegistry.codecs = {};\n/**\n * Maps from classnames to codec names.\n */\nCodecRegistry.aliases = {};\nexport default CodecRegistry;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { NODETYPE } from '../../util/Constants';\nimport { clone } from '../../util/cloneUtils';\nimport Point from '../geometry/Point';\nimport CellPath from './CellPath';\nimport { isNotNullish } from '../../util/Utils';\n/**\n * Cells are the elements of the graph model. They represent the state\n * of the groups, vertices and edges in a graph.\n *\n * ### Custom attributes\n * For custom attributes we recommend using an XML node as the value of a cell.\n * The following code can be used to create a cell with an XML node as the value:\n * ```javascript\n * var doc = mxUtils.createXmlDocument();\n * var node = doc.createElement('MyNode')\n * node.setAttribute('label', 'MyLabel');\n * node.setAttribute('attribute1', 'value1');\n * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\n * ```\n *\n * For the label to work, {@link graph.convertValueToString} and\n * {@link graph.cellLabelChanged} should be overridden as follows:\n *\n * ```javascript\n * graph.convertValueToString(cell)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     return cell.getAttribute('label', '')\n *   }\n * };\n *\n * var cellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged(cell, newValue, autoSize)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     // Clones the value for correct undo/redo\n *     var elt = cell.value.cloneNode(true);\n *     elt.setAttribute('label', newValue);\n *     newValue = elt;\n *   }\n *\n *   cellLabelChanged.apply(this, arguments);\n * };\n * ```\n * @class Cell\n */\nexport class Cell {\n    constructor(value = null, geometry = null, style = {}) {\n        // TODO: Document me!\n        // used by invalidate() of mxGraphView\n        this.invalidating = false;\n        this.onInit = null;\n        // used by addCellOverlay() of mxGraph\n        this.overlays = [];\n        /**\n         * Holds the Id. Default is null.\n         */\n        this.id = null;\n        /**\n         * Holds the user object. Default is null.\n         */\n        this.value = null;\n        /**\n         * Holds the {@link Geometry}. Default is null.\n         */\n        this.geometry = null;\n        /**\n         * Holds the style as a string of the form [(stylename|key=value);]. Default is\n         * null.\n         */\n        this.style = {};\n        /**\n         * Specifies whether the cell is a vertex. Default is false.\n         */\n        this.vertex = false;\n        /**\n         * Specifies whether the cell is an edge. Default is false.\n         */\n        this.edge = false;\n        /**\n         * Specifies whether the cell is connectable. Default is true.\n         */\n        this.connectable = true;\n        /**\n         * Specifies whether the cell is visible. Default is true.\n         */\n        this.visible = true;\n        /**\n         * Specifies whether the cell is collapsed. Default is false.\n         */\n        this.collapsed = false;\n        /**\n         * Reference to the parent cell.\n         */\n        this.parent = null;\n        /**\n         * Reference to the source terminal.\n         */\n        this.source = null;\n        /**\n         * Reference to the target terminal.\n         */\n        this.target = null;\n        /**\n         * Holds the child cells.\n         */\n        this.children = [];\n        /**\n         * Holds the edges.\n         */\n        this.edges = [];\n        /**\n         * List of members that should not be cloned inside <clone>. This field is\n         * passed to {@link Utils#clone} and is not made persistent in <CellCodec>.\n         * This is not a convention for all classes, it is only used in this class\n         * to mark transient fields since transient modifiers are not supported by\n         * the language.\n         */\n        this.mxTransient = [\n            'id',\n            'value',\n            'parent',\n            'source',\n            'target',\n            'children',\n            'edges',\n        ];\n        this.value = value;\n        this.setGeometry(geometry);\n        this.setStyle(style);\n        if (this.onInit) {\n            this.onInit();\n        }\n    }\n    // TODO: Document me!!!\n    getChildren() {\n        return this.children || [];\n    }\n    /**\n     * Returns the Id of the cell as a string.\n     */\n    getId() {\n        return this.id;\n    }\n    /**\n     * Sets the Id of the cell to the given string.\n     */\n    setId(id) {\n        this.id = id;\n    }\n    /**\n     * Returns the user object of the cell. The user\n     * object is stored in <value>.\n     */\n    getValue() {\n        return this.value;\n    }\n    /**\n     * Sets the user object of the cell. The user object\n     * is stored in <value>.\n     */\n    setValue(value) {\n        this.value = value;\n    }\n    /**\n     * Changes the user object after an in-place edit\n     * and returns the previous value. This implementation\n     * replaces the user object with the given value and\n     * returns the old user object.\n     */\n    valueChanged(newValue) {\n        const previous = this.getValue();\n        this.setValue(newValue);\n        return previous;\n    }\n    /**\n     * Returns the {@link Geometry} that describes the <geometry>.\n     */\n    getGeometry() {\n        return this.geometry;\n    }\n    /**\n     * Sets the {@link Geometry} to be used as the <geometry>.\n     */\n    setGeometry(geometry) {\n        this.geometry = geometry;\n    }\n    /**\n     * Returns a string that describes the {@link style}.\n     *\n     * **IMPORTANT**: if you want to get the style object to later update it and propagate changes to the view, use {@link getClonedStyle} instead.\n     */\n    getStyle() {\n        return this.style;\n    }\n    /**\n     * Use this method to get the style object to later update it and propagate changes to the view.\n     *\n     * See {@link GraphDataModel.setStyle} for more details.\n     */\n    getClonedStyle() {\n        return clone(this.getStyle());\n    }\n    /**\n     * Sets the string to be used as the {@link style}.\n     */\n    setStyle(style) {\n        this.style = style;\n    }\n    /**\n     * Returns true if the cell is a vertex.\n     */\n    isVertex() {\n        return this.vertex;\n    }\n    /**\n     * Specifies if the cell is a vertex. This should only be assigned at\n     * construction of the cell and not be changed during its lifecycle.\n     *\n     * @param vertex Boolean that specifies if the cell is a vertex.\n     */\n    setVertex(vertex) {\n        this.vertex = vertex;\n    }\n    /**\n     * Returns true if the cell is an edge.\n     */\n    isEdge() {\n        return this.edge;\n    }\n    /**\n     * Specifies if the cell is an edge. This should only be assigned at\n     * construction of the cell and not be changed during its lifecycle.\n     *\n     * @param edge Boolean that specifies if the cell is an edge.\n     */\n    setEdge(edge) {\n        this.edge = edge;\n    }\n    /**\n     * Returns true if the cell is connectable.\n     */\n    isConnectable() {\n        return this.connectable;\n    }\n    /**\n     * Sets the connectable state.\n     *\n     * @param connectable Boolean that specifies the new connectable state.\n     */\n    setConnectable(connectable) {\n        this.connectable = connectable;\n    }\n    /**\n     * Returns true if the cell is visibile.\n     */\n    isVisible() {\n        return this.visible;\n    }\n    /**\n     * Specifies if the cell is visible.\n     *\n     * @param visible Boolean that specifies the new visible state.\n     */\n    setVisible(visible) {\n        this.visible = visible;\n    }\n    /**\n     * Returns true if the cell is collapsed.\n     */\n    isCollapsed() {\n        return this.collapsed;\n    }\n    /**\n     * Sets the collapsed state.\n     *\n     * @param collapsed Boolean that specifies the new collapsed state.\n     */\n    setCollapsed(collapsed) {\n        this.collapsed = collapsed;\n    }\n    /**\n     * Returns the cell's parent.\n     */\n    getParent() {\n        return this.parent;\n    }\n    /**\n     * Sets the parent cell.\n     *\n     * @param parent<Cell> that represents the new parent.\n     */\n    setParent(parent) {\n        this.parent = parent;\n    }\n    /**\n     * Returns the source or target terminal.\n     *\n     * @param source Boolean that specifies if the source terminal should be\n     * returned.\n     */\n    getTerminal(source = false) {\n        return source ? this.source : this.target;\n    }\n    /**\n     * Sets the source or target terminal and returns the new terminal.\n     *\n     * @param terminal  Cell that represents the new source or target terminal.\n     * @param isSource  boolean that specifies if the source or target terminal should be set.\n     */\n    setTerminal(terminal, isSource) {\n        if (isSource) {\n            this.source = terminal;\n        }\n        else {\n            this.target = terminal;\n        }\n        return terminal;\n    }\n    /**\n     * Returns the number of child cells.\n     */\n    getChildCount() {\n        return this.children.length;\n    }\n    /**\n     * Returns the index of the specified child in the child array.\n     *\n     * @param child Child whose index should be returned.\n     */\n    getIndex(child) {\n        if (child === null)\n            return -1;\n        return this.children.indexOf(child);\n    }\n    /**\n     * Returns the child at the specified index.\n     *\n     * @param indexInteger that specifies the child to be returned.\n     */\n    getChildAt(index) {\n        return this.children[index];\n    }\n    /**\n     * Inserts the specified child into the child array at the specified index\n     * and updates the parent reference of the child. If not childIndex is\n     * specified then the child is appended to the child array. Returns the\n     * inserted child.\n     *\n     * @param child<Cell> to be inserted or appended to the child array.\n     * @param indexOptional integer that specifies the index at which the child\n     * should be inserted into the child array.\n     */\n    insert(child, index) {\n        if (index === undefined) {\n            index = this.getChildCount();\n            if (child.getParent() === this) {\n                index--;\n            }\n        }\n        child.removeFromParent();\n        child.setParent(this);\n        this.children.splice(index, 0, child);\n        return child;\n    }\n    /**\n     * Removes the child at the specified index from the child array and\n     * returns the child that was removed. Will remove the parent reference of\n     * the child.\n     *\n     * @param indexInteger that specifies the index of the child to be\n     * removed.\n     */\n    remove(index) {\n        let child = null;\n        if (index >= 0) {\n            child = this.getChildAt(index);\n            if (child) {\n                this.children.splice(index, 1);\n                child.setParent(null);\n            }\n        }\n        return child;\n    }\n    /**\n     * Removes the cell from its parent.\n     */\n    removeFromParent() {\n        if (this.parent) {\n            const index = this.parent.getIndex(this);\n            this.parent.remove(index);\n        }\n    }\n    /**\n     * Returns the number of edges in the edge array.\n     */\n    getEdgeCount() {\n        return this.edges.length;\n    }\n    /**\n     * Returns the index of the specified edge in <edges>.\n     *\n     * @param edge<Cell> whose index in <edges> should be returned.\n     */\n    getEdgeIndex(edge) {\n        return this.edges.indexOf(edge);\n    }\n    /**\n     * Returns the edge at the specified index in <edges>.\n     *\n     * @param indexInteger that specifies the index of the edge to be returned.\n     */\n    getEdgeAt(index) {\n        return this.edges[index];\n    }\n    /**\n     * Inserts the specified edge into the edge array and returns the edge.\n     * Will update the respective terminal reference of the edge.\n     *\n     * @param edge              <Cell> to be inserted into the edge array.\n     * @param isOutgoing Boolean that specifies if the edge is outgoing.\n     */\n    insertEdge(edge, isOutgoing = false) {\n        edge.removeFromTerminal(isOutgoing);\n        edge.setTerminal(this, isOutgoing);\n        if (this.edges.length === 0 ||\n            edge.getTerminal(!isOutgoing) !== this ||\n            this.edges.indexOf(edge) < 0) {\n            this.edges.push(edge);\n        }\n        return edge;\n    }\n    /**\n     * Removes the specified edge from the edge array and returns the edge.\n     * Will remove the respective terminal reference from the edge.\n     *\n     * @param edge<Cell> to be removed from the edge array.\n     * @param isOutgoing Boolean that specifies if the edge is outgoing.\n     */\n    removeEdge(edge, isOutgoing = false) {\n        if (edge != null) {\n            if (edge.getTerminal(!isOutgoing) !== this && this.edges != null) {\n                const index = this.getEdgeIndex(edge);\n                if (index >= 0) {\n                    this.edges.splice(index, 1);\n                }\n            }\n            edge.setTerminal(null, isOutgoing);\n        }\n        return edge;\n    }\n    /**\n     * Removes the edge from its source or target terminal.\n     *\n     * @param isSource Boolean that specifies if the edge should be removed from its source or target terminal.\n     */\n    removeFromTerminal(isSource) {\n        const terminal = this.getTerminal(isSource);\n        if (terminal) {\n            terminal.removeEdge(this, isSource);\n        }\n    }\n    /**\n     * Returns true if the user object is an XML node that contains the given attribute.\n     *\n     * @param name Name nameName of the attribute.\n     */\n    hasAttribute(name) {\n        const userObject = this.getValue();\n        return (isNotNullish(userObject) &&\n            (userObject.nodeType === NODETYPE.ELEMENT && userObject.hasAttribute\n                ? userObject.hasAttribute(name)\n                : isNotNullish(userObject.getAttribute?.(name))));\n    }\n    /**\n     * Returns the specified attribute from the user object if it is an XML node.\n     *\n     * @param name Name of the attribute whose value should be returned.\n     * @param defaultValue Optional default value to use if the attribute has no\n     * value.\n     */\n    getAttribute(name, defaultValue) {\n        const userObject = this.getValue();\n        const val = isNotNullish(userObject) && userObject.nodeType === NODETYPE.ELEMENT\n            ? userObject.getAttribute?.(name)\n            : null;\n        return val ?? defaultValue;\n    }\n    /**\n     * Sets the specified attribute on the user object if it is an XML node.\n     *\n     * @param name Name of the attribute whose value should be set.\n     * @param value New value of the attribute.\n     */\n    setAttribute(name, value) {\n        const userObject = this.getValue();\n        if (isNotNullish(userObject) && userObject.nodeType === NODETYPE.ELEMENT) {\n            userObject.setAttribute?.(name, value);\n        }\n    }\n    /**\n     * Returns a clone of the cell.\n     *\n     * Uses {@link cloneValue} to clone the user object.\n     *\n     * All fields in {@link mxTransient} are ignored during the cloning.\n     */\n    clone() {\n        const c = clone(this, this.mxTransient);\n        c.setValue(this.cloneValue());\n        return c;\n    }\n    /**\n     * Returns a clone of the cell's user object.\n     */\n    cloneValue() {\n        let value = this.getValue();\n        if (isNotNullish(value)) {\n            if (typeof value.clone === 'function') {\n                value = value.clone();\n            }\n            else if (isNotNullish(value.nodeType) && value.cloneNode) {\n                value = value.cloneNode(true);\n            }\n        }\n        return value;\n    }\n    /**\n     * Returns the nearest common ancestor for the specified cells to `this`.\n     *\n     * @param {Cell} cell2  that specifies the second cell in the tree.\n     */\n    getNearestCommonAncestor(cell2) {\n        // Creates the cell path for the second cell\n        let path = CellPath.create(cell2);\n        if (path.length > 0) {\n            // Bubbles through the ancestors of the first cell to find the nearest common ancestor.\n            // eslint-disable-next-line @typescript-eslint/no-this-alias -- we need to use `this` to refer to the instance to start processing\n            let cell = this;\n            let current = CellPath.create(cell);\n            // Inverts arguments\n            if (path.length < current.length) {\n                cell = cell2;\n                const tmp = current;\n                current = path;\n                path = tmp;\n            }\n            while (cell && current) {\n                const parent = cell.getParent();\n                // Checks if the cell path is equal to the beginning of the given cell path\n                if (path.indexOf(current + CellPath.PATH_SEPARATOR) === 0 && parent) {\n                    return cell;\n                }\n                current = CellPath.getParentPath(current);\n                cell = parent;\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the given parent is an ancestor of the given child. Note\n     * returns true if child == parent.\n     *\n     * @param {Cell} child  that specifies the child.\n     */\n    isAncestor(child) {\n        while (child && child !== this) {\n            child = child.getParent();\n        }\n        return child === this;\n    }\n    /**\n     * Returns the child vertices of the given parent.\n     */\n    getChildVertices() {\n        return this.getChildCells(true, false);\n    }\n    /**\n     * Returns the child edges of the given parent.\n     */\n    getChildEdges() {\n        return this.getChildCells(false, true);\n    }\n    /**\n     * Returns the children of the given cell that are vertices and/or edges\n     * depending on the arguments.\n     *\n     * @param vertices  Boolean indicating if child vertices should be returned.\n     * Default is false.\n     * @param edges  Boolean indicating if child edges should be returned.\n     * Default is false.\n     */\n    getChildCells(vertices = false, edges = false) {\n        const childCount = this.getChildCount();\n        const result = [];\n        for (let i = 0; i < childCount; i += 1) {\n            const child = this.getChildAt(i);\n            if ((!edges && !vertices) ||\n                (edges && child.isEdge()) ||\n                (vertices && child.isVertex())) {\n                result.push(child);\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns the number of incoming or outgoing edges, ignoring the given\n     * edge.\n     *\n     * @param outgoing  Boolean that specifies if the number of outgoing or\n     * incoming edges should be returned.\n     * @param {Cell} ignoredEdge  that represents an edge to be ignored.\n     */\n    getDirectedEdgeCount(outgoing, ignoredEdge = null) {\n        let count = 0;\n        const edgeCount = this.getEdgeCount();\n        for (let i = 0; i < edgeCount; i += 1) {\n            const edge = this.getEdgeAt(i);\n            if (edge !== ignoredEdge && edge && edge.getTerminal(outgoing) === this) {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    /**\n     * Returns all edges of the given cell without loops.\n     */\n    getConnections() {\n        return this.getEdges(true, true, false);\n    }\n    /**\n     * Returns the incoming edges of the given cell without loops.\n     */\n    getIncomingEdges() {\n        return this.getEdges(true, false, false);\n    }\n    /**\n     * Returns the outgoing edges of the given cell without loops.\n     */\n    getOutgoingEdges() {\n        return this.getEdges(false, true, false);\n    }\n    /**\n     * Returns all distinct edges connected to this cell as a new array of\n     * {@link Cell}. If at least one of incoming or outgoing is true, then loops\n     * are ignored, otherwise if both are false, then all edges connected to\n     * the given cell are returned including loops.\n     *\n     * @param incoming  Optional boolean that specifies if incoming edges should be\n     * returned. Default is true.\n     * @param outgoing  Optional boolean that specifies if outgoing edges should be\n     * returned. Default is true.\n     * @param includeLoops  Optional boolean that specifies if loops should be returned.\n     * Default is true.\n     */\n    getEdges(incoming = true, outgoing = true, includeLoops = true) {\n        const edgeCount = this.getEdgeCount();\n        const result = [];\n        for (let i = 0; i < edgeCount; i += 1) {\n            const edge = this.getEdgeAt(i);\n            const source = edge.getTerminal(true);\n            const target = edge.getTerminal(false);\n            if ((includeLoops && source === target) ||\n                (source !== target &&\n                    ((incoming && target === this) || (outgoing && source === this)))) {\n                result.push(edge);\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns the absolute, accumulated origin for the children inside the\n     * given parent as an {@link Point}.\n     */\n    getOrigin() {\n        let result = new Point();\n        const parent = this.getParent();\n        if (parent) {\n            result = parent.getOrigin();\n            if (!this.isEdge()) {\n                const geo = this.getGeometry();\n                if (geo) {\n                    result.x += geo.x;\n                    result.y += geo.y;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns all descendants of the given cell and the cell itself in an array.\n     */\n    getDescendants() {\n        return this.filterDescendants(null);\n    }\n    /**\n     * Visits all cells recursively and applies the specified filter function\n     * to each cell. If the function returns true then the cell is added\n     * to the resulting array. The parent and result paramters are optional.\n     * If parent is not specified then the recursion starts at {@link root}.\n     *\n     * Example:\n     * The following example extracts all vertices from a given model:\n     * ```javascript\n     * var filter(cell)\n     * {\n     * \treturn model.isVertex(cell);\n     * }\n     * var vertices = model.filterDescendants(filter);\n     * ```\n     *\n     * @param filter  JavaScript function that takes an {@link Cell} as an argument\n     * and returns a boolean.\n     */\n    filterDescendants(filter) {\n        // Creates a new array for storing the result\n        let result = [];\n        // Checks if the filter returns true for the cell\n        // and adds it to the result array\n        if (filter === null || filter(this)) {\n            result.push(this);\n        }\n        // Visits the children of the cell\n        const childCount = this.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = this.getChildAt(i);\n            result = result.concat(child.filterDescendants(filter));\n        }\n        return result;\n    }\n    /**\n     * Returns the root of the model or the topmost parent of the given cell.\n     */\n    getRoot() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias -- we need to use `this` to refer to the instance to start processing\n        let cell = this;\n        let root = cell;\n        while (cell) {\n            root = cell;\n            cell = cell.getParent();\n        }\n        return root;\n    }\n}\nexport default Cell;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellPath from '../view/cell/CellPath';\nimport CodecRegistry from './CodecRegistry';\nimport { NODETYPE } from '../util/Constants';\nimport Cell from '../view/cell/Cell';\nimport { GlobalConfig } from '../util/config';\nimport { getFunctionName } from '../util/StringUtils';\nimport { importNode, isNode } from '../util/domUtils';\nconst createXmlDocument = () => {\n    return document.implementation.createDocument('', '', null);\n};\n/**\n * XML codec for JavaScript object graphs. See {@link ObjectCodec} for a\n * description of the general encoding/decoding scheme. This class uses the\n * codecs registered in {@link CodecRegistry} for encoding/decoding each object.\n *\n * ### References\n *\n * In order to resolve references, especially forward references, the Codec\n * constructor must be given the document that contains the referenced\n * elements.\n *\n * ### Examples\n *\n * The following code is used to encode a graph model.\n *\n * ```javascript\n * const encoder = new Codec();\n * const result = encoder.encode(graph.getDataModel());\n * const xml = mxUtils.getXml(result);\n * ```\n *\n * **WARN**: as of version 0.6.0, the codecs provided by maxGraph are no longer registered by default, they **MUST** be registered before\n * performing `encode` or `decode`. For instance, you can use the {@link registerAllCodecs} function (or other related functions)\n * to register the codecs.\n *\n * #### Example\n *\n * Using the code below, an XML document is decoded into an existing model. The\n * document may be obtained using {@link parseXml} for parsing an XML string.\n *\n * ```javascript\n * const doc = xmlUtils.parseXml(xmlString);\n * const codec = new Codec(doc);\n * codec.decode(doc.documentElement, graph.getDataModel());\n * ```\n *\n * #### Example\n *\n * This example demonstrates parsing a list of isolated cells into an existing\n * graph model. Note that the cells do not have a parent reference so they can\n * be added anywhere in the cell hierarchy after parsing.\n *\n * ```javascript\n * const xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\n * const doc = mxUtils.parseXml(xml);\n * const codec = new Codec(doc);\n * let elt = doc.documentElement.firstChild;\n * const cells = [];\n *\n * while (elt != null)\n * {\n *   cells.push(codec.decode(elt));\n *   elt = elt.nextSibling;\n * }\n * graph.addCells(cells);\n * ```\n *\n * #### Example\n *\n * Using the following code, the selection cells of a graph are encoded and the\n * output is displayed in a dialog box.\n *\n * ```javascript\n * const enc = new Codec();\n * const cells = graph.getSelectionCells();\n * const xml = xmlUtils.getPrettyXml(enc.encode(cells));\n * ```\n *\n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\n * must be passed to {@link getXml} as the second argument.\n *\n * ### Debugging\n *\n * For debugging I/O you can use the following code to get the sequence of\n * encoded objects:\n *\n * ```javascript\n * const oldEncode = encode;\n * encode(obj)\n * {\n *   GlobalConfig.logger.show();\n *   GlobalConfig.logger.debug('Codec.encode: obj=' + StringUtils.getFunctionName(obj.constructor));\n *\n *   return oldEncode.apply(this, arguments);\n * };\n * ```\n *\n * Note that the I/O system adds object codecs for new object automatically. For\n * decoding those objects, the constructor should be written as follows:\n *\n * ```javascript\n * var MyObj(name)\n * {\n *   // ...\n * };\n * ```\n *\n * @category Serialization with Codecs\n */\nclass Codec {\n    constructor(document = createXmlDocument()) {\n        /**\n         * Lookup table for resolving IDs to elements.\n         */\n        this.elements = null; // TODO why not { [key: string]: Element } | null\n        /**\n         * Specifies if default values should be encoded. Default is false.\n         */\n        this.encodeDefaults = false;\n        this.document = document;\n        this.objects = {};\n    }\n    /**\n     * Associates the given object with the given ID and returns the given object.\n     *\n     * @param id ID for the object to be associated with.\n     * @param obj Object to be associated with the ID.\n     */\n    putObject(id, obj) {\n        this.objects[id] = obj;\n        return obj;\n    }\n    /**\n     * Returns the decoded object for the element with the specified ID in\n     * {@link document}. If the object is not known then {@link lookup} is used to find an\n     * object. If no object is found, then the element with the respective ID\n     * from the document is parsed using {@link decode}.\n     */\n    getObject(id) {\n        let obj = null;\n        if (id != null) {\n            obj = this.objects[id];\n            if (obj == null) {\n                obj = this.lookup(id);\n                if (obj == null) {\n                    const node = this.getElementById(id);\n                    if (node != null) {\n                        obj = this.decode(node);\n                    }\n                }\n            }\n        }\n        return obj;\n    }\n    /**\n     * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\n     * This implementation always returns null.\n     *\n     * Example:\n     *\n     * ```javascript\n     * const codec = new Codec();\n     * codec.lookup(id)\n     * {\n     *   return model.getCell(id);\n     * };\n     * ```\n     *\n     * @param id ID of the object to be returned.\n     */\n    lookup(id) {\n        return null;\n    }\n    /**\n     * Returns the element with the given ID from {@link document}.\n     *\n     * @param id String that contains the ID.\n     */\n    getElementById(id) {\n        this.updateElements();\n        return this.elements[id];\n    }\n    updateElements() {\n        if (this.elements == null) {\n            this.elements = {};\n            if (this.document.documentElement != null) {\n                this.addElement(this.document.documentElement);\n            }\n        }\n    }\n    /**\n     * Adds the given element to {@link elements} if it has an ID.\n     */\n    addElement(node) {\n        if (node.nodeType === NODETYPE.ELEMENT) {\n            const id = node.getAttribute('id');\n            if (id != null) {\n                if (this.elements[id] == null) {\n                    this.elements[id] = node;\n                }\n                else if (this.elements[id] !== node) {\n                    throw new Error(`${id}: Duplicate ID`);\n                }\n            }\n        }\n        let nodeChild = node.firstChild;\n        while (nodeChild != null) {\n            this.addElement(nodeChild);\n            nodeChild = nodeChild.nextSibling;\n        }\n    }\n    /**\n     * Returns the ID of the specified object. This implementation\n     * calls {@link reference} first and if that returns null handles\n     * the object as an {@link Cell} by returning their IDs using\n     * {@link Cell.getId}. If no ID exists for the given cell, then\n     * an on-the-fly ID is generated using {@link CellPath.create}.\n     *\n     * @param obj Object to return the ID for.\n     */\n    getId(obj) {\n        let id = null;\n        if (obj != null) {\n            id = this.reference(obj);\n            if (id == null && obj instanceof Cell) {\n                id = obj.getId();\n                if (id == null) {\n                    // Uses an on-the-fly Id\n                    id = CellPath.create(obj);\n                    if (id.length === 0) {\n                        id = 'root';\n                    }\n                }\n            }\n        }\n        return id;\n    }\n    /**\n     * Hook for subclassers to implement a custom method\n     * for retrieving IDs from objects. This implementation\n     * always returns null.\n     *\n     * Example:\n     *\n     * ```javascript\n     * const codec = new Codec();\n     * codec.reference(obj)\n     * {\n     *   return obj.getCustomId();\n     * };\n     * ```\n     *\n     * @param obj Object whose ID should be returned.\n     */\n    reference(obj) {\n        return null;\n    }\n    /**\n     * Encodes the specified object and returns the resulting XML node.\n     *\n     * @param obj Object to be encoded.\n     */\n    encode(obj) {\n        let node = null;\n        if (obj != null && obj.constructor != null) {\n            const enc = CodecRegistry.getCodec(obj.constructor);\n            if (enc != null) {\n                node = enc.encode(this, obj);\n            }\n            else if (isNode(obj)) {\n                node = importNode(this.document, obj, true);\n            }\n            else {\n                GlobalConfig.logger.warn(`Codec.encode: No codec for ${getFunctionName(obj.constructor)}`);\n            }\n        }\n        return node;\n    }\n    /**\n     * Decodes the given XML node. The optional \"into\"\n     * argument specifies an existing object to be\n     * used. If no object is given, then a new instance\n     * is created using the constructor from the codec.\n     *\n     * The function returns the passed in object or\n     * the new instance if no object was given.\n     *\n     * @param node XML node to be decoded.\n     * @param into Optional object to be decoded into.\n     */\n    decode(node, into) {\n        this.updateElements();\n        let obj = null;\n        if (node != null && node.nodeType === NODETYPE.ELEMENT) {\n            const dec = CodecRegistry.getCodecByName(node.nodeName);\n            if (dec != null) {\n                obj = dec.decode(this, node, into);\n            }\n            else {\n                obj = node.cloneNode(true);\n                obj.removeAttribute('as');\n            }\n        }\n        return obj;\n    }\n    /**\n     * Encoding of cell hierarchies is built-into the core, but\n     * is a higher-level function that needs to be explicitely\n     * used by the respective object encoders (eg. {@link ModelCodec},\n     * {@link ChildChangeCodec} and {@link RootChangeCodec}). This\n     * implementation writes the given cell and its children as a\n     * (flat) sequence into the given node. The children are not\n     * encoded if the optional includeChildren is false. The\n     * function is in charge of adding the result into the\n     * given node and has no return value.\n     *\n     * @param cell {@link mxCell} to be encoded.\n     * @param node Parent XML node to add the encoded cell into.\n     * @param includeChildren Optional boolean indicating if the\n     * function should include all descendents. Default is true.\n     */\n    encodeCell(cell, node, includeChildren) {\n        const appendMe = this.encode(cell);\n        if (appendMe) {\n            node.appendChild(appendMe);\n        }\n        if (includeChildren == null || includeChildren) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.encodeCell(cell.getChildAt(i), node);\n            }\n        }\n    }\n    /**\n     * Returns true if the given codec is a cell codec. This uses\n     * {@link CellCodec.isCellCodec} to check if the codec is of the\n     * given type.\n     */\n    isCellCodec(codec) {\n        if (codec != null && 'isCellCodec' in codec) {\n            return codec.isCellCodec();\n        }\n        return false;\n    }\n    /**\n     * Decodes cells that have been encoded using inversion, ie.\n     * where the user object is the enclosing node in the XML,\n     * and restores the group and graph structure in the cells.\n     * Returns a new {@link Cell} instance that represents the\n     * given node.\n     *\n     * @param node XML node that contains the cell data.\n     * @param restoreStructures Optional boolean indicating whether\n     * the graph structure should be restored by calling insert\n     * and insertEdge on the parent and terminals, respectively.\n     * Default is `true`.\n     */\n    decodeCell(node, restoreStructures = true) {\n        if (node?.nodeType !== NODETYPE.ELEMENT) {\n            return null;\n        }\n        // Tries to find a codec for the given node name. If that does\n        // not return a codec then the node is the user object (an XML node\n        // that contains the mxCell, aka inversion).\n        let decoder = CodecRegistry.getCodec(node.nodeName);\n        // Tries to find the codec for the cell inside the user object.\n        // This assumes all node names inside the user object are either\n        // not registered or they correspond to a class for cells.\n        if (!this.isCellCodec(decoder)) {\n            let child = node.firstChild;\n            while (child != null && !this.isCellCodec(decoder)) {\n                decoder = CodecRegistry.getCodec(child.nodeName);\n                child = child.nextSibling;\n            }\n        }\n        if (!this.isCellCodec(decoder)) {\n            decoder = CodecRegistry.getCodec(Cell);\n        }\n        const cell = decoder?.decode(this, node);\n        if (restoreStructures) {\n            this.insertIntoGraph(cell);\n        }\n        return cell;\n    }\n    /**\n     * Inserts the given cell into its parent and terminal cells.\n     */\n    insertIntoGraph(cell) {\n        const { parent } = cell;\n        const source = cell.getTerminal(true);\n        const target = cell.getTerminal(false);\n        // Fixes possible inconsistencies during insert into graph\n        cell.setTerminal(null, false);\n        cell.setTerminal(null, true);\n        cell.parent = null;\n        if (parent != null) {\n            if (parent === cell) {\n                throw new Error(`${parent.id}: Self Reference`);\n            }\n            else {\n                parent.insert(cell);\n            }\n        }\n        if (source != null) {\n            source.insertEdge(cell, true);\n        }\n        if (target != null) {\n            target.insertEdge(cell, false);\n        }\n    }\n    /**\n     * Sets the attribute on the specified node to value. This is a\n     * helper method that makes sure the attribute and value arguments\n     * are not null.\n     *\n     * @param node XML node to set the attribute for.\n     * @param attribute The name of the attribute to be set.\n     * @param value New value of the attribute.\n     */\n    setAttribute(node, attribute, value) {\n        if (attribute != null && value != null) {\n            node.setAttribute(attribute, value);\n        }\n    }\n}\nexport default Codec;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isNotNullish } from '../../util/Utils';\nimport { mod } from '../../util/mathUtils';\nimport { getAlignmentAsPoint, matchBinaryMask } from '../../util/styleUtils';\nimport Client from '../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DIRECTION, FONT, LINE_HEIGHT, NONE, NS_SVG, NS_XLINK, SHADOWCOLOR, WORD_WRAP, } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport AbstractCanvas2D from './AbstractCanvas2D';\nimport { getXml } from '../../util/xmlUtils';\nimport { isNode, write } from '../../util/domUtils';\nimport { htmlEntities, trim } from '../../util/StringUtils';\n// Activates workaround for gradient ID resolution if base tag is used.\nconst useAbsoluteIds = typeof DOMParser === 'function' &&\n    !Client.IS_CHROMEAPP &&\n    !Client.IS_EDGE &&\n    document.getElementsByTagName('base').length > 0;\n/**\n * Extends {@link mxAbstractCanvas2D} to implement a canvas for SVG. This canvas writes all calls as SVG output to the\n * given SVG root node.\n *\n * ```javascript\n * var svgDoc = mxUtils.createXmlDocument();\n * var root = (svgDoc.createElementNS != null) ?\n * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');\n *\n * if (svgDoc.createElementNS == null)\n * {\n *   root.setAttribute('xmlns', mxConstants.NS_SVG);\n *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);\n * }\n * else\n * {\n *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);\n * }\n *\n * var bounds = graph.getGraphBounds();\n * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');\n * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');\n * root.setAttribute('version', '1.1');\n *\n * svgDoc.appendChild(root);\n *\n * var svgCanvas = new mxSvgCanvas2D(root);\n * ```\n *\n *\n * To disable anti-aliasing in the output, use the following code.\n * ```javascript\n * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');\n * ```\n * Or set the respective attribute in the SVG element directly.\n */\nclass SvgCanvas2D extends AbstractCanvas2D {\n    constructor(root, styleEnabled) {\n        super();\n        this.defs = null;\n        this.styleEnabled = true;\n        /**\n         * Holds the current DOM node.\n         */\n        this.node = null;\n        /**\n         * Specifies if plain text output should match the vertical HTML alignment.\n         * @default true.\n         */\n        this.matchHtmlAlignment = true;\n        /**\n         * Specifies if text output should be enabled.\n         * @default true\n         */\n        this.textEnabled = true;\n        /**\n         * Specifies if use of foreignObject for HTML markup is allowed.\n         * @default true\n         */\n        this.foEnabled = true;\n        /**\n         * Specifies the fallback text for unsupported foreignObjects in exported documents.\n         * If this is set to `null` then no fallback text is added to the exported document.\n         * @default [Object]\n         */\n        this.foAltText = '[Object]';\n        /**\n         * Offset to be used for foreignObjects.\n         * @default 0\n         */\n        this.foOffset = 0;\n        /**\n         * Offset to be used for text elements.\n         * @default 0\n         */\n        this.textOffset = 0;\n        /**\n         * Offset to be used for image elements.\n         * @default 0\n         */\n        this.imageOffset = 0;\n        /**\n         * Adds transparent paths for strokes.\n         * @default 0\n         */\n        this.strokeTolerance = 0;\n        /**\n         * Minimum stroke width for output.\n         * @default 1\n         */\n        this.minStrokeWidth = 1;\n        /**\n         * Local counter for references in SVG export.\n         * @default 0\n         */\n        this.refCount = 0;\n        /**\n         * Correction factor for {@link mxConstants.LINE_HEIGHT} in HTML output.\n         * @default 1\n         */\n        this.lineHeightCorrection = 1;\n        /**\n         * Default value for active pointer events.\n         * @default all\n         */\n        this.pointerEventsValue = 'all';\n        /**\n         * Padding to be added for text that is not wrapped to account for differences in font metrics on different platforms in pixels.\n         * @default 10.\n         */\n        this.fontMetricsPadding = 10;\n        /**\n         * Specifies if offsetWidth and offsetHeight should be cached. This is used to speed up repaint of text in {@link updateText}.\n         * @default true\n         */\n        this.cacheOffsetSize = true;\n        this.originalRoot = null;\n        /**\n         * Reference to the container for the SVG content.\n         */\n        this.root = root;\n        /**\n         * Local cache of gradients for quick lookups.\n         */\n        this.gradients = {};\n        /**\n         * Reference to the defs section of the SVG document. Only for export.\n         */\n        this.defs = null;\n        /**\n         * Stores the value of styleEnabled passed to the constructor.\n         */\n        this.styleEnabled = styleEnabled != null ? styleEnabled : false;\n        let svg = null;\n        // Adds optional defs section for export\n        if (root.ownerDocument !== document) {\n            let node = root;\n            // Finds owner SVG element in XML DOM\n            while (node && node.nodeName !== 'svg') {\n                node = node.parentElement;\n            }\n            svg = node;\n        }\n        if (svg) {\n            // Tries to get existing defs section\n            const tmp = svg.getElementsByTagName('defs');\n            if (tmp.length > 0) {\n                this.defs = svg.getElementsByTagName('defs')[0];\n            }\n            // Adds defs section if none exists\n            if (!this.defs) {\n                this.defs = this.createElement('defs');\n                if (svg.firstChild != null) {\n                    svg.insertBefore(this.defs, svg.firstChild);\n                }\n                else {\n                    svg.appendChild(this.defs);\n                }\n            }\n            // Adds stylesheet\n            if (this.styleEnabled) {\n                this.defs.appendChild(this.createStyle());\n            }\n        }\n    }\n    /**\n     * Rounds all numbers to 2 decimal points.\n     */\n    format(value) {\n        return parseFloat(value.toFixed(2));\n    }\n    /**\n     * Returns the URL of the page without the hash part. This needs to use href to\n     * include any search part with no params (ie question mark alone). This is a\n     * workaround for the fact that window.location.search is empty if there is\n     * no search string behind the question mark.\n     */\n    getBaseUrl() {\n        let { href } = window.location;\n        const hash = href.lastIndexOf('#');\n        if (hash > 0) {\n            href = href.substring(0, hash);\n        }\n        return href;\n    }\n    /**\n     * Returns any offsets for rendering pixels.\n     */\n    reset() {\n        super.reset();\n        this.gradients = {};\n    }\n    end() {\n        return;\n    }\n    /**\n     * Creates the optional style section.\n     */\n    createStyle() {\n        const style = this.createElement('style');\n        style.setAttribute('type', 'text/css');\n        write(style, `svg{font-family:${DEFAULT_FONTFAMILY};font-size:${DEFAULT_FONTSIZE};fill:none;stroke-miterlimit:10}`);\n        return style;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    createElement(tagName, namespace) {\n        return this.root?.ownerDocument.createElementNS(namespace || NS_SVG, tagName);\n    }\n    /**\n     * Returns the alternate text string for the given foreignObject.\n     */\n    getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {\n        return isNotNullish(str) ? this.foAltText : null;\n    }\n    /**\n     * Returns the alternate content for the given foreignObject.\n     */\n    createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {\n        const text = this.getAlternateText(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n        const s = this.state;\n        if (isNotNullish(text) && s.fontSize > 0) {\n            const dy = valign === ALIGN.TOP ? 1 : valign === ALIGN.BOTTOM ? 0 : 0.3;\n            const anchor = align === ALIGN.RIGHT ? 'end' : align === ALIGN.LEFT ? 'start' : 'middle';\n            const alt = this.createElement('text');\n            alt.setAttribute('x', String(Math.round(x + s.dx)));\n            alt.setAttribute('y', String(Math.round(y + s.dy + dy * s.fontSize)));\n            alt.setAttribute('fill', s.fontColor || 'black');\n            alt.setAttribute('font-family', s.fontFamily);\n            alt.setAttribute('font-size', `${Math.round(s.fontSize)}px`);\n            // Text-anchor start is default in SVG\n            anchor !== 'start' && alt.setAttribute('text-anchor', anchor);\n            const fontStyle = s.fontStyle;\n            matchBinaryMask(fontStyle, FONT.BOLD) && alt.setAttribute('font-weight', 'bold');\n            matchBinaryMask(fontStyle, FONT.ITALIC) && alt.setAttribute('font-style', 'italic');\n            const txtDecor = [];\n            matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n            matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n            txtDecor.length > 0 && alt.setAttribute('text-decoration', txtDecor.join(' '));\n            write(alt, text);\n            return alt;\n        }\n        return null;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    createGradientId(start, end, alpha1, alpha2, direction) {\n        // Removes illegal characters from gradient ID\n        if (start.charAt(0) === '#') {\n            start = start.substring(1);\n        }\n        if (end.charAt(0) === '#') {\n            end = end.substring(1);\n        }\n        // Workaround for gradient IDs not working in Safari 5 / Chrome 6\n        // if they contain uppercase characters\n        start = `${start.toLowerCase()}-${alpha1}`;\n        end = `${end.toLowerCase()}-${alpha2}`;\n        // Wrong gradient directions possible?\n        let dir = null;\n        if (direction == null || direction === DIRECTION.SOUTH) {\n            dir = 's';\n        }\n        else if (direction === DIRECTION.EAST) {\n            dir = 'e';\n        }\n        else {\n            const tmp = start;\n            start = end;\n            end = tmp;\n            if (direction === DIRECTION.NORTH) {\n                dir = 's';\n            }\n            else if (direction === DIRECTION.WEST) {\n                dir = 'e';\n            }\n        }\n        return `mx-gradient-${start}-${end}-${dir}`;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getSvgGradient(start, end, alpha1, alpha2, direction) {\n        const id = this.createGradientId(start, end, alpha1, alpha2, direction);\n        let gradient = this.gradients[id];\n        if (!gradient) {\n            const svg = this.root.ownerSVGElement;\n            let counter = 0;\n            let tmpId = `${id}-${counter}`;\n            if (svg) {\n                gradient = svg.ownerDocument.getElementById(tmpId);\n                while (gradient && gradient.ownerSVGElement !== svg) {\n                    tmpId = `${id}-${counter++}`;\n                    gradient = svg.ownerDocument.getElementById(tmpId);\n                }\n            }\n            else {\n                // Uses shorter IDs for export\n                tmpId = `id${++this.refCount}`;\n            }\n            if (!gradient) {\n                gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);\n                gradient.setAttribute('id', tmpId);\n                if (this.defs) {\n                    this.defs.appendChild(gradient);\n                }\n                else if (svg) {\n                    svg.appendChild(gradient);\n                }\n            }\n            this.gradients[id] = gradient;\n        }\n        return gradient.getAttribute('id');\n    }\n    /**\n     * Creates the given SVG gradient.\n     */\n    createSvgGradient(start, end, alpha1, alpha2, direction) {\n        const gradient = this.createElement('linearGradient');\n        gradient.setAttribute('x1', '0%');\n        gradient.setAttribute('y1', '0%');\n        gradient.setAttribute('x2', '0%');\n        gradient.setAttribute('y2', '0%');\n        if (direction == null || direction === DIRECTION.SOUTH) {\n            gradient.setAttribute('y2', '100%');\n        }\n        else if (direction === DIRECTION.EAST) {\n            gradient.setAttribute('x2', '100%');\n        }\n        else if (direction === DIRECTION.NORTH) {\n            gradient.setAttribute('y1', '100%');\n        }\n        else if (direction === DIRECTION.WEST) {\n            gradient.setAttribute('x1', '100%');\n        }\n        let op = alpha1 < 1 ? `;stop-opacity:${alpha1}` : '';\n        let stop = this.createElement('stop');\n        stop.setAttribute('offset', '0%');\n        stop.setAttribute('style', `stop-color:${start}${op}`);\n        gradient.appendChild(stop);\n        op = alpha2 < 1 ? `;stop-opacity:${alpha2}` : '';\n        stop = this.createElement('stop');\n        stop.setAttribute('offset', '100%');\n        stop.setAttribute('style', `stop-color:${end}${op}`);\n        gradient.appendChild(stop);\n        return gradient;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    addNode(filled, stroked) {\n        const { node } = this;\n        const s = this.state;\n        if (node) {\n            if (node.nodeName === 'path') {\n                // Checks if the path is not empty\n                if (this.path && this.path.length > 0) {\n                    node.setAttribute('d', this.path.join(' '));\n                }\n                else {\n                    return;\n                }\n            }\n            if (filled && s.fillColor !== NONE) {\n                this.updateFill();\n            }\n            else if (!this.styleEnabled) {\n                // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=814952\n                if (node.nodeName === 'ellipse' && Client.IS_FF) {\n                    node.setAttribute('fill', 'transparent');\n                }\n                else {\n                    node.setAttribute('fill', NONE);\n                }\n                // Sets the actual filled state for stroke tolerance\n                filled = false;\n            }\n            if (stroked && s.strokeColor !== NONE) {\n                this.updateStroke();\n            }\n            else if (!this.styleEnabled) {\n                node.setAttribute('stroke', NONE);\n            }\n            if (s.transform && s.transform.length > 0) {\n                node.setAttribute('transform', s.transform);\n            }\n            if (s.shadow) {\n                this.root.appendChild(this.createShadow(node));\n            }\n            // Adds stroke tolerance\n            if (this.strokeTolerance > 0 && !filled) {\n                this.root.appendChild(this.createTolerance(node));\n            }\n            // Adds pointer events\n            if (this.pointerEvents) {\n                node.setAttribute('pointer-events', this.pointerEventsValue);\n            }\n            // Enables clicks for nodes inside a link element\n            else if (!this.pointerEvents && !this.originalRoot) {\n                node.setAttribute('pointer-events', NONE);\n            }\n            // Removes invisible nodes from output if they don't handle events\n            if ((node.nodeName !== 'rect' &&\n                node.nodeName !== 'path' &&\n                node.nodeName !== 'ellipse') ||\n                (node.getAttribute('fill') !== NONE &&\n                    node.getAttribute('fill') !== 'transparent') ||\n                node.getAttribute('stroke') !== NONE ||\n                node.getAttribute('pointer-events') !== NONE) {\n                // LATER: Update existing DOM for performance\n                this.root.appendChild(node);\n            }\n            this.node = null;\n        }\n    }\n    /**\n     * Transfers the stroke attributes from <state> to <node>.\n     */\n    updateFill() {\n        const s = this.state;\n        if (s.alpha < 1 || s.fillAlpha < 1) {\n            this.node.setAttribute('fill-opacity', String(s.alpha * s.fillAlpha));\n        }\n        if (s.fillColor !== NONE) {\n            if (s.gradientColor !== NONE) {\n                const id = this.getSvgGradient(s.fillColor, s.gradientColor, s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);\n                if (this.root?.ownerDocument === document && useAbsoluteIds) {\n                    // Workaround for no fill with base tag in page (escape brackets)\n                    const base = this.getBaseUrl().replace(/([()])/g, '\\\\$1');\n                    this.node.setAttribute('fill', `url(${base}#${id})`);\n                }\n                else {\n                    this.node.setAttribute('fill', `url(#${id})`);\n                }\n            }\n            else {\n                this.node.setAttribute('fill', s.fillColor.toLowerCase());\n            }\n        }\n    }\n    /**\n     * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).\n     */\n    getCurrentStrokeWidth() {\n        return Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));\n    }\n    /**\n     * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.\n     */\n    updateStroke() {\n        const s = this.state;\n        if (s.strokeColor && s.strokeColor !== NONE) {\n            this.node.setAttribute('stroke', s.strokeColor.toLowerCase());\n        }\n        if (s.alpha < 1 || s.strokeAlpha < 1) {\n            this.node.setAttribute('stroke-opacity', String(s.alpha * s.strokeAlpha));\n        }\n        const sw = this.getCurrentStrokeWidth();\n        if (sw !== 1) {\n            this.node.setAttribute('stroke-width', String(sw));\n        }\n        if (this.node.nodeName === 'path') {\n            this.updateStrokeAttributes();\n        }\n        if (s.dashed) {\n            this.node.setAttribute('stroke-dasharray', this.createDashPattern((s.fixDash ? 1 : s.strokeWidth) * s.scale));\n        }\n    }\n    /**\n     * Transfers the stroke attributes from {@link mxAbstractCanvas2D.state} to {@link node}.\n     */\n    updateStrokeAttributes() {\n        const s = this.state;\n        // Linejoin miter is default in SVG\n        if (s.lineJoin && s.lineJoin !== 'miter') {\n            this.node.setAttribute('stroke-linejoin', s.lineJoin);\n        }\n        if (s.lineCap) {\n            // flat is called butt in SVG\n            let value = s.lineCap;\n            if (value === 'flat') {\n                value = 'butt';\n            }\n            // Linecap butt is default in SVG\n            if (value !== 'butt') {\n                this.node.setAttribute('stroke-linecap', value);\n            }\n        }\n        // Miterlimit 10 is default in our document\n        if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit !== 10)) {\n            this.node.setAttribute('stroke-miterlimit', String(s.miterLimit));\n        }\n    }\n    /**\n     * Creates the SVG dash pattern for the given state.\n     */\n    createDashPattern(scale) {\n        const pat = [];\n        if (typeof this.state.dashPattern === 'string') {\n            const dash = this.state.dashPattern.split(' ');\n            if (dash.length > 0) {\n                for (let i = 0; i < dash.length; i += 1) {\n                    pat[i] = Number(dash[i]) * scale;\n                }\n            }\n        }\n        return pat.join(' ');\n    }\n    /**\n     * Creates a hit detection tolerance shape for the given node.\n     */\n    createTolerance(node) {\n        const tol = node.cloneNode(true);\n        const sw = parseFloat(tol.getAttribute('stroke-width') || '1') + this.strokeTolerance;\n        tol.setAttribute('pointer-events', 'stroke');\n        tol.setAttribute('visibility', 'hidden');\n        tol.removeAttribute('stroke-dasharray');\n        tol.setAttribute('stroke-width', String(sw));\n        tol.setAttribute('fill', 'none');\n        tol.setAttribute('stroke', 'white');\n        return tol;\n    }\n    /**\n     * Creates a shadow for the given node.\n     */\n    createShadow(node) {\n        const shadow = node.cloneNode(true);\n        const s = this.state;\n        // Firefox uses transparent for no fill in ellipses\n        if (shadow.getAttribute('fill') !== 'none' &&\n            (!Client.IS_FF || shadow.getAttribute('fill') !== 'transparent')) {\n            shadow.setAttribute('fill', (s.shadowColor ? s.shadow : SHADOWCOLOR));\n        }\n        if (shadow.getAttribute('stroke') !== 'none' &&\n            s.shadowColor &&\n            s.shadowColor !== NONE) {\n            shadow.setAttribute('stroke', s.shadowColor);\n        }\n        shadow.setAttribute('transform', `translate(${this.format(s.shadowDx * s.scale)},${this.format(s.shadowDy * s.scale)})${s.transform || ''}`);\n        shadow.setAttribute('opacity', String(s.shadowAlpha));\n        return shadow;\n    }\n    /**\n     * Experimental implementation for hyperlinks.\n     */\n    setLink(link) {\n        if (!link) {\n            this.root = this.originalRoot;\n        }\n        else {\n            this.originalRoot = this.root;\n            const node = this.createElement('a');\n            // Workaround for implicit namespace handling in HTML5 export, IE adds NS1 namespace so use code below\n            // in all IE versions except quirks mode. KNOWN: Adds xlink namespace to each image tag in output.\n            if (node.setAttributeNS == null || this.root.ownerDocument !== document) {\n                node.setAttribute('xlink:href', link);\n            }\n            else {\n                node.setAttributeNS(NS_XLINK, 'xlink:href', link);\n            }\n            this.root.appendChild(node);\n            this.root = node;\n        }\n    }\n    /**\n     * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\n     */\n    rotate(theta, flipH, flipV, cx, cy) {\n        if (theta !== 0 || flipH || flipV) {\n            const s = this.state;\n            cx += s.dx;\n            cy += s.dy;\n            cx *= s.scale;\n            cy *= s.scale;\n            s.transform = s.transform || '';\n            // This implementation uses custom scale/translate and built-in rotation\n            // Rotation state is part of the AffineTransform in state.transform\n            if (flipH && flipV) {\n                theta += 180;\n            }\n            else if (flipH !== flipV) {\n                const tx = flipH ? cx : 0;\n                const sx = flipH ? -1 : 1;\n                const ty = flipV ? cy : 0;\n                const sy = flipV ? -1 : 1;\n                s.transform +=\n                    `translate(${this.format(tx)},${this.format(ty)})` +\n                        `scale(${this.format(sx)},${this.format(sy)})` +\n                        `translate(${this.format(-tx)},${this.format(-ty)})`;\n            }\n            if (flipH ? !flipV : flipV) {\n                theta *= -1;\n            }\n            if (theta !== 0) {\n                s.transform += `rotate(${this.format(theta)},${this.format(cx)},${this.format(cy)})`;\n            }\n            s.rotation += theta;\n            s.rotationCx = cx;\n            s.rotationCy = cy;\n        }\n    }\n    /**\n     * Extends superclass to create path.\n     */\n    begin() {\n        super.begin();\n        this.node = this.createElement('path');\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    rect(x, y, w, h) {\n        const s = this.state;\n        const n = this.createElement('rect');\n        n.setAttribute('x', String(this.format((x + s.dx) * s.scale)));\n        n.setAttribute('y', String(this.format((y + s.dy) * s.scale)));\n        n.setAttribute('width', String(this.format(w * s.scale)));\n        n.setAttribute('height', String(this.format(h * s.scale)));\n        this.node = n;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    roundrect(x, y, w, h, dx, dy) {\n        this.rect(x, y, w, h);\n        if (dx > 0) {\n            this.node.setAttribute('rx', String(this.format(dx * this.state.scale)));\n        }\n        if (dy > 0) {\n            this.node.setAttribute('ry', String(this.format(dy * this.state.scale)));\n        }\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    ellipse(x, y, w, h) {\n        const s = this.state;\n        const n = this.createElement('ellipse');\n        // No rounding for consistent output with 1.x\n        n.setAttribute('cx', String(this.format((x + w / 2 + s.dx) * s.scale)));\n        n.setAttribute('cy', String(this.format((y + h / 2 + s.dy) * s.scale)));\n        n.setAttribute('rx', String((w / 2) * s.scale));\n        n.setAttribute('ry', String((h / 2) * s.scale));\n        this.node = n;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {\n        src = this.converter.convert(src);\n        const s = this.state;\n        x += s.dx;\n        y += s.dy;\n        const node = this.createElement('image');\n        node.setAttribute('x', String(this.format(x * s.scale) + this.imageOffset));\n        node.setAttribute('y', String(this.format(y * s.scale) + this.imageOffset));\n        node.setAttribute('width', String(this.format(w * s.scale)));\n        node.setAttribute('height', String(this.format(h * s.scale)));\n        // Workaround for missing namespace support\n        if (!node.setAttributeNS) {\n            node.setAttribute('xlink:href', src);\n        }\n        else {\n            node.setAttributeNS(NS_XLINK, 'xlink:href', src);\n        }\n        if (!aspect) {\n            node.setAttribute('preserveAspectRatio', 'none');\n        }\n        if (s.alpha < 1 || s.fillAlpha < 1) {\n            node.setAttribute('opacity', String(s.alpha * s.fillAlpha));\n        }\n        let tr = this.state.transform || '';\n        if (flipH || flipV) {\n            let sx = 1;\n            let sy = 1;\n            let dx = 0;\n            let dy = 0;\n            if (flipH) {\n                sx = -1;\n                dx = -w - 2 * x;\n            }\n            if (flipV) {\n                sy = -1;\n                dy = -h - 2 * y;\n            }\n            // Adds image transformation to existing transform\n            tr += `scale(${sx},${sy})translate(${dx * s.scale},${dy * s.scale})`;\n        }\n        if (tr.length > 0) {\n            node.setAttribute('transform', tr);\n        }\n        if (!this.pointerEvents) {\n            node.setAttribute('pointer-events', 'none');\n        }\n        this.root.appendChild(node);\n    }\n    /**\n     * Converts the given HTML string to XHTML.\n     */\n    convertHtml(val) {\n        const doc = new DOMParser().parseFromString(val, 'text/html');\n        if (doc != null) {\n            val = new XMLSerializer().serializeToString(doc.body);\n            // Extracts body content from DOM\n            if (val.substring(0, 5) === '<body') {\n                val = val.substring(val.indexOf('>', 5) + 1);\n            }\n            if (val.substring(val.length - 7, val.length) === '</body>') {\n                val = val.substring(0, val.length - 7);\n            }\n        }\n        return val;\n    }\n    /**\n     * Private helper function to create SVG elements\n     * Note: signature changed in mxgraph 4.1.0\n     */\n    createDiv(str) {\n        let val = str;\n        if (!isNode(val)) {\n            val = `<div><div>${this.convertHtml(val)}</div></div>`;\n        }\n        if (document.createElementNS) {\n            const div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n            if (isNode(val)) {\n                const n = val;\n                const div2 = document.createElement('div');\n                const div3 = div2.cloneNode(false);\n                // Creates a copy for export\n                if (this.root.ownerDocument !== document) {\n                    div2.appendChild(n.cloneNode(true));\n                }\n                else {\n                    div2.appendChild(n);\n                }\n                div3.appendChild(div2);\n                div.appendChild(div3);\n            }\n            else {\n                div.innerHTML = val;\n            }\n            return div;\n        }\n        if (isNode(val)) {\n            val = `<div><div>${getXml(val)}</div></div>`;\n        }\n        val = `<div xmlns=\"http://www.w3.org/1999/xhtml\">${val}</div>`;\n        // NOTE: FF 3.6 crashes if content CSS contains \"height:100%\"\n        return new DOMParser().parseFromString(val, 'text/xml').documentElement;\n    }\n    /**\n     * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.\n     */\n    updateText(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node) {\n        if (node && node.firstChild && node.firstChild.firstChild) {\n            this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node.firstChild);\n        }\n    }\n    /**\n     * Creates a foreignObject for the given string and adds it to the given root.\n     */\n    addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, root) {\n        const group = this.createElement('g');\n        const fo = this.createElement('foreignObject');\n        // Workarounds for print clipping and static position in Safari\n        fo.setAttribute('style', 'overflow: visible; text-align: left;');\n        fo.setAttribute('pointer-events', 'none');\n        fo.appendChild(div);\n        group.appendChild(fo);\n        this.updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, group);\n        // Alternate content if foreignObject not supported\n        if (this.root?.ownerDocument !== document) {\n            const alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n            if (alt != null) {\n                fo.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');\n                const sw = this.createElement('switch');\n                sw.appendChild(fo);\n                sw.appendChild(alt);\n                group.appendChild(sw);\n            }\n        }\n        root.appendChild(group);\n    }\n    /**\n     * Updates existing DOM nodes for text rendering.\n     */\n    updateTextNodes(x, y, w, h, align, valign, wrap, overflow, clip, rotation, g) {\n        const s = this.state.scale;\n        SvgCanvas2D.createCss(w + 2, h, align, valign, wrap, overflow, clip, this.state.fontBackgroundColor != null ? this.state.fontBackgroundColor : null, this.state.fontBorderColor != null ? this.state.fontBorderColor : null, `display: flex; align-items: unsafe ${valign === ALIGN.TOP\n            ? 'flex-start'\n            : valign === ALIGN.BOTTOM\n                ? 'flex-end'\n                : 'center'}; ` +\n            `justify-content: unsafe ${align === ALIGN.LEFT\n                ? 'flex-start'\n                : align === ALIGN.RIGHT\n                    ? 'flex-end'\n                    : 'center'}; `, this.getTextCss(), s, (dx, dy, flex, item, block) => {\n            x += this.state.dx;\n            y += this.state.dy;\n            const fo = g.firstChild;\n            const div = fo.firstChild;\n            const box = div.firstChild;\n            const text = box.firstChild;\n            const r = (this.rotateHtml ? this.state.rotation : 0) + (rotation != null ? rotation : 0);\n            let t = (this.foOffset !== 0 ? `translate(${this.foOffset} ${this.foOffset})` : '') +\n                (s !== 1 ? `scale(${s})` : '');\n            text.setAttribute('style', block);\n            box.setAttribute('style', item);\n            // Workaround for clipping in Webkit with scrolling and zoom\n            fo.setAttribute('width', `${Math.ceil((1 / Math.min(1, s)) * 100)}%`);\n            fo.setAttribute('height', `${Math.ceil((1 / Math.min(1, s)) * 100)}%`);\n            const yp = Math.round(y + dy);\n            // Allows for negative values which are causing problems with\n            // transformed content where the top edge of the foreignObject\n            // limits the text box being moved further up in the diagram.\n            // KNOWN: Possible clipping problems with zoom and scrolling\n            // but this is normally not used with scrollbars as the\n            // coordinates are always positive with scrollbars.\n            // Margin-top is ignored in Safari and no negative values allowed\n            // for padding.\n            if (yp < 0) {\n                fo.setAttribute('y', String(yp));\n            }\n            else {\n                fo.removeAttribute('y');\n                flex += `padding-top: ${yp}px; `;\n            }\n            div.setAttribute('style', `${flex}margin-left: ${Math.round(x + dx)}px;`);\n            t += r !== 0 ? `rotate(${r} ${x} ${y})` : '';\n            // Output allows for reflow but Safari cannot use absolute position,\n            // transforms or opacity. https://bugs.webkit.org/show_bug.cgi?id=23113\n            if (t !== '') {\n                g.setAttribute('transform', t);\n            }\n            else {\n                g.removeAttribute('transform');\n            }\n            if (this.state.alpha !== 1) {\n                g.setAttribute('opacity', String(this.state.alpha));\n            }\n            else {\n                g.removeAttribute('opacity');\n            }\n        });\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getTextCss() {\n        const s = this.state;\n        const lh = ABSOLUTE_LINE_HEIGHT\n            ? `${s.fontSize * LINE_HEIGHT}px`\n            : LINE_HEIGHT * this.lineHeightCorrection;\n        let css = `display: inline-block; font-size: ${s.fontSize}px; ` +\n            `font-family: ${s.fontFamily}; color: ${s.fontColor}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? this.pointerEventsValue : 'none'}; `;\n        const fontStyle = s.fontStyle;\n        matchBinaryMask(fontStyle, FONT.BOLD) && (css += 'font-weight: bold; ');\n        matchBinaryMask(fontStyle, FONT.ITALIC) && (css += 'font-style: italic; ');\n        const txtDecor = [];\n        matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);\n        return css;\n    }\n    /**\n     * Paints the given text. Possible values for format are empty string for plain\n     * text and html for HTML markup. Note that HTML markup is only supported if\n     * foreignObject is supported and <foEnabled> is true. (This means IE9 and later\n     * does currently not support HTML text as part of shapes.)\n     */\n    text(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation = 0, dir) {\n        if (this.textEnabled && str != null) {\n            rotation = rotation != null ? rotation : 0;\n            if (this.foEnabled && format === 'html') {\n                const div = this.createDiv(str);\n                // Ignores invalid XHTML labels\n                if (div != null) {\n                    if (dir != null) {\n                        div.setAttribute('dir', dir);\n                    }\n                    this.addForeignObject(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir, div, this.root);\n                }\n            }\n            else {\n                this.plainText(x + this.state.dx, y + this.state.dy, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);\n            }\n        }\n    }\n    /**\n     * Creates a clip for the given coordinates.\n     */\n    createClip(x, y, w, h) {\n        x = Math.round(x);\n        y = Math.round(y);\n        w = Math.round(w);\n        h = Math.round(h);\n        const id = `mx-clip-${x}-${y}-${w}-${h}`;\n        let counter = 0;\n        let tmp = `${id}-${counter}`;\n        // Resolves ID conflicts\n        while (document.getElementById(tmp) != null) {\n            tmp = `${id}-${++counter}`;\n        }\n        const clip = this.createElement('clipPath');\n        clip.setAttribute('id', tmp);\n        const rect = this.createElement('rect');\n        rect.setAttribute('x', String(x));\n        rect.setAttribute('y', String(y));\n        rect.setAttribute('width', String(w));\n        rect.setAttribute('height', String(h));\n        clip.appendChild(rect);\n        return clip;\n    }\n    /**\n     * Paints the given text. Possible values for format are empty string for\n     * plain text and html for HTML markup.\n     */\n    plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation = 0, dir) {\n        const s = this.state;\n        const size = s.fontSize;\n        const node = this.createElement('g');\n        let tr = s.transform || '';\n        this.updateFont(node);\n        // Ignores pointer events\n        if (!this.pointerEvents && this.originalRoot == null) {\n            node.setAttribute('pointer-events', 'none');\n        }\n        // Non-rotated text\n        if (rotation !== 0) {\n            tr += `rotate(${rotation},${this.format(x * s.scale)},${this.format(y * s.scale)})`;\n        }\n        if (dir != null) {\n            node.setAttribute('direction', dir);\n        }\n        if (clip && w > 0 && h > 0) {\n            let cx = x;\n            let cy = y;\n            if (align === ALIGN.CENTER) {\n                cx -= w / 2;\n            }\n            else if (align === ALIGN.RIGHT) {\n                cx -= w;\n            }\n            if (overflow !== 'fill') {\n                if (valign === ALIGN.MIDDLE) {\n                    cy -= h / 2;\n                }\n                else if (valign === ALIGN.BOTTOM) {\n                    cy -= h;\n                }\n            }\n            // LATER: Remove spacing from clip rectangle\n            const c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w * s.scale + 4, h * s.scale + 4);\n            if (this.defs != null) {\n                this.defs.appendChild(c);\n            }\n            else {\n                // Makes sure clip is removed with referencing node\n                this.root.appendChild(c);\n            }\n            if (!Client.IS_CHROMEAPP &&\n                !Client.IS_EDGE &&\n                this.root.ownerDocument === document) {\n                // Workaround for potential base tag\n                const base = this.getBaseUrl().replace(/([()])/g, '\\\\$1');\n                node.setAttribute('clip-path', `url(${base}#${c.getAttribute('id')})`);\n            }\n            else {\n                node.setAttribute('clip-path', `url(#${c.getAttribute('id')})`);\n            }\n        }\n        // Default is left\n        const anchor = align === ALIGN.RIGHT ? 'end' : align === ALIGN.CENTER ? 'middle' : 'start';\n        // Text-anchor start is default in SVG\n        if (anchor !== 'start') {\n            node.setAttribute('text-anchor', anchor);\n        }\n        if (!this.styleEnabled || size !== DEFAULT_FONTSIZE) {\n            node.setAttribute('font-size', `${size * s.scale}px`);\n        }\n        if (tr.length > 0) {\n            node.setAttribute('transform', tr);\n        }\n        if (s.alpha < 1) {\n            node.setAttribute('opacity', String(s.alpha));\n        }\n        const lines = str.split('\\n');\n        const lh = Math.round(size * LINE_HEIGHT);\n        const textHeight = size + (lines.length - 1) * lh;\n        let cy = y + size - 1;\n        if (valign === ALIGN.MIDDLE) {\n            if (overflow === 'fill') {\n                cy -= h / 2;\n            }\n            else {\n                const dy = (this.matchHtmlAlignment && clip && h > 0\n                    ? Math.min(textHeight, h)\n                    : textHeight) / 2;\n                cy -= dy;\n            }\n        }\n        else if (valign === ALIGN.BOTTOM) {\n            if (overflow === 'fill') {\n                cy -= h;\n            }\n            else {\n                const dy = this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight;\n                cy -= dy + 1;\n            }\n        }\n        for (let i = 0; i < lines.length; i += 1) {\n            const line = trim(lines[i]);\n            // Workaround for bounding box of empty lines and spaces\n            if (line) {\n                const text = this.createElement('text');\n                // LATER: Match horizontal HTML alignment\n                text.setAttribute('x', String(this.format(x * s.scale) + this.textOffset));\n                text.setAttribute('y', String(this.format(cy * s.scale) + this.textOffset));\n                write(text, line);\n                node.appendChild(text);\n            }\n            cy += lh;\n        }\n        this.root.appendChild(node);\n        this.addTextBackground(node, str, x, y, w, overflow === 'fill' ? h : textHeight, align, valign, overflow);\n    }\n    /**\n     * Updates the text properties for the given node. (NOTE: For this to work in\n     * IE, the given node must be a text or tspan element.)\n     */\n    updateFont(node) {\n        const s = this.state;\n        if (s.fontColor && s.fontColor !== NONE) {\n            node.setAttribute('fill', s.fontColor);\n        }\n        if (!this.styleEnabled || s.fontFamily !== DEFAULT_FONTFAMILY) {\n            node.setAttribute('font-family', s.fontFamily);\n        }\n        const fontStyle = s.fontStyle;\n        matchBinaryMask(fontStyle, FONT.BOLD) && node.setAttribute('font-weight', 'bold');\n        matchBinaryMask(fontStyle, FONT.ITALIC) && node.setAttribute('font-style', 'italic');\n        const txtDecor = [];\n        matchBinaryMask(fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && node.setAttribute('text-decoration', txtDecor.join(' '));\n    }\n    /**\n     * Background color and border\n     */\n    addTextBackground(node, str, x, y, w, h, align, valign, overflow) {\n        const s = this.state;\n        if (s.fontBackgroundColor != null || s.fontBorderColor != null) {\n            let bbox = null;\n            if (overflow === 'fill' || overflow === 'width') {\n                if (align === ALIGN.CENTER) {\n                    x -= w / 2;\n                }\n                else if (align === ALIGN.RIGHT) {\n                    x -= w;\n                }\n                if (valign === ALIGN.MIDDLE) {\n                    y -= h / 2;\n                }\n                else if (valign === ALIGN.BOTTOM) {\n                    y -= h;\n                }\n                bbox = new Rectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);\n                // @ts-ignore check for getBBox\n            }\n            else if (node.getBBox != null && this.root.ownerDocument === document) {\n                // Uses getBBox only if inside document for correct size\n                try {\n                    // @ts-ignore getBBox exists\n                    bbox = node.getBBox();\n                    bbox = new Rectangle(bbox.x, bbox.y + 1, bbox.width, bbox.height + 0);\n                }\n                catch (e) {\n                    // Ignores NS_ERROR_FAILURE in FF if container display is none.\n                }\n            }\n            if (bbox == null || bbox.width === 0 || bbox.height === 0) {\n                // Computes size if not in document or no getBBox available\n                const div = document.createElement('div');\n                // Wrapping and clipping can be ignored here\n                div.style.lineHeight = ABSOLUTE_LINE_HEIGHT\n                    ? `${s.fontSize * LINE_HEIGHT}px`\n                    : String(LINE_HEIGHT);\n                div.style.fontSize = `${s.fontSize}px`;\n                div.style.fontFamily = s.fontFamily;\n                div.style.whiteSpace = 'nowrap';\n                div.style.position = 'absolute';\n                div.style.visibility = 'hidden';\n                div.style.display = 'inline-block';\n                matchBinaryMask(s.fontStyle, FONT.BOLD) && (div.style.fontWeight = 'bold');\n                matchBinaryMask(s.fontStyle, FONT.ITALIC) && (div.style.fontStyle = 'italic');\n                str = htmlEntities(str, false);\n                div.innerHTML = str.replace(/\\n/g, '<br/>');\n                document.body.appendChild(div);\n                const w = div.offsetWidth;\n                const h = div.offsetHeight;\n                document.body.removeChild(div);\n                if (align === ALIGN.CENTER) {\n                    x -= w / 2;\n                }\n                else if (align === ALIGN.RIGHT) {\n                    x -= w;\n                }\n                if (valign === ALIGN.MIDDLE) {\n                    y -= h / 2;\n                }\n                else if (valign === ALIGN.BOTTOM) {\n                    y -= h;\n                }\n                bbox = new Rectangle((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);\n            }\n            if (bbox != null) {\n                const n = this.createElement('rect');\n                n.setAttribute('fill', s.fontBackgroundColor || 'none');\n                n.setAttribute('stroke', s.fontBorderColor || 'none');\n                n.setAttribute('x', String(Math.floor(bbox.x - 1)));\n                n.setAttribute('y', String(Math.floor(bbox.y - 1)));\n                n.setAttribute('width', String(Math.ceil(bbox.width + 2)));\n                n.setAttribute('height', String(Math.ceil(bbox.height)));\n                const sw = s.fontBorderColor ? Math.max(1, this.format(s.scale)) : 0;\n                n.setAttribute('stroke-width', String(sw));\n                // Workaround for crisp rendering - only required if not exporting\n                if (this.root?.ownerDocument === document && mod(sw, 2) === 1) {\n                    n.setAttribute('transform', 'translate(0.5, 0.5)');\n                }\n                node.insertBefore(n, node.firstChild);\n            }\n        }\n    }\n    /**\n     * Paints the outline of the current path.\n     */\n    stroke() {\n        this.addNode(false, true);\n    }\n    /**\n     * Fills the current path.\n     */\n    fill() {\n        this.addNode(true, false);\n    }\n    /**\n     * Fills and paints the outline of the current path.\n     */\n    fillAndStroke() {\n        this.addNode(true, true);\n    }\n}\n/**\n * Updates existing DOM nodes for text rendering.\n */\nSvgCanvas2D.createCss = (w, h, align, valign, wrap, overflow, clip, bg, border, flex, block, scale, callback) => {\n    let item = `box-sizing: border-box; font-size: 0; text-align: ${align === ALIGN.LEFT ? 'left' : align === ALIGN.RIGHT ? 'right' : 'center'}; `;\n    const pt = getAlignmentAsPoint(align, valign);\n    let ofl = 'overflow: hidden; ';\n    let fw = 'width: 1px; ';\n    let fh = 'height: 1px; ';\n    let dx = pt.x * w;\n    let dy = pt.y * h;\n    if (clip) {\n        fw = `width: ${Math.round(w)}px; `;\n        item += `max-height: ${Math.round(h)}px; `;\n        dy = 0;\n    }\n    else if (overflow === 'fill') {\n        fw = `width: ${Math.round(w)}px; `;\n        fh = `height: ${Math.round(h)}px; `;\n        block += 'width: 100%; height: 100%; ';\n        item += fw + fh;\n    }\n    else if (overflow === 'width') {\n        fw = `width: ${Math.round(w)}px; `;\n        block += 'width: 100%; ';\n        item += fw;\n        dy = 0;\n        if (h > 0) {\n            item += `max-height: ${Math.round(h)}px; `;\n        }\n    }\n    else {\n        ofl = '';\n        dy = 0;\n    }\n    let bgc = '';\n    if (bg) {\n        bgc += `background-color: ${bg}; `;\n    }\n    if (border) {\n        bgc += `border: 1px solid ${border}; `;\n    }\n    if (ofl == '' || clip) {\n        block += bgc;\n    }\n    else {\n        item += bgc;\n    }\n    if (wrap && w > 0) {\n        block += `white-space: normal; word-wrap: ${WORD_WRAP}; `;\n        fw = `width: ${Math.round(w)}px; `;\n        if (ofl !== '' && overflow !== 'fill') {\n            dy = 0;\n        }\n    }\n    else {\n        block += 'white-space: nowrap; ';\n        if (ofl === '') {\n            dx = 0;\n        }\n    }\n    callback(dx, dy, flex + fw + fh, item + ofl, block, ofl);\n};\nexport default SvgCanvas2D;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from './Rectangle';\nimport { isNotNullish } from '../../util/Utils';\nimport { getBoundingBox, getDirectedBounds, mod } from '../../util/mathUtils';\nimport { DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y, } from '../../util/Constants';\nimport Point from './Point';\nimport SvgCanvas2D from '../canvas/SvgCanvas2D';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\n/**\n * Base class for all shapes.\n * A shape in mxGraph is a separate implementation for SVG, VML and HTML.\n * Which implementation to use is controlled by the dialect property which\n * is assigned from within the mxCellRenderer when the shape is created.\n * The dialect must be assigned for a shape, and it does normally depend on\n * the browser and the configuration of the graph (see mxGraph rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding shape exists in\n * mxGraph, namely for text, image, rectangle, rhombus, ellipse and polyline.\n * The other shapes are a combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects (eg. actor and cylinder).\n * The HTML implementation is optional but may be required for a HTML-only view\n * of the graph.\n *\n * ### Custom Shapes\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of one filled region\n * or one filled region and an additional stroke the mxActor and mxCylinder\n * should be subclassed, respectively.\n * ```javascript\n * function CustomShape() { }\n *\n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape;\n * ```\n * To register a custom shape in an existing graph instance, one must register the\n * shape under a new name in the graphs cell renderer as follows:\n * ```javascript\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * ```\n * The second argument is the name of the constructor.\n * In order to use the shape you can refer to the given name above in a stylesheet.\n * For example, to change the shape for the default vertex style, the following code\n * is used:\n * ```javascript\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style.shape = 'customShape';\n * ```\n */\nclass Shape {\n    constructor(stencil = null) {\n        // Assigned in mxCellRenderer\n        this.preserveImageAspect = false;\n        this.overlay = null;\n        this.indicator = null;\n        this.indicatorShape = null;\n        // Assigned in mxCellHighlight\n        this.opacity = 100;\n        this.isDashed = false;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.stroke = NONE;\n        this.strokeWidth = 1;\n        this.spacing = 0;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.flipH = false;\n        this.flipV = false;\n        this.isShadow = false;\n        this.isRounded = false;\n        this.rotation = 0;\n        this.cursor = '';\n        this.verticalTextRotation = 0;\n        this.oldGradients = {};\n        this.glass = false;\n        /**\n         * Holds the dialect in which the shape is to be painted.\n         * This can be one of the DIALECT constants in {@link Constants}.\n         */\n        this.dialect = null;\n        /**\n         * Holds the scale in which the shape is being painted.\n         */\n        this.scale = 1;\n        /**\n         * Rendering hint for configuring the canvas.\n         */\n        this.antiAlias = true;\n        /**\n         * Minimum stroke width for SVG output.\n         */\n        this.minSvgStrokeWidth = 1;\n        /**\n         * Holds the {@link Rectangle} that specifies the bounds of this shape.\n         */\n        this.bounds = null;\n        /**\n         * Holds the array of <Point> that specify the points of this shape.\n         */\n        this.points = [];\n        /**\n         * Optional reference to the corresponding <CellState>.\n         */\n        this.state = null;\n        /**\n         * Optional reference to the style of the corresponding <CellState>.\n         */\n        this.style = null;\n        /**\n         * Contains the bounding box of the shape, that is, the smallest rectangle\n         * that includes all pixels of the shape.\n         */\n        this.boundingBox = null;\n        /**\n         * Holds the {@link StencilShape} that defines the shape.\n         */\n        this.stencil = null;\n        /**\n         * Event-tolerance for SVG strokes (in px).\n         * This is only passed to the canvas in {@link createSvgCanvas} if {@link pointerEvents} is `true`.\n         * @default 8\n         */\n        this.svgStrokeTolerance = 8;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.pointerEvents = true;\n        this.originalPointerEvents = null;\n        /**\n         * Specifies if pointer events should be handled. Default is true.\n         */\n        this.svgPointerEvents = 'all';\n        /**\n         * Specifies if pointer events outside of shape should be handled. Default\n         * is false.\n         */\n        this.shapePointerEvents = false;\n        /**\n         * Specifies if pointer events outside of stencils should be handled. Default\n         * is false. Set this to true for backwards compatibility with the 1.x branch.\n         */\n        this.stencilPointerEvents = false;\n        /**\n         * Specifies if the shape should be drawn as an outline. This disables all\n         * fill colors and can be used to disable other drawing states that should\n         * not be painted for outlines. Default is false. This should be set before\n         * calling <apply>.\n         */\n        this.outline = false;\n        /**\n         * Specifies if the shape is visible. Default is true.\n         */\n        this.visible = true;\n        /**\n         * Allows to use the SVG bounding box in SVG. Default is false for performance\n         * reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.image = null;\n        this.imageSrc = null;\n        this.indicatorColor = NONE;\n        this.indicatorStrokeColor = NONE;\n        this.indicatorGradientColor = NONE;\n        this.indicatorDirection = DIRECTION.EAST;\n        this.indicatorImageSrc = null;\n        // `stencil` is not null when instantiated directly,\n        // but can be null when instantiated through a child class.\n        if (stencil) {\n            this.stencil = stencil;\n        }\n        // moved from init()\n        this.node = this.create();\n    }\n    /**\n     * Initializes the shape by creaing the DOM node using <create>\n     * and adding it into the given container.\n     *\n     * @param container DOM node that will contain the shape.\n     */\n    init(container) {\n        if (!this.node.parentNode) {\n            container.appendChild(this.node);\n        }\n    }\n    /**\n     * Sets the styles to their default values.\n     */\n    initStyles() {\n        this.strokeWidth = 1;\n        this.rotation = 0;\n        this.opacity = 100;\n        this.fillOpacity = 100;\n        this.strokeOpacity = 100;\n        this.flipH = false;\n        this.flipV = false;\n    }\n    /**\n     * Returns true if HTML is allowed for this shape. This implementation always\n     * returns false.\n     */\n    isHtmlAllowed() {\n        return false;\n    }\n    /**\n     * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n     */\n    getSvgScreenOffset() {\n        const sw = this.stencil && this.stencil.strokeWidthValue !== 'inherit'\n            ? Number(this.stencil.strokeWidthValue)\n            : this.strokeWidth ?? 0;\n        return mod(Math.max(1, Math.round(sw * this.scale)), 2) === 1 ? 0.5 : 0;\n    }\n    /**\n     * Creates and returns the DOM node for the shape.\n     * This implementation assumes that `maxGraph` produces SVG elements.\n     */\n    create() {\n        return document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    }\n    redraw() {\n        this.updateBoundsFromPoints();\n        if (this.visible && this.checkBounds()) {\n            this.node.style.visibility = 'visible';\n            this.clear();\n            this.redrawShape();\n            this.updateBoundingBox();\n        }\n        else {\n            this.node.style.visibility = 'hidden';\n            this.boundingBox = null;\n        }\n    }\n    /**\n     * Removes all child nodes and resets all CSS.\n     */\n    clear() {\n        while (this.node.lastChild) {\n            this.node.removeChild(this.node.lastChild);\n        }\n    }\n    /**\n     * Updates the bounds based on the points.\n     */\n    updateBoundsFromPoints() {\n        const pts = this.points;\n        if (pts.length > 0 && pts[0]) {\n            this.bounds = new Rectangle(Math.round(pts[0].x), Math.round(pts[0].y), 1, 1);\n            for (const pt of pts) {\n                if (pt) {\n                    this.bounds.add(new Rectangle(Math.round(pt.x), Math.round(pt.y), 1, 1));\n                }\n            }\n        }\n    }\n    /**\n     * Returns the {@link Rectangle} for the label bounds of this shape, based on the\n     * given scaled and translated bounds of the shape. This method should not\n     * change the rectangle in-place. This implementation returns the given rect.\n     */\n    getLabelBounds(rect) {\n        const d = this.style?.direction ?? DIRECTION.EAST;\n        let bounds = rect.clone();\n        // Normalizes argument for getLabelMargins hook\n        if (d !== DIRECTION.SOUTH &&\n            d !== DIRECTION.NORTH &&\n            this.state &&\n            this.state.text &&\n            this.state.text.isPaintBoundsInverted()) {\n            bounds = bounds.clone();\n            [bounds.width, bounds.height] = [bounds.height, bounds.width];\n        }\n        let labelMargins = this.getLabelMargins(bounds);\n        if (labelMargins) {\n            labelMargins = labelMargins.clone();\n            let flipH = this.style?.flipH ?? false;\n            let flipV = this.style?.flipV ?? false;\n            // Handles special case for vertical labels\n            if (this.state && this.state.text && this.state.text.isPaintBoundsInverted()) {\n                const tmp = labelMargins.x;\n                labelMargins.x = labelMargins.height;\n                labelMargins.height = labelMargins.width;\n                labelMargins.width = labelMargins.y;\n                labelMargins.y = tmp;\n                [flipH, flipV] = [flipV, flipH];\n            }\n            return getDirectedBounds(rect, labelMargins, this.style, flipH, flipV);\n        }\n        return rect;\n    }\n    /**\n     * Returns the scaled top, left, bottom and right margin to be used for\n     * computing the label bounds as an {@link Rectangle}, where the bottom and right\n     * margin are defined in the width and height of the rectangle, respectively.\n     */\n    getLabelMargins(rect) {\n        return null;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!Number.isNaN(this.scale) &&\n            Number.isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !Number.isNaN(this.bounds.x) &&\n            !Number.isNaN(this.bounds.y) &&\n            !Number.isNaN(this.bounds.width) &&\n            !Number.isNaN(this.bounds.height) &&\n            this.bounds.width > 0 &&\n            this.bounds.height > 0);\n    }\n    /**\n     * Updates the SVG or VML shape.\n     */\n    redrawShape() {\n        const canvas = this.createCanvas();\n        if (canvas) {\n            // Specifies if events should be handled\n            canvas.pointerEvents = this.pointerEvents;\n            this.beforePaint(canvas);\n            this.paint(canvas);\n            this.afterPaint(canvas);\n            if (this.node !== canvas.root && canvas.root) {\n                // Forces parsing in IE8 standards mode - slow! avoid\n                this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n            }\n            this.destroyCanvas(canvas);\n        }\n    }\n    /**\n     * Creates a new canvas for drawing this shape. May return null.\n     */\n    createCanvas() {\n        const canvas = this.createSvgCanvas();\n        if (canvas && this.outline) {\n            canvas.setStrokeWidth(this.strokeWidth);\n            canvas.setStrokeColor(this.stroke);\n            if (this.isDashed) {\n                canvas.setDashed(this.isDashed);\n            }\n            canvas.setStrokeWidth = () => {\n                return;\n            };\n            canvas.setStrokeColor = () => {\n                return;\n            };\n            canvas.setFillColor = () => {\n                return;\n            };\n            canvas.setGradient = () => {\n                return;\n            };\n            canvas.setDashed = () => {\n                return;\n            };\n            canvas.text = () => {\n                return;\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Creates and returns an {@link SvgCanvas2D} for rendering this shape.\n     */\n    createSvgCanvas() {\n        if (!this.node)\n            return null;\n        const canvas = new SvgCanvas2D(this.node, false);\n        canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;\n        canvas.pointerEventsValue = this.svgPointerEvents;\n        const off = this.getSvgScreenOffset();\n        if (off !== 0) {\n            this.node.setAttribute('transform', `translate(${off},${off})`);\n        }\n        else {\n            this.node.removeAttribute('transform');\n        }\n        canvas.minStrokeWidth = this.minSvgStrokeWidth;\n        if (!this.antiAlias) {\n            // Rounds all numbers in the SVG output to integers\n            canvas.format = (value) => {\n                return Math.round(value);\n            };\n        }\n        return canvas;\n    }\n    /**\n     * Destroys the given canvas which was used for drawing. This implementation\n     * increments the reference counts on all shared gradients used in the canvas.\n     */\n    destroyCanvas(canvas) {\n        // Manages reference counts\n        if (canvas instanceof SvgCanvas2D) {\n            // Increments ref counts\n            for (const key in canvas.gradients) {\n                const gradient = canvas.gradients[key];\n                if (gradient) {\n                    gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n                }\n            }\n            this.releaseSvgGradients(this.oldGradients);\n            this.oldGradients = canvas.gradients;\n        }\n    }\n    /**\n     * Invoked before paint is called.\n     */\n    beforePaint(c) {\n        return;\n    }\n    /**\n     * Invokes after paint was called.\n     */\n    afterPaint(c) {\n        return;\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c) {\n        let strokeDrawn = false;\n        if (c && this.outline) {\n            const { stroke } = c;\n            c.stroke = (...args) => {\n                strokeDrawn = true;\n                stroke.apply(c, args);\n            };\n            const { fillAndStroke } = c;\n            c.fillAndStroke = (...args) => {\n                strokeDrawn = true;\n                fillAndStroke.apply(c, args);\n            };\n        }\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const bounds = this.bounds;\n        if (bounds) {\n            let x = bounds.x / s;\n            let y = bounds.y / s;\n            let w = bounds.width / s;\n            let h = bounds.height / s;\n            if (this.isPaintBoundsInverted()) {\n                const t = (w - h) / 2;\n                x += t;\n                y -= t;\n                const tmp = w;\n                w = h;\n                h = tmp;\n            }\n            this.updateTransform(c, x, y, w, h);\n            this.configureCanvas(c, x, y, w, h);\n            // Adds background rectangle to capture events\n            let bg = null;\n            if ((!this.stencil && this.points.length === 0 && this.shapePointerEvents) ||\n                (this.stencil && this.stencilPointerEvents)) {\n                const bb = this.createBoundingBox();\n                if (bb && this.node) {\n                    bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n                    this.node.appendChild(bg);\n                }\n            }\n            if (this.stencil) {\n                this.stencil.drawShape(c, this, x, y, w, h);\n            }\n            else {\n                // Stencils have separate strokewidth\n                c.setStrokeWidth(this.strokeWidth);\n                if (this.points.length > 0) {\n                    // Paints edge shape\n                    const pts = [];\n                    for (let i = 0; i < this.points.length; i += 1) {\n                        const p = this.points[i];\n                        if (p) {\n                            pts.push(new Point(p.x / s, p.y / s));\n                        }\n                    }\n                    this.paintEdgeShape(c, pts);\n                }\n                else {\n                    // Paints vertex shape\n                    this.paintVertexShape(c, x, y, w, h);\n                }\n            }\n            if (bg && c.state && isNotNullish(c.state.transform)) {\n                bg.setAttribute('transform', c.state.transform);\n            }\n            // Draws highlight rectangle if no stroke was used\n            if (c && this.outline && !strokeDrawn) {\n                c.rect(x, y, w, h);\n                c.stroke();\n            }\n        }\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        let dash = null;\n        if (this.style && this.style.dashPattern != null) {\n            dash = this.style.dashPattern;\n        }\n        c.setAlpha(this.opacity / 100);\n        c.setFillAlpha(this.fillOpacity / 100);\n        c.setStrokeAlpha(this.strokeOpacity / 100);\n        // Sets alpha, colors and gradients\n        if (this.isShadow) {\n            c.setShadow(this.isShadow);\n        }\n        // Dash pattern\n        if (this.isDashed) {\n            c.setDashed(this.isDashed, this.style?.fixDash ?? false);\n        }\n        if (dash) {\n            c.setDashPattern(dash);\n        }\n        if (this.fill !== NONE && this.gradient !== NONE) {\n            const b = this.getGradientBounds(c, x, y, w, h);\n            c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n        }\n        else {\n            c.setFillColor(this.fill);\n        }\n        c.setStrokeColor(this.stroke);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        return new Rectangle(x, y, w, h);\n    }\n    /**\n     * Sets the scale and rotation on the given canvas.\n     */\n    updateTransform(c, x, y, w, h) {\n        // NOTE: Currently, scale is implemented in state and canvas. This will\n        // move to canvas in a later version, so that the states are unscaled\n        // and untranslated and do not need an update after zooming or panning.\n        c.scale(this.scale);\n        c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n    }\n    /**\n     * Paints the vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        this.paintBackground(c, x, y, w, h);\n        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {\n            c.setShadow(false);\n            this.paintForeground(c, x, y, w, h);\n        }\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintBackground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintForeground(c, x, y, w, h) {\n        return;\n    }\n    /**\n     * Hook for subclassers. This implementation is empty.\n     */\n    paintEdgeShape(c, pts) {\n        return;\n    }\n    /**\n     * Returns the arc size for the given dimension.\n     */\n    getArcSize(w, h) {\n        let r = 0;\n        if (this.style?.absoluteArcSize ?? false) {\n            r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? LINE_ARCSIZE) / 2));\n        }\n        else {\n            const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n            r = Math.min(w * f, h * f);\n        }\n        return r;\n    }\n    /**\n     * Paints the glass gradient effect.\n     */\n    paintGlassEffect(c, x, y, w, h, arc) {\n        const sw = Math.ceil((this.strokeWidth ?? 0) / 2);\n        const size = 0.4;\n        c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n        c.begin();\n        arc += 2 * sw;\n        if (this.isRounded) {\n            c.moveTo(x - sw + arc, y - sw);\n            c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw + arc);\n            c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n        }\n        else {\n            c.moveTo(x - sw, y - sw);\n            c.lineTo(x - sw, y + h * size);\n            c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n            c.lineTo(x + w + sw, y - sw);\n        }\n        c.close();\n        c.fill();\n    }\n    /**\n     * Paints the given points with rounded corners.\n     */\n    addPoints(c, pts, rounded = false, arcSize, close = false, exclude = [], initialMove = true) {\n        if (pts.length > 0) {\n            const pe = pts[pts.length - 1];\n            // Adds virtual waypoint in the center between start and end point\n            if (close && rounded) {\n                pts = pts.slice();\n                const p0 = pts[0];\n                const wp = new Point(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n                pts.splice(0, 0, wp);\n            }\n            let pt = pts[0];\n            let i = 1;\n            // Draws the line segments\n            if (initialMove) {\n                c.moveTo(pt.x, pt.y);\n            }\n            else {\n                c.lineTo(pt.x, pt.y);\n            }\n            while (i < (close ? pts.length : pts.length - 1)) {\n                let tmp = pts[mod(i, pts.length)];\n                let dx = pt.x - tmp.x;\n                let dy = pt.y - tmp.y;\n                if (rounded && (dx !== 0 || dy !== 0) && exclude.indexOf(i - 1) < 0) {\n                    // Draws a line from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the last point\n                    let dist = Math.sqrt(dx * dx + dy * dy);\n                    const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x1 = tmp.x + nx1;\n                    const y1 = tmp.y + ny1;\n                    c.lineTo(x1, y1);\n                    // Draws a curve from the last point to the current\n                    // point with a spacing of size off the current point\n                    // into direction of the next point\n                    let next = pts[mod(i + 1, pts.length)];\n                    // Uses next non-overlapping point\n                    while (i < pts.length - 2 &&\n                        Math.round(next.x - tmp.x) === 0 &&\n                        Math.round(next.y - tmp.y) === 0) {\n                        next = pts[mod(i + 2, pts.length)];\n                        i++;\n                    }\n                    dx = next.x - tmp.x;\n                    dy = next.y - tmp.y;\n                    dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n                    const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;\n                    const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;\n                    const x2 = tmp.x + nx2;\n                    const y2 = tmp.y + ny2;\n                    c.quadTo(tmp.x, tmp.y, x2, y2);\n                    tmp = new Point(x2, y2);\n                }\n                else {\n                    c.lineTo(tmp.x, tmp.y);\n                }\n                pt = tmp;\n                i += 1;\n            }\n            if (close) {\n                c.close();\n            }\n            else {\n                c.lineTo(pe.x, pe.y);\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        this.initStyles();\n        this.spacing = 0;\n        this.fill = NONE;\n        this.gradient = NONE;\n        this.gradientDirection = DIRECTION.EAST;\n        this.stroke = NONE;\n        this.startSize = 1;\n        this.endSize = 1;\n        this.startArrow = NONE;\n        this.endArrow = NONE;\n        this.direction = DIRECTION.EAST;\n        this.isShadow = false;\n        this.isDashed = false;\n        this.isRounded = false;\n        this.glass = false;\n    }\n    /**\n     * Applies the style of the given <CellState> to the shape. This\n     * implementation assigns the following styles to local fields:\n     *\n     * - <'fillColor'> => fill\n     * - <'gradientColor'> => gradient\n     * - <'gradientDirection'> => gradientDirection\n     * - <'opacity'> => opacity\n     * - {@link Constants#STYLE_FILL_OPACITY} => fillOpacity\n     * - {@link Constants#STYLE_STROKE_OPACITY} => strokeOpacity\n     * - <'strokeColor'> => stroke\n     * - <'strokeWidth'> => strokewidth\n     * - <'shadow'> => isShadow\n     * - <'dashed'> => isDashed\n     * - <'spacing'> => spacing\n     * - <'startSize'> => startSize\n     * - <'endSize'> => endSize\n     * - <'rounded'> => isRounded\n     * - <'startArrow'> => startArrow\n     * - <'endArrow'> => endArrow\n     * - <'rotation'> => rotation\n     * - <'direction'> => direction\n     * - <'glass'> => glass\n     *\n     * This keeps a reference to the <style>. If you need to keep a reference to\n     * the cell, you can override this method and store a local reference to\n     * state.cell or the <CellState> itself. If <outline> should be true, make\n     * sure to set it before calling this method.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        this.state = state;\n        this.style = state.style;\n        if (this.style) {\n            this.fill = this.style.fillColor ?? this.fill;\n            this.gradient = this.style.gradientColor ?? this.gradient;\n            this.gradientDirection = this.style.gradientDirection ?? this.gradientDirection;\n            this.opacity = this.style.opacity ?? this.opacity;\n            this.fillOpacity = this.style.fillOpacity ?? this.fillOpacity;\n            this.strokeOpacity = this.style.strokeOpacity ?? this.strokeOpacity;\n            this.stroke = this.style.strokeColor ?? this.stroke;\n            this.strokeWidth = this.style.strokeWidth ?? this.strokeWidth;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.startSize = this.style.startSize ?? this.startSize;\n            this.endSize = this.style.endSize ?? this.endSize;\n            this.startArrow = this.style.startArrow ?? this.startArrow;\n            this.endArrow = this.style.endArrow ?? this.endArrow;\n            this.rotation = this.style.rotation ?? this.rotation;\n            this.direction = this.style.direction ?? this.direction;\n            this.flipH = !!this.style.flipH;\n            this.flipV = !!this.style.flipV;\n            if (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH) {\n                const tmp = this.flipH;\n                this.flipH = this.flipV;\n                this.flipV = tmp;\n            }\n            this.isShadow = this.style.shadow ?? this.isShadow;\n            this.isDashed = this.style.dashed ?? this.isDashed;\n            this.isRounded = this.style.rounded ?? this.isRounded;\n            this.glass = this.style.glass ?? this.glass;\n        }\n    }\n    /**\n     * Sets the cursor on the given shape.\n     *\n     * @param cursor The cursor to be used.\n     */\n    setCursor(cursor) {\n        this.cursor = cursor;\n        this.node.style.cursor = cursor;\n    }\n    /**\n     * Returns the current cursor.\n     */\n    getCursor() {\n        return this.cursor;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable(c, x, y, w, h) {\n        return false;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using <createBoundingBox> and\n     * <augmentBoundingBox> and stores the result in <boundingBox>.\n     */\n    updateBoundingBox() {\n        // Tries to get bounding box from SVG subsystem\n        // LATER: Use getBoundingClientRect for fallback in VML\n        if (this.useSvgBoundingBox && this.node.ownerSVGElement) {\n            try {\n                const b = this.node.getBBox();\n                if (b.width > 0 && b.height > 0) {\n                    this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    // Adds strokeWidth\n                    this.boundingBox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n                    return;\n                }\n            }\n            catch (e) {\n                // fallback to code below\n            }\n        }\n        if (this.bounds) {\n            let bbox = this.createBoundingBox();\n            if (bbox) {\n                this.augmentBoundingBox(bbox);\n                const rot = this.getShapeRotation();\n                if (rot !== 0) {\n                    bbox = getBoundingBox(bbox, rot);\n                }\n            }\n            this.boundingBox = bbox;\n        }\n    }\n    /**\n     * Returns a new rectangle that represents the bounding box of the bare shape\n     * with no shadows or strokewidths.\n     */\n    createBoundingBox() {\n        if (!this.bounds)\n            return null;\n        const bb = this.bounds.clone();\n        if ((this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH)) ||\n            this.isPaintBoundsInverted()) {\n            bb.rotate90();\n        }\n        return bb;\n    }\n    /**\n     * Augments the bounding box with the strokewidth and shadow offsets.\n     */\n    augmentBoundingBox(bbox) {\n        if (this.isShadow) {\n            bbox.width += Math.ceil(SHADOW_OFFSET_X * this.scale);\n            bbox.height += Math.ceil(SHADOW_OFFSET_Y * this.scale);\n        }\n        // Adds strokeWidth\n        bbox.grow(((this.strokeWidth ?? 0) * this.scale) / 2);\n    }\n    /**\n     * Returns true if the bounds should be inverted.\n     */\n    isPaintBoundsInverted() {\n        // Stencil implements inversion via aspect\n        return (!this.stencil &&\n            (this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH));\n    }\n    /**\n     * Returns the rotation from the style.\n     */\n    getRotation() {\n        return this.rotation ?? 0;\n    }\n    /**\n     * Returns the rotation for the text label.\n     */\n    getTextRotation() {\n        let rot = this.getRotation();\n        if (!(this.style?.horizontal ?? true)) {\n            rot += this.verticalTextRotation || -90; // WARNING WARNING!!!! ===============================================================================================\n        }\n        return rot;\n    }\n    /**\n     * Returns the actual rotation of the shape.\n     */\n    getShapeRotation() {\n        let rot = this.getRotation();\n        if (this.direction === DIRECTION.NORTH) {\n            rot += 270;\n        }\n        else if (this.direction === DIRECTION.WEST) {\n            rot += 180;\n        }\n        else if (this.direction === DIRECTION.SOUTH) {\n            rot += 90;\n        }\n        return rot;\n    }\n    /**\n     * Adds a transparent rectangle that catches all events.\n     */\n    createTransparentSvgRectangle(x, y, w, h) {\n        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        rect.setAttribute('x', String(x));\n        rect.setAttribute('y', String(y));\n        rect.setAttribute('width', String(w));\n        rect.setAttribute('height', String(h));\n        rect.setAttribute('fill', NONE);\n        rect.setAttribute('stroke', NONE);\n        rect.setAttribute('pointer-events', 'all');\n        return rect;\n    }\n    redrawHtmlShape() {\n        return;\n    }\n    /**\n     * Sets a transparent background CSS style to catch all events.\n     *\n     * Paints the line shape.\n     */\n    setTransparentBackgroundImage(node) {\n        node.style.backgroundImage = `url('${Client.imageBasePath}/transparent.gif')`;\n    }\n    /**\n     * Paints the line shape.\n     */\n    releaseSvgGradients(grads) {\n        for (const key in grads) {\n            const gradient = grads[key];\n            if (gradient) {\n                gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n                if (gradient.mxRefCount === 0 && gradient.parentNode) {\n                    gradient.parentNode.removeChild(gradient);\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the shape by removing it from the DOM and releasing the DOM\n     * node associated with the shape using {@link Event#release}.\n     */\n    destroy() {\n        InternalEvent.release(this.node);\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n        this.node.innerHTML = '';\n        // Decrements refCount and removes unused\n        this.releaseSvgGradients(this.oldGradients);\n        this.oldGradients = {};\n    }\n}\nexport default Shape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR } from '../../../util/Constants';\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a rectangle shape.\n * This shape is registered by default under {@link SHAPE.RECTANGLE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass RectangleShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Returns true for non-rounded, non-rotated shapes with no glass gradient.\n     */\n    isHtmlAllowed() {\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        return (!this.isRounded &&\n            !this.glass &&\n            this.rotation === 0 &&\n            (events || this.fill !== NONE));\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintBackground(c, x, y, w, h) {\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (events || this.fill !== NONE || this.stroke !== NONE) {\n            if (!events && this.fill === NONE) {\n                c.pointerEvents = false;\n            }\n            if (this.isRounded) {\n                let r = 0;\n                if (this.style?.absoluteArcSize ?? false) {\n                    r = Math.min(w / 2, Math.min(h / 2, (this.style?.arcSize ?? LINE_ARCSIZE) / 2));\n                }\n                else {\n                    const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n                    r = Math.min(w * f, h * f);\n                }\n                c.roundrect(x, y, w, h, r, r);\n            }\n            else {\n                c.rect(x, y, w, h);\n            }\n            c.fillAndStroke();\n        }\n    }\n    /**\n     * Adds roundable support.\n     */\n    isRoundable(c, x, y, w, h) {\n        return true;\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintForeground(c, x, y, w, h) {\n        if (this.glass && !this.outline && this.fill !== NONE) {\n            this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokeWidth, h + this.strokeWidth));\n        }\n    }\n}\nexport default RectangleShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\nimport { ALIGN, NONE } from '../../util/Constants';\n/**\n * Represents the current state of a cell in a given {@link GraphView}.\n *\n * For edges, the edge label position is stored in <absoluteOffset>.\n *\n * The size for oversize labels can be retrieved using the boundingBox property\n * of the <text> field as shown below.\n *\n * ```javascript\n * let bbox = (state.text != null) ? state.text.boundingBox : null;\n * ```\n *\n */\nclass CellState extends Rectangle {\n    /**\n     * Constructs a new object that represents the current state of the given Cell in the specified view.\n     *\n     * @param view {@link GraphView} that contains the state.\n     * @param cell {@link Cell} that this state represents.\n     * @param style the style of the Cell.\n     */\n    constructor(view = null, cell = null, style = null) {\n        super();\n        // referenced in mxCellRenderer\n        this.node = null;\n        // TODO: Document me!!\n        this.cellBounds = null;\n        this.paintBounds = null;\n        this.boundingBox = null;\n        // Used by mxCellRenderer's createControl()\n        this.control = null;\n        // Used by mxCellRenderer's createCellOverlays()\n        this.overlays = new Dictionary();\n        /**\n         * Specifies if the style is invalid. Default is false.\n         */\n        this.invalidStyle = false;\n        /**\n         * Specifies if the state is invalid. Default is true.\n         */\n        this.invalid = true;\n        /**\n         * Holds an array of <Point> that represent the absolute points of an\n         * edge.\n         */\n        this.absolutePoints = [];\n        /**\n         * Caches the visible source terminal state.\n         */\n        this.visibleSourceState = null;\n        /**\n         * Caches the visible target terminal state.\n         */\n        this.visibleTargetState = null;\n        /**\n         * Caches the distance between the end points for an edge.\n         */\n        this.terminalDistance = 0;\n        /**\n         * Caches the length of an edge.\n         */\n        this.length = 0;\n        /**\n         * Array of numbers that represent the cached length of each segment of the\n         * edge.\n         */\n        this.segments = [];\n        /**\n         * Holds the {@link Shape} that represents the cell graphically.\n         */\n        this.shape = null;\n        /**\n         * Holds the {@link Text} that represents the label of the cell. Thi smay be\n         * null if the cell has no label.\n         */\n        this.text = null;\n        /**\n         * Holds the unscaled width of the state.\n         */\n        this.unscaledWidth = 0;\n        /**\n         * Holds the unscaled height of the state.\n         */\n        this.unscaledHeight = 0;\n        this.parentHighlight = null;\n        this.point = null;\n        if (view) {\n            this.view = view;\n        }\n        if (cell) {\n            this.cell = cell;\n        }\n        this.style = style ?? {};\n        this.origin = new Point();\n        this.absoluteOffset = new Point();\n    }\n    /**\n     * Returns the {@link Rectangle} that should be used as the perimeter of the\n     * cell.\n     *\n     * @param border Optional border to be added around the perimeter bounds.\n     * @param bounds Optional {@link Rectangle} to be used as the initial bounds.\n     */\n    getPerimeterBounds(border = 0, bounds = new Rectangle(this.x, this.y, this.width, this.height)) {\n        if (this.shape?.stencil?.aspect === 'fixed') {\n            const aspect = this.shape.stencil.computeAspect(this.shape, bounds.x, bounds.y, bounds.width, bounds.height);\n            bounds.x = aspect.x;\n            bounds.y = aspect.y;\n            bounds.width = this.shape.stencil.w0 * aspect.width;\n            bounds.height = this.shape.stencil.h0 * aspect.height;\n        }\n        if (border !== 0) {\n            bounds.grow(border);\n        }\n        return bounds;\n    }\n    /**\n     * Sets the first or last point in <absolutePoints> depending on isSource.\n     *\n     * @param point {@link Point} that represents the terminal point.\n     * @param isSource Boolean that specifies if the first or last point should\n     * be assigned.\n     */\n    setAbsoluteTerminalPoint(point, isSource = false) {\n        if (isSource) {\n            if (this.absolutePoints.length === 0) {\n                this.absolutePoints.push(point);\n            }\n            else {\n                this.absolutePoints[0] = point;\n            }\n        }\n        else if (this.absolutePoints.length === 0) {\n            this.absolutePoints.push(null);\n            this.absolutePoints.push(point);\n        }\n        else if (this.absolutePoints.length === 1) {\n            this.absolutePoints.push(point);\n        }\n        else {\n            this.absolutePoints[this.absolutePoints.length - 1] = point;\n        }\n    }\n    /**\n     * Sets the given cursor on the shape and text shape.\n     */\n    setCursor(cursor) {\n        if (this.shape) {\n            this.shape.setCursor(cursor);\n        }\n        if (this.text) {\n            this.text.setCursor(cursor);\n        }\n    }\n    /**\n     * Returns the visible source or target terminal cell.\n     *\n     * @param source Boolean that specifies if the source or target cell should be\n     * returned.\n     */\n    getVisibleTerminal(source = false) {\n        return this.getVisibleTerminalState(source)?.cell ?? null;\n    }\n    /**\n     * Returns the visible source or target terminal state.\n     *\n     * @param source Boolean that specifies if the source or target state should be\n     * returned.\n     */\n    getVisibleTerminalState(source = false) {\n        return source ? this.visibleSourceState : this.visibleTargetState;\n    }\n    /**\n     * Sets the visible source or target terminal state.\n     *\n     * @param terminalState <CellState> that represents the terminal.\n     * @param source Boolean that specifies if the source or target state should be set.\n     */\n    setVisibleTerminalState(terminalState, source = false) {\n        if (source) {\n            this.visibleSourceState = terminalState;\n        }\n        else {\n            this.visibleTargetState = terminalState;\n        }\n    }\n    /**\n     * Returns the unscaled, untranslated bounds.\n     */\n    getCellBounds() {\n        return this.cellBounds;\n    }\n    /**\n     * Returns the unscaled, untranslated paint bounds. This is the same as\n     * <getCellBounds> but with a 90 degree rotation if the shape's\n     * isPaintBoundsInverted returns true.\n     */\n    getPaintBounds() {\n        return this.paintBounds;\n    }\n    /**\n     * Updates the cellBounds and paintBounds.\n     */\n    updateCachedBounds() {\n        const view = this.view;\n        const tr = view.translate;\n        const s = view.scale;\n        this.cellBounds = new Rectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);\n        this.paintBounds = Rectangle.fromRectangle(this.cellBounds);\n        if (this.shape && this.shape.isPaintBoundsInverted()) {\n            this.paintBounds.rotate90();\n        }\n    }\n    /**\n     * Destructor: setState\n     *\n     * Copies all fields from the given state to this state.\n     */\n    setState(state) {\n        this.view = state.view;\n        this.cell = state.cell;\n        this.style = state.style;\n        this.absolutePoints = state.absolutePoints;\n        this.origin = state.origin;\n        this.absoluteOffset = state.absoluteOffset;\n        this.boundingBox = state.boundingBox;\n        this.terminalDistance = state.terminalDistance;\n        this.segments = state.segments;\n        this.length = state.length;\n        this.x = state.x;\n        this.y = state.y;\n        this.width = state.width;\n        this.height = state.height;\n        this.unscaledWidth = state.unscaledWidth;\n        this.unscaledHeight = state.unscaledHeight;\n    }\n    /**\n     * Returns a clone of this {@link Point}.\n     */\n    clone() {\n        const clone = new CellState(this.view, this.cell, this.style);\n        // Clones the absolute points\n        for (let i = 0; i < this.absolutePoints.length; i += 1) {\n            const p = this.absolutePoints[i];\n            clone.absolutePoints[i] = p ? p.clone() : null;\n        }\n        if (this.origin) {\n            clone.origin = this.origin.clone();\n        }\n        if (this.absoluteOffset) {\n            clone.absoluteOffset = this.absoluteOffset.clone();\n        }\n        if (this.boundingBox) {\n            clone.boundingBox = this.boundingBox.clone();\n        }\n        clone.terminalDistance = this.terminalDistance;\n        clone.segments = this.segments;\n        clone.length = this.length;\n        clone.x = this.x;\n        clone.y = this.y;\n        clone.width = this.width;\n        clone.height = this.height;\n        clone.unscaledWidth = this.unscaledWidth;\n        clone.unscaledHeight = this.unscaledHeight;\n        return clone;\n    }\n    /**\n     * Destructor: destroy\n     *\n     * Destroys the state and all associated resources.\n     */\n    destroy() {\n        this.view.graph.cellRenderer.destroy(this);\n    }\n    /**\n     * Returns true if the given cell state is a loop.\n     *\n     * @param state {@link CellState} that represents a potential loop.\n     */\n    isLoop(state) {\n        const src = this.getVisibleTerminalState(true);\n        return src && src === this.getVisibleTerminalState(false);\n    }\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    /**\n     * Returns the vertical alignment for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.verticalAlign}\n     * property of {@link style}.\n     */\n    getVerticalAlign() {\n        return this.style.verticalAlign ?? ALIGN.MIDDLE;\n    }\n    /**\n     * Returns `true` if the given state has no stroke, no fill color and no image.\n     */\n    isTransparentState() {\n        return ((this.style.strokeColor ?? NONE) === NONE &&\n            (this.style.fillColor ?? NONE) === NONE &&\n            !this.getImageSrc());\n    }\n    /**\n     * Returns the image URL for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.image} property\n     * of {@link style}.\n     */\n    getImageSrc() {\n        return this.style.image || null;\n    }\n    /**\n     * Returns the indicator color for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.indicatorColor}\n     * property of {@link style}.\n     */\n    getIndicatorColor() {\n        return this.style.indicatorColor || null;\n    }\n    /**\n     * Returns the indicator gradient color for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.gradientColor}\n     * property of {@link style}.\n     */\n    getIndicatorGradientColor() {\n        return this.style.gradientColor || null;\n    }\n    /**\n     * Returns the indicator shape for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.indicatorShape}\n     * property of {@link style}.\n     */\n    getIndicatorShape() {\n        return this.style.indicatorShape || null;\n    }\n    /**\n     * Returns the indicator image for the given cell state.\n     * This implementation returns the value stored in the {@link CellStateStyle.indicatorImage}\n     * property of {@link style}.\n     */\n    getIndicatorImageSrc() {\n        return this.style.indicatorImage || null;\n    }\n}\nexport default CellState;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport EventObject from '../event/EventObject';\n/**\n * Implements a composite undoable edit. Here is an example for a custom change\n * which gets executed via the model:\n *\n * ```javascript\n * function CustomChange(model, name)\n * {\n *   this.model = model;\n *   this.name = name;\n *   this.previous = name;\n * };\n *\n * execute = ()=>\n * {\n *   let tmp = this.model.name;\n *   this.model.name = this.previous;\n *   this.previous = tmp;\n * };\n *\n * let name = prompt('Enter name');\n * graph.model.execute(new CustomChange(graph.model, name));\n * ```\n *\n * Event: mxEvent.EXECUTED\n *\n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n *\n * Event: mxEvent.START_EDIT\n *\n * Fires before a set of changes will be executed in <undo> or <redo>.\n * This event contains no properties.\n *\n * Event: mxEvent.END_EDIT\n *\n * Fires after a set of changeswas executed in <undo> or <redo>.\n * This event contains no properties.\n *\n * Constructor: mxUndoableEdit\n *\n * Constructs a new undoable edit for the given source.\n */\nclass UndoableEdit {\n    constructor(source, significant = true) {\n        /**\n         * Array that contains the changes that make up this edit. The changes are\n         * expected to either have an undo and redo function, or an execute\n         * function. Default is an empty array.\n         */\n        this.changes = [];\n        /**\n         * Specifies if the undoable change is significant.\n         * Default is true.\n         */\n        this.significant = true;\n        /**\n         * Specifies if this edit has been undone. Default is false.\n         */\n        this.undone = false;\n        /**\n         * Specifies if this edit has been redone. Default is false.\n         */\n        this.redone = false;\n        this.source = source;\n        this.changes = [];\n        this.significant = significant;\n    }\n    /**\n     * Returns true if the this edit contains no changes.\n     */\n    isEmpty() {\n        return this.changes.length === 0;\n    }\n    /**\n     * Returns <significant>.\n     */\n    isSignificant() {\n        return this.significant;\n    }\n    /**\n     * Adds the specified change to this edit. The change is an object that is\n     * expected to either have an undo and redo, or an execute function.\n     */\n    add(change) {\n        this.changes.push(change);\n    }\n    /**\n     * Hook to notify any listeners of the changes after an <undo> or <redo>\n     * has been carried out. This implementation is empty.\n     */\n    notify() {\n        return;\n    }\n    /**\n     * Hook to free resources after the edit has been removed from the command\n     * history. This implementation is empty.\n     */\n    die() {\n        return;\n    }\n    /**\n     * Undoes all changes in this edit.\n     */\n    undo() {\n        if (!this.undone) {\n            this.source.fireEvent(new EventObject(InternalEvent.START_EDIT));\n            const count = this.changes.length;\n            for (let i = count - 1; i >= 0; i--) {\n                const change = this.changes[i];\n                if (change.execute) {\n                    change.execute();\n                }\n                else if (change.undo) {\n                    change.undo();\n                }\n                // New global executed event\n                this.source.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));\n            }\n            this.undone = true;\n            this.redone = false;\n            this.source.fireEvent(new EventObject(InternalEvent.END_EDIT));\n        }\n        this.notify();\n    }\n    /**\n     * Redoes all changes in this edit.\n     */\n    redo() {\n        if (!this.redone) {\n            this.source.fireEvent(new EventObject(InternalEvent.START_EDIT));\n            const count = this.changes.length;\n            for (let i = 0; i < count; i += 1) {\n                const change = this.changes[i];\n                if (change.execute != null) {\n                    change.execute();\n                }\n                else if (change.redo != null) {\n                    change.redo();\n                }\n                // New global executed event\n                this.source.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));\n            }\n            this.undone = false;\n            this.redone = true;\n            this.source.fireEvent(new EventObject(InternalEvent.END_EDIT));\n        }\n        this.notify();\n    }\n}\nexport default UndoableEdit;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport RectangleShape from './RectangleShape';\nimport { NONE } from '../../../util/Constants';\n/**\n * Extends {@link RectangleShape} to implement an image shape.\n * This shape is registered by default under {@link SHAPE.IMAGE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass ImageShape extends RectangleShape {\n    constructor(bounds, imageSrc, fill = '#FFFFFF', stroke = '#000000', strokeWidth = 1) {\n        super(bounds, fill, stroke, strokeWidth);\n        // Used in mxCellRenderer\n        this.overlay = null;\n        /**\n         * Switch to preserve image aspect. Default is true.\n         * @default true\n         */\n        // preserveImageAspect: boolean;\n        this.preserveImageAspect = true;\n        this.imageSrc = imageSrc;\n        this.shadow = false;\n    }\n    /**\n     * Disables offset in IE9 for crisper image output.\n     */\n    getSvgScreenOffset() {\n        return 0;\n    }\n    /**\n     * Overrides to replace the fill and stroke colors with the respective values from {@link imageBackground} and {@link imageBorder}.\n     *\n     * Applies the style of the given {@link CellState} to the shape. This implementation assigns the following styles to local fields:\n     *\n     * - {@link imageBackground} => fill\n     * - {@link imageBorder} => stroke\n     *\n     * @param {CellState} state   {@link CellState} of the corresponding cell.\n     */\n    apply(state) {\n        super.apply(state);\n        this.fill = NONE;\n        this.stroke = NONE;\n        this.gradient = NONE;\n        if (this.style && this.style.imageAspect != null) {\n            this.preserveImageAspect = this.style.imageAspect;\n        }\n    }\n    /**\n     * Returns true if HTML is allowed for this shape. This implementation always\n     * returns false.\n     */\n    isHtmlAllowed() {\n        return !this.preserveImageAspect;\n    }\n    /**\n     * Disables inherited roundable support.\n     */\n    isRoundable(c, x, y, w, h) {\n        return false;\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        if (this.imageSrc) {\n            const fill = this.style?.imageBackground ?? NONE;\n            const stroke = this.style?.imageBorder ?? NONE;\n            if (fill !== NONE) {\n                // Stroke rendering required for shadow\n                c.setFillColor(fill);\n                c.setStrokeColor(stroke);\n                c.rect(x, y, w, h);\n                c.fillAndStroke();\n            }\n            // FlipH/V are implicit via mxShape.updateTransform\n            c.image(x, y, w, h, this.imageSrc, this.preserveImageAspect, false, false);\n            if (stroke !== NONE) {\n                c.setShadow(false);\n                c.setStrokeColor(stroke);\n                c.rect(x, y, w, h);\n                c.stroke();\n            }\n        }\n        else {\n            this.paintBackground(c, x, y, w, h);\n        }\n    }\n}\nexport default ImageShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventObject from '../event/EventObject';\nimport Point from '../geometry/Point';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Action to change the current root in a view.\n */\nclass CurrentRootChange {\n    constructor(view, root) {\n        this.view = view;\n        this.root = root;\n        this.previous = root;\n        this.isUp = root === null;\n        if (!this.isUp) {\n            let tmp = this.view.currentRoot;\n            while (tmp) {\n                if (tmp === root) {\n                    this.isUp = true;\n                    break;\n                }\n                tmp = tmp.getParent();\n            }\n        }\n    }\n    /**\n     * Changes the current root of the view.\n     */\n    execute() {\n        const tmp = this.view.currentRoot;\n        this.view.currentRoot = this.previous;\n        this.previous = tmp;\n        const translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);\n        if (translate) {\n            this.view.translate = new Point(-translate.x, -translate.y);\n        }\n        if (this.isUp) {\n            this.view.clear(this.view.currentRoot, true, true);\n            this.view.validate(null);\n        }\n        else {\n            this.view.refresh();\n        }\n        const name = this.isUp ? InternalEvent.UP : InternalEvent.DOWN;\n        this.view.fireEvent(new EventObject(name, { root: this.view.currentRoot, previous: this.previous }));\n        this.isUp = !this.isUp;\n    }\n}\nexport default CurrentRootChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Singleton class that acts as a global converter from string to object values\n * in a style. This is currently only used to perimeters and edge styles.\n */\nclass StyleRegistry {\n    /**\n     * Puts the given object into the registry under the given name.\n     */\n    static putValue(name, obj) {\n        StyleRegistry.values[name] = obj;\n    }\n    /**\n     * Returns the value associated with the given name.\n     */\n    static getValue(name) {\n        return StyleRegistry.values[name];\n    }\n    /**\n     * Returns the name for the given value.\n     */\n    static getName(value) {\n        for (const key in StyleRegistry.values) {\n            if (StyleRegistry.values[key] === value) {\n                return key;\n            }\n        }\n        return null;\n    }\n}\n/**\n * Maps from strings to objects.\n */\nStyleRegistry.values = {};\nexport default StyleRegistry;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from './geometry/Point';\nimport Rectangle from './geometry/Rectangle';\nimport Dictionary from '../util/Dictionary';\nimport EventSource from './event/EventSource';\nimport EventObject from './event/EventObject';\nimport RectangleShape from './geometry/node/RectangleShape';\nimport { ALIGN } from '../util/Constants';\nimport Client from '../Client';\nimport InternalEvent from './event/InternalEvent';\nimport { convertPoint, getCurrentStyle, getOffset } from '../util/styleUtils';\nimport { getRotatedPoint, ptSegDistSq, relativeCcw, toRadians } from '../util/mathUtils';\nimport { GlobalConfig } from '../util/config';\nimport CellState from './cell/CellState';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport ImageShape from './geometry/node/ImageShape';\nimport InternalMouseEvent from './event/InternalMouseEvent';\nimport CurrentRootChange from './undoable_changes/CurrentRootChange';\nimport { getClientX, getClientY, getSource, isConsumed } from '../util/EventUtils';\nimport { clone } from '../util/cloneUtils';\nimport StyleRegistry from './style/StyleRegistry';\n/**\n * @class GraphView\n * @extends {EventSource}\n *\n * Extends {@link EventSource} to implement a view for a graph. This class is in\n * charge of computing the absolute coordinates for the relative child\n * geometries, the points for perimeters and edge styles and keeping them\n * cached in {@link CellState}s for faster retrieval. The states are updated\n * whenever the model or the view state (translate, scale) changes. The scale\n * and translate are honoured in the bounds.\n *\n * #### Event: mxEvent.UNDO\n *\n * Fires after the root was changed in {@link setCurrentRoot}. The `edit`\n * property contains the {@link UndoableEdit} which contains the\n * {@link CurrentRootChange}.\n *\n * #### Event: mxEvent.SCALE_AND_TRANSLATE\n *\n * Fires after the scale and translate have been changed in {@link scaleAndTranslate}.\n * The `scale`, `previousScale`, `translate`\n * and `previousTranslate` properties contain the new and previous\n * scale and translate, respectively.\n *\n * #### Event: mxEvent.SCALE\n *\n * Fires after the scale was changed in {@link setScale}. The `scale` and\n * `previousScale` properties contain the new and previous scale.\n *\n * #### Event: mxEvent.TRANSLATE\n *\n * Fires after the translate was changed in {@link setTranslate}. The\n * `translate` and `previousTranslate` properties contain\n * the new and previous value for translate.\n *\n * #### Event: mxEvent.DOWN and mxEvent.UP\n *\n * Fire if the current root is changed by executing an {@link CurrentRootChange}.\n * The event name depends on the location of the root in the cell hierarchy\n * with respect to the current root. The `root` and\n * `previous` properties contain the new and previous root,\n * respectively.\n */\nexport class GraphView extends EventSource {\n    constructor(graph) {\n        super();\n        // TODO: Document me!\n        this.backgroundImage = null;\n        this.backgroundPageShape = null;\n        this.EMPTY_POINT = new Point();\n        /**\n         * Specifies the resource key for the status message after a long operation.\n         * If the resource for this key does not exist then the value is used as\n         * the status message. Default is 'done'.\n         */\n        this.doneResource = Client.language !== 'none' ? 'done' : '';\n        /**\n         * Specifies the resource key for the status message while the document is\n         * being updated. If the resource for this key does not exist then the\n         * value is used as the status message. Default is 'updatingDocument'.\n         */\n        this.updatingDocumentResource = Client.language !== 'none' ? 'updatingDocument' : '';\n        /**\n         * Specifies if string values in cell styles should be evaluated using\n         * {@link eval}. This will only be used if the string values can't be mapped\n         * to objects using {@link StyleRegistry}. Default is false. NOTE: Enabling this\n         * switch carries a possible security risk.\n         */\n        this.allowEval = false;\n        /**\n         * Specifies if a gesture should be captured when it goes outside of the\n         * graph container. Default is true.\n         */\n        this.captureDocumentGesture = true;\n        /**\n         * Specifies if shapes should be created, updated and destroyed using the\n         * methods of {@link cellRenderer} in {@link graph}. Default is true.\n         */\n        this.rendering = true;\n        /**\n         * {@link Cell} that acts as the root of the displayed cell hierarchy.\n         */\n        this.currentRoot = null;\n        this.graphBounds = new Rectangle();\n        this.scale = 1;\n        /**\n         * {@link Point} that specifies the current translation. Default is a new\n         * empty {@link Point}.\n         */\n        this.translate = new Point();\n        this.states = new Dictionary();\n        /**\n         * Specifies if the style should be updated in each validation step. If this\n         * is false then the style is only updated if the state is created or if the\n         * style of the cell was changed. Default is false.\n         */\n        this.updateStyle = false;\n        /**\n         * During validation, this contains the last DOM node that was processed.\n         */\n        this.lastNode = null;\n        /**\n         * During validation, this contains the last HTML DOM node that was processed.\n         */\n        this.lastHtmlNode = null;\n        /**\n         * During validation, this contains the last edge's DOM node that was processed.\n         */\n        this.lastForegroundNode = null;\n        /**\n         * During validation, this contains the last edge HTML DOM node that was processed.\n         */\n        this.lastForegroundHtmlNode = null;\n        this.endHandler = null;\n        this.moveHandler = null;\n        this.graph = graph;\n    }\n    /**\n     * Returns {@link graphBounds}.\n     */\n    getGraphBounds() {\n        return this.graphBounds;\n    }\n    /**\n     * Sets {@link graphBounds}.\n     */\n    setGraphBounds(value) {\n        this.graphBounds = value;\n    }\n    /**\n     * Returns the {@link scale}.\n     */\n    getScale() {\n        return this.scale;\n    }\n    /**\n     * Sets the scale and fires a {@link scale} event before calling {@link revalidate} followed\n     * by {@link Graph.sizeDidChange}.\n     *\n     * @param value Decimal value that specifies the new scale (1 is 100%).\n     */\n    setScale(value) {\n        const previousScale = this.scale;\n        if (previousScale !== value) {\n            this.scale = value;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.SCALE, { scale: value, previousScale }));\n    }\n    /**\n     * Returns the {@link translate}.\n     */\n    getTranslate() {\n        return this.translate;\n    }\n    isRendering() {\n        return this.rendering;\n    }\n    setRendering(value) {\n        this.rendering = value;\n    }\n    /**\n     * Sets the translation and fires a {@link translate} event before calling\n     * {@link revalidate} followed by {@link Graph.sizeDidChange}. The translation is the\n     * negative of the origin.\n     *\n     * @param dx X-coordinate of the translation.\n     * @param dy Y-coordinate of the translation.\n     */\n    setTranslate(dx, dy) {\n        const previousTranslate = new Point(this.translate.x, this.translate.y);\n        if (this.translate.x !== dx || this.translate.y !== dy) {\n            this.translate.x = dx;\n            this.translate.y = dy;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.TRANSLATE, {\n            translate: this.translate,\n            previousTranslate: previousTranslate,\n        }));\n    }\n    isAllowEval() {\n        return this.allowEval;\n    }\n    setAllowEval(value) {\n        this.allowEval = value;\n    }\n    /**\n     * Returns {@link states}.\n     */\n    getStates() {\n        return this.states;\n    }\n    /**\n     * Sets {@link states}.\n     */\n    setStates(value) {\n        this.states = value;\n    }\n    /**\n     * Returns the DOM node that contains the background-, draw- and\n     * overlay- and decoratorpanes.\n     */\n    getCanvas() {\n        return this.canvas;\n    }\n    /**\n     * Returns the DOM node that represents the background layer.\n     */\n    getBackgroundPane() {\n        return this.backgroundPane;\n    }\n    /**\n     * Returns the DOM node that represents the main drawing layer.\n     */\n    getDrawPane() {\n        return this.drawPane;\n    }\n    /**\n     * Returns the DOM node that represents the layer above the drawing layer.\n     */\n    getOverlayPane() {\n        return this.overlayPane;\n    }\n    /**\n     * Returns the DOM node that represents the topmost drawing layer.\n     */\n    getDecoratorPane() {\n        return this.decoratorPane;\n    }\n    /**\n     * Returns the union of all {@link mxCellStates} for the given array of {@link Cell}.\n     *\n     * @param cells Array of {@link Cell} whose bounds should be returned.\n     */\n    getBounds(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (cells[i].isVertex() || cells[i].isEdge()) {\n                    const state = this.getState(cells[i]);\n                    if (state) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(state);\n                        }\n                        else {\n                            result.add(state);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Sets and returns the current root and fires an {@link undo} event before\n     * calling {@link graph.sizeDidChange}.\n     *\n     * @param root {@link mxCell} that specifies the root of the displayed cell hierarchy.\n     */\n    setCurrentRoot(root) {\n        if (this.currentRoot !== root) {\n            const change = new CurrentRootChange(this, root);\n            change.execute();\n            const edit = new UndoableEdit(this, true);\n            edit.add(change);\n            this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));\n            this.graph.sizeDidChange();\n            this.currentRoot = root;\n        }\n        return root;\n    }\n    /**\n     * Sets the scale and translation and fires a {@link scale} and {@link translate} event\n     * before calling {@link revalidate} followed by {@link graph.sizeDidChange}.\n     *\n     * @param scale Decimal value that specifies the new scale (1 is 100%).\n     * @param dx X-coordinate of the translation.\n     * @param dy Y-coordinate of the translation.\n     */\n    scaleAndTranslate(scale, dx, dy) {\n        const previousScale = this.scale;\n        const previousTranslate = new Point(this.translate.x, this.translate.y);\n        if (this.scale !== scale || this.translate.x !== dx || this.translate.y !== dy) {\n            this.scale = scale;\n            this.translate.x = dx;\n            this.translate.y = dy;\n            if (this.isEventsEnabled()) {\n                this.viewStateChanged();\n            }\n        }\n        this.fireEvent(new EventObject(InternalEvent.SCALE_AND_TRANSLATE, {\n            scale,\n            previousScale,\n            translate: this.translate,\n            previousTranslate: previousTranslate,\n        }));\n    }\n    /**\n     * Invoked after {@link scale} and/or {@link translate} has changed.\n     */\n    viewStateChanged() {\n        this.revalidate();\n        this.graph.sizeDidChange();\n    }\n    /**\n     * Clears the view if {@link currentRoot} is not null and revalidates.\n     */\n    refresh() {\n        if (this.currentRoot) {\n            this.clear();\n        }\n        this.revalidate();\n    }\n    /**\n     * Revalidates the complete view with all cell states.\n     */\n    revalidate() {\n        this.invalidate();\n        this.validate();\n    }\n    /**\n     * Removes the state of the given cell and all descendants if the given\n     * cell is not the current root.\n     *\n     * @param cell Optional {@link Cell} for which the state should be removed. Default\n     * is the root of the model.\n     * @param force Boolean indicating if the current root should be ignored for\n     * recursion.\n     */\n    clear(cell, force = false, recurse = true) {\n        if (!cell) {\n            cell = this.graph.getDataModel().getRoot();\n        }\n        if (cell) {\n            this.removeState(cell);\n            if (recurse && (force || cell !== this.currentRoot)) {\n                const childCount = cell.getChildCount();\n                for (let i = 0; i < childCount; i += 1) {\n                    this.clear(cell.getChildAt(i), force);\n                }\n            }\n            else {\n                this.invalidate(cell);\n            }\n        }\n    }\n    /**\n     * Invalidates the state of the given cell, all its descendants and\n     * connected edges.\n     *\n     * @param cell Optional {@link Cell} to be invalidated. Default is the root of the\n     * model.\n     */\n    invalidate(cell = null, recurse = true, includeEdges = true) {\n        const model = this.graph.getDataModel();\n        cell = cell ?? model.getRoot();\n        if (cell) {\n            const state = this.getState(cell);\n            if (state) {\n                state.invalid = true;\n            }\n            // Avoids infinite loops for invalid graphs\n            if (!cell.invalidating) {\n                cell.invalidating = true;\n                // Recursively invalidates all descendants\n                if (recurse) {\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        const child = cell.getChildAt(i);\n                        this.invalidate(child, recurse, includeEdges);\n                    }\n                }\n                // Propagates invalidation to all connected edges\n                if (includeEdges) {\n                    const edgeCount = cell.getEdgeCount();\n                    for (let i = 0; i < edgeCount; i += 1) {\n                        this.invalidate(cell.getEdgeAt(i), recurse, includeEdges);\n                    }\n                }\n                cell.invalidating = false;\n            }\n        }\n    }\n    /**\n     * Calls {@link validateCell} and {@link validateCellState} and updates the {@link graphBounds}\n     * using {@link getBoundingBox}. Finally the background is validated using\n     * {@link validateBackground}.\n     *\n     * @param cell Optional {@link Cell} to be used as the root of the validation.\n     * Default is {@link currentRoot} or the root of the model.\n     */\n    validate(cell = null) {\n        const t0 = GlobalConfig.logger.enter('GraphView.validate');\n        this.resetValidationState();\n        const c = cell || (this.currentRoot ?? this.graph.getDataModel().getRoot());\n        if (c) {\n            const graphBounds = this.getBoundingBox(this.validateCellState(c ? this.validateCell(c) : null));\n            this.setGraphBounds(graphBounds ?? this.getEmptyBounds());\n            this.validateBackground();\n            this.resetValidationState();\n        }\n        GlobalConfig.logger.leave('GraphView.validate', t0);\n    }\n    /**\n     * Returns the bounds for an empty graph. This returns a rectangle at\n     * {@link translate} with the size of 0 x 0.\n     */\n    getEmptyBounds() {\n        return new Rectangle(this.translate.x * this.scale, this.translate.y * this.scale);\n    }\n    /**\n     * Returns the bounding box of the shape and the label for the given\n     * {@link CellState} and its children if recurse is true.\n     *\n     * @param state {@link CellState} whose bounding box should be returned.\n     * @param recurse Optional boolean indicating if the children should be included.\n     * Default is true.\n     */\n    getBoundingBox(state = null, recurse = true) {\n        let bbox = null;\n        if (state) {\n            if (state.shape && state.shape.boundingBox) {\n                bbox = state.shape.boundingBox.clone();\n            }\n            // Adds label bounding box to graph bounds\n            if (state.text && state.text.boundingBox) {\n                if (bbox) {\n                    bbox.add(state.text.boundingBox);\n                }\n                else {\n                    bbox = state.text.boundingBox.clone();\n                }\n            }\n            if (recurse) {\n                const childCount = state.cell.getChildCount();\n                for (let i = 0; i < childCount; i += 1) {\n                    const bounds = this.getBoundingBox(this.getState(state.cell.getChildAt(i)));\n                    if (bounds) {\n                        if (!bbox) {\n                            bbox = bounds;\n                        }\n                        else {\n                            bbox.add(bounds);\n                        }\n                    }\n                }\n            }\n        }\n        return bbox;\n    }\n    /**\n     * Creates and returns the shape used as the background page.\n     *\n     * @param bounds {@link mxRectangle} that represents the bounds of the shape.\n     */\n    createBackgroundPageShape(bounds) {\n        return new RectangleShape(bounds, 'white', 'black');\n    }\n    /**\n     * Calls {@link validateBackgroundImage} and {@link validateBackgroundPage}.\n     */\n    validateBackground() {\n        this.validateBackgroundImage();\n        this.validateBackgroundPage();\n    }\n    /**\n     * Validates the background image.\n     */\n    validateBackgroundImage() {\n        const bg = this.graph.getBackgroundImage();\n        if (bg) {\n            if (!this.backgroundImage || this.backgroundImage.imageSrc !== bg.src) {\n                if (this.backgroundImage) {\n                    this.backgroundImage.destroy();\n                }\n                const bounds = new Rectangle(0, 0, 1, 1);\n                this.backgroundImage = new ImageShape(bounds, bg.src);\n                this.backgroundImage.dialect = this.graph.dialect;\n                this.backgroundImage.init(this.backgroundPane);\n                this.backgroundImage.redraw();\n            }\n            this.redrawBackgroundImage(this.backgroundImage, bg);\n        }\n        else if (this.backgroundImage) {\n            this.backgroundImage.destroy();\n            this.backgroundImage = null;\n        }\n    }\n    /**\n     * Validates the background page.\n     */\n    validateBackgroundPage() {\n        const graph = this.graph;\n        if (graph.pageVisible) {\n            const bounds = this.getBackgroundPageBounds();\n            if (this.backgroundPageShape == null) {\n                this.backgroundPageShape = this.createBackgroundPageShape(bounds);\n                this.backgroundPageShape.scale = this.scale;\n                this.backgroundPageShape.isShadow = true;\n                this.backgroundPageShape.dialect = this.graph.dialect;\n                this.backgroundPageShape.init(this.backgroundPane);\n                this.backgroundPageShape.redraw();\n                if (this.backgroundPageShape.node) {\n                    // Adds listener for double click handling on background\n                    if (graph.isNativeDblClickEnabled()) {\n                        InternalEvent.addListener(this.backgroundPageShape.node, 'dblclick', ((evt) => {\n                            graph.dblClick(evt);\n                        }));\n                    }\n                    // Adds basic listeners for graph event dispatching outside of the\n                    // container and finishing the handling of a single gesture\n                    InternalEvent.addGestureListeners(this.backgroundPageShape.node, (evt) => {\n                        graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n                    }, (evt) => {\n                        const tooltipHandler = graph.getPlugin('TooltipHandler');\n                        // Hides the tooltip if mouse is outside container\n                        if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n                            tooltipHandler.hide();\n                        }\n                        if (graph.isMouseDown && !isConsumed(evt)) {\n                            graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n                        }\n                    }, (evt) => {\n                        graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n                    });\n                }\n            }\n            else {\n                this.backgroundPageShape.scale = this.scale;\n                this.backgroundPageShape.bounds = bounds;\n                this.backgroundPageShape.redraw();\n            }\n        }\n        else if (this.backgroundPageShape) {\n            this.backgroundPageShape.destroy();\n            this.backgroundPageShape = null;\n        }\n    }\n    /**\n     * Returns the bounds for the background page.\n     */\n    getBackgroundPageBounds() {\n        const fmt = this.graph.pageFormat;\n        const ps = this.scale * this.graph.pageScale;\n        return new Rectangle(this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);\n    }\n    /**\n     * Updates the bounds and redraws the background image.\n     *\n     * Example:\n     *\n     * If the background image should not be scaled, this can be replaced with\n     * the following.\n     *\n     * @example\n     * ```javascript\n     * redrawBackground(backgroundImage, bg)\n     * {\n     *   backgroundImage.bounds.x = this.translate.x;\n     *   backgroundImage.bounds.y = this.translate.y;\n     *   backgroundImage.bounds.width = bg.width;\n     *   backgroundImage.bounds.height = bg.height;\n     *\n     *   backgroundImage.redraw();\n     * };\n     * ```\n     *\n     * @param backgroundImage {@link mxImageShape} that represents the background image.\n     * @param bg {@link mxImage} that specifies the image and its dimensions.\n     */\n    redrawBackgroundImage(backgroundImage, bg) {\n        backgroundImage.scale = this.scale;\n        if (backgroundImage.bounds) {\n            const bounds = backgroundImage.bounds;\n            bounds.x = this.scale * this.translate.x;\n            bounds.y = this.scale * this.translate.y;\n            bounds.width = this.scale * bg.width;\n            bounds.height = this.scale * bg.height;\n        }\n        backgroundImage.redraw();\n    }\n    /**\n     * Recursively creates the cell state for the given cell if visible is true and\n     * the given cell is visible. If the cell is not visible but the state exists\n     * then it is removed using {@link removeState}.\n     *\n     * @param cell {@link mxCell} whose {@link CellState} should be created.\n     * @param visible Optional boolean indicating if the cell should be visible. Default\n     * is true.\n     */\n    validateCell(cell, visible = true) {\n        visible = visible && cell.isVisible();\n        const state = this.getState(cell, visible);\n        if (state && !visible) {\n            this.removeState(cell);\n        }\n        else {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.validateCell(cell.getChildAt(i), visible && (!cell.isCollapsed() || cell === this.currentRoot));\n            }\n        }\n        return cell;\n    }\n    /**\n     * Validates and repaints the {@link CellState} for the given {@link Cell}.\n     *\n     * @param cell {@link mxCell} whose {@link CellState} should be validated.\n     * @param recurse Optional boolean indicating if the children of the cell should be\n     * validated. Default is true.\n     */\n    validateCellState(cell, recurse = true) {\n        let state = null;\n        if (cell) {\n            state = this.getState(cell);\n            if (state) {\n                if (state.invalid) {\n                    state.invalid = false;\n                    if (!state.style || state.invalidStyle) {\n                        state.style = this.graph.getCellStyle(state.cell);\n                        state.invalidStyle = false;\n                    }\n                    if (cell !== this.currentRoot) {\n                        this.validateCellState(cell.getParent(), false);\n                    }\n                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n                    state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n                    this.updateCellState(state);\n                    // Repaint happens immediately after the cell is validated\n                    if (cell !== this.currentRoot && !state.invalid) {\n                        this.graph.cellRenderer.redraw(state, false, this.isRendering());\n                        // Handles changes to invertex paintbounds after update of rendering shape\n                        state.updateCachedBounds();\n                    }\n                }\n                if (recurse && !state.invalid) {\n                    // Updates order in DOM if recursively traversing\n                    if (state.shape) {\n                        this.stateValidated(state);\n                    }\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        this.validateCellState(cell.getChildAt(i));\n                    }\n                }\n            }\n        }\n        return state;\n    }\n    /**\n     * Updates the given {@link CellState}.\n     *\n     * @param state {@link CellState} to be updated.\n     */\n    updateCellState(state) {\n        const absoluteOffset = state.absoluteOffset;\n        const origin = state.origin;\n        absoluteOffset.x = 0;\n        absoluteOffset.y = 0;\n        origin.x = 0;\n        origin.y = 0;\n        state.length = 0;\n        if (state.cell !== this.currentRoot) {\n            const parent = state.cell.getParent();\n            const pState = parent ? this.getState(parent) : null;\n            if (pState && pState.cell !== this.currentRoot) {\n                origin.x += pState.origin.x;\n                origin.y += pState.origin.y;\n            }\n            let offset = this.graph.getChildOffsetForCell(state.cell);\n            if (offset) {\n                origin.x += offset.x;\n                origin.y += offset.y;\n            }\n            const geo = state.cell.getGeometry();\n            if (geo) {\n                if (!state.cell.isEdge()) {\n                    offset = geo.offset ? geo.offset : this.EMPTY_POINT;\n                    if (geo.relative && pState) {\n                        if (pState.cell.isEdge()) {\n                            const point = this.getPoint(pState, geo);\n                            if (point) {\n                                origin.x += point.x / this.scale - pState.origin.x - this.translate.x;\n                                origin.y += point.y / this.scale - pState.origin.y - this.translate.y;\n                            }\n                        }\n                        else {\n                            origin.x += geo.x * pState.unscaledWidth + offset.x;\n                            origin.y += geo.y * pState.unscaledHeight + offset.y;\n                        }\n                    }\n                    else {\n                        absoluteOffset.x = this.scale * offset.x;\n                        absoluteOffset.y = this.scale * offset.y;\n                        origin.x += geo.x;\n                        origin.y += geo.y;\n                    }\n                }\n                state.x = this.scale * (this.translate.x + origin.x);\n                state.y = this.scale * (this.translate.y + origin.y);\n                state.width = this.scale * geo.width;\n                state.unscaledWidth = geo.width;\n                state.height = this.scale * geo.height;\n                state.unscaledHeight = geo.height;\n                if (state.cell.isVertex()) {\n                    this.updateVertexState(state, geo);\n                }\n                if (state.cell.isEdge()) {\n                    this.updateEdgeState(state, geo);\n                }\n            }\n        }\n        state.updateCachedBounds();\n    }\n    /**\n     * Validates the given cell state.\n     */\n    updateVertexState(state, geo) {\n        const parent = state.cell.getParent();\n        const pState = parent ? this.getState(parent) : null;\n        if (geo.relative && pState && !pState.cell.isEdge()) {\n            const alpha = toRadians(pState.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const ct = new Point(state.getCenterX(), state.getCenterY());\n                const cx = new Point(pState.getCenterX(), pState.getCenterY());\n                const pt = getRotatedPoint(ct, cos, sin, cx);\n                state.x = pt.x - state.width / 2;\n                state.y = pt.y - state.height / 2;\n            }\n        }\n        this.updateVertexLabelOffset(state);\n    }\n    /**\n     * Validates the given cell state.\n     */\n    updateEdgeState(state, geo) {\n        const source = state.getVisibleTerminalState(true);\n        const target = state.getVisibleTerminalState(false);\n        // This will remove edges with no terminals and no terminal points\n        // as such edges are invalid and produce NPEs in the edge styles.\n        // Also removes connected edges that have no visible terminals.\n        if ((state.cell.getTerminal(true) && !source) ||\n            (!source && !geo.getTerminalPoint(true)) ||\n            (state.cell.getTerminal(false) && !target) ||\n            (!target && !geo.getTerminalPoint(false))) {\n            this.clear(state.cell, true);\n        }\n        else {\n            this.updateFixedTerminalPoints(state, source, target);\n            this.updatePoints(state, geo.points, source, target);\n            this.updateFloatingTerminalPoints(state, source, target);\n            const pts = state.absolutePoints;\n            if (state.cell !== this.currentRoot &&\n                (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {\n                // This will remove edges with invalid points from the list of states in the view.\n                // Happens if the one of the terminals and the corresponding terminal point is null.\n                this.clear(state.cell, true);\n            }\n            else {\n                this.updateEdgeBounds(state);\n                this.updateEdgeLabelOffset(state);\n            }\n        }\n    }\n    /**\n     * Updates the absoluteOffset of the given vertex cell state. This takes\n     * into account the label position styles.\n     *\n     * @param state {@link CellState} whose absolute offset should be updated.\n     */\n    updateVertexLabelOffset(state) {\n        const h = state.style.labelPosition ?? ALIGN.CENTER;\n        if (h === ALIGN.LEFT) {\n            let lw = state.style.labelWidth ?? null;\n            if (lw != null) {\n                lw *= this.scale;\n            }\n            else {\n                lw = state.width;\n            }\n            // @ts-ignore\n            state.absoluteOffset.x -= lw;\n        }\n        else if (h === ALIGN.RIGHT) {\n            // @ts-ignore\n            state.absoluteOffset.x += state.width;\n        }\n        else if (h === ALIGN.CENTER) {\n            const lw = state.style.labelWidth ?? null;\n            if (lw != null) {\n                // Aligns text block with given width inside the vertex width\n                const align = state.style.align ?? ALIGN.CENTER;\n                let dx = 0;\n                if (align === ALIGN.CENTER) {\n                    dx = 0.5;\n                }\n                else if (align === ALIGN.RIGHT) {\n                    dx = 1;\n                }\n                if (dx !== 0) {\n                    // @ts-ignore\n                    state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n                }\n            }\n        }\n        const v = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n        if (v === ALIGN.TOP) {\n            // @ts-ignore\n            state.absoluteOffset.y -= state.height;\n        }\n        else if (v === ALIGN.BOTTOM) {\n            // @ts-ignore\n            state.absoluteOffset.y += state.height;\n        }\n    }\n    /**\n     * Resets the current validation state.\n     */\n    resetValidationState() {\n        this.lastNode = null;\n        this.lastHtmlNode = null;\n        this.lastForegroundNode = null;\n        this.lastForegroundHtmlNode = null;\n    }\n    /**\n     * Invoked when a state has been processed in {@link validatePoints}. This is used\n     * to update the order of the DOM nodes of the shape.\n     *\n     * @param state {@link CellState} that represents the cell state.\n     */\n    stateValidated(state) {\n        const graph = this.graph;\n        const fg = (state.cell.isEdge() && graph.keepEdgesInForeground) ||\n            (state.cell.isVertex() && graph.keepEdgesInBackground);\n        const htmlNode = fg\n            ? this.lastForegroundHtmlNode || this.lastHtmlNode\n            : this.lastHtmlNode;\n        const node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;\n        const result = graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n        if (fg) {\n            this.lastForegroundHtmlNode = result[1];\n            this.lastForegroundNode = result[0];\n        }\n        else {\n            this.lastHtmlNode = result[1];\n            this.lastNode = result[0];\n        }\n    }\n    /**\n     * Sets the initial absolute terminal points in the given state before the edge\n     * style is computed.\n     *\n     * @param edge {@link CellState} whose initial terminal points should be updated.\n     * @param source {@link CellState} which represents the source terminal.\n     * @param target {@link CellState} which represents the target terminal.\n     */\n    updateFixedTerminalPoints(edge, source, target) {\n        this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));\n        this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));\n    }\n    /**\n     * Sets the fixed source or target terminal point on the given edge.\n     *\n     * @param edge <CellState> whose terminal point should be updated.\n     * @param terminal <CellState> which represents the actual terminal.\n     * @param source Boolean that specifies if the terminal is the source.\n     * @param constraint {@link ConnectionConstraint} that specifies the connection.\n     */\n    updateFixedTerminalPoint(edge, terminal, source, constraint) {\n        edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n    }\n    /**\n     * Returns the fixed source or target terminal point for the given edge.\n     *\n     * @param edge <CellState> whose terminal point should be returned.\n     * @param terminal <CellState> which represents the actual terminal.\n     * @param source Boolean that specifies if the terminal is the source.\n     * @param constraint {@link ConnectionConstraint} that specifies the connection.\n     */\n    getFixedTerminalPoint(edge, terminal, source, constraint) {\n        let pt = null;\n        if (constraint && terminal) {\n            pt = this.graph.getConnectionPoint(terminal, constraint, false); // FIXME Rounding introduced bugs when calculating label positions -> , this.graph.isOrthogonal(edge));\n        }\n        if (!pt && !terminal) {\n            const s = this.scale;\n            const tr = this.translate;\n            const orig = edge.origin;\n            const geo = edge.cell.getGeometry();\n            pt = geo.getTerminalPoint(source);\n            if (pt) {\n                pt = new Point(s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n            }\n        }\n        return pt;\n    }\n    /**\n     * Updates the bounds of the given cell state to reflect the bounds of the stencil\n     * if it has a fixed aspect and returns the previous bounds as an {@link Rectangle} if\n     * the bounds have been modified or null otherwise.\n     *\n     * @param edge {@link CellState} whose bounds should be updated.\n     */\n    updateBoundsFromStencil(state) {\n        let previous = null;\n        if (state &&\n            state.shape &&\n            state.shape.stencil &&\n            state.shape.stencil.aspect === 'fixed') {\n            previous = Rectangle.fromRectangle(state);\n            const asp = state.shape.stencil.computeAspect(null, // this argument is not used\n            state.x, state.y, state.width, state.height);\n            state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n        }\n        return previous;\n    }\n    /**\n     * Updates the absolute points in the given state using the specified array\n     * of {@link Point} as the relative points.\n     *\n     * @param edge {@link CellState} whose absolute points should be updated.\n     * @param points Array of {@link Point} that constitute the relative points.\n     * @param source {@link CellState} that represents the source terminal.\n     * @param target {@link CellState} that represents the target terminal.\n     */\n    updatePoints(edge, points, source, target) {\n        const pts = [];\n        pts.push(edge.absolutePoints[0]);\n        const edgeStyle = this.getEdgeStyle(edge, points, source, target);\n        if (edgeStyle && source) {\n            // target can be null\n            const src = this.getTerminalPort(edge, source, true);\n            const trg = target ? this.getTerminalPort(edge, target, false) : null;\n            // Uses the stencil bounds for routing and restores after routing\n            const srcBounds = this.updateBoundsFromStencil(src);\n            const trgBounds = this.updateBoundsFromStencil(trg);\n            edgeStyle(edge, src, trg, points, pts);\n            // Restores previous bounds\n            if (src && srcBounds) {\n                src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n            }\n            if (trg && trgBounds) {\n                trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n            }\n        }\n        else if (points) {\n            for (let i = 0; i < points.length; i += 1) {\n                if (points[i]) {\n                    const pt = clone(points[i]);\n                    pts.push(this.transformControlPoint(edge, pt));\n                }\n            }\n        }\n        const tmp = edge.absolutePoints;\n        pts.push(tmp[tmp.length - 1]);\n        edge.absolutePoints = pts;\n    }\n    /**\n     * Transforms the given control point to an absolute point.\n     */\n    transformControlPoint(state, pt, ignoreScale = false) {\n        if (state && pt) {\n            const orig = state.origin;\n            const scale = ignoreScale ? 1 : this.scale;\n            return new Point(scale * (pt.x + this.translate.x + orig.x), scale * (pt.y + this.translate.y + orig.y));\n        }\n        return null;\n    }\n    /**\n     * Returns true if the given edge should be routed with {@link graph.defaultLoopStyle}\n     * or the {@link CellStateStyle.STYLE_LOOP} defined for the given edge.\n     * This implementation returns `true` if the given edge is a loop and does not\n     */\n    isLoopStyleEnabled(edge, points = [], source = null, target = null) {\n        const sc = this.graph.getConnectionConstraint(edge, source, true);\n        const tc = this.graph.getConnectionConstraint(edge, target, false);\n        if ((points == null || points.length < 2) &&\n            !((edge.style.orthogonalLoop ?? false) ||\n                ((sc == null || sc.point == null) && (tc == null || tc.point == null)))) {\n            return source != null && source === target;\n        }\n        return false;\n    }\n    /**\n     * Returns the edge style function to be used to render the given edge state.\n     */\n    getEdgeStyle(edge, points = [], source = null, target = null) {\n        let edgeStyle = this.isLoopStyleEnabled(edge, points, source, target)\n            ? edge.style.loopStyle ?? this.graph.defaultLoopStyle\n            : !(edge.style.noEdgeStyle ?? false)\n                ? edge.style.edgeStyle\n                : null;\n        // Converts string values to objects\n        if (typeof edgeStyle === 'string') {\n            let tmp = StyleRegistry.getValue(edgeStyle);\n            if (!tmp && this.isAllowEval()) {\n                tmp = eval(edgeStyle);\n            }\n            edgeStyle = tmp;\n        }\n        if (typeof edgeStyle === 'function') {\n            return edgeStyle;\n        }\n        return null;\n    }\n    /**\n     * Updates the terminal points in the given state after the edge style was\n     * computed for the edge.\n     *\n     * @param state {@link CellState} whose terminal points should be updated.\n     * @param source {@link CellState} that represents the source terminal.\n     * @param target {@link CellState} that represents the target terminal.\n     */\n    updateFloatingTerminalPoints(state, source, target) {\n        const pts = state.absolutePoints;\n        const p0 = pts[0];\n        const pe = pts[pts.length - 1];\n        if (!pe && target) {\n            this.updateFloatingTerminalPoint(state, target, source, false);\n        }\n        if (!p0 && source) {\n            this.updateFloatingTerminalPoint(state, source, target, true);\n        }\n    }\n    /**\n     * Updates the absolute terminal point in the given state for the given\n     * start and end state, where start is the source if source is true.\n     *\n     * @param edge {@link CellState} whose terminal point should be updated.\n     * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n     * @param end {@link CellState} for the terminal on the other side of the edge.\n     * @param source Boolean indicating if start is the source terminal state.\n     */\n    updateFloatingTerminalPoint(edge, start, end, source) {\n        edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n    }\n    /**\n     * Returns the floating terminal point for the given edge, start and end\n     * state, where start is the source if source is true.\n     *\n     * @param edge {@link CellState} whose terminal point should be returned.\n     * @param start {@link CellState} for the terminal on \"this\" side of the edge.\n     * @param end {@link CellState} for the terminal on the other side of the edge.\n     * @param source Boolean indicating if start is the source terminal state.\n     */\n    getFloatingTerminalPoint(edge, start, end, source) {\n        start = this.getTerminalPort(edge, start, source);\n        let next = this.getNextPoint(edge, end, source);\n        const orth = this.graph.isOrthogonal(edge);\n        const alpha = toRadians(start.style.rotation ?? 0);\n        const center = new Point(start.getCenterX(), start.getCenterY());\n        if (alpha !== 0) {\n            const cos = Math.cos(-alpha);\n            const sin = Math.sin(-alpha);\n            next = getRotatedPoint(next, cos, sin, center);\n        }\n        let border = edge.style.perimeterSpacing ?? 0;\n        border +=\n            edge.style[source ? 'sourcePerimeterSpacing' : 'targetPerimeterSpacing'] ?? 0;\n        let pt = this.getPerimeterPoint(start, next, alpha === 0 && orth, border);\n        if (pt && alpha !== 0) {\n            const cos = Math.cos(alpha);\n            const sin = Math.sin(alpha);\n            pt = getRotatedPoint(pt, cos, sin, center);\n        }\n        return pt;\n    }\n    /**\n     * Returns an {@link CellState} that represents the source or target terminal or\n     * port for the given edge.\n     *\n     * @param state {@link CellState} that represents the state of the edge.\n     * @param terminal {@link CellState} that represents the terminal.\n     * @param source Boolean indicating if the given terminal is the source terminal.\n     */\n    getTerminalPort(state, terminal, source = false) {\n        const key = source ? 'sourcePort' : 'targetPort';\n        const id = state.style[key];\n        if (id) {\n            const cell = this.graph.getDataModel().getCell(id);\n            if (cell) {\n                const tmp = this.getState(cell, false);\n                // Only uses ports where a cell state exists\n                if (tmp) {\n                    terminal = tmp;\n                }\n            }\n        }\n        return terminal;\n    }\n    /**\n     * Returns an {@link Point} that defines the location of the intersection point between\n     * the perimeter and the line between the center of the shape and the given point.\n     *\n     * @param terminal {@link CellState} for the source or target terminal.\n     * @param next {@link Point} that lies outside the given terminal.\n     * @param orthogonal Boolean that specifies if the orthogonal projection onto\n     * the perimeter should be returned. If this is false then the intersection\n     * of the perimeter and the line between the next and the center point is\n     * returned.\n     * @param border Optional border between the perimeter and the shape.\n     */\n    getPerimeterPoint(terminal, next, orthogonal, border = 0) {\n        let point = null;\n        if (terminal != null) {\n            const perimeter = this.getPerimeterFunction(terminal);\n            if (perimeter != null && next != null) {\n                const bounds = this.getPerimeterBounds(terminal, border);\n                if (bounds.width > 0 || bounds.height > 0) {\n                    point = new Point(next.x, next.y);\n                    let flipH = false;\n                    let flipV = false;\n                    if (terminal.cell.isVertex()) {\n                        flipH = !!terminal.style.flipH;\n                        flipV = !!terminal.style.flipV;\n                        if (flipH) {\n                            point.x = 2 * bounds.getCenterX() - point.x;\n                        }\n                        if (flipV) {\n                            point.y = 2 * bounds.getCenterY() - point.y;\n                        }\n                    }\n                    point = perimeter(bounds, terminal, point, orthogonal);\n                    if (point != null) {\n                        if (flipH) {\n                            point.x = 2 * bounds.getCenterX() - point.x;\n                        }\n                        if (flipV) {\n                            point.y = 2 * bounds.getCenterY() - point.y;\n                        }\n                    }\n                }\n            }\n            if (point == null) {\n                point = this.getPoint(terminal);\n            }\n        }\n        return point;\n    }\n    /**\n     * Returns the x-coordinate of the center point for automatic routing.\n     */\n    getRoutingCenterX(state) {\n        const f = state.style ? state.style.routingCenterX ?? 0 : 0;\n        return state.getCenterX() + f * state.width;\n    }\n    /**\n     * Returns the y-coordinate of the center point for automatic routing.\n     */\n    getRoutingCenterY(state) {\n        const f = state.style ? state.style.routingCenterY ?? 0 : 0;\n        return state.getCenterY() + f * state.height;\n    }\n    /**\n     * Returns the perimeter bounds for the given terminal, edge pair as an\n     * {@link Rectangle}.\n     *\n     * If you have a model where each terminal has a relative child that should\n     * act as the graphical endpoint for a connection from/to the terminal, then\n     * this method can be replaced as follows:\n     *\n     * @example\n     * ```javascript\n     * var oldGetPerimeterBounds = getPerimeterBounds;\n     * getPerimeterBounds(terminal, edge, isSource)\n     * {\n     *   var model = this.graph.getDataModel();\n     *   var childCount = model.getChildCount(terminal.cell);\n     *\n     *   if (childCount > 0)\n     *   {\n     *     var child = model.getChildAt(terminal.cell, 0);\n     *     var geo = model.getGeometry(child);\n     *\n     *     if (geo != null &&\n     *         geo.relative)\n     *     {\n     *       var state = this.getState(child);\n     *\n     *       if (state != null)\n     *       {\n     *         terminal = state;\n     *       }\n     *     }\n     *   }\n     *\n     *   return oldGetPerimeterBounds.apply(this, arguments);\n     * };\n     * ```\n     *\n     * @param terminal CellState that represents the terminal.\n     * @param border Number that adds a border between the shape and the perimeter.\n     */\n    getPerimeterBounds(terminal, border = 0) {\n        border += terminal.style.perimeterSpacing ?? 0;\n        return terminal.getPerimeterBounds(border * this.scale);\n    }\n    /**\n     * Returns the perimeter function for the given state.\n     */\n    getPerimeterFunction(state) {\n        let perimeter = state.style.perimeter;\n        // Converts string values to objects\n        if (typeof perimeter === 'string') {\n            let tmp = StyleRegistry.getValue(perimeter);\n            if (tmp == null && this.isAllowEval()) {\n                tmp = eval(perimeter);\n            }\n            perimeter = tmp;\n        }\n        if (typeof perimeter === 'function') {\n            return perimeter;\n        }\n        return null;\n    }\n    /**\n     * Returns the nearest point in the list of absolute points or the center\n     * of the opposite terminal.\n     *\n     * @param edge {@link CellState} that represents the edge.\n     * @param opposite {@link CellState} that represents the opposite terminal.\n     * @param source Boolean indicating if the next point for the source or target\n     * should be returned.\n     */\n    getNextPoint(edge, opposite, source = false) {\n        const pts = edge.absolutePoints;\n        let point = null;\n        if (pts.length >= 2) {\n            const count = pts.length;\n            point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n        }\n        if (!point && opposite) {\n            point = new Point(opposite.getCenterX(), opposite.getCenterY());\n        }\n        return point; // shouldn't return null, but really?\n    }\n    /**\n     * Returns the nearest ancestor terminal that is visible. The edge appears\n     * to be connected to this terminal on the display. The result of this method\n     * is cached in {@link CellState.getVisibleTerminalState}.\n     *\n     * @param edge {@link mxCell} whose visible terminal should be returned.\n     * @param source Boolean that specifies if the source or target terminal\n     * should be returned.\n     */\n    getVisibleTerminal(edge, source) {\n        const model = this.graph.getDataModel();\n        let result = edge.getTerminal(source);\n        let best = result;\n        while (result && result !== this.currentRoot) {\n            if ((best && !best.isVisible()) || result.isCollapsed()) {\n                best = result;\n            }\n            result = result.getParent();\n        }\n        // Checks if the result is valid for the current view state\n        if (best &&\n            (!model.contains(best) ||\n                best.getParent() === model.getRoot() ||\n                best === this.currentRoot)) {\n            best = null;\n        }\n        return best;\n    }\n    /**\n     * Updates the given state using the bounding box of t\n     * he absolute points.\n     * Also updates {@link CellState.terminalDistance}, {@link CellState.length} and\n     * {@link CellState.segments}.\n     *\n     * @param state {@link CellState} whose bounds should be updated.\n     */\n    updateEdgeBounds(state) {\n        const points = state.absolutePoints;\n        const p0 = points[0];\n        const pe = points[points.length - 1];\n        if (p0 && pe && (p0.x !== pe.x || p0.y !== pe.y)) {\n            const dx = pe.x - p0.x;\n            const dy = pe.y - p0.y;\n            state.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n        }\n        else {\n            state.terminalDistance = 0;\n        }\n        let length = 0;\n        const segments = [];\n        let pt = p0;\n        if (pt) {\n            let minX = pt.x;\n            let minY = pt.y;\n            let maxX = minX;\n            let maxY = minY;\n            for (let i = 1; i < points.length; i += 1) {\n                const tmp = points[i];\n                if (tmp) {\n                    const dx = pt.x - tmp.x;\n                    const dy = pt.y - tmp.y;\n                    const segment = Math.sqrt(dx * dx + dy * dy);\n                    segments.push(segment);\n                    length += segment;\n                    pt = tmp;\n                    minX = Math.min(pt.x, minX);\n                    minY = Math.min(pt.y, minY);\n                    maxX = Math.max(pt.x, maxX);\n                    maxY = Math.max(pt.y, maxY);\n                }\n            }\n            state.length = length;\n            state.segments = segments;\n            const markerSize = 1; // TODO: include marker size\n            state.x = minX;\n            state.y = minY;\n            state.width = Math.max(markerSize, maxX - minX);\n            state.height = Math.max(markerSize, maxY - minY);\n        }\n    }\n    /**\n     * Returns the absolute point on the edge for the given relative\n     * {@link Geometry} as an {@link Point}. The edge is represented by the given\n     * {@link CellState}.\n     *\n     * @param state {@link CellState} that represents the state of the parent edge.\n     * @param geometry {@link mxGeometry} that represents the relative location.\n     */\n    getPoint(state, geometry = null) {\n        let x = state.getCenterX();\n        let y = state.getCenterY();\n        if (state.segments != null && (geometry == null || geometry.relative)) {\n            const gx = geometry != null ? geometry.x / 2 : 0;\n            const pointCount = state.absolutePoints.length;\n            const dist = Math.round((gx + 0.5) * state.length);\n            let segment = state.segments[0];\n            let length = 0;\n            let index = 1;\n            while (dist >= Math.round(length + segment) && index < pointCount - 1) {\n                length += segment;\n                segment = state.segments[index++];\n            }\n            const factor = segment === 0 ? 0 : (dist - length) / segment;\n            const p0 = state.absolutePoints[index - 1];\n            const pe = state.absolutePoints[index];\n            if (p0 != null && pe != null) {\n                let gy = 0;\n                let offsetX = 0;\n                let offsetY = 0;\n                if (geometry != null) {\n                    gy = geometry.y;\n                    const { offset } = geometry;\n                    if (offset != null) {\n                        offsetX = offset.x;\n                        offsetY = offset.y;\n                    }\n                }\n                const dx = pe.x - p0.x;\n                const dy = pe.y - p0.y;\n                const nx = segment === 0 ? 0 : dy / segment;\n                const ny = segment === 0 ? 0 : dx / segment;\n                x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n                y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n            }\n        }\n        else if (geometry != null) {\n            const { offset } = geometry;\n            if (offset != null) {\n                x += offset.x;\n                y += offset.y;\n            }\n        }\n        return new Point(x, y);\n    }\n    /**\n     * Gets the relative point that describes the given, absolute label\n     * position for the given edge state.\n     *\n     * @param state {@link CellState} that represents the state of the parent edge.\n     * @param x Specifies the x-coordinate of the absolute label location.\n     * @param y Specifies the y-coordinate of the absolute label location.\n     */\n    getRelativePoint(edgeState, x, y) {\n        const geometry = edgeState.cell.getGeometry();\n        if (geometry) {\n            const absolutePoints = edgeState.absolutePoints;\n            const pointCount = absolutePoints.length;\n            if (geometry.relative && pointCount > 1) {\n                const totalLength = edgeState.length;\n                const { segments } = edgeState;\n                // Works out which line segment the point of the label is closest to\n                let p0 = absolutePoints[0];\n                let pe = absolutePoints[1];\n                let minDist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n                let length = 0;\n                let index = 0;\n                let tmp = 0;\n                for (let i = 2; i < pointCount; i += 1) {\n                    p0 = pe;\n                    pe = absolutePoints[i];\n                    const dist = ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n                    tmp += segments[i - 2];\n                    if (dist <= minDist) {\n                        minDist = dist;\n                        index = i - 1;\n                        length = tmp;\n                    }\n                }\n                const seg = segments[index];\n                p0 = absolutePoints[index];\n                pe = absolutePoints[index + 1];\n                const x2 = p0.x;\n                const y2 = p0.y;\n                const x1 = pe.x;\n                const y1 = pe.y;\n                let px = x;\n                let py = y;\n                const xSegment = x2 - x1;\n                const ySegment = y2 - y1;\n                px -= x1;\n                py -= y1;\n                let projlenSq = 0;\n                px = xSegment - px;\n                py = ySegment - py;\n                const dotprod = px * xSegment + py * ySegment;\n                if (dotprod <= 0.0) {\n                    projlenSq = 0;\n                }\n                else {\n                    projlenSq = (dotprod * dotprod) / (xSegment * xSegment + ySegment * ySegment);\n                }\n                let projlen = Math.sqrt(projlenSq);\n                if (projlen > seg) {\n                    projlen = seg;\n                }\n                let yDistance = Math.sqrt(ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));\n                const direction = relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n                if (direction === -1) {\n                    yDistance = -yDistance;\n                }\n                // Constructs the relative point for the label\n                return new Point(((totalLength / 2 - length - projlen) / totalLength) * -2, yDistance / this.scale);\n            }\n        }\n        return new Point();\n    }\n    /**\n     * Updates {@link CellState.absoluteOffset} for the given state. The absolute\n     * offset is normally used for the position of the edge label. Is is\n     * calculated from the geometry as an absolute offset from the center\n     * between the two endpoints if the geometry is absolute, or as the\n     * relative distance between the center along the line and the absolute\n     * orthogonal distance if the geometry is relative.\n     *\n     * @param state {@link CellState} whose absolute offset should be updated.\n     */\n    updateEdgeLabelOffset(state) {\n        const points = state.absolutePoints;\n        const absoluteOffset = state.absoluteOffset;\n        absoluteOffset.x = state.getCenterX();\n        absoluteOffset.y = state.getCenterY();\n        if (points.length > 0 && state.segments) {\n            const geometry = state.cell.getGeometry();\n            if (geometry) {\n                if (geometry.relative) {\n                    const offset = this.getPoint(state, geometry);\n                    state.absoluteOffset = offset;\n                }\n                else {\n                    const p0 = points[0];\n                    const pe = points[points.length - 1];\n                    if (p0 && pe) {\n                        const dx = pe.x - p0.x;\n                        const dy = pe.y - p0.y;\n                        let x0 = 0;\n                        let y0 = 0;\n                        const off = geometry.offset;\n                        if (off) {\n                            x0 = off.x;\n                            y0 = off.y;\n                        }\n                        const x = p0.x + dx / 2 + x0 * this.scale;\n                        const y = p0.y + dy / 2 + y0 * this.scale;\n                        absoluteOffset.x = x;\n                        absoluteOffset.y = y;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the {@link CellState} for the given cell. If create is true, then\n     * the state is created if it does not yet exist.\n     *\n     * @param cell {@link mxCell} for which the {@link CellState} should be returned.\n     * @param create Optional boolean indicating if a new state should be created\n     * if it does not yet exist. Default is false.\n     */\n    getState(cell, create = false) {\n        let state = this.states.get(cell);\n        if (create && (!state || this.updateStyle) && cell.isVisible()) {\n            if (!state) {\n                state = this.createState(cell);\n                this.states.put(cell, state);\n            }\n            else {\n                state.style = this.graph.getCellStyle(cell);\n            }\n        }\n        return state;\n    }\n    /**\n     * Returns the {@link mxCellStates} for the given array of {@link Cell}. The array\n     * contains all states that are not null, that is, the returned array may\n     * have less elements than the given array. If no argument is given, then\n     * this returns {@link states}.\n     */\n    getCellStates(cells = null) {\n        if (!cells) {\n            return this.states.getValues();\n        }\n        const result = [];\n        for (const cell of cells) {\n            const state = this.getState(cell);\n            if (state) {\n                result.push(state);\n            }\n        }\n        return result;\n    }\n    /**\n     * Removes and returns the {@link CellState} for the given cell.\n     *\n     * @param cell {@link mxCell} for which the {@link CellState} should be removed.\n     */\n    removeState(cell) {\n        const state = this.states.remove(cell);\n        if (state) {\n            this.graph.cellRenderer.destroy(state);\n            state.invalid = true;\n            state.destroy();\n        }\n        return state;\n    }\n    /**\n     * Creates and returns an {@link CellState} for the given cell and initializes\n     * it using {@link cellRenderer.initialize}.\n     *\n     * @param cell {@link mxCell} for which a new {@link CellState} should be created.\n     */\n    createState(cell) {\n        return new CellState(this, cell, this.graph.getCellStyle(cell));\n    }\n    /**\n     * Returns true if the event origin is one of the drawing panes or\n     * containers of the view.\n     */\n    isContainerEvent(evt) {\n        const source = getSource(evt);\n        return (source &&\n            (source === this.graph.container ||\n                // @ts-ignore parentNode may exist\n                source.parentNode === this.backgroundPane ||\n                // @ts-ignore parentNode may exist\n                (source.parentNode && source.parentNode.parentNode === this.backgroundPane) ||\n                source === this.canvas.parentNode ||\n                source === this.canvas ||\n                source === this.backgroundPane ||\n                source === this.drawPane ||\n                source === this.overlayPane ||\n                source === this.decoratorPane));\n    }\n    /**\n     * Returns true if the event origin is one of the scrollbars of the\n     * container in IE. Such events are ignored.\n     */\n    isScrollEvent(evt) {\n        const graph = this.graph;\n        const offset = getOffset(graph.container);\n        const pt = new Point(evt.clientX - offset.x, evt.clientY - offset.y);\n        const container = graph.container;\n        const outWidth = container.offsetWidth;\n        const inWidth = container.clientWidth;\n        if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {\n            return true;\n        }\n        const outHeight = container.offsetHeight;\n        const inHeight = container.clientHeight;\n        return outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight;\n    }\n    /**\n     * Initializes the graph event dispatch loop for the specified container\n     * and invokes {@link create} to create the required DOM nodes for the display.\n     */\n    init() {\n        this.installListeners();\n        this.createSvg();\n    }\n    /**\n     * Installs the required listeners in the container.\n     */\n    installListeners() {\n        const graph = this.graph;\n        const { container } = graph;\n        // Support for touch device gestures (eg. pinch to zoom)\n        // Double-tap handling is implemented in mxGraph.fireMouseEvent\n        if (Client.IS_TOUCH) {\n            InternalEvent.addListener(container, 'gesturestart', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n            InternalEvent.addListener(container, 'gesturechange', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n            InternalEvent.addListener(container, 'gestureend', ((evt) => {\n                graph.fireGestureEvent(evt);\n                InternalEvent.consume(evt);\n            }));\n        }\n        // Fires event only for one pointer per gesture\n        let pointerId = null;\n        // Adds basic listeners for graph event dispatching\n        InternalEvent.addGestureListeners(container, ((evt) => {\n            // Condition to avoid scrollbar events starting a rubberband selection\n            if (this.isContainerEvent(evt) &&\n                ((!Client.IS_GC && !Client.IS_SF) || !this.isScrollEvent(evt))) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n                // @ts-ignore\n                pointerId = evt.pointerId;\n            }\n        }), (evt) => {\n            if (this.isContainerEvent(evt) &&\n                // @ts-ignore\n                (pointerId === null || evt.pointerId === pointerId)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n            }\n        }, (evt) => {\n            if (this.isContainerEvent(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            }\n            pointerId = null;\n        });\n        // Adds listener for double click handling on background, this does always\n        // use native event handler, we assume that the DOM of the background\n        // does not change during the double click\n        InternalEvent.addListener(container, 'dblclick', ((evt) => {\n            if (this.isContainerEvent(evt)) {\n                graph.dblClick(evt);\n            }\n        }));\n        // Workaround for touch events which started on some DOM node\n        // on top of the container, in which case the cells under the\n        // mouse for the move and up events are not detected.\n        const getState = (evt) => {\n            let state = null;\n            // Workaround for touch events which started on some DOM node\n            // on top of the container, in which case the cells under the\n            // mouse for the move and up events are not detected.\n            if (Client.IS_TOUCH) {\n                const x = getClientX(evt);\n                const y = getClientY(evt);\n                // Dispatches the drop event to the graph which\n                // consumes and executes the source function\n                const pt = convertPoint(container, x, y);\n                const cell = graph.getCellAt(pt.x, pt.y);\n                if (cell)\n                    state = graph.view.getState(cell);\n            }\n            return state;\n        };\n        // Adds basic listeners for graph event dispatching outside of the\n        // container and finishing the handling of a single gesture\n        // Implemented via graph event dispatch loop to avoid duplicate events\n        // in Firefox and Chrome\n        graph.addMouseListener({\n            mouseDown: (sender, me) => {\n                const popupMenuHandler = graph.getPlugin('PopupMenuHandler');\n                popupMenuHandler?.hideMenu();\n            },\n            mouseMove: () => {\n                return;\n            },\n            mouseUp: () => {\n                return;\n            },\n        });\n        this.moveHandler = (evt) => {\n            const tooltipHandler = graph.getPlugin('TooltipHandler');\n            // Hides the tooltip if mouse is outside container\n            if (tooltipHandler && tooltipHandler.isHideOnHover()) {\n                tooltipHandler.hide();\n            }\n            if (this.captureDocumentGesture &&\n                graph.isMouseDown &&\n                graph.container != null &&\n                !this.isContainerEvent(evt) &&\n                graph.container.style.display !== 'none' &&\n                graph.container.style.visibility !== 'hidden' &&\n                !isConsumed(evt)) {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n            }\n        };\n        this.endHandler = (evt) => {\n            if (this.captureDocumentGesture &&\n                graph.isMouseDown &&\n                graph.container != null &&\n                !this.isContainerEvent(evt) &&\n                graph.container.style.display !== 'none' &&\n                graph.container.style.visibility !== 'hidden') {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            }\n        };\n        InternalEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);\n    }\n    /**\n     * Creates and returns the DOM nodes for the SVG display.\n     */\n    createSvg() {\n        const { container } = this.graph;\n        const canvas = (this.canvas = document.createElementNS('http://www.w3.org/2000/svg', 'g'));\n        // For background image\n        this.backgroundPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.backgroundPane);\n        // Adds two layers (background is early feature)\n        this.drawPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.drawPane);\n        this.overlayPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.overlayPane);\n        this.decoratorPane = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        canvas.appendChild(this.decoratorPane);\n        const root = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        root.style.left = '0px';\n        root.style.top = '0px';\n        root.style.width = '100%';\n        root.style.height = '100%';\n        // NOTE: In standards mode, the SVG must have block layout\n        // in order for the container DIV to not show scrollbars.\n        root.style.display = 'block';\n        root.appendChild(this.canvas);\n        if (container != null) {\n            container.appendChild(root);\n            this.updateContainerStyle(container);\n        }\n    }\n    /**\n     * Function: createHtml\n     *\n     * Creates the DOM nodes for the HTML display.\n     */\n    createHtml() {\n        const container = this.graph.container;\n        if (container != null) {\n            this.canvas = this.createHtmlPane('100%', '100%');\n            this.canvas.style.overflow = 'hidden';\n            // Uses minimal size for inner DIVs on Canvas. This is required\n            // for correct event processing in IE. If we have an overlapping\n            // DIV then the events on the cells are only fired for labels.\n            this.backgroundPane = this.createHtmlPane('1px', '1px');\n            this.drawPane = this.createHtmlPane('1px', '1px');\n            this.overlayPane = this.createHtmlPane('1px', '1px');\n            this.decoratorPane = this.createHtmlPane('1px', '1px');\n            this.canvas.appendChild(this.backgroundPane);\n            this.canvas.appendChild(this.drawPane);\n            this.canvas.appendChild(this.overlayPane);\n            this.canvas.appendChild(this.decoratorPane);\n            container.appendChild(this.canvas);\n            this.updateContainerStyle(container);\n        }\n    }\n    /**\n     * Function: updateHtmlCanvasSize\n     *\n     * Updates the size of the HTML canvas.\n     */\n    updateHtmlCanvasSize(width, height) {\n        if (this.graph.container != null) {\n            const ow = this.graph.container.offsetWidth;\n            const oh = this.graph.container.offsetHeight;\n            if (ow < width) {\n                this.canvas.style.width = width + 'px';\n            }\n            else {\n                this.canvas.style.width = '100%';\n            }\n            if (oh < height) {\n                this.canvas.style.height = height + 'px';\n            }\n            else {\n                this.canvas.style.height = '100%';\n            }\n        }\n    }\n    /**\n     * Function: createHtmlPane\n     *\n     * Creates and returns a drawing pane in HTML (DIV).\n     */\n    createHtmlPane(width, height) {\n        const pane = document.createElement('DIV');\n        if (width != null && height != null) {\n            pane.style.position = 'absolute';\n            pane.style.left = '0px';\n            pane.style.top = '0px';\n            pane.style.width = width;\n            pane.style.height = height;\n        }\n        else {\n            pane.style.position = 'relative';\n        }\n        return pane;\n    }\n    /**\n     * Updates the style of the container after installing the SVG DOM elements.\n     */\n    updateContainerStyle(container) {\n        // Workaround for offset of container\n        const style = getCurrentStyle(container);\n        if (style != null && style.position == 'static') {\n            container.style.position = 'relative';\n        }\n        // Disables built-in pan and zoom in IE10 and later\n        if (Client.IS_POINTER) {\n            container.style.touchAction = 'none';\n        }\n    }\n    /**\n     * Destroys the view and all its resources.\n     */\n    destroy() {\n        let root = null;\n        if (this.canvas && this.canvas instanceof SVGElement) {\n            root = this.canvas.ownerSVGElement;\n        }\n        if (!root) {\n            root = this.canvas;\n        }\n        if (root && root.parentNode) {\n            this.clear(this.currentRoot, true);\n            InternalEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n            InternalEvent.release(this.graph.container);\n            root.parentNode.removeChild(root);\n            this.moveHandler = null;\n            this.endHandler = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.canvas = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.backgroundPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.drawPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.overlayPane = null;\n            // @ts-expect-error Can be null when destroyed.\n            this.decoratorPane = null;\n        }\n    }\n}\nexport default GraphView;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a polyline (a line with multiple points).\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is not registered in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass PolylineShape extends Shape {\n    /**\n     * Constructs a new polyline shape.\n     *\n     * @param points Array of <{@link Point} that define the points. This is stored in {@link Shape.points}.\n     * @param stroke String that defines the stroke color. Default is 'black'. This is stored in {@link Shape.stroke}.\n     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link Shape.strokeWidth}.\n     */\n    constructor(points, stroke, strokeWidth = 1) {\n        super();\n        this.points = points;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Returns 0.\n     */\n    getRotation() {\n        return 0;\n    }\n    /**\n     * Returns 0.\n     */\n    getShapeRotation() {\n        return 0;\n    }\n    /**\n     * Returns false.\n     */\n    isPaintBoundsInverted() {\n        return false;\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        const prev = c.pointerEventsValue;\n        c.pointerEventsValue = 'stroke';\n        if (!this.style || !this.style.curved) {\n            this.paintLine(c, pts, this.isRounded);\n        }\n        else {\n            this.paintCurvedLine(c, pts);\n        }\n        c.pointerEventsValue = prev;\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintLine(c, pts, rounded) {\n        const arcSize = this.style?.arcSize ?? LINE_ARCSIZE;\n        c.begin();\n        this.addPoints(c, pts, rounded, arcSize, false);\n        c.stroke();\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintCurvedLine(c, pts) {\n        c.begin();\n        const pt = pts[0];\n        const n = pts.length;\n        c.moveTo(pt.x, pt.y);\n        for (let i = 1; i < n - 2; i += 1) {\n            const p0 = pts[i];\n            const p1 = pts[i + 1];\n            const ix = (p0.x + p1.x) / 2;\n            const iy = (p0.y + p1.y) / 2;\n            c.quadTo(p0.x, p0.y, ix, iy);\n        }\n        const p0 = pts[n - 2];\n        const p1 = pts[n - 1];\n        c.quadTo(p0.x, p0.y, p1.x, p1.y);\n        c.stroke();\n    }\n}\nexport default PolylineShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { ARROW } from '../../../util/Constants';\n/**\n * A registry that stores all edge markers using .\n *\n * NOTE: The signatures in this class will change.\n */\nclass MarkerShape {\n    /**\n     * Adds a factory method that updates a given endpoint and returns a\n     * function to paint the marker onto the given canvas.\n     */\n    static addMarker(type, funct) {\n        MarkerShape.markers[type] = funct;\n    }\n    /**\n     * Returns a function to paint the given marker.\n     */\n    static createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n        const markerFunction = MarkerShape.markers[type];\n        return markerFunction\n            ? markerFunction(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n            : null;\n    }\n}\n/**\n * Maps from markers names to functions to paint the markers.\n *\n * Mapping: the attribute name on the object is the marker type, the associated value is the function to paint the marker\n */\nMarkerShape.markers = {};\nexport default MarkerShape;\n/**\n * For the classic and block marker factory methods.\n */\nfunction createArrow(widthFactor) {\n    return (canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) => {\n        // The angle of the forward facing arrow sides against the x axis is\n        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n        // only half the strokewidth is processed ).\n        const endOffsetX = unitX * sw * 1.118;\n        const endOffsetY = unitY * sw * 1.118;\n        unitX *= size + sw;\n        unitY *= size + sw;\n        const pt = pe.clone();\n        pt.x -= endOffsetX;\n        pt.y -= endOffsetY;\n        const f = type !== ARROW.CLASSIC && type !== ARROW.CLASSIC_THIN ? 1 : 3 / 4;\n        pe.x += -unitX * f - endOffsetX;\n        pe.y += -unitY * f - endOffsetY;\n        return () => {\n            canvas.begin();\n            canvas.moveTo(pt.x, pt.y);\n            canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n            if (type === ARROW.CLASSIC || type === ARROW.CLASSIC_THIN) {\n                canvas.lineTo(pt.x - (unitX * 3) / 4, pt.y - (unitY * 3) / 4);\n            }\n            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n            canvas.close();\n            if (filled) {\n                canvas.fillAndStroke();\n            }\n            else {\n                canvas.stroke();\n            }\n        };\n    };\n}\nfunction createOpenArrow(widthFactor) {\n    return (canvas, _shape, _type, pe, unitX, unitY, size, _source, sw, _filled) => {\n        // The angle of the forward facing arrow sides against the x axis is\n        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n        // only half the strokewidth is processed ).\n        const endOffsetX = unitX * sw * 1.118;\n        const endOffsetY = unitY * sw * 1.118;\n        unitX *= size + sw;\n        unitY *= size + sw;\n        const pt = pe.clone();\n        pt.x -= endOffsetX;\n        pt.y -= endOffsetY;\n        pe.x += -endOffsetX * 2;\n        pe.y += -endOffsetY * 2;\n        return () => {\n            canvas.begin();\n            canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n            canvas.lineTo(pt.x, pt.y);\n            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n            canvas.stroke();\n        };\n    };\n}\nconst oval = (canvas, _shape, _type, pe, unitX, unitY, size, _source, _sw, filled) => {\n    const a = size / 2;\n    const pt = pe.clone();\n    pe.x -= unitX * a;\n    pe.y -= unitY * a;\n    return () => {\n        canvas.ellipse(pt.x - a, pt.y - a, size, size);\n        if (filled) {\n            canvas.fillAndStroke();\n        }\n        else {\n            canvas.stroke();\n        }\n    };\n};\nfunction diamond(canvas, _shape, type, pe, unitX, unitY, size, _source, sw, filled) {\n    // The angle of the forward facing arrow sides against the x axis is\n    // 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for\n    // only half the strokewidth is processed ). Or 0.9862 for thin diamond.\n    // Note these values and the tk variable below are dependent, update\n    // both together (saves trig hard coding it).\n    const swFactor = type === ARROW.DIAMOND ? 0.7071 : 0.9862;\n    const endOffsetX = unitX * sw * swFactor;\n    const endOffsetY = unitY * sw * swFactor;\n    unitX *= size + sw;\n    unitY *= size + sw;\n    const pt = pe.clone();\n    pt.x -= endOffsetX;\n    pt.y -= endOffsetY;\n    pe.x += -unitX - endOffsetX;\n    pe.y += -unitY - endOffsetY;\n    // thickness factor for diamond\n    const tk = type === ARROW.DIAMOND ? 2 : 3.4;\n    return () => {\n        canvas.begin();\n        canvas.moveTo(pt.x, pt.y);\n        canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);\n        canvas.lineTo(pt.x - unitX, pt.y - unitY);\n        canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);\n        canvas.close();\n        if (filled) {\n            canvas.fillAndStroke();\n        }\n        else {\n            canvas.stroke();\n        }\n    };\n}\nlet isDefaultMarkersRegistered = false;\n/**\n * @category Configuration\n */\nexport const registerDefaultEdgeMarkers = () => {\n    if (!isDefaultMarkersRegistered) {\n        MarkerShape.addMarker('classic', createArrow(2));\n        MarkerShape.addMarker('classicThin', createArrow(3));\n        MarkerShape.addMarker('block', createArrow(2));\n        MarkerShape.addMarker('blockThin', createArrow(3));\n        MarkerShape.addMarker('open', createOpenArrow(2));\n        MarkerShape.addMarker('openThin', createOpenArrow(3));\n        MarkerShape.addMarker('oval', oval);\n        MarkerShape.addMarker('diamond', diamond);\n        MarkerShape.addMarker('diamondThin', diamond);\n        isDefaultMarkersRegistered = true;\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DEFAULT_MARKERSIZE, NONE } from '../../../util/Constants';\nimport PolylineShape from './PolylineShape';\nimport MarkerShape from './MarkerShape';\n/**\n * Extends {@link PolylineShape} to implement a connector shape including a polyline (a line with multiple points)\n * that allows for arrow heads on either side.\n *\n * The shape is used to represent edges, not vertices.\n *\n * This shape is registered under {@link SHAPE.CONNECTOR} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ConnectorShape extends PolylineShape {\n    constructor(points, stroke, strokewidth) {\n        super(points, stroke, strokewidth);\n    }\n    /**\n     * Updates the <boundingBox> for this shape using <createBoundingBox>\n     * and augmentBoundingBox and stores the result in <boundingBox>.\n     */\n    updateBoundingBox() {\n        this.useSvgBoundingBox = !!this.style?.curved;\n        super.updateBoundingBox();\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // The indirection via functions for markers is needed in\n        // order to apply the offsets before painting the line and\n        // paint the markers after painting the line.\n        const sourceMarker = this.createMarker(c, pts, true);\n        const targetMarker = this.createMarker(c, pts, false);\n        super.paintEdgeShape(c, pts);\n        // Disables shadows, dashed styles\n        c.setShadow(false);\n        c.setDashed(false);\n        if (sourceMarker) {\n            const strokeColor = this.style?.startStrokeColor ?? this.stroke;\n            c.setStrokeColor(strokeColor);\n            c.setFillColor(this.style?.startFillColor ?? strokeColor);\n            sourceMarker();\n        }\n        if (targetMarker) {\n            const strokeColor = this.style?.endStrokeColor ?? this.stroke;\n            c.setStrokeColor(strokeColor);\n            c.setFillColor(this.style?.endFillColor ?? strokeColor);\n            targetMarker();\n        }\n    }\n    /**\n     * Prepares the marker by adding offsets in pts and returning a function to paint the marker.\n     */\n    createMarker(c, pts, source) {\n        if (!this.style)\n            return null;\n        let result = null;\n        const n = pts.length;\n        const type = (source ? this.style.startArrow : this.style.endArrow) || NONE;\n        let p0 = source ? pts[1] : pts[n - 2];\n        const pe = source ? pts[0] : pts[n - 1];\n        if (type !== NONE && p0 !== null && pe !== null) {\n            let count = 1;\n            // Uses next non-overlapping point\n            while (count < n - 1 &&\n                Math.round(p0.x - pe.x) === 0 &&\n                Math.round(p0.y - pe.y) === 0) {\n                p0 = source ? pts[1 + count] : pts[n - 2 - count];\n                count++;\n            }\n            // Computes the norm and the inverse norm\n            const dx = pe.x - p0.x;\n            const dy = pe.y - p0.y;\n            const dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n            const unitX = dx / dist;\n            const unitY = dy / dist;\n            const size = (source ? this.style.startSize : this.style.endSize) ?? DEFAULT_MARKERSIZE;\n            // Allow for stroke width in the end point used and the\n            // orthogonal vectors describing the direction of the marker\n            const filled = (source ? this.style.startFill : this.style.endFill) ?? true;\n            result = MarkerShape.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokeWidth, filled);\n        }\n        return result;\n    }\n    /**\n     * Augments the bounding box with the strokewidth and shadow offsets.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        if (!this.style)\n            return;\n        // Adds marker sizes\n        let size = 0;\n        if (this.style.startArrow !== NONE) {\n            size = (this.style.startSize ?? DEFAULT_MARKERSIZE) + 1;\n        }\n        if (this.style.endArrow !== NONE) {\n            size = Math.max(size, this.style.endSize ?? DEFAULT_MARKERSIZE) + 1;\n        }\n        bbox.grow(size * this.scale);\n    }\n}\nexport default ConnectorShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, NONE, TEXT_DIRECTION, WORD_WRAP, LINE_HEIGHT, } from '../../../util/Constants';\nimport { getBoundingBox } from '../../../util/mathUtils';\nimport { getAlignmentAsPoint, matchBinaryMask } from '../../../util/styleUtils';\nimport Point from '../Point';\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { htmlEntities, replaceTrailingNewlines, trim } from '../../../util/StringUtils';\nimport { isNode } from '../../../util/domUtils';\nimport SvgCanvas2D from '../../canvas/SvgCanvas2D';\n/**\n * Extends {@link Shape} to implement a text shape.\n *\n * To change vertical text from \"bottom to top\" to \"top to bottom\", the following code can be used:\n * ```javascript\n * TextShape.prototype.verticalTextRotation = 90;\n * ```\n *\n * @category Vertex Shapes\n */\nclass TextShape extends Shape {\n    constructor(value, bounds, align = ALIGN.CENTER, valign = ALIGN.MIDDLE, color = 'black', family = DEFAULT_FONTFAMILY, size = DEFAULT_FONTSIZE, fontStyle = DEFAULT_FONTSTYLE, spacing = 2, spacingTop = 0, spacingRight = 0, spacingBottom = 0, spacingLeft = 0, horizontal = true, background = NONE, border = NONE, wrap = false, clipped = false, overflow = 'visible', labelPadding = 0, textDirection = DEFAULT_TEXT_DIRECTION) {\n        super();\n        this.margin = null;\n        this.unrotatedBoundingBox = null;\n        this.flipH = false;\n        this.flipV = false;\n        /**\n         * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n         * value 5 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingTop = 0;\n        /**\n         * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n         * value 1 here to get the same label positions as in mxGraph 1.x.\n         */\n        this.baseSpacingBottom = 0;\n        /**\n         * Specifies the spacing to be added to the left spacing. Default is 0.\n         */\n        this.baseSpacingLeft = 0;\n        /**\n         * Specifies the spacing to be added to the right spacing. Default is 0.\n         */\n        this.baseSpacingRight = 0;\n        /**\n         * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n         * Default is true.\n         */\n        this.replaceLinefeeds = true;\n        /**\n         * Rotation for vertical text. Default is -90 (bottom to top).\n         */\n        this.verticalTextRotation = -90;\n        /**\n         * Specifies if the string size should be measured in <updateBoundingBox> if\n         * the label is clipped and the label position is center and middle. If this is\n         * true, then the bounding box will be set to <bounds>. Default is true.\n         * <ignoreStringSize> has precedence over this switch.\n         */\n        this.ignoreClippedStringSize = true;\n        /**\n         * Specifies if the actual string size should be measured. If disabled the\n         * boundingBox will not ignore the actual size of the string, otherwise\n         * <bounds> will be used instead. Default is false.\n         */\n        this.ignoreStringSize = false;\n        /**\n         * Contains the last rendered text value. Used for caching.\n         */\n        this.lastValue = null;\n        /**\n         * Specifies if caching for HTML labels should be enabled. Default is true.\n         */\n        this.cacheEnabled = true;\n        this.value = value;\n        this.bounds = bounds;\n        this.color = color ?? 'black';\n        this.align = align ?? ALIGN.CENTER;\n        this.valign = valign ?? ALIGN.MIDDLE;\n        this.family = family ?? DEFAULT_FONTFAMILY;\n        this.size = size ?? DEFAULT_FONTSIZE;\n        this.fontStyle = fontStyle ?? DEFAULT_FONTSTYLE;\n        this.spacing = spacing ?? 2;\n        this.spacingTop = this.spacing + (spacingTop ?? 0);\n        this.spacingRight = this.spacing + (spacingRight ?? 0);\n        this.spacingBottom = this.spacing + (spacingBottom ?? 0);\n        this.spacingLeft = this.spacing + (spacingLeft ?? 0);\n        this.horizontal = horizontal ?? true;\n        this.background = background;\n        this.border = border;\n        this.wrap = wrap ?? false;\n        this.clipped = clipped ?? false;\n        this.overflow = overflow ?? 'visible';\n        this.labelPadding = labelPadding ?? 0;\n        this.textDirection = textDirection;\n        this.rotation = 0;\n        this.updateMargin();\n    }\n    /**\n     * Disables offset in IE9 for crisper image output.\n     */\n    getSvgScreenOffset() {\n        return 0;\n    }\n    /**\n     * Returns true if the bounds are not null and all of its variables are numeric.\n     */\n    checkBounds() {\n        return (!isNaN(this.scale) &&\n            isFinite(this.scale) &&\n            this.scale > 0 &&\n            this.bounds &&\n            !isNaN(this.bounds.x) &&\n            !isNaN(this.bounds.y) &&\n            !isNaN(this.bounds.width) &&\n            !isNaN(this.bounds.height));\n    }\n    /**\n     * Generic rendering code.\n     */\n    paint(c, update = false) {\n        // Scale is passed-through to canvas\n        const s = this.scale;\n        const x = this.bounds.x / s;\n        const y = this.bounds.y / s;\n        const w = this.bounds.width / s;\n        const h = this.bounds.height / s;\n        this.updateTransform(c, x, y, w, h);\n        this.configureCanvas(c, x, y, w, h);\n        if (update) {\n            c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);\n        }\n        else {\n            // Checks if text contains HTML markup\n            const realHtml = isNode(this.value) || this.dialect === DIALECT.STRICTHTML;\n            // Always renders labels as HTML in VML\n            const fmt = realHtml ? 'html' : '';\n            let val = this.value;\n            if (!realHtml && fmt === 'html') {\n                // @ts-ignore\n                val = htmlEntities(val, false);\n            }\n            if (fmt === 'html' && !isNode(this.value)) {\n                val = replaceTrailingNewlines(val, '<div><br></div>');\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val =\n                !isNode(this.value) && this.replaceLinefeeds && fmt === 'html'\n                    ? val.replace(/\\n/g, '<br/>')\n                    : val;\n            let dir = this.textDirection;\n            if (dir === TEXT_DIRECTION.AUTO && !realHtml) {\n                dir = this.getAutoDirection();\n            }\n            if (dir !== TEXT_DIRECTION.LTR && dir !== TEXT_DIRECTION.RTL) {\n                dir = TEXT_DIRECTION.DEFAULT;\n            }\n            c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);\n        }\n    }\n    /**\n     * Renders the text using the given DOM nodes.\n     */\n    redraw() {\n        if (this.visible &&\n            this.checkBounds() &&\n            this.cacheEnabled &&\n            this.lastValue === this.value &&\n            (isNode(this.value) || this.dialect === DIALECT.STRICTHTML)) {\n            if (this.node.nodeName === 'DIV') {\n                this.redrawHtmlShape();\n                this.updateBoundingBox();\n            }\n            else {\n                const canvas = this.createCanvas();\n                if (canvas) {\n                    // Specifies if events should be handled\n                    canvas.pointerEvents = this.pointerEvents;\n                    this.paint(canvas, true);\n                    this.destroyCanvas(canvas);\n                    this.updateBoundingBox();\n                }\n            }\n        }\n        else {\n            super.redraw();\n            if (isNode(this.value) || this.dialect === DIALECT.STRICTHTML) {\n                this.lastValue = this.value;\n            }\n            else {\n                this.lastValue = null;\n            }\n        }\n    }\n    /**\n     * Resets all styles.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.color = 'black';\n        this.align = ALIGN.CENTER;\n        this.valign = ALIGN.MIDDLE;\n        this.family = DEFAULT_FONTFAMILY;\n        this.size = DEFAULT_FONTSIZE;\n        this.fontStyle = DEFAULT_FONTSTYLE;\n        this.spacing = 2;\n        this.spacingTop = 2;\n        this.spacingRight = 2;\n        this.spacingBottom = 2;\n        this.spacingLeft = 2;\n        this.horizontal = true;\n        this.background = NONE;\n        this.border = NONE;\n        this.textDirection = DEFAULT_TEXT_DIRECTION;\n        this.margin = null;\n    }\n    /**\n     * Extends mxShape to update the text styles.\n     *\n     * @param state <CellState> of the corresponding cell.\n     */\n    apply(state) {\n        const old = this.spacing;\n        super.apply(state);\n        if (this.style) {\n            this.fontStyle = this.style.fontStyle ?? this.fontStyle;\n            this.family = this.style.fontFamily ?? this.family;\n            this.size = this.style.fontSize ?? this.size;\n            this.color = this.style.fontColor ?? this.color;\n            this.align = this.style.align ?? this.align;\n            this.valign = this.style.verticalAlign ?? this.valign;\n            this.spacing = this.style.spacing ?? this.spacing;\n            this.spacingTop = (this.style.spacingTop ?? this.spacingTop - old) + this.spacing;\n            this.spacingRight =\n                (this.style.spacingRight ?? this.spacingRight - old) + this.spacing;\n            this.spacingBottom =\n                (this.style.spacingBottom ?? this.spacingBottom - old) + this.spacing;\n            this.spacingLeft =\n                (this.style.spacingLeft ?? this.spacingLeft - old) + this.spacing;\n            this.horizontal = this.style.horizontal ?? this.horizontal;\n            this.background = this.style.labelBackgroundColor ?? this.background;\n            this.border = this.style.labelBorderColor ?? this.border;\n            this.textDirection = this.style.textDirection ?? DEFAULT_TEXT_DIRECTION;\n            this.opacity = this.style.textOpacity ?? 100;\n            this.updateMargin();\n        }\n        this.flipV = false;\n        this.flipH = false;\n    }\n    /**\n     * Used to determine the automatic text direction. Returns\n     * {@link Constants#TEXT_DIRECTION_LTR} or {@link Constants#TEXT_DIRECTION_RTL}\n     * depending on the contents of <value>. This is not invoked for HTML, wrapped\n     * content or if <value> is a DOM node.\n     */\n    getAutoDirection() {\n        // Looks for strong (directional) characters\n        const tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(String(this.value));\n        // Returns the direction defined by the character\n        return tmp && tmp.length > 0 && tmp[0] > 'z'\n            ? TEXT_DIRECTION.RTL\n            : TEXT_DIRECTION.LTR;\n    }\n    /**\n     * Returns the node that contains the rendered input.\n     */\n    getContentNode() {\n        let result = this.node;\n        if (result) {\n            // Rendered with no foreignObject\n            if (!result.ownerSVGElement) {\n                // @ts-ignore\n                result = this.node.firstChild.firstChild;\n            }\n            else {\n                // Innermost DIV that contains the actual content\n                // @ts-ignore\n                result = result.firstChild.firstChild.firstChild.firstChild.firstChild;\n            }\n        }\n        return result;\n    }\n    /**\n     * Updates the <boundingBox> for this shape using the given node and position.\n     */\n    updateBoundingBox() {\n        let { node } = this;\n        this.boundingBox = this.bounds.clone();\n        const rot = this.getTextRotation();\n        const h = this.style?.labelPosition ?? ALIGN.CENTER;\n        const v = this.style?.verticalLabelPosition ?? ALIGN.MIDDLE;\n        if (!this.ignoreStringSize &&\n            node &&\n            this.overflow !== 'fill' &&\n            (!this.clipped ||\n                !this.ignoreClippedStringSize ||\n                h !== ALIGN.CENTER ||\n                v !== ALIGN.MIDDLE)) {\n            let ow = null;\n            let oh = null;\n            if (node.firstChild &&\n                node.firstChild.firstChild &&\n                node.firstChild.firstChild.nodeName === 'foreignObject') {\n                // Uses second inner DIV for font metrics\n                // @ts-ignore\n                node = node.firstChild.firstChild.firstChild.firstChild;\n                // @ts-ignore\n                oh = node.offsetHeight * this.scale;\n                if (this.overflow === 'width') {\n                    ow = this.boundingBox.width;\n                }\n                else {\n                    // @ts-ignore\n                    ow = node.offsetWidth * this.scale;\n                }\n            }\n            else {\n                try {\n                    const b = node.getBBox();\n                    // Workaround for bounding box of empty string\n                    if (typeof this.value === 'string' && trim(this.value)?.length === 0) {\n                        this.boundingBox = null;\n                    }\n                    else if (b.width === 0 && b.height === 0) {\n                        this.boundingBox = null;\n                    }\n                    else {\n                        this.boundingBox = new Rectangle(b.x, b.y, b.width, b.height);\n                    }\n                    return;\n                }\n                catch (e) {\n                    // Ignores NS_ERROR_FAILURE in FF if container display is none.\n                }\n            }\n            if (ow && oh) {\n                this.boundingBox = new Rectangle(this.bounds.x, this.bounds.y, ow, oh);\n            }\n        }\n        if (this.boundingBox) {\n            const margin = this.margin;\n            if (rot !== 0) {\n                // Accounts for pre-rotated x and y\n                const bbox = (getBoundingBox(new Rectangle(margin.x * this.boundingBox.width, margin.y * this.boundingBox.height, this.boundingBox.width, this.boundingBox.height), rot, new Point(0, 0)));\n                this.unrotatedBoundingBox = Rectangle.fromRectangle(this.boundingBox);\n                this.unrotatedBoundingBox.x += margin.x * this.unrotatedBoundingBox.width;\n                this.unrotatedBoundingBox.y += margin.y * this.unrotatedBoundingBox.height;\n                this.boundingBox.x += bbox.x;\n                this.boundingBox.y += bbox.y;\n                this.boundingBox.width = bbox.width;\n                this.boundingBox.height = bbox.height;\n            }\n            else {\n                this.boundingBox.x += margin.x * this.boundingBox.width;\n                this.boundingBox.y += margin.y * this.boundingBox.height;\n                this.unrotatedBoundingBox = null;\n            }\n        }\n    }\n    /**\n     * Returns 0 to avoid using rotation in the canvas via updateTransform.\n     */\n    getShapeRotation() {\n        return 0;\n    }\n    /**\n     * Returns the rotation for the text label of the corresponding shape.\n     */\n    getTextRotation() {\n        return this.state && this.state.shape ? this.state.shape.getTextRotation() : 0;\n    }\n    /**\n     * Inverts the bounds if {@link Shape#isBoundsInverted} returns true or if the\n     * horizontal style is false.\n     */\n    isPaintBoundsInverted() {\n        return !this.horizontal && !!this.state && this.state.cell.isVertex();\n    }\n    /**\n     * Sets the state of the canvas for drawing the shape.\n     */\n    configureCanvas(c, x, y, w, h) {\n        super.configureCanvas(c, x, y, w, h);\n        c.setFontColor(this.color);\n        c.setFontBackgroundColor(this.background);\n        c.setFontBorderColor(this.border);\n        c.setFontFamily(this.family);\n        c.setFontSize(this.size);\n        c.setFontStyle(this.fontStyle);\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getHtmlValue() {\n        let val = this.value;\n        if (this.dialect !== DIALECT.STRICTHTML) {\n            // @ts-ignore\n            val = htmlEntities(val, false);\n        }\n        // Handles trailing newlines to make sure they are visible in rendering output\n        val = replaceTrailingNewlines(val, '<div><br></div>');\n        val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n        return val;\n    }\n    /**\n     * Private helper function to create SVG elements\n     */\n    getTextCss() {\n        const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n        let css = `display: inline-block; font-size: ${this.size}px; ` +\n            `font-family: ${this.family}; color: ${this.color}; line-height: ${lh}; pointer-events: ${this.pointerEvents ? 'all' : 'none'}; `;\n        matchBinaryMask(this.fontStyle, FONT.BOLD) && (css += 'font-weight: bold; ');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC) && (css += 'font-style: italic; ');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (css += `text-decoration: ${txtDecor.join(' ')}; `);\n        return css;\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    redrawHtmlShape() {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const flex = `position: absolute; left: ${Math.round(this.bounds.x)}px; ` +\n            `top: ${Math.round(this.bounds.y)}px; pointer-events: none; `;\n        const block = this.getTextCss();\n        const margin = this.margin;\n        const node = this.node;\n        SvgCanvas2D.createCss(w + 2, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.background !== NONE ? htmlEntities(this.background, true) : null, this.border !== NONE ? htmlEntities(this.border, true) : null, flex, block, this.scale, (dx, dy, flex, item, block, ofl) => {\n            const r = this.getTextRotation();\n            let tr = (this.scale !== 1 ? `scale(${this.scale}) ` : '') +\n                (r !== 0 ? `rotate(${r}deg) ` : '') +\n                (margin.x !== 0 || margin.y !== 0\n                    ? `translate(${margin.x * 100}%,${margin.y * 100}%)`\n                    : '');\n            if (tr !== '') {\n                tr = `transform-origin: 0 0; transform: ${tr}; `;\n            }\n            if (ofl === '') {\n                flex += item;\n                item = `display:inline-block; min-width: 100%; ${tr}`;\n            }\n            else {\n                item += tr;\n                if (Client.IS_SF) {\n                    item += '-webkit-clip-path: content-box;';\n                }\n            }\n            if (this.opacity < 100) {\n                block += `opacity: ${this.opacity / 100}; `;\n            }\n            node.setAttribute('style', flex);\n            const html = isNode(this.value)\n                ? // @ts-ignore\n                    this.value.outerHTML\n                : this.getHtmlValue();\n            if (!node.firstChild) {\n                node.innerHTML = `<div><div>${html}</div></div>`;\n            }\n            // @ts-ignore\n            node.firstChild.firstChild.setAttribute('style', block);\n            // @ts-ignore\n            node.firstChild.setAttribute('style', item);\n        });\n    }\n    /**\n     * Sets the inner HTML of the given element to the <value>.\n     */\n    updateInnerHtml(elt) {\n        if (isNode(this.value)) {\n            // @ts-ignore\n            elt.innerHTML = this.value.outerHTML;\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                // LATER: Can be cached in updateValue\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            val = `<div style=\"display:inline-block;_display:inline;\">${val}</div>`;\n            elt.innerHTML = val;\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateValue() {\n        const node = this.node;\n        if (isNode(this.value)) {\n            node.innerHTML = '';\n            node.appendChild(this.value);\n        }\n        else {\n            let val = this.value;\n            if (this.dialect !== DIALECT.STRICTHTML) {\n                val = htmlEntities(val, false);\n            }\n            // Handles trailing newlines to make sure they are visible in rendering output\n            val = replaceTrailingNewlines(val, '<div><br></div>');\n            val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n            const bg = this.background !== NONE ? this.background : null;\n            const bd = this.border !== NONE ? this.border : null;\n            if (this.overflow === 'fill' || this.overflow === 'width') {\n                if (bg) {\n                    node.style.backgroundColor = bg;\n                }\n                if (bd) {\n                    node.style.border = `1px solid ${bd}`;\n                }\n            }\n            else {\n                let css = '';\n                if (bg) {\n                    css += `background-color:${htmlEntities(bg, true)};`;\n                }\n                if (bd) {\n                    css += `border:1px solid ${htmlEntities(bd, true)};`;\n                }\n                // Wrapper DIV for background, zoom needed for inline in quirks\n                // and to measure wrapped font sizes in all browsers\n                // FIXME: Background size in quirks mode for wrapped text\n                const lh = ABSOLUTE_LINE_HEIGHT ? `${this.size * LINE_HEIGHT}px` : LINE_HEIGHT;\n                val =\n                    `<div style=\"zoom:1;${css}display:inline-block;_display:inline;text-decoration:inherit;` +\n                        `padding-bottom:1px;padding-right:1px;line-height:${lh}\">${val}</div>`;\n            }\n            node.innerHTML = val;\n            // Sets text direction\n            const divs = node.getElementsByTagName('div');\n            if (divs.length > 0) {\n                let dir = this.textDirection;\n                if (dir === TEXT_DIRECTION.AUTO && this.dialect !== DIALECT.STRICTHTML) {\n                    dir = this.getAutoDirection();\n                }\n                if (dir === TEXT_DIRECTION.LTR || dir === TEXT_DIRECTION.RTL) {\n                    divs[divs.length - 1].setAttribute('dir', dir);\n                }\n                else {\n                    divs[divs.length - 1].removeAttribute('dir');\n                }\n            }\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateFont(node) {\n        const { style } = node;\n        // @ts-ignore\n        style.lineHeight = ABSOLUTE_LINE_HEIGHT\n            ? `${this.size * LINE_HEIGHT}px`\n            : LINE_HEIGHT;\n        style.fontSize = `${this.size}px`;\n        style.fontFamily = this.family;\n        style.verticalAlign = 'top';\n        style.color = this.color;\n        matchBinaryMask(this.fontStyle, FONT.BOLD)\n            ? (style.fontWeight = 'bold')\n            : (style.fontWeight = '');\n        matchBinaryMask(this.fontStyle, FONT.ITALIC)\n            ? (style.fontStyle = 'italic')\n            : (style.fontStyle = '');\n        const txtDecor = [];\n        matchBinaryMask(this.fontStyle, FONT.UNDERLINE) && txtDecor.push('underline');\n        matchBinaryMask(this.fontStyle, FONT.STRIKETHROUGH) && txtDecor.push('line-through');\n        txtDecor.length > 0 && (style.textDecoration = txtDecor.join(' '));\n        if (this.align === ALIGN.CENTER) {\n            style.textAlign = 'center';\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            style.textAlign = 'right';\n        }\n        else {\n            style.textAlign = 'left';\n        }\n    }\n    /**\n     * Updates the HTML node(s) to reflect the latest bounds and scale.\n     */\n    updateSize(node, enableWrap = false) {\n        const w = Math.max(0, Math.round(this.bounds.width / this.scale));\n        const h = Math.max(0, Math.round(this.bounds.height / this.scale));\n        const { style } = node;\n        // NOTE: Do not use maxWidth here because wrapping will\n        // go wrong if the cell is outside of the viewable area\n        if (this.clipped) {\n            style.overflow = 'hidden';\n            style.maxHeight = `${h}px`;\n            style.maxWidth = `${w}px`;\n        }\n        else if (this.overflow === 'fill') {\n            style.width = `${w + 1}px`;\n            style.height = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        else if (this.overflow === 'width') {\n            style.width = `${w + 1}px`;\n            style.maxHeight = `${h + 1}px`;\n            style.overflow = 'hidden';\n        }\n        if (this.wrap && w > 0) {\n            style.wordWrap = WORD_WRAP;\n            style.whiteSpace = 'normal';\n            style.width = `${w}px`;\n            if (enableWrap && this.overflow !== 'fill' && this.overflow !== 'width') {\n                let sizeDiv = node;\n                if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName === 'DIV') {\n                    // @ts-ignore\n                    sizeDiv = sizeDiv.firstChild;\n                    if (node.style.wordWrap === 'break-word') {\n                        sizeDiv.style.width = '100%';\n                    }\n                }\n                let tmp = sizeDiv.offsetWidth;\n                // Workaround for text measuring in hidden containers\n                if (tmp === 0) {\n                    const prev = node.parentNode;\n                    node.style.visibility = 'hidden';\n                    document.body.appendChild(node);\n                    tmp = sizeDiv.offsetWidth;\n                    node.style.visibility = '';\n                    prev.appendChild(node);\n                }\n                tmp += 3;\n                if (this.clipped) {\n                    tmp = Math.min(tmp, w);\n                }\n                style.width = `${tmp}px`;\n            }\n        }\n        else {\n            style.whiteSpace = 'nowrap';\n        }\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    updateMargin() {\n        this.margin = getAlignmentAsPoint(this.align, this.valign);\n    }\n    /**\n     * Returns the spacing as an {@link Point}.\n     */\n    getSpacing() {\n        let dx = 0;\n        let dy = 0;\n        if (this.align === ALIGN.CENTER) {\n            dx = (this.spacingLeft - this.spacingRight) / 2;\n        }\n        else if (this.align === ALIGN.RIGHT) {\n            dx = -this.spacingRight - this.baseSpacingRight;\n        }\n        else {\n            dx = this.spacingLeft + this.baseSpacingLeft;\n        }\n        if (this.valign === ALIGN.MIDDLE) {\n            dy = (this.spacingTop - this.spacingBottom) / 2;\n        }\n        else if (this.valign === ALIGN.BOTTOM) {\n            dy = -this.spacingBottom - this.baseSpacingBottom;\n        }\n        else {\n            dy = this.spacingTop + this.baseSpacingTop;\n        }\n        return new Point(dx, dy);\n    }\n}\nexport default TextShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * A singleton class that provides a registry for stencils and the methods\n * for painting those stencils onto a canvas or into a DOM.\n *\n * Code to add stencils:\n * ```javascript\n * let req = mxUtils.load('test/stencils.xml');\n * let root = req.getDocumentElement();\n * let shape = root.firstChild;\n *\n * while (shape != null)\n * {\n *   if (shape.nodeType === mxConstants.NODETYPE_ELEMENT)\n *  {\n *    mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\n *  }\n *\n *  shape = shape.nextSibling;\n * }\n * ```\n * @class StencilShapeRegistry\n */\nclass StencilShapeRegistry {\n    /**\n     * Adds the given {@link Stencil}.\n     * @static\n     * @param {string} name\n     * @param {StencilShape} stencil\n     */\n    static addStencil(name, stencil) {\n        StencilShapeRegistry.stencils[name] = stencil;\n    }\n    /**\n     * Returns the {@link Stencil} for the given name.\n     * @static\n     * @param {string} name\n     * @returns {StencilShape}\n     */\n    static getStencil(name) {\n        return StencilShapeRegistry.stencils[name];\n    }\n}\nStencilShapeRegistry.stencils = {};\nexport default StencilShapeRegistry;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2017, JGraph Ltd\nCopyright (c) 2006-2017, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectorShape from '../geometry/edge/ConnectorShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport TextShape from '../geometry/node/TextShape';\nimport { ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_FONTSTYLE, DEFAULT_TEXT_DIRECTION, DIALECT, NONE, } from '../../util/Constants';\nimport { getRotatedPoint, mod, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport { equalEntries, equalPoints } from '../../util/arrayUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport StencilShapeRegistry from '../geometry/node/StencilShapeRegistry';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport Point from '../geometry/Point';\nimport Shape from '../geometry/Shape';\nimport { getClientX, getClientY, getSource } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\nconst placeholderStyleValues = ['inherit', 'swimlane', 'indicated'];\nconst placeholderStyleProperties = [\n    'fillColor',\n    'strokeColor',\n    'gradientColor',\n    'fontColor',\n];\n/**\n * Renders cells into a document object model. The <defaultShapes> is a global\n * map of shape names, constructor pairs that is used in all instances. You can\n * get a list of all available shape names using the following code.\n *\n * In general the cell renderer is in charge of creating, redrawing and\n * destroying the shape and label associated with a cell state, as well as\n * some other graphical objects, namely controls and overlays. The shape\n * hierarchy in the display (i.e. the hierarchy in which the DOM nodes\n * appear in the document) does not reflect the cell hierarchy. The shapes\n * are a (flat) sequence of shapes and labels inside the draw pane of the\n * graph view, with some exceptions, namely the HTML labels being placed\n * directly inside the graph container for certain browsers.\n *\n * ```javascript\n * GlobalConfig.logger.show();\n * for (var i in mxCellRenderer.defaultShapes)\n * {\n *   GlobalConfig.logger.debug(i);\n * }\n * ```\n */\nclass CellRenderer {\n    constructor() {\n        /**\n         * Defines the default shape for edges.\n         * @default {@link ConnectorShape}\n         */\n        // @ts-expect-error The constructors for Shape and Connector are different.\n        this.defaultEdgeShape = ConnectorShape;\n        /**\n         * Defines the default shape for vertices.\n         * @default {@link RectangleShape}.\n         */\n        this.defaultVertexShape = RectangleShape;\n        /**\n         * Defines the default shape for labels.\n         * @default {@link TextShape}.\n         */\n        this.defaultTextShape = TextShape;\n        /**\n         * Specifies if the folding icon should ignore the horizontal\n         * orientation of a swimlane.\n         * @default true.\n         */\n        this.legacyControlPosition = true;\n        /**\n         * Specifies if spacing and label position should be ignored if overflow is\n         * fill or width.\n         * @default true for backwards compatibility.\n         */\n        this.legacySpacing = true;\n        /**\n         * Antialiasing option for new shapes.\n         * @default true.\n         */\n        this.antiAlias = true;\n        /**\n         * Minimum stroke width for SVG output.\n         */\n        this.minSvgStrokeWidth = 1;\n        /**\n         * Specifies if the enabled state of the graph should be ignored in the control\n         * click handler (to allow folding in disabled graphs).\n         * @default false.\n         */\n        this.forceControlClickHandler = false;\n    }\n    /**\n     * Registers the given constructor under the specified key in this instance of the renderer.\n     * @example\n     * ```\n     * CellRenderer.registerShape(Constants.SHAPE_RECTANGLE, RectangleShape);\n     * ```\n     *\n     * @param key the shape name.\n     * @param shape constructor of the {@link Shape} subclass.\n     */\n    static registerShape(key, shape) {\n        CellRenderer.defaultShapes[key] = shape;\n    }\n    /**\n     * Initializes the shape in the given state by calling its init method with\n     * the correct container after configuring it using {@link configureShape}.\n     *\n     * @param state <CellState> for which the shape should be initialized.\n     */\n    initializeShape(state) {\n        if (state.shape) {\n            state.shape.dialect = state.view.graph.dialect;\n            this.configureShape(state);\n            state.shape.init(state.view.getDrawPane());\n        }\n    }\n    /**\n     * Creates and returns the shape for the given cell state.\n     *\n     * @param state {@link CellState} for which the shape should be created.\n     */\n    createShape(state) {\n        let shape = null;\n        // Checks if there is a stencil for the name and creates\n        // a shape instance for the stencil if one exists\n        const stencil = StencilShapeRegistry.getStencil(state.style.shape);\n        if (stencil) {\n            shape = new Shape(stencil);\n        }\n        else {\n            const ctor = this.getShapeConstructor(state);\n            shape = new ctor();\n        }\n        return shape;\n    }\n    /**\n     * Creates the indicator shape for the given cell state.\n     *\n     * @param state {@link CellState} for which the indicator shape should be created.\n     */\n    createIndicatorShape(state) {\n        if (state.shape) {\n            state.shape.indicatorShape = this.getShape(state.getIndicatorShape() || null);\n        }\n    }\n    /**\n     * Returns the shape for the given name from {@link defaultShapes}.\n     */\n    getShape(name) {\n        return name ? CellRenderer.defaultShapes[name] : null;\n    }\n    /**\n     * Returns the constructor to be used for creating the shape.\n     */\n    getShapeConstructor(state) {\n        let ctor = this.getShape(state.style.shape || null);\n        if (!ctor) {\n            // @ts-expect-error The various Shape constructors are not compatible.\n            ctor = state.cell.isEdge() ? this.defaultEdgeShape : this.defaultVertexShape;\n        }\n        return ctor;\n    }\n    /**\n     * Configures the shape for the given cell state.\n     *\n     * @param state <CellState> for which the shape should be configured.\n     */\n    configureShape(state) {\n        const shape = state.shape;\n        if (shape) {\n            shape.apply(state);\n            shape.imageSrc = state.getImageSrc() || null;\n            shape.indicatorColor = state.getIndicatorColor() || NONE;\n            shape.indicatorStrokeColor = state.style.indicatorStrokeColor || NONE;\n            shape.indicatorGradientColor = state.getIndicatorGradientColor() || NONE;\n            if (state.style.indicatorDirection) {\n                shape.indicatorDirection = state.style.indicatorDirection;\n            }\n            shape.indicatorImageSrc = state.getIndicatorImageSrc() || null;\n            this.postConfigureShape(state);\n        }\n    }\n    /**\n     * Replaces any reserved words used for attributes, eg. inherit,\n     * indicated or swimlane for colors in the shape for the given state.\n     * This implementation resolves these keywords on the fill, stroke\n     * and gradient color keys.\n     */\n    postConfigureShape(state) {\n        if (state.shape) {\n            this.resolveColor(state, 'indicatorGradientColor', 'gradientColor');\n            this.resolveColor(state, 'indicatorColor', 'fillColor');\n            this.resolveColor(state, 'gradient', 'gradientColor');\n            this.resolveColor(state, 'stroke', 'strokeColor');\n            this.resolveColor(state, 'fill', 'fillColor');\n        }\n    }\n    /**\n     * Check if style properties supporting placeholders requires resolution.\n     */\n    checkPlaceholderStyles(state) {\n        // LATER: Check if the color has actually changed\n        for (const property of placeholderStyleProperties) {\n            if (placeholderStyleValues.includes(state.style[property])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n     * the respective color on the shape.\n     */\n    resolveColor(state, field, key) {\n        const shape = key === 'fontColor' ? state.text : state.shape;\n        if (shape) {\n            const graph = state.view.graph;\n            // @ts-ignore\n            const value = shape[field];\n            let referenced = null;\n            if (value === 'inherit') {\n                referenced = state.cell.getParent();\n            }\n            else if (value === 'swimlane') {\n                // @ts-ignore\n                shape[field] =\n                    key === 'strokeColor' || key === 'fontColor' ? '#000000' : '#ffffff';\n                if (state.cell.getTerminal(false)) {\n                    referenced = state.cell.getTerminal(false);\n                }\n                else {\n                    referenced = state.cell;\n                }\n                referenced = graph.getSwimlane(referenced);\n                key = graph.swimlaneIndicatorColorAttribute;\n            }\n            else if (value === 'indicated' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.shape.indicatorColor;\n            }\n            else if (key !== 'fillColor' && value === 'fillColor' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.style.fillColor;\n            }\n            else if (key !== 'strokeColor' && value === 'strokeColor' && state.shape) {\n                // @ts-ignore\n                shape[field] = state.style.strokeColor;\n            }\n            if (referenced) {\n                const rstate = graph.getView().getState(referenced);\n                // @ts-ignore\n                shape[field] = null;\n                if (rstate) {\n                    const rshape = key === 'fontColor' ? rstate.text : rstate.shape;\n                    if (rshape && field !== 'indicatorColor') {\n                        // @ts-ignore\n                        shape[field] = rshape[field];\n                    }\n                    else {\n                        // @ts-ignore\n                        shape[field] = rstate.style[key];\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns the value to be used for the label.\n     *\n     * @param state <CellState> for which the label should be created.\n     */\n    getLabelValue(state) {\n        const graph = state.view.graph;\n        return graph.getLabel(state.cell);\n    }\n    /**\n     * Creates the label for the given cell state.\n     *\n     * @param state <CellState> for which the label should be created.\n     */\n    createLabel(state, value) {\n        const graph = state.view.graph;\n        if ((state.style.fontSize || 0) > 0 || state.style.fontSize == null) {\n            // Avoids using DOM node for empty labels\n            const isForceHtml = graph.isHtmlLabel(state.cell) || isNode(value);\n            state.text = new this.defaultTextShape(value, new Rectangle(), state.style.align ?? ALIGN.CENTER, state.getVerticalAlign(), state.style.fontColor, state.style.fontFamily, state.style.fontSize, state.style.fontStyle, state.style.spacing, state.style.spacingTop, state.style.spacingRight, state.style.spacingBottom, state.style.spacingLeft, state.style.horizontal, state.style.labelBackgroundColor, state.style.labelBorderColor, graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style.overflow, state.style.labelPadding, state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n            state.text.opacity = state.style.textOpacity ?? 100;\n            state.text.dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n            state.text.style = state.style;\n            state.text.state = state;\n            this.initializeLabel(state, state.text);\n            // Workaround for touch devices routing all events for a mouse gesture\n            // (down, move, up) via the initial DOM node. IE additionally redirects\n            // the event via the initial DOM node but the event source is the node\n            // under the mouse, so we need to check if this is the case and force\n            // getCellAt for the subsequent mouseMoves and the final mouseUp.\n            let forceGetCell = false;\n            const getState = (evt) => {\n                let result = state;\n                if (Client.IS_TOUCH || forceGetCell) {\n                    const x = getClientX(evt);\n                    const y = getClientY(evt);\n                    // Dispatches the drop event to the graph which\n                    // consumes and executes the source function\n                    const pt = convertPoint(graph.container, x, y);\n                    result = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n                }\n                return result;\n            };\n            // TODO: Add handling for special touch device gestures\n            InternalEvent.addGestureListeners(state.text.node, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                    const source = getSource(evt);\n                    forceGetCell =\n                        // @ts-ignore nodeName should exist.\n                        graph.dialect !== DIALECT.SVG && source.nodeName === 'IMG';\n                }\n            }, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n                }\n            }, (evt) => {\n                if (this.isLabelEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n                    forceGetCell = false;\n                }\n            });\n            // Uses double click timeout in mxGraph for quirks mode\n            if (graph.isNativeDblClickEnabled()) {\n                InternalEvent.addListener(state.text.node, 'dblclick', (evt) => {\n                    if (this.isLabelEvent(state, evt)) {\n                        graph.dblClick(evt, state.cell);\n                        InternalEvent.consume(evt);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Initiailzes the label with a suitable container.\n     *\n     * @param state <CellState> whose label should be initialized.\n     */\n    initializeLabel(state, shape) {\n        if (Client.IS_SVG && Client.NO_FO && shape.dialect !== DIALECT.SVG) {\n            const graph = state.view.graph;\n            shape.init(graph.container);\n        }\n        else {\n            shape.init(state.view.getDrawPane());\n        }\n    }\n    /**\n     * Creates the actual shape for showing the overlay for the given cell state.\n     *\n     * @param state <CellState> for which the overlay should be created.\n     */\n    createCellOverlays(state) {\n        const graph = state.view.graph;\n        const overlays = graph.getCellOverlays(state.cell);\n        const dict = new Dictionary();\n        for (let i = 0; i < overlays.length; i += 1) {\n            const shape = state.overlays.remove(overlays[i]);\n            if (!shape) {\n                const tmp = new ImageShape(new Rectangle(), overlays[i].image.src);\n                tmp.dialect = graph.dialect;\n                tmp.preserveImageAspect = false;\n                tmp.overlay = overlays[i];\n                this.initializeOverlay(state, tmp);\n                this.installCellOverlayListeners(state, overlays[i], tmp);\n                if (overlays[i].cursor) {\n                    tmp.node.style.cursor = overlays[i].cursor;\n                }\n                dict.put(overlays[i], tmp);\n            }\n            else {\n                dict.put(overlays[i], shape);\n            }\n        }\n        // Removes unused\n        state.overlays.visit((id, shape) => {\n            shape.destroy();\n        });\n        state.overlays = dict;\n    }\n    /**\n     * Initializes the given overlay.\n     *\n     * @param state <CellState> for which the overlay should be created.\n     * @param overlay {@link ImageShape} that represents the overlay.\n     */\n    initializeOverlay(state, overlay) {\n        overlay.init(state.view.getOverlayPane());\n    }\n    /**\n     * Installs the listeners for the given <CellState>, <CellOverlay> and\n     * {@link Shape} that represents the overlay.\n     */\n    installCellOverlayListeners(state, overlay, shape) {\n        const graph = state.view.graph;\n        InternalEvent.addListener(shape.node, 'click', (evt) => {\n            if (graph.isEditing()) {\n                graph.stopEditing(!graph.isInvokesStopCellEditing());\n            }\n            overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));\n        });\n        InternalEvent.addGestureListeners(shape.node, (evt) => {\n            InternalEvent.consume(evt);\n        }, (evt) => {\n            graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n        });\n        if (Client.IS_TOUCH) {\n            InternalEvent.addListener(shape.node, 'touchend', (evt) => {\n                overlay.fireEvent(new EventObject(InternalEvent.CLICK, { event: evt, cell: state.cell }));\n            });\n        }\n    }\n    /**\n     * Creates the control for the given cell state.\n     *\n     * @param state <CellState> for which the control should be created.\n     */\n    createControl(state) {\n        const graph = state.view.graph;\n        const image = graph.getFoldingImage(state);\n        if (graph.isFoldingEnabled() && image) {\n            if (!state.control) {\n                const b = new Rectangle(0, 0, image.width, image.height);\n                state.control = new ImageShape(b, image.src);\n                state.control.preserveImageAspect = false;\n                state.control.dialect = graph.dialect;\n                this.initControl(state, state.control, true, this.createControlClickHandler(state));\n            }\n        }\n        else if (state.control) {\n            state.control.destroy();\n            state.control = null;\n        }\n    }\n    /**\n     * Hook for creating the click handler for the folding icon.\n     *\n     * @param state <CellState> whose control click handler should be returned.\n     */\n    createControlClickHandler(state) {\n        const graph = state.view.graph;\n        return (evt) => {\n            if (this.forceControlClickHandler || graph.isEnabled()) {\n                const collapse = !state.cell.isCollapsed();\n                graph.foldCells(collapse, false, [state.cell], false, evt);\n                InternalEvent.consume(evt);\n            }\n        };\n    }\n    /**\n     * Initializes the given control and returns the corresponding DOM node.\n     *\n     * @param state <CellState> for which the control should be initialized.\n     * @param control {@link Shape} to be initialized.\n     * @param handleEvents Boolean indicating if mousedown and mousemove should fire events via the graph.\n     * @param clickHandler Optional function to implement clicks on the control.\n     */\n    initControl(state, control, handleEvents, clickHandler) {\n        const graph = state.view.graph;\n        // In the special case where the label is in HTML and the display is SVG the image\n        // should go into the graph container directly in order to be clickable. Otherwise\n        // it is obscured by the HTML label that overlaps the cell.\n        const isForceHtml = graph.isHtmlLabel(state.cell) && Client.NO_FO && graph.dialect === DIALECT.SVG;\n        if (isForceHtml) {\n            control.dialect = DIALECT.PREFERHTML;\n            control.init(graph.container);\n            control.node.style.zIndex = String(1);\n        }\n        else {\n            control.init(state.view.getOverlayPane());\n        }\n        const node = control.node;\n        // Workaround for missing click event on iOS is to check tolerance below\n        if (clickHandler && !Client.IS_IOS) {\n            if (graph.isEnabled()) {\n                node.style.cursor = 'pointer';\n            }\n            InternalEvent.addListener(node, 'click', clickHandler);\n        }\n        if (handleEvents) {\n            let first = null;\n            InternalEvent.addGestureListeners(node, (evt) => {\n                first = new Point(getClientX(evt), getClientY(evt));\n                graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                InternalEvent.consume(evt);\n            }, (evt) => {\n                graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, state));\n            }, (evt) => {\n                graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, state));\n                InternalEvent.consume(evt);\n            });\n            // Uses capture phase for event interception to stop bubble phase\n            if (clickHandler && Client.IS_IOS) {\n                node.addEventListener('touchend', (evt) => {\n                    if (first) {\n                        const tol = graph.getEventTolerance();\n                        if (Math.abs(first.x - getClientX(evt)) < tol &&\n                            Math.abs(first.y - getClientY(evt)) < tol) {\n                            clickHandler.call(clickHandler, evt);\n                            InternalEvent.consume(evt);\n                        }\n                    }\n                }, true);\n            }\n        }\n        return node;\n    }\n    /**\n     * Returns true if the event is for the shape of the given state. This\n     * implementation always returns true.\n     *\n     * @param state <CellState> whose shape fired the event.\n     * @param evt Mouse event which was fired.\n     */\n    isShapeEvent(state, evt) {\n        return true;\n    }\n    /**\n     * Returns true if the event is for the label of the given state. This\n     * implementation always returns true.\n     *\n     * @param state <CellState> whose label fired the event.\n     * @param evt Mouse event which was fired.\n     */\n    isLabelEvent(state, evt) {\n        return true;\n    }\n    /**\n     * Installs the event listeners for the given cell state.\n     *\n     * @param state <CellState> for which the event listeners should be isntalled.\n     */\n    installListeners(state) {\n        const graph = state.view.graph;\n        // Workaround for touch devices routing all events for a mouse\n        // gesture (down, move, up) via the initial DOM node. Same for\n        // HTML images in all IE versions (VML images are working).\n        const getState = (evt) => {\n            let result = state;\n            const source = getSource(evt);\n            if ((source &&\n                graph.dialect !== DIALECT.SVG &&\n                // @ts-ignore nodeName should exist\n                source.nodeName === 'IMG') ||\n                Client.IS_TOUCH) {\n                const x = getClientX(evt);\n                const y = getClientY(evt);\n                // Dispatches the drop event to the graph which\n                // consumes and executes the source function\n                const pt = convertPoint(graph.container, x, y);\n                const cell = graph.getCellAt(pt.x, pt.y);\n                result = cell ? graph.view.getState(cell) : null;\n            }\n            return result;\n        };\n        if (state.shape) {\n            InternalEvent.addGestureListeners(state.shape.node, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, state));\n                }\n            }, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, getState(evt)));\n                }\n            }, (evt) => {\n                if (this.isShapeEvent(state, evt)) {\n                    graph.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, getState(evt)));\n                }\n            });\n            // Uses double click timeout in mxGraph for quirks mode\n            if (graph.isNativeDblClickEnabled()) {\n                InternalEvent.addListener(state.shape.node, 'dblclick', (evt) => {\n                    if (this.isShapeEvent(state, evt)) {\n                        graph.dblClick(evt, state.cell);\n                        InternalEvent.consume(evt);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * Redraws the label for the given cell state.\n     *\n     * @param state <CellState> whose label should be redrawn.\n     */\n    redrawLabel(state, forced) {\n        const graph = state.view.graph;\n        const value = this.getLabelValue(state);\n        const wrapping = graph.isWrapping(state.cell);\n        const clipping = graph.isLabelClipped(state.cell);\n        const isForceHtml = graph.isHtmlLabel(state.cell) || (value && isNode(value));\n        const dialect = isForceHtml ? DIALECT.STRICTHTML : graph.dialect;\n        const overflow = state.style.overflow ?? 'visible';\n        if (state.text &&\n            (state.text.wrap !== wrapping ||\n                state.text.clipped !== clipping ||\n                state.text.overflow !== overflow ||\n                state.text.dialect !== dialect)) {\n            state.text.destroy();\n            state.text = null;\n        }\n        if (state.text == null && value != null && (isNode(value) || value.length > 0)) {\n            this.createLabel(state, value);\n        }\n        else if (state.text != null && (value == null || value.length == 0)) {\n            state.text.destroy();\n            state.text = null;\n        }\n        if (state.text != null) {\n            // Forced is true if the style has changed, so to get the updated\n            // result in getLabelBounds we apply the new style to the shape\n            if (forced) {\n                // Checks if a full repaint is needed\n                if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {\n                    // Forces a full repaint\n                    state.text.lastValue = null;\n                }\n                state.text.resetStyles();\n                state.text.apply(state);\n                // Special case where value is obtained via hook in graph\n                state.text.valign = state.getVerticalAlign();\n            }\n            const bounds = this.getLabelBounds(state);\n            const nextScale = this.getTextScale(state);\n            this.resolveColor(state, 'color', 'fontColor');\n            if (forced ||\n                state.text.value !== value ||\n                state.text.wrap !== wrapping ||\n                state.text.overflow !== overflow ||\n                state.text.clipped !== clipping ||\n                state.text.scale !== nextScale ||\n                state.text.dialect !== dialect ||\n                state.text.bounds == null ||\n                !state.text.bounds.equals(bounds)) {\n                state.text.dialect = dialect;\n                state.text.value = value;\n                state.text.bounds = bounds;\n                state.text.scale = nextScale;\n                state.text.wrap = wrapping;\n                state.text.clipped = clipping;\n                state.text.overflow = overflow;\n                // Preserves visible state\n                // @ts-ignore\n                const vis = state.text.node.style.visibility;\n                this.redrawLabelShape(state.text);\n                // @ts-ignore\n                state.text.node.style.visibility = vis;\n            }\n        }\n    }\n    /**\n     * Returns true if the style for the text shape has changed.\n     *\n     * @param state <CellState> whose label should be checked.\n     * @param shape {@link Text} shape to be checked.\n     */\n    isTextShapeInvalid(state, shape) {\n        function check(property, stylename, defaultValue) {\n            let result = false;\n            // Workaround for spacing added to directional spacing\n            if (stylename === 'spacingTop' ||\n                stylename === 'spacingRight' ||\n                stylename === 'spacingBottom' ||\n                stylename === 'spacingLeft') {\n                result =\n                    // @ts-ignore\n                    parseFloat(String(shape[property])) - parseFloat(String(shape.spacing)) !==\n                        (state.style[stylename] || defaultValue);\n            }\n            else {\n                // @ts-ignore\n                result = shape[property] !== (state.style[stylename] || defaultValue);\n            }\n            return result;\n        }\n        return (check('fontStyle', 'fontStyle', DEFAULT_FONTSTYLE) ||\n            check('family', 'fontFamily', DEFAULT_FONTFAMILY) ||\n            check('size', 'fontSize', DEFAULT_FONTSIZE) ||\n            check('color', 'fontColor', 'black') ||\n            check('align', 'align', '') ||\n            check('valign', 'verticalAlign', '') ||\n            check('spacing', 'spacing', 2) ||\n            check('spacingTop', 'spacingTop', 0) ||\n            check('spacingRight', 'spacingRight', 0) ||\n            check('spacingBottom', 'spacingBottom', 0) ||\n            check('spacingLeft', 'spacingLeft', 0) ||\n            check('horizontal', 'horizontal', true) ||\n            check('background', 'labelBackgroundColor', null) ||\n            check('border', 'labelBorderColor', null) ||\n            check('opacity', 'textOpacity', 100) ||\n            check('textDirection', 'textDirection', DEFAULT_TEXT_DIRECTION));\n    }\n    /**\n     * Called to invoked redraw on the given text shape.\n     *\n     * @param shape {@link Text} shape to be redrawn.\n     */\n    redrawLabelShape(shape) {\n        shape.redraw();\n    }\n    /**\n     * Returns the scaling used for the label of the given state\n     *\n     * @param state <CellState> whose label scale should be returned.\n     */\n    getTextScale(state) {\n        return state.view.scale;\n    }\n    /**\n     * Returns the bounds to be used to draw the label of the given state.\n     *\n     * @param state <CellState> whose label bounds should be returned.\n     */\n    getLabelBounds(state) {\n        const { scale } = state.view;\n        const isEdge = state.cell.isEdge();\n        let bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y);\n        if (isEdge) {\n            // @ts-ignore\n            const spacing = state.text.getSpacing();\n            bounds.x += spacing.x * scale;\n            bounds.y += spacing.y * scale;\n            const geo = state.cell.getGeometry();\n            if (geo != null) {\n                bounds.width = Math.max(0, geo.width * scale);\n                bounds.height = Math.max(0, geo.height * scale);\n            }\n        }\n        else {\n            // Inverts label position\n            // @ts-ignore\n            if (state.text.isPaintBoundsInverted()) {\n                const tmp = bounds.x;\n                bounds.x = bounds.y;\n                bounds.y = tmp;\n            }\n            bounds.x += state.x;\n            bounds.y += state.y;\n            // Minimum of 1 fixes alignment bug in HTML labels\n            bounds.width = Math.max(1, state.width);\n            bounds.height = Math.max(1, state.height);\n        }\n        // @ts-ignore\n        if (state.text.isPaintBoundsInverted()) {\n            // Rotates around center of state\n            const t = (state.width - state.height) / 2;\n            bounds.x += t;\n            bounds.y -= t;\n            const tmp = bounds.width;\n            bounds.width = bounds.height;\n            bounds.height = tmp;\n        }\n        // Shape can modify its label bounds\n        if (state.shape != null) {\n            const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n            const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n            if (hpos === ALIGN.CENTER && vpos === ALIGN.MIDDLE) {\n                bounds = state.shape.getLabelBounds(bounds);\n            }\n        }\n        // Label width style overrides actual label width\n        const lw = state.style.labelWidth ?? null;\n        if (lw != null) {\n            bounds.width = lw * scale;\n        }\n        if (!isEdge) {\n            this.rotateLabelBounds(state, bounds);\n        }\n        return bounds;\n    }\n    /**\n     * Adds the shape rotation to the given label bounds and\n     * applies the alignment and offsets.\n     *\n     * @param state <CellState> whose label bounds should be rotated.\n     * @param bounds {@link Rectangle} the rectangle to be rotated.\n     */\n    rotateLabelBounds(state, bounds) {\n        bounds.y -= state.text.margin.y * bounds.height;\n        bounds.x -= state.text.margin.x * bounds.width;\n        if (!this.legacySpacing ||\n            (state.style.overflow !== 'fill' && state.style.overflow !== 'width')) {\n            const s = state.view.scale;\n            const spacing = state.text.getSpacing();\n            bounds.x += spacing.x * s;\n            bounds.y += spacing.y * s;\n            const hpos = state.style.labelPosition ?? ALIGN.CENTER;\n            const vpos = state.style.verticalLabelPosition ?? ALIGN.MIDDLE;\n            const lw = state.style.labelWidth ?? null;\n            bounds.width = Math.max(0, bounds.width -\n                (hpos === ALIGN.CENTER && lw == null\n                    ? // @ts-ignore\n                        state.text.spacingLeft * s + state.text.spacingRight * s\n                    : 0));\n            bounds.height = Math.max(0, bounds.height -\n                (vpos === ALIGN.MIDDLE\n                    ? // @ts-ignore\n                        state.text.spacingTop * s + state.text.spacingBottom * s\n                    : 0));\n        }\n        // @ts-ignore\n        const theta = state.text.getTextRotation();\n        // Only needed if rotated around another center\n        if (theta !== 0 &&\n            state != null &&\n            // @ts-ignore\n            state.cell.isVertex()) {\n            const cx = state.getCenterX();\n            const cy = state.getCenterY();\n            if (bounds.x !== cx || bounds.y !== cy) {\n                const rad = theta * (Math.PI / 180);\n                const pt = getRotatedPoint(new Point(bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new Point(cx, cy));\n                bounds.x = pt.x;\n                bounds.y = pt.y;\n            }\n        }\n    }\n    /**\n     * Redraws the overlays for the given cell state.\n     *\n     * @param state <CellState> whose overlays should be redrawn.\n     */\n    redrawCellOverlays(state, forced = false) {\n        this.createCellOverlays(state);\n        if (state.overlays != null) {\n            const rot = mod(state.style.rotation ?? 0, 90);\n            const rad = toRadians(rot);\n            const cos = Math.cos(rad);\n            const sin = Math.sin(rad);\n            state.overlays.visit((id, shape) => {\n                // @ts-ignore\n                const bounds = shape.overlay.getBounds(state);\n                if (!state.cell.isEdge()) {\n                    if (state.shape != null && rot !== 0) {\n                        let cx = bounds.getCenterX();\n                        let cy = bounds.getCenterY();\n                        const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n                        cx = point.x;\n                        cy = point.y;\n                        bounds.x = Math.round(cx - bounds.width / 2);\n                        bounds.y = Math.round(cy - bounds.height / 2);\n                    }\n                }\n                if (forced ||\n                    shape.bounds == null ||\n                    shape.scale !== state.view.scale ||\n                    !shape.bounds.equals(bounds)) {\n                    shape.bounds = bounds;\n                    shape.scale = state.view.scale;\n                    shape.redraw();\n                }\n            });\n        }\n    }\n    /**\n     * Redraws the control for the given cell state.\n     *\n     * @param state <CellState> whose control should be redrawn.\n     */\n    redrawControl(state, forced = false) {\n        const image = state.view.graph.getFoldingImage(state);\n        if (state.control != null && image != null) {\n            const bounds = this.getControlBounds(state, image.width, image.height);\n            const r = this.legacyControlPosition\n                ? state.style.rotation ?? 0\n                : state.shape.getTextRotation();\n            const s = state.view.scale;\n            if (forced ||\n                state.control.scale !== s ||\n                !state.control.bounds.equals(bounds) ||\n                state.control.rotation !== r) {\n                state.control.rotation = r;\n                state.control.bounds = bounds;\n                state.control.scale = s;\n                state.control.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the bounds to be used to draw the control (folding icon) of the\n     * given state.\n     */\n    getControlBounds(state, w, h) {\n        if (state.control != null) {\n            const s = state.view.scale;\n            let cx = state.getCenterX();\n            let cy = state.getCenterY();\n            if (!state.cell.isEdge()) {\n                cx = state.x + w * s;\n                cy = state.y + h * s;\n                if (state.shape != null) {\n                    // TODO: Factor out common code\n                    let rot = state.shape.getShapeRotation();\n                    if (this.legacyControlPosition) {\n                        rot = state.style.rotation ?? 0;\n                    }\n                    else if (state.shape.isPaintBoundsInverted()) {\n                        const t = (state.width - state.height) / 2;\n                        cx += t;\n                        cy -= t;\n                    }\n                    if (rot !== 0) {\n                        const rad = toRadians(rot);\n                        const cos = Math.cos(rad);\n                        const sin = Math.sin(rad);\n                        const point = getRotatedPoint(new Point(cx, cy), cos, sin, new Point(state.getCenterX(), state.getCenterY()));\n                        cx = point.x;\n                        cy = point.y;\n                    }\n                }\n            }\n            return state.cell.isEdge()\n                ? new Rectangle(Math.round(cx - (w / 2) * s), Math.round(cy - (h / 2) * s), Math.round(w * s), Math.round(h * s))\n                : new Rectangle(Math.round(cx - (w / 2) * s), Math.round(cy - (h / 2) * s), Math.round(w * s), Math.round(h * s));\n        }\n        return null;\n    }\n    /**\n     * Inserts the given array of {@link Shapes} after the given nodes in the DOM.\n     *\n     * @param shapes Array of {@link Shapes} to be inserted.\n     * @param node Node in <drawPane> after which the shapes should be inserted.\n     * @param htmlNode Node in the graph container after which the shapes should be inserted that\n     * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\n     */\n    insertStateAfter(state, node, htmlNode) {\n        const graph = state.view.graph;\n        const shapes = this.getShapesForState(state);\n        for (let i = 0; i < shapes.length; i += 1) {\n            // @ts-ignore\n            if (shapes[i] != null && shapes[i].node != null) {\n                const html = \n                // @ts-ignore\n                shapes[i].node.parentNode !== state.view.getDrawPane() &&\n                    // @ts-ignore\n                    shapes[i].node.parentNode !== state.view.getOverlayPane();\n                const temp = html ? htmlNode : node;\n                // @ts-ignore\n                if (temp != null && temp.nextSibling !== shapes[i].node) {\n                    if (temp.nextSibling == null) {\n                        // @ts-ignore\n                        temp.parentNode.appendChild(shapes[i].node);\n                    }\n                    else {\n                        // @ts-ignore\n                        temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n                    }\n                }\n                else if (temp == null) {\n                    // Special case: First HTML node should be first sibling after canvas\n                    // @ts-ignore\n                    const shapeNode = shapes[i].node;\n                    if (shapeNode.parentNode === graph.container) {\n                        let { canvas } = state.view;\n                        while (canvas != null && canvas.parentNode !== graph.container) {\n                            // @ts-ignore\n                            canvas = canvas.parentNode;\n                        }\n                        if (canvas != null && canvas.nextSibling != null) {\n                            if (canvas.nextSibling !== shapeNode) {\n                                // @ts-ignore\n                                shapeNode.parentNode.insertBefore(shapeNode, canvas.nextSibling);\n                            }\n                        }\n                        else {\n                            // @ts-ignore\n                            shapeNode.parentNode.appendChild(shapeNode);\n                        }\n                    }\n                    else if (shapeNode.parentNode != null &&\n                        shapeNode.parentNode.firstChild != null &&\n                        shapeNode.parentNode.firstChild != shapeNode) {\n                        // Inserts the node as the first child of the parent to implement the order\n                        shapeNode.parentNode.insertBefore(shapeNode, shapeNode.parentNode.firstChild);\n                    }\n                }\n                if (html) {\n                    // @ts-ignore\n                    htmlNode = shapes[i].node;\n                }\n                else {\n                    // @ts-ignore\n                    node = shapes[i].node;\n                }\n            }\n        }\n        return [node, htmlNode];\n    }\n    /**\n     * Returns the {@link Shapes} for the given cell state in the order in which they should\n     * appear in the DOM.\n     *\n     * @param state <CellState> whose shapes should be returned.\n     */\n    getShapesForState(state) {\n        return [state.shape, state.text, state.control];\n    }\n    /**\n     * Updates the bounds or points and scale of the shapes for the given cell\n     * state. This is called in mxGraphView.validatePoints as the last step of\n     * updating all cells.\n     *\n     * @param state <CellState> for which the shapes should be updated.\n     * @param force Optional boolean that specifies if the cell should be reconfiured\n     * and redrawn without any additional checks.\n     * @param rendering Optional boolean that specifies if the cell should actually\n     * be drawn into the DOM. If this is false then redraw and/or reconfigure\n     * will not be called on the shape.\n     */\n    redraw(state, force = false, rendering = true) {\n        const shapeChanged = this.redrawShape(state, force, rendering);\n        if (state.shape != null && rendering) {\n            this.redrawLabel(state, shapeChanged);\n            this.redrawCellOverlays(state, shapeChanged);\n            this.redrawControl(state, shapeChanged);\n        }\n    }\n    /**\n     * Redraws the shape for the given cell state.\n     *\n     * @param state <CellState> whose label should be redrawn.\n     */\n    redrawShape(state, force = false, rendering = true) {\n        let shapeChanged = false;\n        const graph = state.view.graph;\n        // Forces creation of new shape if shape style has changed\n        if (state.shape != null &&\n            state.shape.style != null &&\n            state.style != null &&\n            state.shape.style.shape !== state.style.shape) {\n            state.shape.destroy();\n            state.shape = null;\n        }\n        if (state.shape == null &&\n            graph.container != null &&\n            state.cell !== state.view.currentRoot &&\n            (state.cell.isVertex() || state.cell.isEdge())) {\n            state.shape = this.createShape(state);\n            if (state.shape != null) {\n                state.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;\n                state.shape.antiAlias = this.antiAlias;\n                this.createIndicatorShape(state);\n                this.initializeShape(state);\n                this.createCellOverlays(state);\n                this.installListeners(state);\n                // Forces a refresh of the handler if one exists\n                const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n                selectionCellsHandler?.updateHandler(state);\n            }\n        }\n        else if (!force &&\n            state.shape != null &&\n            (!equalEntries(state.shape.style, state.style) ||\n                this.checkPlaceholderStyles(state))) {\n            state.shape.resetStyles();\n            this.configureShape(state);\n            // LATER: Ignore update for realtime to fix reset of current gesture\n            const selectionCellsHandler = graph.getPlugin('SelectionCellsHandler');\n            selectionCellsHandler?.updateHandler(state);\n            force = true;\n        }\n        // Updates indicator shape\n        if (state.shape != null &&\n            state.shape.indicatorShape != this.getShape(state.getIndicatorShape())) {\n            if (state.shape.indicator != null) {\n                state.shape.indicator.destroy();\n                state.shape.indicator = null;\n            }\n            this.createIndicatorShape(state);\n            if (state.shape.indicatorShape != null) {\n                state.shape.indicator = new state.shape.indicatorShape();\n                state.shape.indicator.dialect = state.shape.dialect;\n                state.shape.indicator.init(state.node);\n                force = true;\n            }\n        }\n        if (state.shape) {\n            // Handles changes of the collapse icon\n            this.createControl(state);\n            // Redraws the cell if required, ignores changes to bounds if points are\n            // defined as the bounds are updated for the given points inside the shape\n            if (force || this.isShapeInvalid(state, state.shape)) {\n                if (state.absolutePoints.length > 0) {\n                    state.shape.points = state.absolutePoints.slice();\n                    state.shape.bounds = null;\n                }\n                else {\n                    state.shape.points = [];\n                    state.shape.bounds = new Rectangle(state.x, state.y, state.width, state.height);\n                }\n                state.shape.scale = state.view.scale;\n                if (rendering == null || rendering) {\n                    this.doRedrawShape(state);\n                }\n                else {\n                    state.shape.updateBoundingBox();\n                }\n                shapeChanged = true;\n            }\n        }\n        return shapeChanged;\n    }\n    /**\n     * Invokes redraw on the shape of the given state.\n     */\n    doRedrawShape(state) {\n        state.shape?.redraw();\n    }\n    /**\n     * Returns true if the given shape must be repainted.\n     */\n    isShapeInvalid(state, shape) {\n        return (shape.bounds == null ||\n            shape.scale !== state.view.scale ||\n            (state.absolutePoints.length === 0 && !shape.bounds.equals(state)) ||\n            (state.absolutePoints.length > 0 &&\n                !equalPoints(shape.points, state.absolutePoints)));\n    }\n    /**\n     * Destroys the shapes associated with the given cell state.\n     *\n     * @param state <CellState> for which the shapes should be destroyed.\n     */\n    destroy(state) {\n        if (state.shape) {\n            if (state.text) {\n                state.text.destroy();\n                state.text = null;\n            }\n            state.overlays.visit((id, shape) => {\n                shape.destroy();\n            });\n            state.overlays = new Dictionary();\n            if (state.control) {\n                state.control.destroy();\n                state.control = null;\n            }\n            state.shape.destroy();\n            state.shape = null;\n        }\n    }\n}\n/**\n * Static array that contains the globally registered shapes which are\n * known to all instances of this class. For adding new shapes you should\n * use the static {@link CellRenderer#registerShape} function.\n *\n * Built-in shapes: arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\n * swimlane, connector, actor and cloud.\n */\nCellRenderer.defaultShapes = {};\nexport default CellRenderer;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to add or remove a child in a model.\n *\n * Constructor: mxChildChange\n *\n * Constructs a change of a child in the\n * specified model.\n *\n * @class ChildChange\n */\nexport class ChildChange {\n    constructor(model, parent, child, index = 0) {\n        this.model = model;\n        this.parent = parent;\n        this.previous = parent;\n        this.child = child;\n        this.index = index;\n        this.previousIndex = index;\n    }\n    /**\n     * Changes the parent of {@link child}` using\n     * <Transactions.parentForCellChanged> and\n     * removes or restores the cell's\n     * connections.\n     */\n    execute() {\n        let tmp = this.child.getParent();\n        const tmp2 = tmp ? tmp.getIndex(this.child) : 0;\n        if (!this.previous) {\n            this.connect(this.child, false);\n        }\n        tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);\n        if (this.previous) {\n            this.connect(this.child, true);\n        }\n        this.parent = this.previous;\n        this.previous = tmp;\n        this.index = this.previousIndex;\n        this.previousIndex = tmp2;\n    }\n    /**\n     * Disconnects the given cell recursively from its\n     * terminals and stores the previous terminal in the\n     * cell's terminals.\n     *\n     * @warning doc from mxGraph source code is incorrect\n     */\n    connect(cell, isConnect = true) {\n        const source = cell.getTerminal(true);\n        const target = cell.getTerminal(false);\n        if (source) {\n            if (isConnect) {\n                this.model.terminalForCellChanged(cell, source, true);\n            }\n            else {\n                this.model.terminalForCellChanged(cell, null, true);\n            }\n        }\n        if (target) {\n            if (isConnect) {\n                this.model.terminalForCellChanged(cell, target, false);\n            }\n            else {\n                this.model.terminalForCellChanged(cell, null, false);\n            }\n        }\n        cell.setTerminal(source, true);\n        cell.setTerminal(target, false);\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            this.connect(cell.getChildAt(i), isConnect);\n        }\n    }\n}\nexport default ChildChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a cell's collapsed state in a model.\n *\n * Constructor: mxCollapseChange\n *\n * Constructs a change of a collapsed state in the\n * specified model.\n */\nclass CollapseChange {\n    constructor(model, cell, collapsed) {\n        this.model = model;\n        this.cell = cell;\n        this.collapsed = collapsed;\n        this.previous = collapsed;\n    }\n    /**\n     * Changes the collapsed state of {@link cell}` to {@link previous}` using\n     * <Transactions.collapsedStateForCellChanged>.\n     */\n    execute() {\n        this.collapsed = this.previous;\n        this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);\n    }\n}\nexport default CollapseChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a cell's geometry in a model.\n *\n * Constructor: mxGeometryChange\n *\n * Constructs a change of a geometry in the\n * specified model.\n */\nclass GeometryChange {\n    constructor(model, cell, geometry) {\n        this.model = model;\n        this.cell = cell;\n        this.geometry = geometry;\n        this.previous = geometry;\n    }\n    /**\n     * Changes the geometry of {@link cell}` ro {@link previous}` using\n     * <Transactions.geometryForCellChanged>.\n     */\n    execute() {\n        this.geometry = this.previous;\n        this.previous = this.model.geometryForCellChanged(this.cell, this.previous);\n    }\n}\nexport default GeometryChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change the root in a model.\n *\n * Constructor: mxRootChange\n *\n * Constructs a change of the root in the\n * specified model.\n *\n * @class RootChange\n */\nexport class RootChange {\n    constructor(model, root) {\n        this.model = model;\n        this.root = root;\n        this.previous = root;\n    }\n    /**\n     * Carries out a change of the root using\n     * <Transactions.rootChanged>.\n     */\n    execute() {\n        this.root = this.previous;\n        this.previous = this.model.rootChanged(this.previous);\n    }\n}\nexport default RootChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a cell's style in a model.\n *\n * @class StyleChange\n */\nclass StyleChange {\n    constructor(model, cell, style) {\n        this.model = model;\n        this.cell = cell;\n        this.style = style;\n        this.previous = style;\n    }\n    /**\n     * Changes the style of {@link cell}` to {@link previous}` using\n     * <Transactions.styleForCellChanged>.\n     */\n    execute() {\n        this.style = this.previous;\n        this.previous = this.model.styleForCellChanged(this.cell, this.previous);\n    }\n}\nexport default StyleChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a terminal in a model.\n */\nexport class TerminalChange {\n    constructor(model, cell, terminal, source) {\n        this.model = model;\n        this.cell = cell;\n        this.terminal = terminal;\n        this.previous = terminal;\n        this.source = source;\n    }\n    /**\n     * Changes the terminal of {@link cell}` to {@link previous}` using\n     * <Transactions.terminalForCellChanged>.\n     */\n    execute() {\n        this.terminal = this.previous;\n        this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);\n    }\n}\nexport default TerminalChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a user object in a model.\n *\n * Constructs a change of a user object in the\n * specified model.\n *\n * @class ValueChange\n */\nclass ValueChange {\n    constructor(model, cell, value) {\n        this.model = model;\n        this.cell = cell;\n        this.value = value;\n        this.previous = value;\n    }\n    /**\n     * Changes the value of {@link cell}` to {@link previous}` using\n     * <Transactions.valueForCellChanged>.\n     */\n    execute() {\n        this.value = this.previous;\n        this.previous = this.model.valueForCellChanged(this.cell, this.previous);\n    }\n}\nexport default ValueChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Action to change a cell's visible state in a model.\n *\n * Constructor: mxVisibleChange\n *\n * Constructs a change of a visible state in the\n * specified model.\n */\nclass VisibleChange {\n    constructor(model, cell, visible) {\n        this.model = model;\n        this.cell = cell;\n        this.visible = visible;\n        this.previous = visible;\n    }\n    /**\n     * Changes the visible state of {@link cell}` to {@link previous}` using\n     * <Transactions.visibleStateForCellChanged>.\n     */\n    execute() {\n        this.visible = this.previous;\n        this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);\n    }\n}\nexport default VisibleChange;\n", "import Dictionary from './Dictionary';\nimport ObjectIdentity from './ObjectIdentity';\n/**\n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nexport const filterCells = (filter) => (cells) => {\n    const result = [];\n    for (let i = 0; i < cells.length; i += 1) {\n        if (filter(cells[i])) {\n            result.push(cells[i]);\n        }\n    }\n    return result;\n};\n/**\n * Returns all opposite vertices terminal for the given edges, only returning sources and/or targets as specified.\n * The result is returned as an array of {@link Cell}.\n *\n * @param edges Array of {Cell} that contain the edges to be examined.\n * @param {Cell} terminal  that specifies the known end of the edges.\n * @param includeSources  Boolean that specifies if source terminals should be included in the result. Default is `true`.\n * @param includeTargets  Boolean that specifies if target terminals should be included in the result. Default is `true`.\n */\nexport const getOpposites = (edges, terminal, includeSources = true, includeTargets = true) => {\n    return edges.reduce((terminals, edge) => {\n        const source = edge.getTerminal(true);\n        const target = edge.getTerminal(false);\n        // Checks if the terminal is the source of the edge and if the target should be stored in the result\n        if (source === terminal && target != null && target !== terminal && includeTargets) {\n            terminals.push(target);\n        }\n        // Checks if the terminal is the target of the edge and if the source should be stored in the result\n        else if (target === terminal &&\n            source != null &&\n            source !== terminal &&\n            includeSources) {\n            terminals.push(source);\n        }\n        return terminals;\n    }, []);\n};\n/**\n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each {@link Cell} that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n */\nexport const getTopmostCells = (cells) => {\n    const dict = new Dictionary();\n    const tmp = [];\n    for (let i = 0; i < cells.length; i += 1) {\n        dict.put(cells[i], true);\n    }\n    for (let i = 0; i < cells.length; i += 1) {\n        const cell = cells[i];\n        let topmost = true;\n        let parent = cell.getParent();\n        while (parent != null) {\n            if (dict.get(parent)) {\n                topmost = false;\n                break;\n            }\n            parent = parent.getParent();\n        }\n        if (topmost) {\n            tmp.push(cell);\n        }\n    }\n    return tmp;\n};\n/**\n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n */\nexport const getParents = (cells) => {\n    const parents = [];\n    const dict = new Dictionary();\n    for (const cell of cells) {\n        const parent = cell.getParent();\n        if (parent != null && !dict.get(parent)) {\n            dict.put(parent, true);\n            parents.push(parent);\n        }\n    }\n    return parents;\n};\n/**\n * Returns a deep clone of the given {@link Cell}` (including the children) which is created using {@link cloneCells}`.\n *\n * @param cell {@link Cell} to be cloned. Default is `null`.\n * @param includeChildren Boolean indicating if the cells should be cloned with all descendants. Default is `true`.\n */\nexport const cloneCell = (cell = null, includeChildren = true) => {\n    if (!cell) {\n        return null;\n    }\n    return cloneCells([cell], includeChildren)[0];\n};\n/**\n * Returns an array of clones for the given array of {@link Cell}`.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the provided in array.\n *\n * @param cells The cells to clone\n * @param includeChildren  Boolean indicating if the cells should be cloned with all descendants.\n * @param mapping  Optional mapping for existing clones.\n */\nexport const cloneCells = (cells, includeChildren = true, mapping = {}) => {\n    const clones = [];\n    for (const cell of cells) {\n        clones.push(cloneCellImpl(cell, mapping, includeChildren));\n    }\n    for (let i = 0; i < clones.length; i += 1) {\n        if (clones[i] != null) {\n            restoreClone(clones[i], cells[i], mapping);\n        }\n    }\n    return clones;\n};\n/**\n * Inner helper method for cloning cells recursively.\n *\n * @private\n */\nconst cloneCellImpl = (cell, mapping = {}, includeChildren = false) => {\n    const identity = ObjectIdentity.get(cell);\n    let clone = mapping ? mapping[identity] : null;\n    if (clone == null) {\n        clone = cell.clone();\n        mapping[identity] = clone;\n        if (includeChildren) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const cloneChild = cloneCellImpl(cell.getChildAt(i), mapping, true);\n                clone.insert(cloneChild);\n            }\n        }\n    }\n    return clone;\n};\n/**\n * Inner helper method for restoring the connections in a network of cloned cells.\n *\n * @private\n */\nconst restoreClone = (clone, cell, mapping) => {\n    const source = cell.getTerminal(true);\n    if (source != null) {\n        const tmp = mapping[ObjectIdentity.get(source)];\n        if (tmp != null) {\n            tmp.insertEdge(clone, true);\n        }\n    }\n    const target = cell.getTerminal(false);\n    if (target != null) {\n        const tmp = mapping[ObjectIdentity.get(target)];\n        if (tmp != null) {\n            tmp.insertEdge(clone, false);\n        }\n    }\n    const childCount = clone.getChildCount();\n    for (let i = 0; i < childCount; i += 1) {\n        restoreClone(clone.getChildAt(i), cell.getChildAt(i), mapping);\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from './event/EventSource';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport CellPath from './cell/CellPath';\nimport Cell from './cell/Cell';\nimport { isNumeric } from '../util/mathUtils';\nimport EventObject from './event/EventObject';\nimport InternalEvent from './event/InternalEvent';\nimport ChildChange from './undoable_changes/ChildChange';\nimport CollapseChange from './undoable_changes/CollapseChange';\nimport GeometryChange from './undoable_changes/GeometryChange';\nimport RootChange from './undoable_changes/RootChange';\nimport StyleChange from './undoable_changes/StyleChange';\nimport TerminalChange from './undoable_changes/TerminalChange';\nimport ValueChange from './undoable_changes/ValueChange';\nimport VisibleChange from './undoable_changes/VisibleChange';\nimport { filterCells } from '../util/cellArrayUtils';\n/**\n * Extends {@link EventSource} to implement a graph model. The graph model acts as\n * a wrapper around the cells which are in charge of storing the actual graph\n * datastructure. The model acts as a transactional wrapper with event\n * notification for all changes, whereas the cells contain the atomic\n * operations for updating the actual datastructure.\n *\n * ### Layers\n *\n * The cell hierarchy in the model must have a top-level root cell which\n * contains the layers (typically one default layer), which in turn contain the\n * top-level cells of the layers. This means each cell is contained in a layer.\n * If no layers are required, then all new cells should be added to the default\n * layer.\n *\n * Layers are useful for hiding and showing groups of cells, or for placing\n * groups of cells on top of other cells in the display. To identify a layer,\n * the {@link isLayer} function is used. It returns true if the parent of the given\n * cell is the root of the model.\n *\n * ### Events\n *\n * See events section for more details. There is a new set of events for\n * tracking transactional changes as they happen. The events are called\n * startEdit for the initial beginUpdate, executed for each executed change\n * and endEdit for the terminal endUpdate. The executed event contains a\n * property called change which represents the change after execution.\n *\n * ### Encoding the model\n *\n * #### To encode a graph model, use the following code:\n *\n * ```javascript\n * var enc = new Codec();\n * var node = enc.encode(graph.getDataModel());\n * ```\n *\n * This will create an XML node that contains all the model information.\n *\n * #### Encoding and decoding changes:\n *\n * For the encoding of changes, a graph model listener is required that encodes\n * each change from the given array of changes.\n *\n * ```javascript\n * model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *   var nodes = [];\n *   var codec = new Codec();\n *\n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     nodes.push(codec.encode(changes[i]));\n *   }\n *   // do something with the nodes\n * });\n * ```\n *\n * For the decoding and execution of changes, the codec needs a lookup function\n * that allows it to resolve cell IDs as follows:\n *\n * ```javascript\n * var codec = new Codec();\n * codec.lookup(id)\n * {\n *   return model.getCell(id);\n * }\n * ```\n *\n * For each encoded change (represented by a node), the following code can be\n * used to carry out the decoding and create a change object.\n *\n * ```javascript\n * var changes = [];\n * var change = codec.decode(node);\n * change.model = model;\n * change.execute();\n * changes.push(change);\n * ```\n *\n * The changes can then be dispatched using the model as follows.\n *\n * ```javascript\n * var edit = new mxUndoableEdit(model, false);\n * edit.changes = changes;\n *\n * edit.notify()\n * {\n *   edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n *   \t'edit', edit, 'changes', edit.changes));\n *   edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n *   \t'edit', edit, 'changes', edit.changes));\n * }\n *\n * model.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n * model.fireEvent(new mxEventObject(mxEvent.CHANGE,\n *    'edit', edit, 'changes', changes));\n * ```\n *\n * Event: mxEvent.CHANGE\n *\n * Fires when an undoable edit is dispatched. The `edit` property\n * contains the {@link UndoableEdit}. The `changes` property contains\n * the array of atomic changes inside the undoable edit. The changes property\n * is **deprecated**, please use edit.changes instead.\n *\n * ### Example\n *\n * For finding newly inserted cells, the following code can be used:\n *\n * ```javascript\n * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *\n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     var change = changes[i];\n *\n *     if (change instanceof mxChildChange &&\n *       change.change.previous == null)\n *     {\n *       graph.startEditingAtCell(change.child);\n *       break;\n *     }\n *   }\n * });\n * ```\n *\n * Event: mxEvent.NOTIFY\n *\n * Same as {@link Event#CHANGE}, this event can be used for classes that need to\n * implement a sync mechanism between this model and, say, a remote model. In\n * such a setup, only local changes should trigger a notify event and all\n * changes should trigger a change event.\n *\n * Event: mxEvent.EXECUTE\n *\n * Fires between begin- and endUpdate and after an atomic change was executed\n * in the model. The `change` property contains the atomic change\n * that was executed.\n *\n * Event: mxEvent.EXECUTED\n *\n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The `change` property contains the change that was executed.\n *\n * Event: mxEvent.BEGIN_UPDATE\n *\n * Fires after the {@link updateLevel} was incremented in {@link beginUpdate}. This event\n * contains no properties.\n *\n * Event: mxEvent.START_EDIT\n *\n * Fires after the {@link updateLevel} was changed from 0 to 1. This event\n * contains no properties.\n *\n * Event: mxEvent.END_UPDATE\n *\n * Fires after the {@link updateLevel} was decreased in {@link endUpdate} but before any\n * notification or change dispatching. The `edit` property contains\n * the {@link currentEdit}.\n *\n * Event: mxEvent.END_EDIT\n *\n * Fires after the {@link updateLevel} was changed from 1 to 0. This event\n * contains no properties.\n *\n * Event: mxEvent.BEFORE_UNDO\n *\n * Fires before the change is dispatched after the update level has reached 0\n * in {@link endUpdate}. The `edit` property contains the {@link currentEdit}.\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the change was dispatched in {@link endUpdate}. The `edit`\n * property contains the {@link currentEdit}.\n *\n * @class GraphDataModel\n */\nexport class GraphDataModel extends EventSource {\n    constructor(root = null) {\n        super();\n        /**\n         * Holds the root cell, which in turn contains the cells that represent the\n         * layers of the diagram as child cells. That is, the actual elements of the\n         * diagram are supposed to live in the third generation of cells and below.\n         */\n        this.root = null;\n        /**\n         * Maps from Ids to cells.\n         */\n        this.cells = {};\n        /**\n         * Specifies if edges should automatically be moved into the nearest common\n         * ancestor of their terminals. Default is true.\n         */\n        this.maintainEdgeParent = true;\n        /**\n         * Specifies if relative edge parents should be ignored for finding the nearest\n         * common ancestors of an edge's terminals. Default is true.\n         */\n        this.ignoreRelativeEdgeParent = true;\n        /**\n         * Specifies if the model should automatically create Ids for new cells.\n         * Default is true.\n         */\n        this.createIds = true;\n        /**\n         * Defines the prefix of new Ids. Default is an empty string.\n         */\n        this.prefix = '';\n        /**\n         * Defines the postfix of new Ids. Default is an empty string.\n         */\n        this.postfix = '';\n        /**\n         * Specifies the next Id to be created. Initial value is 0.\n         */\n        // nextId: number | string;\n        this.nextId = 0;\n        /**\n         * Holds the changes for the current transaction. If the transaction is\n         * closed then a new object is created for this variable using\n         * {@link createUndoableEdit}.\n         */\n        this.currentEdit = null;\n        /**\n         * Counter for the depth of nested transactions. Each call to {@link beginUpdate}\n         * will increment this number and each call to {@link endUpdate} will decrement\n         * it. When the counter reaches 0, the transaction is closed and the\n         * respective events are fired. Initial value is 0.\n         */\n        this.updateLevel = 0;\n        /**\n         * True if the program flow is currently inside endUpdate.\n         */\n        this.endingUpdate = false;\n        this.currentEdit = this.createUndoableEdit();\n        if (root != null) {\n            this.setRoot(root);\n        }\n        else {\n            this.clear();\n        }\n    }\n    /**\n     * Sets a new root using {@link createRoot}.\n     */\n    clear() {\n        this.setRoot(this.createRoot());\n    }\n    /**\n     * Returns {@link createIds}.\n     */\n    isCreateIds() {\n        return this.createIds;\n    }\n    /**\n     * Sets {@link createIds}.\n     */\n    setCreateIds(value) {\n        this.createIds = value;\n    }\n    /**\n     * Creates a new root cell with a default layer (child 0).\n     */\n    createRoot() {\n        const cell = new Cell();\n        cell.insert(new Cell());\n        return cell;\n    }\n    /**\n     * Returns the {@link Cell} for the specified Id or null if no cell can be\n     * found for the given Id.\n     *\n     * @param {string} id  A string representing the Id of the cell.\n     */\n    getCell(id) {\n        return this.cells ? this.cells[id] : null;\n    }\n    filterCells(cells, filter) {\n        return filterCells(filter)(cells);\n    }\n    getRoot(cell = null) {\n        return cell ? cell.getRoot() : this.root;\n    }\n    /**\n     * Sets the {@link root} of the model using {@link RootChange} and adds the change to\n     * the current transaction. This resets all datastructures in the model and\n     * is the preferred way of clearing an existing model. Returns the new\n     * root.\n     *\n     * Example:\n     *\n     * ```javascript\n     * var root = new mxCell();\n     * root.insert(new mxCell());\n     * model.setRoot(root);\n     * ```\n     *\n     * @param {Cell} root  that specifies the new root.\n     */\n    setRoot(root) {\n        this.execute(new RootChange(this, root));\n        return root;\n    }\n    /**\n     * Inner callback to change the root of the model and update the internal\n     * datastructures, such as {@link cells} and {@link nextId}. Returns the previous root.\n     *\n     * @param {Cell} root  that specifies the new root.\n     */\n    rootChanged(root) {\n        const oldRoot = this.root;\n        this.root = root;\n        // Resets counters and datastructures\n        this.nextId = 0;\n        this.cells = null;\n        this.cellAdded(root);\n        return oldRoot;\n    }\n    /**\n     * Returns true if the given cell is the root of the model and a non-null\n     * value.\n     *\n     * @param {Cell} cell  that represents the possible root.\n     */\n    isRoot(cell = null) {\n        return cell != null && this.root === cell;\n    }\n    /**\n     * Returns true if {@link isRoot} returns true for the parent of the given cell.\n     *\n     * @param cell  that represents the possible layer.\n     */\n    isLayer(cell) {\n        return cell ? this.isRoot(cell.getParent()) : false;\n    }\n    /**\n     * Returns true if the model contains the given {@link Cell}.\n     *\n     * @param {Cell} cell  that specifies the cell.\n     */\n    contains(cell) {\n        return this.root.isAncestor(cell);\n    }\n    /**\n     * Adds the specified child to the parent at the given index using\n     * {@link ChildChange} and adds the change to the current transaction. If no\n     * index is specified then the child is appended to the parent's array of\n     * children. Returns the inserted child.\n     *\n     * @param {Cell} parent  that specifies the parent to contain the child.\n     * @param {Cell} child  that specifies the child to be inserted.\n     * @param index  Optional integer that specifies the index of the child.\n     */\n    add(parent, child, index = null) {\n        if (child !== parent && parent != null && child != null) {\n            // Appends the child if no index was specified\n            if (index == null) {\n                index = parent.getChildCount();\n            }\n            const parentChanged = parent !== child.getParent();\n            this.execute(new ChildChange(this, parent, child, index));\n            // Maintains the edges parents by moving the edges\n            // into the nearest common ancestor of its terminals\n            if (this.maintainEdgeParent && parentChanged) {\n                this.updateEdgeParents(child);\n            }\n        }\n        return child;\n    }\n    /**\n     * Inner callback to update {@link cells} when a cell has been added. This\n     * implementation resolves collisions by creating new Ids. To change the\n     * ID of a cell after it was inserted into the model, use the following\n     * code:\n     *\n     * (code\n     * delete model.cells[cell.getId()];\n     * cell.setId(newId);\n     * model.cells[cell.getId()] = cell;\n     * ```\n     *\n     * If the change of the ID should be part of the command history, then the\n     * cell should be removed from the model and a clone with the new ID should\n     * be reinserted into the model instead.\n     *\n     * @param {Cell} cell  that specifies the cell that has been added.\n     */\n    cellAdded(cell) {\n        if (cell != null) {\n            // Creates an Id for the cell if not Id exists\n            if (cell.getId() == null && this.createIds) {\n                cell.setId(this.createId(cell));\n            }\n            if (cell.getId() != null) {\n                let collision = this.getCell(cell.getId());\n                if (collision !== cell) {\n                    // Creates new Id for the cell\n                    // as long as there is a collision\n                    while (collision != null) {\n                        cell.setId(this.createId(cell));\n                        collision = this.getCell(cell.getId());\n                    }\n                    // Lazily creates the cells dictionary\n                    if (this.cells == null) {\n                        this.cells = {};\n                    }\n                    this.cells[cell.getId()] = cell;\n                }\n            }\n            // Makes sure IDs of deleted cells are not reused\n            if (isNumeric(String(cell.getId()))) {\n                this.nextId = Math.max(this.nextId, parseInt(cell.getId()));\n            }\n            // Recursively processes child cells\n            for (const child of cell.getChildren()) {\n                this.cellAdded(child);\n            }\n        }\n    }\n    /**\n     * Hook method to create an Id for the specified cell. This implementation\n     * concatenates {@link prefix}, id and {@link postfix} to create the Id and increments\n     * {@link nextId}. The cell is ignored by this implementation, but can be used in\n     * overridden methods to prefix the Ids with eg. the cell type.\n     *\n     * @param {Cell} cell  to create the Id for.\n     */\n    createId(cell) {\n        const id = this.nextId;\n        this.nextId++;\n        return this.prefix + id + this.postfix;\n    }\n    /**\n     * Updates the parent for all edges that are connected to cell or one of\n     * its descendants using {@link updateEdgeParent}.\n     */\n    updateEdgeParents(cell, root = this.getRoot(cell)) {\n        // Updates edges on children first\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            this.updateEdgeParents(child, root);\n        }\n        // Updates the parents of all connected edges\n        const edgeCount = cell.getEdgeCount();\n        const edges = [];\n        for (let i = 0; i < edgeCount; i += 1) {\n            edges.push(cell.getEdgeAt(i));\n        }\n        for (let i = 0; i < edges.length; i += 1) {\n            const edge = edges[i];\n            // Updates edge parent if edge and child have\n            // a common root node (does not need to be the\n            // model root node)\n            if (root.isAncestor(edge)) {\n                this.updateEdgeParent(edge, root);\n            }\n        }\n    }\n    /**\n     * Inner callback to update the parent of the specified {@link Cell} to the\n     * nearest-common-ancestor of its two terminals.\n     *\n     * @param {Cell} edge  that specifies the edge.\n     * @param {Cell} root  that represents the current root of the model.\n     */\n    updateEdgeParent(edge, root) {\n        let source = edge.getTerminal(true);\n        let target = edge.getTerminal(false);\n        let cell = null;\n        // Uses the first non-relative descendants of the source terminal\n        while (source != null &&\n            !source.isEdge() &&\n            source.geometry != null &&\n            source.geometry.relative) {\n            source = source.getParent();\n        }\n        // Uses the first non-relative descendants of the target terminal\n        while (target != null &&\n            this.ignoreRelativeEdgeParent &&\n            !target.isEdge() &&\n            target.geometry != null &&\n            target.geometry.relative) {\n            target = target.getParent();\n        }\n        if (root.isAncestor(source) && root.isAncestor(target)) {\n            if (source === target) {\n                cell = source ? source.getParent() : null;\n            }\n            else if (source) {\n                cell = source.getNearestCommonAncestor(target);\n            }\n            if (cell != null &&\n                (cell.getParent() !== this.root || cell.isAncestor(edge)) &&\n                edge &&\n                edge.getParent() !== cell) {\n                let geo = edge.getGeometry();\n                if (geo != null) {\n                    const origin1 = edge.getParent().getOrigin();\n                    const origin2 = cell.getOrigin();\n                    const dx = origin2.x - origin1.x;\n                    const dy = origin2.y - origin1.y;\n                    geo = geo.clone();\n                    geo.translate(-dx, -dy);\n                    this.setGeometry(edge, geo);\n                }\n                this.add(cell, edge, cell.getChildCount());\n            }\n        }\n    }\n    /**\n     * Removes the specified cell from the model using {@link ChildChange} and adds\n     * the change to the current transaction. This operation will remove the\n     * cell and all of its children from the model. Returns the removed cell.\n     *\n     * @param {Cell} cell  that should be removed.\n     */\n    remove(cell) {\n        if (cell === this.root) {\n            this.setRoot(null);\n        }\n        else if (cell.getParent() != null) {\n            this.execute(new ChildChange(this, null, cell));\n        }\n        return cell;\n    }\n    /**\n     * Inner callback to update {@link cells} when a cell has been removed.\n     *\n     * @param {Cell} cell  that specifies the cell that has been removed.\n     */\n    cellRemoved(cell) {\n        if (cell != null && this.cells != null) {\n            // Recursively processes child cells\n            const childCount = cell.getChildCount();\n            for (let i = childCount - 1; i >= 0; i--) {\n                this.cellRemoved(cell.getChildAt(i));\n            }\n            // Removes the dictionary entry for the cell\n            if (this.cells != null && cell.getId() != null) {\n                // @ts-ignore\n                delete this.cells[cell.getId()];\n            }\n        }\n    }\n    /**\n     * Inner callback to update the parent of a cell using {@link Cell#insert}\n     * on the parent and return the previous parent.\n     *\n     * @param {Cell} cell  to update the parent for.\n     * @param {Cell} parent  that specifies the new parent of the cell.\n     * @param index  Optional integer that defines the index of the child\n     * in the parent's child array.\n     */\n    parentForCellChanged(cell, parent, index) {\n        const previous = cell.getParent();\n        if (parent != null) {\n            if (parent !== previous || previous.getIndex(cell) !== index) {\n                parent.insert(cell, index);\n            }\n        }\n        else if (previous != null) {\n            const oldIndex = previous.getIndex(cell);\n            previous.remove(oldIndex);\n        }\n        // Adds or removes the cell from the model\n        const par = parent ? this.contains(parent) : null;\n        const pre = this.contains(previous);\n        if (par && !pre) {\n            this.cellAdded(cell);\n        }\n        else if (pre && !par) {\n            this.cellRemoved(cell);\n        }\n        return previous;\n    }\n    /**\n     * Sets the source or target terminal of the given {@link Cell} using\n     * {@link TerminalChange} and adds the change to the current transaction.\n     * This implementation updates the parent of the edge using {@link updateEdgeParent}\n     * if required.\n     *\n     * @param {Cell} edge  that specifies the edge.\n     * @param {Cell} terminal  that specifies the new terminal.\n     * @param isSource  Boolean indicating if the terminal is the new source or\n     * target terminal of the edge.\n     */\n    // setTerminal(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;\n    setTerminal(edge, terminal, isSource) {\n        const terminalChanged = terminal !== edge.getTerminal(isSource);\n        this.execute(new TerminalChange(this, edge, terminal, isSource));\n        if (this.maintainEdgeParent && terminalChanged) {\n            this.updateEdgeParent(edge, this.getRoot());\n        }\n        return terminal;\n    }\n    /**\n     * Sets the source and target {@link Cell} of the given {@link Cell} in a single\n     * transaction using {@link setTerminal} for each end of the edge.\n     *\n     * @param {Cell} edge  that specifies the edge.\n     * @param {Cell} source  that specifies the new source terminal.\n     * @param {Cell} target  that specifies the new target terminal.\n     */\n    // setTerminals(edge: mxCell, source: mxCell, target: mxCell): void;\n    setTerminals(edge, source, target) {\n        this.beginUpdate();\n        try {\n            this.setTerminal(edge, source, true);\n            this.setTerminal(edge, target, false);\n        }\n        finally {\n            this.endUpdate();\n        }\n    }\n    /**\n     * Inner helper function to update the terminal of the edge using\n     * {@link Cell#insertEdge} and return the previous terminal.\n     *\n     * @param {Cell} edge  that specifies the edge to be updated.\n     * @param {Cell} terminal  that specifies the new terminal.\n     * @param isSource  Boolean indicating if the terminal is the new source or\n     * target terminal of the edge.\n     */\n    // terminalForCellChanged(edge: mxCell, terminal: mxCell, isSource: boolean): mxCell;\n    terminalForCellChanged(edge, terminal, isSource = false) {\n        const previous = edge.getTerminal(isSource);\n        if (terminal != null) {\n            terminal.insertEdge(edge, isSource);\n        }\n        else if (previous != null) {\n            previous.removeEdge(edge, isSource);\n        }\n        return previous;\n    }\n    /**\n     * Returns all edges between the given source and target pair. If directed\n     * is true, then only edges from the source to the target are returned,\n     * otherwise, all edges between the two cells are returned.\n     *\n     * @param {Cell} source  that defines the source terminal of the edge to be\n     * returned.\n     * @param {Cell} target  that defines the target terminal of the edge to be\n     * returned.\n     * @param directed  Optional boolean that specifies if the direction of the\n     * edge should be taken into account. Default is false.\n     */\n    getEdgesBetween(source, target, directed = false) {\n        const tmp1 = source.getEdgeCount();\n        const tmp2 = target.getEdgeCount();\n        // Assumes the source has less connected edges\n        let terminal = source;\n        let edgeCount = tmp1;\n        // Uses the smaller array of connected edges\n        // for searching the edge\n        if (tmp2 < tmp1) {\n            edgeCount = tmp2;\n            terminal = target;\n        }\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edgeCount; i += 1) {\n            const edge = terminal.getEdgeAt(i);\n            const src = edge.getTerminal(true);\n            const trg = edge.getTerminal(false);\n            const directedMatch = src === source && trg === target;\n            const oppositeMatch = trg === source && src === target;\n            if (directedMatch || (!directed && oppositeMatch)) {\n                result.push(edge);\n            }\n        }\n        return result;\n    }\n    /**\n     * Sets the user object of then given {@link Cell} using {@link ValueChange}\n     * and adds the change to the current transaction.\n     *\n     * @param {Cell} cell  whose user object should be changed.\n     * @param value  Object that defines the new user object.\n     */\n    setValue(cell, value) {\n        this.execute(new ValueChange(this, cell, value));\n        return value;\n    }\n    /**\n     * Inner callback to update the user object of the given {@link Cell}\n     * using {@link Cell#valueChanged} and return the previous value,\n     * that is, the return value of {@link Cell#valueChanged}.\n     *\n     * To change a specific attribute in an XML node, the following code can be\n     * used.\n     *\n     * ```javascript\n     * graph.getDataModel().valueForCellChanged(cell, value)\n     * {\n     *   var previous = cell.value.getAttribute('label');\n     *   cell.value.setAttribute('label', value);\n     *\n     *   return previous;\n     * };\n     * ```\n     */\n    valueForCellChanged(cell, value) {\n        return cell.valueChanged(value);\n    }\n    /**\n     * Sets the {@link Geometry} of the given {@link Cell}. The actual update\n     * of the cell is carried out in {@link geometryForCellChanged}. The\n     * {@link GeometryChange} action is used to encapsulate the change.\n     *\n     * @param {Cell} cell  whose geometry should be changed.\n     * @param {Geometry} geometry  that defines the new geometry.\n     */\n    setGeometry(cell, geometry) {\n        if (geometry !== cell.getGeometry()) {\n            this.execute(new GeometryChange(this, cell, geometry));\n        }\n        return geometry;\n    }\n    /**\n     * Inner callback to update the {@link Geometry} of the given {@link Cell} using\n     * {@link Cell#setGeometry} and return the previous {@link Geometry}.\n     */\n    geometryForCellChanged(cell, geometry) {\n        const previous = cell.getGeometry();\n        cell.setGeometry(geometry);\n        return previous;\n    }\n    /**\n     * Sets the style of the given {@link Cell} using {@link StyleChange} and adds the change to the current transaction.\n     *\n     * **IMPORTANT**: Do not pass {@link Cell.getStyle} as value of the `style` parameter. Otherwise, no style change is performed, so the view won't be updated.\n     * Always get a clone of the style of the cell with {@link Cell.getClonedStyle}, then update it and pass the updated style to this method.\n     *\n     * @param cell  whose style should be changed.\n     * @param style the new cell style to set.\n     */\n    setStyle(cell, style) {\n        // To investigate in the future: it may be more convenient to do a deep comparison to prevent unnecessary changes\n        // If the passed style is the same as the current style without being the same instance, we don't need to do anything\n        // With the current implementation, a style change is executed when the styles are deep equal.\n        if (style !== cell.getStyle()) {\n            this.execute(new StyleChange(this, cell, style));\n        }\n    }\n    /**\n     * Inner callback to update the style of the given {@link Cell}  using {@link Cell#setStyle} and return the previous style.\n     *\n     * **IMPORTANT**: to fully work, this method should not receive `cell.getStyle` as value of the `style` parameter. See {@link setStyle} for more information.\n     *\n     * @param cell  whose style should be changed.\n     * @param style the new cell style to set.\n     */\n    styleForCellChanged(cell, style) {\n        const previous = cell.getStyle();\n        cell.setStyle(style);\n        return previous;\n    }\n    /**\n     * Sets the collapsed state of the given {@link Cell} using {@link CollapseChange}\n     * and adds the change to the current transaction.\n     *\n     * @param {Cell} cell  whose collapsed state should be changed.\n     * @param collapsed  Boolean that specifies the new collpased state.\n     */\n    setCollapsed(cell, collapsed) {\n        if (collapsed !== cell.isCollapsed()) {\n            this.execute(new CollapseChange(this, cell, collapsed));\n        }\n        return collapsed;\n    }\n    /**\n     * Inner callback to update the collapsed state of the\n     * given {@link Cell} using {@link Cell#setCollapsed} and return\n     * the previous collapsed state.\n     *\n     * @param {Cell} cell  that specifies the cell to be updated.\n     * @param collapsed  Boolean that specifies the new collapsed state.\n     */\n    collapsedStateForCellChanged(cell, collapsed) {\n        const previous = cell.isCollapsed();\n        cell.setCollapsed(collapsed);\n        return previous;\n    }\n    /**\n     * Sets the visible state of the given {@link Cell} using {@link VisibleChange} and\n     * adds the change to the current transaction.\n     *\n     * @param {Cell} cell  whose visible state should be changed.\n     * @param visible  Boolean that specifies the new visible state.\n     */\n    setVisible(cell, visible) {\n        if (visible !== cell.isVisible()) {\n            this.execute(new VisibleChange(this, cell, visible));\n        }\n        return visible;\n    }\n    /**\n     * Inner callback to update the visible state of the\n     * given {@link Cell} using {@link Cell#setCollapsed} and return\n     * the previous visible state.\n     *\n     * @param {Cell} cell  that specifies the cell to be updated.\n     * @param visible  Boolean that specifies the new visible state.\n     */\n    visibleStateForCellChanged(cell, visible) {\n        const previous = cell.isVisible();\n        cell.setVisible(visible);\n        return previous;\n    }\n    /**\n     * Executes the given edit and fires events if required. The edit object\n     * requires an execute function which is invoked. The edit is added to the\n     * {@link currentEdit} between {@link beginUpdate} and {@link endUpdate} calls, so that\n     * events will be fired if this execute is an individual transaction, that\n     * is, if no previous {@link beginUpdate} calls have been made without calling\n     * {@link endUpdate}. This implementation fires an {@link execute} event before\n     * executing the given change.\n     *\n     * @param change  Object that described the change.\n     */\n    execute(change) {\n        change.execute();\n        this.beginUpdate();\n        this.currentEdit.add(change);\n        this.fireEvent(new EventObject(InternalEvent.EXECUTE, { change }));\n        // New global executed event\n        this.fireEvent(new EventObject(InternalEvent.EXECUTED, { change }));\n        this.endUpdate();\n    }\n    /**\n     * Updates the model in a transaction.\n     * This is a shortcut to the usage of {@link beginUpdate} and the {@link endUpdate} methods.\n     *\n     * ```javascript\n     * const model = graph.getDataModel();\n     * const parent = graph.getDefaultParent();\n     * const index = model.getChildCount(parent);\n     * model.batchUpdate(() => {\n     *   model.add(parent, v1, index);\n     *   model.add(parent, v2, index+1);\n     * });\n     * ```\n     *\n     * @param fn the update to be performed in the transaction.\n     */\n    batchUpdate(fn) {\n        this.beginUpdate();\n        try {\n            fn();\n        }\n        finally {\n            this.endUpdate();\n        }\n    }\n    /**\n     * Increments the {@link updateLevel} by one. The event notification\n     * is queued until {@link updateLevel} reaches 0 by use of\n     * {@link endUpdate}.\n     *\n     * All changes on {@link GraphDataModel} are transactional,\n     * that is, they are executed in a single undoable change\n     * on the model (without transaction isolation).\n     * Therefore, if you want to combine any\n     * number of changes into a single undoable change,\n     * you should group any two or more API calls that\n     * modify the graph model between {@link beginUpdate}\n     * and {@link endUpdate} calls as shown here:\n     *\n     * ```javascript\n     * const model = graph.getDataModel();\n     * const parent = graph.getDefaultParent();\n     * const index = model.getChildCount(parent);\n     * model.beginUpdate();\n     * try\n     * {\n     *   model.add(parent, v1, index);\n     *   model.add(parent, v2, index+1);\n     * }\n     * finally\n     * {\n     *   model.endUpdate();\n     * }\n     * ```\n     *\n     * Of course there is a shortcut for appending a\n     * sequence of cells into the default parent:\n     *\n     * ```javascript\n     * graph.addCells([v1, v2]).\n     * ```\n     */\n    beginUpdate() {\n        this.updateLevel += 1;\n        this.fireEvent(new EventObject(InternalEvent.BEGIN_UPDATE));\n        if (this.updateLevel === 1) {\n            this.fireEvent(new EventObject(InternalEvent.START_EDIT));\n        }\n    }\n    /**\n     * Decrements the {@link updateLevel} by one and fires an {@link undo}\n     * event if the {@link updateLevel} reaches 0. This function\n     * indirectly fires a {@link change} event by invoking the notify\n     * function on the {@link currentEdit} und then creates a new\n     * {@link currentEdit} using {@link createUndoableEdit}.\n     *\n     * The {@link undo} event is fired only once per edit, whereas\n     * the {@link change} event is fired whenever the notify\n     * function is invoked, that is, on undo and redo of\n     * the edit.\n     */\n    endUpdate() {\n        this.updateLevel -= 1;\n        if (this.updateLevel === 0) {\n            this.fireEvent(new EventObject(InternalEvent.END_EDIT));\n        }\n        if (!this.endingUpdate) {\n            this.endingUpdate = this.updateLevel === 0;\n            this.fireEvent(new EventObject(InternalEvent.END_UPDATE, { edit: this.currentEdit }));\n            try {\n                if (this.endingUpdate && !this.currentEdit.isEmpty()) {\n                    this.fireEvent(new EventObject(InternalEvent.BEFORE_UNDO, { edit: this.currentEdit }));\n                    const tmp = this.currentEdit;\n                    this.currentEdit = this.createUndoableEdit();\n                    tmp.notify();\n                    this.fireEvent(new EventObject(InternalEvent.UNDO, { edit: tmp }));\n                }\n            }\n            finally {\n                this.endingUpdate = false;\n            }\n        }\n    }\n    /**\n     * Creates a new {@link UndoableEdit} that implements the\n     * notify function to fire a {@link change} and {@link notify} event\n     * through the {@link UndoableEdit}'s source.\n     *\n     * @param significant  Optional boolean that specifies if the edit to be created is\n     * significant. Default is true.\n     */\n    createUndoableEdit(significant = true) {\n        const edit = new UndoableEdit(this, significant);\n        edit.notify = () => {\n            // LATER: Remove changes property (deprecated)\n            edit.source.fireEvent(new EventObject(InternalEvent.CHANGE, { edit, changes: edit.changes }));\n            edit.source.fireEvent(new EventObject(InternalEvent.NOTIFY, { edit, changes: edit.changes }));\n        };\n        return edit;\n    }\n    /**\n     * Merges the children of the given cell into the given target cell inside\n     * this model. All cells are cloned unless there is a corresponding cell in\n     * the model with the same id, in which case the source cell is ignored and\n     * all edges are connected to the corresponding cell in this model. Edges\n     * are considered to have no identity and are always cloned unless the\n     * cloneAllEdges flag is set to false, in which case edges with the same\n     * id in the target model are reconnected to reflect the terminals of the\n     * source edges.\n     */\n    mergeChildren(from, to, cloneAllEdges = true) {\n        this.beginUpdate();\n        try {\n            const mapping = {};\n            this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);\n            // Post-processes all edges in the mapping and\n            // reconnects the terminals to the corresponding\n            // cells in the target model\n            for (const key in mapping) {\n                const cell = mapping[key];\n                let terminal = cell.getTerminal(true);\n                if (terminal != null) {\n                    terminal = mapping[CellPath.create(terminal)];\n                    this.setTerminal(cell, terminal, true);\n                }\n                terminal = cell.getTerminal(false);\n                if (terminal != null) {\n                    terminal = mapping[CellPath.create(terminal)];\n                    this.setTerminal(cell, terminal, false);\n                }\n            }\n        }\n        finally {\n            this.endUpdate();\n        }\n    }\n    /**\n     * Clones the children of the source cell into the given target cell in\n     * this model and adds an entry to the mapping that maps from the source\n     * cell to the target cell with the same id or the clone of the source cell\n     * that was inserted into this model.\n     */\n    mergeChildrenImpl(from, to, cloneAllEdges, mapping = {}) {\n        this.beginUpdate();\n        try {\n            const childCount = from.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const cell = from.getChildAt(i);\n                if (typeof cell.getId === 'function') {\n                    const id = cell.getId();\n                    let target = id != null && (!cell.isEdge() || !cloneAllEdges) ? this.getCell(id) : null;\n                    // Clones and adds the child if no cell exists for the id\n                    if (target == null) {\n                        const clone = cell.clone();\n                        clone.setId(id);\n                        // Sets the terminals from the original cell to the clone\n                        // because the lookup uses strings not cells in JS\n                        clone.setTerminal(cell.getTerminal(true), true);\n                        clone.setTerminal(cell.getTerminal(false), false);\n                        // Do *NOT* use model.add as this will move the edge away\n                        // from the parent in updateEdgeParent if maintainEdgeParent\n                        // is enabled in the target model\n                        target = to.insert(clone);\n                        this.cellAdded(target);\n                    }\n                    // Stores the mapping for later reconnecting edges\n                    mapping[CellPath.create(cell)] = target;\n                    // Recurses\n                    this.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);\n                }\n            }\n        }\n        finally {\n            this.endUpdate();\n        }\n    }\n}\nexport default GraphDataModel;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { ALIGN, ARROW, NONE, SHAPE } from '../../util/Constants';\n/**\n * Defines the appearance of the cells in a graph. See {@link putCellStyle} for an example\n * of creating a new cell style.\n *\n * Existing styles can be cloned using {@link clone} and turned into a string for debugging\n * using {@link toString}.\n *\n * ### Default Styles\n *\n * The stylesheet contains two built-in styles, which are used if no style is defined for\n * a cell:\n *\n * - `defaultVertex`: default style for vertices\n * - `defaultEdge`: default style for edges\n *\n * ### Example\n *\n * ```javascript\n * const defaultVertexStyle = stylesheet.getDefaultVertexStyle();\n * defaultVertexStyle.rounded = true;\n * const defaultEdgeStyle = stylesheet.getDefaultEdgeStyle();\n * defaultEdgeStyle.edgeStyle = EdgeStyle.EntityRelation;\n * ```\n */\nexport class Stylesheet {\n    constructor() {\n        this.styles = new Map();\n        this.putDefaultVertexStyle(this.createDefaultVertexStyle());\n        this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());\n    }\n    /**\n     * Creates and returns the default vertex style.\n     */\n    createDefaultVertexStyle() {\n        const style = {};\n        style.shape = SHAPE.RECTANGLE;\n        style.perimeter = 'rectanglePerimeter';\n        style.verticalAlign = ALIGN.MIDDLE;\n        style.align = ALIGN.CENTER;\n        style.fillColor = '#C3D9FF';\n        style.strokeColor = '#6482B9';\n        style.fontColor = '#774400';\n        return style;\n    }\n    /**\n     * Creates and returns the default edge style.\n     */\n    createDefaultEdgeStyle() {\n        const style = {};\n        style.shape = SHAPE.CONNECTOR;\n        style.endArrow = ARROW.CLASSIC;\n        style.verticalAlign = ALIGN.MIDDLE;\n        style.align = ALIGN.CENTER;\n        style.strokeColor = '#6482B9';\n        style.fontColor = '#446299';\n        return style;\n    }\n    /**\n     * Sets the default style for vertices using `defaultVertex` as the style name.\n     * @param style The style to be stored.\n     */\n    putDefaultVertexStyle(style) {\n        this.putCellStyle('defaultVertex', style);\n    }\n    /**\n     * Sets the default style for edges using `defaultEdge` as the style name.\n     * @param style The style to be stored.\n     */\n    putDefaultEdgeStyle(style) {\n        this.putCellStyle('defaultEdge', style);\n    }\n    /**\n     * Returns the default style for vertices.\n     */\n    getDefaultVertexStyle() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor\n        return this.styles.get('defaultVertex');\n    }\n    /**\n     * Returns the default style for edges.\n     */\n    getDefaultEdgeStyle() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the style is set in the constructor\n        return this.styles.get('defaultEdge');\n    }\n    /**\n     * Stores the given {@link CellStateStyle} under the given name in {@link styles}.\n     *\n     * ### Example\n     *\n     * The following example adds a new style called `rounded` into an existing stylesheet:\n     *\n     * ```javascript\n     * const style = {} as CellStateStyle;\n     * style.shape = SHAPE.RECTANGLE;\n     * style.perimeter = PERIMETER.RECTANGLE;\n     * style.rounded = true;\n     * graph.getStylesheet().putCellStyle('rounded', style);\n     * ```\n     *\n     * ### Description\n     *\n     * Note that not all properties will be interpreted by all shapes. For example, the 'line' shape ignores the fill color.\n     * The final call to this method associates the style with a name in the stylesheet.\n     *\n     * The style is used in a cell with the following code:\n     * ```javascript\n     * // model is an instance of GraphDataModel\n     * // style is an instance of CellStyle\n     * model.setStyle(cell, { baseStyleNames: ['rounded'] });\n     * ```\n     *\n     * @param name Name for the style to be stored.\n     * @param style The instance of the style to be stored.\n     */\n    putCellStyle(name, style) {\n        this.styles.set(name, style);\n    }\n    /**\n     * Returns a {@link CellStateStyle} computed by merging the default style, styles referenced in the specified `baseStyleNames`\n     * and the properties of the `cellStyle` parameter.\n     *\n     * The properties are merged by taking the properties from various styles in the following order:\n     *   - default style (if {@link CellStyle.ignoreDefaultStyle} is not set to `true`, otherwise it is ignored)\n     *   - registered styles referenced in `baseStyleNames`, in the order of the array\n     *   - `cellStyle` parameter\n     *\n     * To fully unset a style property i.e. the property is not set even if a value is set in the default style or in the referenced styles,\n     * set the `cellStyle` property to `none`. For example. `cellStyle.fillColor = 'none'`\n     *\n     * @param cellStyle An object that represents the style.\n     * @param defaultStyle Default style used as reference to compute the returned style.\n     */\n    getCellStyle(cellStyle, defaultStyle) {\n        let style = cellStyle.ignoreDefaultStyle ? {} : { ...defaultStyle };\n        if (cellStyle.baseStyleNames) {\n            // creates style with the given baseStyleNames. (merges from left to right)\n            style = cellStyle.baseStyleNames.reduce((acc, styleName) => {\n                return {\n                    ...acc,\n                    ...this.styles.get(styleName),\n                };\n            }, style);\n        }\n        // Merges cellStyle into style\n        for (const key of Object.keys(cellStyle)) {\n            // @ts-ignore\n            if (cellStyle[key] !== undefined) {\n                // @ts-ignore\n                cellStyle[key] == NONE ? delete style[key] : (style[key] = cellStyle[key]);\n            }\n        }\n        // Remove the specific CellStyle properties that may have been copied from the cellStyle parameter to match the method signature\n        'baseStyleNames' in style && delete style.baseStyleNames;\n        'ignoreDefaultStyle' in style && delete style.ignoreDefaultStyle;\n        return style;\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * Scales an array of {@link Point}\n *\n * @param points array of {@link Point} to scale\n * @param scale the scaling to divide by\n */\nexport function scalePointArray(points, scale) {\n    let result = [];\n    if (points != null) {\n        for (let i = 0; i < points.length; i += 1) {\n            if (points[i] != null) {\n                result[i] = new Point(Math.round((points[i].x / scale) * 10) / 10, Math.round((points[i].y / scale) * 10) / 10);\n            }\n            else {\n                result[i] = null;\n            }\n        }\n    }\n    else {\n        result = null;\n    }\n    return result;\n}\n/**\n * Scales an {@link CellState}.\n *\n * @param state {@link CellState} to scale\n * @param scale the scaling to divide by\n */\nexport function scaleCellState(state, scale) {\n    let result = null;\n    if (state != null) {\n        result = state.clone();\n        result.setRect(Math.round((state.x / scale) * 10) / 10, Math.round((state.y / scale) * 10) / 10, Math.round((state.width / scale) * 10) / 10, Math.round((state.height / scale) * 10) / 10);\n    }\n    return result;\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nexport const SideToSide = (state, source, target, points, result) => {\n    const { view } = state;\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (pt != null) {\n        pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    if (source != null && target != null) {\n        const l = Math.max(source.x, target.x);\n        const r = Math.min(source.x + source.width, target.x + target.width);\n        const x = pt != null ? pt.x : Math.round(r + (l - r) / 2);\n        let y1 = view.getRoutingCenterY(source);\n        let y2 = view.getRoutingCenterY(target);\n        if (pt != null) {\n            if (pt.y >= source.y && pt.y <= source.y + source.height) {\n                y1 = pt.y;\n            }\n            if (pt.y >= target.y && pt.y <= target.y + target.height) {\n                y2 = pt.y;\n            }\n        }\n        if (!contains(target, x, y1) && !contains(source, x, y1)) {\n            result.push(new Point(x, y1));\n        }\n        if (!contains(target, x, y2) && !contains(source, x, y2)) {\n            result.push(new Point(x, y2));\n        }\n        if (result.length === 1) {\n            if (pt != null) {\n                if (!contains(target, x, pt.y) && !contains(source, x, pt.y)) {\n                    result.push(new Point(x, pt.y));\n                }\n            }\n            else {\n                const t = Math.max(source.y, target.y);\n                const b = Math.min(source.y + source.height, target.y + target.height);\n                result.push(new Point(x, t + (b - t) / 2));\n            }\n        }\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nexport const TopToBottom = (state, source, target, points, result) => {\n    const { view } = state;\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (pt != null) {\n        pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    if (source != null && target != null) {\n        const t = Math.max(source.y, target.y);\n        const b = Math.min(source.y + source.height, target.y + target.height);\n        let x = view.getRoutingCenterX(source);\n        if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {\n            x = pt.x;\n        }\n        const y = pt != null ? pt.y : Math.round(b + (t - b) / 2);\n        if (!contains(target, x, y) && !contains(source, x, y)) {\n            result.push(new Point(x, y));\n        }\n        if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {\n            x = pt.x;\n        }\n        else {\n            x = view.getRoutingCenterX(target);\n        }\n        if (!contains(target, x, y) && !contains(source, x, y)) {\n            result.push(new Point(x, y));\n        }\n        if (result.length === 1) {\n            if (pt != null && result.length === 1) {\n                if (!contains(target, pt.x, y) && !contains(source, pt.x, y)) {\n                    result.push(new Point(pt.x, y));\n                }\n            }\n            else {\n                const l = Math.max(source.x, target.x);\n                const r = Math.min(source.x + source.width, target.x + target.width);\n                result.push(new Point(l + (r - l) / 2, y));\n            }\n        }\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { SideToSide } from './SideToSide';\nimport { TopToBottom } from './TopToBottom';\nimport { ELBOW } from '../../../util/Constants';\nexport const ElbowConnector = (state, source, target, points, result) => {\n    let pt = points != null && points.length > 0 ? points[0] : null;\n    let vertical = false;\n    let horizontal = false;\n    if (source != null && target != null) {\n        if (pt != null) {\n            const left = Math.min(source.x, target.x);\n            const right = Math.max(source.x + source.width, target.x + target.width);\n            const top = Math.min(source.y, target.y);\n            const bottom = Math.max(source.y + source.height, target.y + target.height);\n            pt = state.view.transformControlPoint(state, pt);\n            vertical = pt.y < top || pt.y > bottom;\n            horizontal = pt.x < left || pt.x > right;\n        }\n        else {\n            const left = Math.max(source.x, target.x);\n            const right = Math.min(source.x + source.width, target.x + target.width);\n            vertical = left === right;\n            if (!vertical) {\n                const top = Math.max(source.y, target.y);\n                const bottom = Math.min(source.y + source.height, target.y + target.height);\n                horizontal = top === bottom;\n            }\n        }\n    }\n    if (!horizontal && (vertical || state.style.elbow === ELBOW.VERTICAL)) {\n        TopToBottom(state, source, target, points, result);\n    }\n    else {\n        SideToSide(state, source, target, points, result);\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellState from '../../cell/CellState';\nimport Point from '../../geometry/Point';\nimport { DIRECTION_MASK, ENTITY_SEGMENT } from '../../../util/Constants';\nimport { getPortConstraints } from '../../../util/mathUtils';\nimport { getValue } from '../../../util/Utils';\nexport const EntityRelation = (state, source, target, _points, result) => {\n    const { view } = state;\n    const segment = getValue(state.style, 'segment', ENTITY_SEGMENT) * view.scale;\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    let isSourceLeft = false;\n    if (source != null) {\n        const sourceGeometry = source.cell.getGeometry();\n        if (sourceGeometry.relative) {\n            isSourceLeft = sourceGeometry.x <= 0.5;\n        }\n        else if (target != null) {\n            isSourceLeft =\n                (pe != null ? pe.x : target.x + target.width) < (p0 != null ? p0.x : source.x);\n        }\n    }\n    if (p0 != null) {\n        source = new CellState();\n        source.x = p0.x;\n        source.y = p0.y;\n    }\n    else if (source != null) {\n        const constraint = getPortConstraints(source, state, true, DIRECTION_MASK.NONE);\n        if (constraint !== DIRECTION_MASK.NONE &&\n            constraint !== DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {\n            isSourceLeft = constraint === DIRECTION_MASK.WEST;\n        }\n    }\n    else {\n        return;\n    }\n    let isTargetLeft = true;\n    if (target != null) {\n        const targetGeometry = target.cell.getGeometry();\n        if (targetGeometry.relative) {\n            isTargetLeft = targetGeometry.x <= 0.5;\n        }\n        else if (source != null) {\n            isTargetLeft =\n                (p0 != null ? p0.x : source.x + source.width) < (pe != null ? pe.x : target.x);\n        }\n    }\n    if (pe != null) {\n        target = new CellState();\n        target.x = pe.x;\n        target.y = pe.y;\n    }\n    else if (target != null) {\n        const constraint = getPortConstraints(target, state, false, DIRECTION_MASK.NONE);\n        if (constraint !== DIRECTION_MASK.NONE &&\n            constraint != DIRECTION_MASK.WEST + DIRECTION_MASK.EAST) {\n            isTargetLeft = constraint === DIRECTION_MASK.WEST;\n        }\n    }\n    if (source != null && target != null) {\n        const x0 = isSourceLeft ? source.x : source.x + source.width;\n        const y0 = view.getRoutingCenterY(source);\n        const xe = isTargetLeft ? target.x : target.x + target.width;\n        const ye = view.getRoutingCenterY(target);\n        const seg = segment;\n        let dx = isSourceLeft ? -seg : seg;\n        const dep = new Point(x0 + dx, y0);\n        dx = isTargetLeft ? -seg : seg;\n        const arr = new Point(xe + dx, ye);\n        // Adds intermediate points if both go out on same side\n        if (isSourceLeft === isTargetLeft) {\n            const x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;\n            result.push(new Point(x, y0));\n            result.push(new Point(x, ye));\n        }\n        else if (dep.x < arr.x === isSourceLeft) {\n            const midY = y0 + (ye - y0) / 2;\n            result.push(dep);\n            result.push(new Point(dep.x, midY));\n            result.push(new Point(arr.x, midY));\n            result.push(arr);\n        }\n        else {\n            result.push(dep);\n            result.push(arr);\n        }\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { contains } from '../../../util/mathUtils';\nimport { getValue } from '../../../util/Utils';\nexport const Loop = (state, source, _target, points, result) => {\n    const pts = state.absolutePoints;\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    if (p0 != null && pe != null) {\n        if (points != null && points.length > 0) {\n            for (let i = 0; i < points.length; i += 1) {\n                let pt = points[i];\n                pt = state.view.transformControlPoint(state, pt);\n                result.push(new Point(pt.x, pt.y));\n            }\n        }\n        return;\n    }\n    if (source != null) {\n        const { view } = state;\n        const { graph } = view;\n        let pt = points != null && points.length > 0 ? points[0] : null;\n        if (pt != null) {\n            pt = view.transformControlPoint(state, pt);\n            if (contains(source, pt.x, pt.y)) {\n                pt = null;\n            }\n        }\n        let x = 0;\n        let dx = 0;\n        let y = 0;\n        let dy = 0;\n        const seg = getValue(state.style, 'segment', graph.gridSize) * view.scale;\n        const dir = getValue(state.style, 'direction', DIRECTION.WEST);\n        if (dir === DIRECTION.NORTH || dir === DIRECTION.SOUTH) {\n            x = view.getRoutingCenterX(source);\n            dx = seg;\n        }\n        else {\n            y = view.getRoutingCenterY(source);\n            dy = seg;\n        }\n        if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {\n            if (pt != null) {\n                x = pt.x;\n                dy = Math.max(Math.abs(y - pt.y), dy);\n            }\n            else if (dir === DIRECTION.NORTH) {\n                y = source.y - 2 * dx;\n            }\n            else if (dir === DIRECTION.SOUTH) {\n                y = source.y + source.height + 2 * dx;\n            }\n            else if (dir === DIRECTION.EAST) {\n                x = source.x - 2 * dy;\n            }\n            else {\n                x = source.x + source.width + 2 * dy;\n            }\n        }\n        else if (pt !== null) {\n            x = view.getRoutingCenterX(source);\n            dx = Math.max(Math.abs(x - pt.x), dy);\n            y = pt.y;\n            dy = 0;\n        }\n        result.push(new Point(x - dx, y - dy));\n        result.push(new Point(x + dx, y + dy));\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { contains } from '../../../util/mathUtils';\nimport { scaleCellState, scalePointArray } from './shared';\nexport const SegmentConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n    // Creates array of all way- and terminal points\n    // TODO: Figure out what to do when there are nulls in `pts`!\n    const pts = scalePointArray(state.absolutePoints, state.view.scale);\n    const source = scaleCellState(sourceScaled, state.view.scale);\n    const target = scaleCellState(targetScaled, state.view.scale);\n    const tol = 1;\n    // Whether the first segment outgoing from the source end is horizontal\n    let lastPushed = result.length > 0 ? result[0] : null;\n    let horizontal = true;\n    let hint = null;\n    // Adds waypoints only if outside of tolerance\n    function pushPoint(pt) {\n        pt.x = Math.round(pt.x * state.view.scale * 10) / 10;\n        pt.y = Math.round(pt.y * state.view.scale * 10) / 10;\n        if (lastPushed == null ||\n            Math.abs(lastPushed.x - pt.x) >= tol ||\n            Math.abs(lastPushed.y - pt.y) >= Math.max(1, state.view.scale)) {\n            result.push(pt);\n            lastPushed = pt;\n        }\n        return lastPushed;\n    }\n    // Adds the first point\n    let pt = pts[0];\n    if (pt == null && source != null) {\n        pt = new Point(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n    }\n    else if (pt != null) {\n        pt = pt.clone();\n    }\n    const lastInx = pts.length - 1;\n    let pe = null;\n    // Adds the waypoints\n    if (controlHints != null && controlHints.length > 0) {\n        // Converts all hints and removes nulls\n        let hints = [];\n        for (let i = 0; i < controlHints.length; i += 1) {\n            const tmp = state.view.transformControlPoint(state, controlHints[i], true);\n            if (tmp != null) {\n                hints.push(tmp);\n            }\n        }\n        if (hints.length === 0) {\n            return;\n        }\n        // Aligns source and target hint to fixed points\n        if (pt != null && hints[0] != null) {\n            if (Math.abs(hints[0].x - pt.x) < tol) {\n                hints[0].x = pt.x;\n            }\n            if (Math.abs(hints[0].y - pt.y) < tol) {\n                hints[0].y = pt.y;\n            }\n        }\n        pe = pts[lastInx];\n        if (pe != null && hints[hints.length - 1] != null) {\n            if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {\n                hints[hints.length - 1].x = pe.x;\n            }\n            if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {\n                hints[hints.length - 1].y = pe.y;\n            }\n        }\n        hint = hints[0];\n        let currentTerm = source;\n        let currentPt = pts[0];\n        let hozChan = false;\n        let vertChan = false;\n        let currentHint = hint;\n        if (currentPt != null) {\n            currentTerm = null;\n        }\n        // Check for alignment with fixed points and with channels\n        // at source and target segments only\n        for (let i = 0; i < 2; i += 1) {\n            const fixedVertAlign = currentPt != null && currentPt.x === currentHint.x;\n            const fixedHozAlign = currentPt != null && currentPt.y === currentHint.y;\n            const inHozChan = currentTerm != null &&\n                currentHint.y >= currentTerm.y &&\n                currentHint.y <= currentTerm.y + currentTerm.height;\n            const inVertChan = currentTerm != null &&\n                currentHint.x >= currentTerm.x &&\n                currentHint.x <= currentTerm.x + currentTerm.width;\n            hozChan = fixedHozAlign || (currentPt == null && inHozChan);\n            vertChan = fixedVertAlign || (currentPt == null && inVertChan);\n            // If the current hint falls in both the hor and vert channels in the case\n            // of a floating port, or if the hint is exactly co-incident with a\n            // fixed point, ignore the source and try to work out the orientation\n            // from the target end\n            if (!(i == 0 && ((hozChan && vertChan) || (fixedVertAlign && fixedHozAlign)))) {\n                if (currentPt != null &&\n                    !fixedHozAlign &&\n                    !fixedVertAlign &&\n                    (inHozChan || inVertChan)) {\n                    horizontal = !inHozChan;\n                    break;\n                }\n                if (vertChan || hozChan) {\n                    horizontal = hozChan;\n                    if (i === 1) {\n                        // Work back from target end\n                        horizontal = hints.length % 2 === 0 ? hozChan : vertChan;\n                    }\n                    break;\n                }\n            }\n            currentTerm = target;\n            currentPt = pts[lastInx];\n            if (currentPt != null) {\n                currentTerm = null;\n            }\n            currentHint = hints[hints.length - 1];\n            if (fixedVertAlign && fixedHozAlign) {\n                hints = hints.slice(1);\n            }\n        }\n        if (horizontal &&\n            ((pts[0] != null && pts[0].y !== hint.y) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.y < source.y || hint.y > source.y + source.height)))) {\n            pushPoint(new Point(pt.x, hint.y));\n        }\n        else if (!horizontal &&\n            ((pts[0] != null && pts[0].x !== hint.x) ||\n                (pts[0] == null &&\n                    source != null &&\n                    (hint.x < source.x || hint.x > source.x + source.width)))) {\n            pushPoint(new Point(hint.x, pt.y));\n        }\n        if (horizontal) {\n            pt.y = hint.y;\n        }\n        else {\n            pt.x = hint.x;\n        }\n        for (let i = 0; i < hints.length; i += 1) {\n            horizontal = !horizontal;\n            hint = hints[i];\n            if (horizontal) {\n                pt.y = hint.y;\n            }\n            else {\n                pt.x = hint.x;\n            }\n            pushPoint(pt.clone());\n        }\n    }\n    else {\n        hint = pt;\n        // FIXME: First click in connect preview toggles orientation\n        horizontal = true;\n    }\n    // Adds the last point\n    pt = pts[lastInx];\n    if (pt == null && target != null) {\n        pt = new Point(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n    }\n    if (pt != null) {\n        if (hint != null) {\n            if (horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].y !== hint.y) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.y < target.y || hint.y > target.y + target.height)))) {\n                pushPoint(new Point(pt.x, hint.y));\n            }\n            else if (!horizontal &&\n                ((pts[lastInx] != null && pts[lastInx].x !== hint.x) ||\n                    (pts[lastInx] == null &&\n                        target != null &&\n                        (hint.x < target.x || hint.x > target.x + target.width)))) {\n                pushPoint(new Point(hint.x, pt.y));\n            }\n        }\n    }\n    // Removes bends inside the source terminal for floating ports\n    if (pts[0] == null && source != null) {\n        while (result.length > 1 &&\n            result[1] != null &&\n            contains(source, result[1].x, result[1].y)) {\n            result.splice(1, 1);\n        }\n    }\n    // Removes bends inside the target terminal\n    if (pts[lastInx] == null && target != null) {\n        while (result.length > 1 &&\n            result[result.length - 1] != null &&\n            contains(target, result[result.length - 1].x, result[result.length - 1].y)) {\n            result.splice(result.length - 1, 1);\n        }\n    }\n    // Removes last point if inside tolerance with end point\n    if (pe != null &&\n        result[result.length - 1] != null &&\n        Math.abs(pe.x - result[result.length - 1].x) <= tol &&\n        Math.abs(pe.y - result[result.length - 1].y) <= tol) {\n        result.splice(result.length - 1, 1);\n        // Lines up second last point in result with end point\n        if (result[result.length - 1] != null) {\n            if (Math.abs(result[result.length - 1].x - pe.x) < tol) {\n                result[result.length - 1].x = pe.x;\n            }\n            if (Math.abs(result[result.length - 1].y - pe.y) < tol) {\n                result[result.length - 1].y = pe.y;\n            }\n        }\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nvar _a;\nimport { getValue } from '../../util/Utils';\nimport { getNumber } from '../../util/StringUtils';\nimport { getBoundingBox, getPortConstraints, reversePortConstraints, } from '../../util/mathUtils';\nimport Point from '../geometry/Point';\nimport { DEFAULT_MARKERSIZE, DIRECTION, DIRECTION_MASK, NONE, } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport Geometry from '../geometry/Geometry';\nimport { scaleCellState, scalePointArray } from './edge/shared';\nimport { ElbowConnector as ElbowConnectorFunction } from './edge/Elbow';\nimport { EntityRelation as EntityRelationFunction } from './edge/EntityRelation';\nimport { Loop as LoopFunction } from './edge/Loop';\nimport { SegmentConnector as SegmentConnectorFunction } from './edge/Segment';\nimport { SideToSide as SideToSideFunction } from './edge/SideToSide';\nimport { TopToBottom as TopToBottomFunction } from './edge/TopToBottom';\n/**\n * Provides various edge styles to be used as the values for `edgeStyle` in a cell style.\n *\n * Example:\n *\n * ```javascript\n * let style = stylesheet.getDefaultEdgeStyle();\n * style.edgeStyle = EdgeStyle.ElbowConnector;\n * ```\n *\n * Sets the default edge style to `ElbowConnector`.\n *\n * Custom edge style:\n *\n * To write a custom edge style, a function must be added to the EdgeStyle object as follows:\n *\n * ```javascript\n * EdgeStyle.MyStyle = (state, source, target, points, result)=>\n * {\n *   if (source != null && target != null)\n *   {\n *     let pt = new Point(target.getCenterX(), source.getCenterY());\n *\n *     if (Utils.contains(source, pt.x, pt.y))\n *     {\n *       pt.y = source.y + source.height;\n *     }\n *\n *     result.push(pt);\n *   }\n * };\n * ```\n *\n * In the above example, a right angle is created using a point on the\n * horizontal center of the target vertex and the vertical center of the source\n * vertex. The code checks if that point intersects the source vertex and makes\n * the edge straight if it does. The point is then added into the result array,\n * which acts as the return value of the function.\n *\n * The new edge style should then be registered in the {@link StyleRegistry} as follows:\n * ```javascript\n * StyleRegistry.putValue('myEdgeStyle', EdgeStyle.MyStyle);\n * ```\n *\n * The custom edge style above can now be used in a specific edge as follows:\n *\n * ```javascript\n * style.edgeStyle = 'myEdgeStyle';\n * ```\n *\n * Note that the key of the {@link StyleRegistry} entry for the function should\n * be used in string values, unless {@link GraphView#allowEval} is true, in\n * which case you can also use `EdgeStyle.MyStyle` for the value in the\n * cell style above.\n *\n * Or it can be used for all edges in the graph as follows:\n *\n * ```javascript\n * let style = graph.getStylesheet().getDefaultEdgeStyle();\n * style.edgeStyle = EdgeStyle.MyStyle;\n * ```\n *\n * Note that the object can be used directly when programmatically setting\n * the value, but the key in the {@link StyleRegistry} should be used when\n * setting the value via a key, value pair in a cell style.\n */\nclass EdgeStyle {\n    // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,\n    static getJettySize(state, isSource) {\n        let value = getValue(state.style, isSource ? 'sourceJettySize' : 'targetJettySize', getValue(state.style, 'jettySize', _a.orthBuffer));\n        if (value === 'auto') {\n            // Computes the automatic jetty size\n            const type = getValue(state.style, isSource ? 'startArrow' : 'endArrow', NONE);\n            if (type !== NONE) {\n                const size = getNumber(state.style, isSource ? 'startSize' : 'endSize', DEFAULT_MARKERSIZE);\n                value =\n                    Math.max(2, Math.ceil((size + _a.orthBuffer) / _a.orthBuffer)) *\n                        _a.orthBuffer;\n            }\n            else {\n                value = 2 * _a.orthBuffer;\n            }\n        }\n        return value;\n    }\n    static getRoutePattern(dir, quad, dx, dy) {\n        let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];\n        let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];\n        sourceIndex -= quad;\n        targetIndex -= quad;\n        if (sourceIndex < 1) {\n            sourceIndex += 4;\n        }\n        if (targetIndex < 1) {\n            targetIndex += 4;\n        }\n        let result = _a.routePatterns[sourceIndex - 1][targetIndex - 1];\n        if (dx === 0 || dy === 0) {\n            if (_a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {\n                result = _a.inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];\n            }\n        }\n        return result;\n    }\n}\n_a = EdgeStyle;\n/**\n * Implements an entity relation style for edges (as used in database\n * schema diagrams). At the time the function is called, the result\n * array contains a placeholder (null) for the first absolute point,\n * that is, the point where the edge and source terminal are connected.\n * The implementation of the style then adds all intermediate waypoints\n * except for the last point, that is, the connection point between the\n * edge and the target terminal. The first ant the last point in the\n * result array are then replaced with Point that take into account\n * the terminal's perimeter and next point on the edge.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param source {@link CellState} that represents the source terminal.\n * @param target {@link CellState} that represents the target terminal.\n * @param points List of relative control points.\n * @param result Array of {@link Point} that represent the actual points of the edge.\n */\nEdgeStyle.EntityRelation = EntityRelationFunction;\n/**\n * Implements a self-reference, aka. loop.\n */\nEdgeStyle.Loop = LoopFunction;\n/**\n * Uses either {@link SideToSide} or {@link TopToBottom} depending on the horizontal flag in the cell style.\n * {@link SideToSide} is used if horizontal is `true` or unspecified.\n */\nEdgeStyle.ElbowConnector = ElbowConnectorFunction;\n/**\n * Implements a vertical elbow edge.\n */\nEdgeStyle.SideToSide = SideToSideFunction;\n/**\n * Implements a horizontal elbow edge.\n */\nEdgeStyle.TopToBottom = TopToBottomFunction;\n/**\n * Implements an orthogonal edge style. Use {@link EdgeSegmentHandler}\n * as an interactive handler for this style.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param sourceScaled {@link CellState} that represents the source terminal.\n * @param targetScaled {@link CellState} that represents the target terminal.\n * @param controlHints List of relative control points.\n * @param result Array of {@link Point} that represent the actual points of the edge.\n */\nEdgeStyle.SegmentConnector = SegmentConnectorFunction;\nEdgeStyle.orthBuffer = 10;\nEdgeStyle.orthPointsFallback = true;\nEdgeStyle.dirVectors = [\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n    [0, 1],\n    [-1, 0],\n    [0, -1],\n    [1, 0],\n];\nEdgeStyle.wayPoints1 = [\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n    [0, 0],\n];\nEdgeStyle.routePatterns = [\n    [\n        [513, 2308, 2081, 2562],\n        [513, 1090, 514, 2184, 2114, 2561],\n        [513, 1090, 514, 2564, 2184, 2562],\n        [513, 2308, 2561, 1090, 514, 2568, 2308],\n    ],\n    [\n        [514, 1057, 513, 2308, 2081, 2562],\n        [514, 2184, 2114, 2561],\n        [514, 2184, 2562, 1057, 513, 2564, 2184],\n        [514, 1057, 513, 2568, 2308, 2561],\n    ],\n    [\n        [1090, 514, 1057, 513, 2308, 2081, 2562],\n        [2114, 2561],\n        [1090, 2562, 1057, 513, 2564, 2184],\n        [1090, 514, 1057, 513, 2308, 2561, 2568],\n    ],\n    [\n        [2081, 2562],\n        [1057, 513, 1090, 514, 2184, 2114, 2561],\n        [1057, 513, 1090, 514, 2184, 2562, 2564],\n        [1057, 2561, 1090, 514, 2568, 2308],\n    ],\n];\nEdgeStyle.inlineRoutePatterns = [\n    [null, [2114, 2568], null, null],\n    [null, [514, 2081, 2114, 2568], null, null],\n    [null, [2114, 2561], null, null],\n    [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null],\n];\nEdgeStyle.vertexSeperations = [];\nEdgeStyle.limits = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n];\nEdgeStyle.LEFT_MASK = 32;\nEdgeStyle.TOP_MASK = 64;\nEdgeStyle.RIGHT_MASK = 128;\nEdgeStyle.BOTTOM_MASK = 256;\nEdgeStyle.LEFT = 1;\nEdgeStyle.TOP = 2;\nEdgeStyle.RIGHT = 4;\nEdgeStyle.BOTTOM = 8;\n// TODO remove magic numbers\nEdgeStyle.SIDE_MASK = 480;\n// mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK\n// | mxEdgeStyle.BOTTOM_MASK,\nEdgeStyle.CENTER_MASK = 512;\nEdgeStyle.SOURCE_MASK = 1024;\nEdgeStyle.TARGET_MASK = 2048;\nEdgeStyle.VERTEX_MASK = 3072;\n/**\n * Implements a local orthogonal router between the given cells.\n *\n * @param state {@link CellState} that represents the edge to be updated.\n * @param sourceScaled {@link CellState} that represents the source terminal.\n * @param targetScaled {@link CellState} that represents the target terminal.\n * @param controlHints List of relative control {@link Point}s.\n * @param result Array of {@link Point}s that represent the actual points of the\n * edge.\n */\nEdgeStyle.OrthConnector = (state, sourceScaled, targetScaled, controlHints, result) => {\n    // TODO: Figure out what to do when there are nulls in `pts`!\n    const pts = scalePointArray(state.absolutePoints, state.view.scale);\n    const source = scaleCellState(sourceScaled, state.view.scale);\n    const target = scaleCellState(targetScaled, state.view.scale);\n    const sourceEdge = source == null ? false : source.cell.isEdge();\n    const targetEdge = target == null ? false : target.cell.isEdge();\n    const p0 = pts[0];\n    const pe = pts[pts.length - 1];\n    let sourceX = source != null ? source.x : p0.x;\n    let sourceY = source != null ? source.y : p0.y;\n    let sourceWidth = source != null ? source.width : 0;\n    let sourceHeight = source != null ? source.height : 0;\n    let targetX = target != null ? target.x : pe.x;\n    let targetY = target != null ? target.y : pe.y;\n    let targetWidth = target != null ? target.width : 0;\n    let targetHeight = target != null ? target.height : 0;\n    let sourceBuffer = _a.getJettySize(state, true);\n    let targetBuffer = _a.getJettySize(state, false);\n    // Workaround for loop routing within buffer zone\n    if (source != null && target === source) {\n        targetBuffer = Math.max(sourceBuffer, targetBuffer);\n        sourceBuffer = targetBuffer;\n    }\n    const totalBuffer = targetBuffer + sourceBuffer;\n    let tooShort = false;\n    // Checks minimum distance for fixed points and falls back to segment connector\n    if (p0 != null && pe != null) {\n        const dx = pe.x - p0.x;\n        const dy = pe.y - p0.y;\n        tooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;\n    }\n    if (tooShort ||\n        (_a.orthPointsFallback && controlHints != null && controlHints.length > 0) ||\n        sourceEdge ||\n        targetEdge) {\n        _a.SegmentConnector(state, sourceScaled, targetScaled, controlHints, result);\n        return;\n    }\n    // Determine the side(s) of the source and target vertices\n    // that the edge may connect to\n    // portConstraint [source, target]\n    const portConstraint = [DIRECTION_MASK.ALL, DIRECTION_MASK.ALL];\n    let rotation = 0;\n    if (source != null) {\n        portConstraint[0] = getPortConstraints(source, state, true, DIRECTION_MASK.ALL);\n        rotation = source.style.rotation ?? 0;\n        if (rotation !== 0) {\n            const newRect = (getBoundingBox(new Rectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation));\n            sourceX = newRect.x;\n            sourceY = newRect.y;\n            sourceWidth = newRect.width;\n            sourceHeight = newRect.height;\n        }\n    }\n    if (target != null) {\n        portConstraint[1] = getPortConstraints(target, state, false, DIRECTION_MASK.ALL);\n        rotation = target.style.rotation ?? 0;\n        if (rotation !== 0) {\n            const newRect = (getBoundingBox(new Rectangle(targetX, targetY, targetWidth, targetHeight), rotation));\n            targetX = newRect.x;\n            targetY = newRect.y;\n            targetWidth = newRect.width;\n            targetHeight = newRect.height;\n        }\n    }\n    const dir = [0, 0];\n    // Work out which faces of the vertices present against each other\n    // in a way that would allow a 3-segment connection if port constraints\n    // permitted.\n    // geo -> [source, target] [x, y, width, height]\n    const geo = [\n        [sourceX, sourceY, sourceWidth, sourceHeight],\n        [targetX, targetY, targetWidth, targetHeight],\n    ];\n    const buffer = [sourceBuffer, targetBuffer];\n    for (let i = 0; i < 2; i += 1) {\n        _a.limits[i][1] = geo[i][0] - buffer[i];\n        _a.limits[i][2] = geo[i][1] - buffer[i];\n        _a.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];\n        _a.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];\n    }\n    // Work out which quad the target is in\n    const sourceCenX = geo[0][0] + geo[0][2] / 2.0;\n    const sourceCenY = geo[0][1] + geo[0][3] / 2.0;\n    const targetCenX = geo[1][0] + geo[1][2] / 2.0;\n    const targetCenY = geo[1][1] + geo[1][3] / 2.0;\n    const dx = sourceCenX - targetCenX;\n    const dy = sourceCenY - targetCenY;\n    let quad = 0;\n    // 0 | 1\n    // -----\n    // 3 | 2\n    if (dx < 0) {\n        if (dy < 0) {\n            quad = 2;\n        }\n        else {\n            quad = 1;\n        }\n    }\n    else if (dy <= 0) {\n        quad = 3;\n        // Special case on x = 0 and negative y\n        if (dx === 0) {\n            quad = 2;\n        }\n    }\n    // Check for connection constraints\n    let currentTerm = null;\n    if (source != null) {\n        currentTerm = p0;\n    }\n    const constraint = [\n        [0.5, 0.5],\n        [0.5, 0.5],\n    ];\n    for (let i = 0; i < 2; i += 1) {\n        if (currentTerm != null) {\n            constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];\n            if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {\n                dir[i] = DIRECTION_MASK.WEST;\n            }\n            else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {\n                dir[i] = DIRECTION_MASK.EAST;\n            }\n            constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];\n            if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {\n                dir[i] = DIRECTION_MASK.NORTH;\n            }\n            else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {\n                dir[i] = DIRECTION_MASK.SOUTH;\n            }\n        }\n        currentTerm = null;\n        if (target != null) {\n            currentTerm = pe;\n        }\n    }\n    const sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);\n    const sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);\n    const sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);\n    const sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);\n    _a.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);\n    _a.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);\n    _a.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);\n    _a.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);\n    //= =============================================================\n    // Start of source and target direction determination\n    // Work through the preferred orientations by relative positioning\n    // of the vertices and list them in preferred and available order\n    const dirPref = [];\n    const horPref = [];\n    const vertPref = [];\n    horPref[0] =\n        sourceLeftDist >= sourceRightDist ? DIRECTION_MASK.WEST : DIRECTION_MASK.EAST;\n    vertPref[0] =\n        sourceTopDist >= sourceBottomDist ? DIRECTION_MASK.NORTH : DIRECTION_MASK.SOUTH;\n    horPref[1] = reversePortConstraints(horPref[0]);\n    vertPref[1] = reversePortConstraints(vertPref[0]);\n    const preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;\n    const preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;\n    const prefOrdering = [\n        [0, 0],\n        [0, 0],\n    ];\n    let preferredOrderSet = false;\n    // If the preferred port isn't available, switch it\n    for (let i = 0; i < 2; i += 1) {\n        if (dir[i] !== 0x0) {\n            continue;\n        }\n        if ((horPref[i] & portConstraint[i]) === 0) {\n            horPref[i] = reversePortConstraints(horPref[i]);\n        }\n        if ((vertPref[i] & portConstraint[i]) === 0) {\n            vertPref[i] = reversePortConstraints(vertPref[i]);\n        }\n        prefOrdering[i][0] = vertPref[i];\n        prefOrdering[i][1] = horPref[i];\n    }\n    if (preferredVertDist > 0 && preferredHorizDist > 0) {\n        // Possibility of two segment edge connection\n        if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {\n            prefOrdering[0][0] = horPref[0];\n            prefOrdering[0][1] = vertPref[0];\n            prefOrdering[1][0] = vertPref[1];\n            prefOrdering[1][1] = horPref[1];\n            preferredOrderSet = true;\n        }\n        else if ((vertPref[0] & portConstraint[0]) > 0 &&\n            (horPref[1] & portConstraint[1]) > 0) {\n            prefOrdering[0][0] = vertPref[0];\n            prefOrdering[0][1] = horPref[0];\n            prefOrdering[1][0] = horPref[1];\n            prefOrdering[1][1] = vertPref[1];\n            preferredOrderSet = true;\n        }\n    }\n    if (preferredVertDist > 0 && !preferredOrderSet) {\n        prefOrdering[0][0] = vertPref[0];\n        prefOrdering[0][1] = horPref[0];\n        prefOrdering[1][0] = vertPref[1];\n        prefOrdering[1][1] = horPref[1];\n        preferredOrderSet = true;\n    }\n    if (preferredHorizDist > 0 && !preferredOrderSet) {\n        prefOrdering[0][0] = horPref[0];\n        prefOrdering[0][1] = vertPref[0];\n        prefOrdering[1][0] = horPref[1];\n        prefOrdering[1][1] = vertPref[1];\n        preferredOrderSet = true;\n    }\n    // The source and target prefs are now an ordered list of\n    // the preferred port selections\n    // If the list contains gaps, compact it\n    for (let i = 0; i < 2; i += 1) {\n        if (dir[i] !== 0x0) {\n            continue;\n        }\n        if ((prefOrdering[i][0] & portConstraint[i]) === 0) {\n            prefOrdering[i][0] = prefOrdering[i][1];\n        }\n        dirPref[i] = prefOrdering[i][0] & portConstraint[i];\n        dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;\n        dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;\n        dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;\n        if ((dirPref[i] & 0xf) === 0) {\n            dirPref[i] = dirPref[i] << 8;\n        }\n        if ((dirPref[i] & 0xf00) === 0) {\n            dirPref[i] = (dirPref[i] & 0xf) | (dirPref[i] >> 8);\n        }\n        if ((dirPref[i] & 0xf0000) === 0) {\n            dirPref[i] = (dirPref[i] & 0xffff) | ((dirPref[i] & 0xf000000) >> 8);\n        }\n        dir[i] = dirPref[i] & 0xf;\n        if (portConstraint[i] === DIRECTION_MASK.WEST ||\n            portConstraint[i] === DIRECTION_MASK.NORTH ||\n            portConstraint[i] === DIRECTION_MASK.EAST ||\n            portConstraint[i] === DIRECTION_MASK.SOUTH) {\n            dir[i] = portConstraint[i];\n        }\n    }\n    //= =============================================================\n    // End of source and target direction determination\n    let sourceIndex = dir[0] === DIRECTION_MASK.EAST ? 3 : dir[0];\n    let targetIndex = dir[1] === DIRECTION_MASK.EAST ? 3 : dir[1];\n    sourceIndex -= quad;\n    targetIndex -= quad;\n    if (sourceIndex < 1) {\n        sourceIndex += 4;\n    }\n    if (targetIndex < 1) {\n        targetIndex += 4;\n    }\n    const routePattern = _a.routePatterns[sourceIndex - 1][targetIndex - 1];\n    _a.wayPoints1[0][0] = geo[0][0];\n    _a.wayPoints1[0][1] = geo[0][1];\n    switch (dir[0]) {\n        case DIRECTION_MASK.WEST:\n            _a.wayPoints1[0][0] -= sourceBuffer;\n            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n            break;\n        case DIRECTION_MASK.SOUTH:\n            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n            _a.wayPoints1[0][1] += geo[0][3] + sourceBuffer;\n            break;\n        case DIRECTION_MASK.EAST:\n            _a.wayPoints1[0][0] += geo[0][2] + sourceBuffer;\n            _a.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n            break;\n        case DIRECTION_MASK.NORTH:\n            _a.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n            _a.wayPoints1[0][1] -= sourceBuffer;\n            break;\n    }\n    let currentIndex = 0;\n    // Orientation, 0 horizontal, 1 vertical\n    let lastOrientation = (dir[0] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;\n    const initialOrientation = lastOrientation;\n    let currentOrientation = 0;\n    for (let i = 0; i < routePattern.length; i += 1) {\n        const nextDirection = routePattern[i] & 0xf;\n        // Rotate the index of this direction by the quad\n        // to get the real direction\n        let directionIndex = nextDirection === DIRECTION_MASK.EAST ? 3 : nextDirection;\n        directionIndex += quad;\n        if (directionIndex > 4) {\n            directionIndex -= 4;\n        }\n        const direction = _a.dirVectors[directionIndex - 1];\n        currentOrientation = directionIndex % 2 > 0 ? 0 : 1;\n        // Only update the current index if the point moved\n        // in the direction of the current segment move,\n        // otherwise the same point is moved until there is\n        // a segment direction change\n        if (currentOrientation !== lastOrientation) {\n            currentIndex++;\n            // Copy the previous way point into the new one\n            // We can't base the new position on index - 1\n            // because sometime elbows turn out not to exist,\n            // then we'd have to rewind.\n            _a.wayPoints1[currentIndex][0] = _a.wayPoints1[currentIndex - 1][0];\n            _a.wayPoints1[currentIndex][1] = _a.wayPoints1[currentIndex - 1][1];\n        }\n        const tar = (routePattern[i] & _a.TARGET_MASK) > 0;\n        const sou = (routePattern[i] & _a.SOURCE_MASK) > 0;\n        let side = (routePattern[i] & _a.SIDE_MASK) >> 5;\n        side <<= quad;\n        if (side > 0xf) {\n            side >>= 4;\n        }\n        const center = (routePattern[i] & _a.CENTER_MASK) > 0;\n        if ((sou || tar) && side < 9) {\n            let limit = 0;\n            const souTar = sou ? 0 : 1;\n            if (center && currentOrientation === 0) {\n                limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];\n            }\n            else if (center) {\n                limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];\n            }\n            else {\n                limit = _a.limits[souTar][side];\n            }\n            if (currentOrientation === 0) {\n                const lastX = _a.wayPoints1[currentIndex][0];\n                const deltaX = (limit - lastX) * direction[0];\n                if (deltaX > 0) {\n                    _a.wayPoints1[currentIndex][0] += direction[0] * deltaX;\n                }\n            }\n            else {\n                const lastY = _a.wayPoints1[currentIndex][1];\n                const deltaY = (limit - lastY) * direction[1];\n                if (deltaY > 0) {\n                    _a.wayPoints1[currentIndex][1] += direction[1] * deltaY;\n                }\n            }\n        }\n        else if (center) {\n            // Which center we're travelling to depend on the current direction\n            _a.wayPoints1[currentIndex][0] +=\n                direction[0] * Math.abs(_a.vertexSeperations[directionIndex] / 2);\n            _a.wayPoints1[currentIndex][1] +=\n                direction[1] * Math.abs(_a.vertexSeperations[directionIndex] / 2);\n        }\n        if (currentIndex > 0 &&\n            _a.wayPoints1[currentIndex][currentOrientation] ===\n                _a.wayPoints1[currentIndex - 1][currentOrientation]) {\n            currentIndex--;\n        }\n        else {\n            lastOrientation = currentOrientation;\n        }\n    }\n    for (let i = 0; i <= currentIndex; i += 1) {\n        if (i === currentIndex) {\n            // Last point can cause last segment to be in\n            // same direction as jetty/approach. If so,\n            // check the number of points is consistent\n            // with the relative orientation of source and target\n            // jx. Same orientation requires an even\n            // number of turns (points), different requires\n            // odd.\n            const targetOrientation = (dir[1] & (DIRECTION_MASK.EAST | DIRECTION_MASK.WEST)) > 0 ? 0 : 1;\n            const sameOrient = targetOrientation === initialOrientation ? 0 : 1;\n            // (currentIndex + 1) % 2 is 0 for even number of points,\n            // 1 for odd\n            if (sameOrient !== (currentIndex + 1) % 2) {\n                // The last point isn't required\n                break;\n            }\n        }\n        result.push(new Point(Math.round(_a.wayPoints1[i][0] * state.view.scale * 10) / 10, Math.round(_a.wayPoints1[i][1] * state.view.scale * 10) / 10));\n    }\n    // Removes duplicates\n    let index = 1;\n    while (index < result.length) {\n        if (result[index - 1] == null ||\n            result[index] == null ||\n            result[index - 1].x !== result[index].x ||\n            result[index - 1].y !== result[index].y) {\n            index++;\n        }\n        else {\n            result.splice(index, 1);\n        }\n    }\n};\n// Size of the step to find a route\nEdgeStyle.MANHATTAN_STEP = 12;\n// If number of route finding loops exceed the maximum, stops searching and returns\n// fallback route\nEdgeStyle.MANHATTAN_MAXIMUM_LOOPS = 2000;\n// Possible starting directions from an element\nEdgeStyle.MANHATTAN_START_DIRECTIONS = [\n    DIRECTION.NORTH,\n    DIRECTION.EAST,\n    DIRECTION.SOUTH,\n    DIRECTION.WEST,\n];\n// Possible ending directions to an element\nEdgeStyle.MANHATTAN_END_DIRECTIONS = [\n    DIRECTION.NORTH,\n    DIRECTION.EAST,\n    DIRECTION.SOUTH,\n    DIRECTION.WEST,\n];\n// Limit for directions change when searching route\nEdgeStyle.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE = 90;\nEdgeStyle.MANHATTAN_PADDING_BOX = new Geometry(-_a.MANHATTAN_STEP, -_a.MANHATTAN_STEP, _a.MANHATTAN_STEP * 2, _a.MANHATTAN_STEP * 2);\n/**\n * ManhattanConnector code is based on code from https://github.com/mwangm/mxgraph-manhattan-connector\n *\n * Implements router to find the shortest route that avoids cells using manhattan distance as metric.\n */\nEdgeStyle.ManhattanConnector = (state, source, target, points, result) => {\n    /**\n     * Adds all values from source geometry to target.\n     * Used to create padding box around cell geometry.\n     * @param target\n     * @param source\n     * @returns\n     */\n    function moveAndExpand(target, source) {\n        target.x += source.x || 0;\n        target.y += source.y || 0;\n        target.width += source.width || 0;\n        target.height += source.height || 0;\n        return target;\n    }\n    function snapCoordinateToGrid(value, gridSize) {\n        return gridSize * Math.round(value / gridSize);\n    }\n    function snapPointToGrid(p, gx, gy) {\n        p.x = snapCoordinateToGrid(p.x, gx);\n        p.y = snapCoordinateToGrid(p.y, gy || gx);\n        return p;\n    }\n    function isPointInRectangle(rect, p) {\n        return (p.x >= rect.x &&\n            p.x <= rect.x + rect.width &&\n            p.y >= rect.y &&\n            p.y <= rect.y + rect.height);\n    }\n    function getRectangleCenter(rect) {\n        return new Point(rect.x + rect.width / 2, rect.y + rect.height / 2);\n    }\n    function getDifferencePoint(p1, p2) {\n        return new Point(p1.x - p2.x, p1.y - p2.y);\n    }\n    function movePoint(p, moveX, moveY) {\n        p.x += moveX || 0;\n        p.y += moveY || 0;\n        return p;\n    }\n    function getPointTheta(p1, p2) {\n        const p = p2.clone();\n        const y = -(p.y - p1.y);\n        const x = p.x - p1.x;\n        const PRECISION = 10;\n        const rad = y.toFixed(PRECISION) == '0' && x.toFixed(PRECISION) == '0' ? 0 : Math.atan2(y, x);\n        return (180 * rad) / Math.PI;\n    }\n    function normalizePoint(point) {\n        return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n    }\n    function getManhattanDistance(p1, p2) {\n        return Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y);\n    }\n    function toPointFromString(pointString) {\n        const xy = pointString.split(pointString.indexOf('@') === -1 ? ' ' : '@');\n        return new Point(parseInt(xy[0], 10), parseInt(xy[1], 10));\n    }\n    function pointToString(point) {\n        return `${point.x}@${point.y}`;\n    }\n    function getCellAbsoluteBounds(cellState) {\n        const graph = cellState.view.graph;\n        const cellBounds = graph.getCellBounds(cellState.cell, false, false)?.clone();\n        if (!cellBounds)\n            return undefined;\n        const view = graph.view;\n        const { scale, translate } = view;\n        const { x, y } = translate;\n        const round = (v) => Math.round(v * 10) / 10;\n        const res = new Rectangle(round(cellBounds.x / scale - x), round(cellBounds.y / scale - y), round(cellBounds.width / scale), round(cellBounds.height / scale));\n        return res;\n    }\n    const mStep = _a.MANHATTAN_STEP;\n    const config = {\n        // Padding applied on the element bounding boxes\n        paddingBox: _a.MANHATTAN_PADDING_BOX,\n        // An array of directions to find next points on the route\n        directions: [\n            {\n                offsetX: mStep,\n                offsetY: 0,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(mStep, 0))),\n            },\n            {\n                offsetX: 0,\n                offsetY: mStep,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, mStep))),\n            },\n            {\n                offsetX: -mStep,\n                offsetY: 0,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(-mStep, 0))),\n            },\n            {\n                offsetX: 0,\n                offsetY: -mStep,\n                cost: mStep,\n                angle: normalizeAngle(getPointTheta(new Point(0, 0), new Point(0, -mStep))),\n            },\n        ],\n        directionMap: {\n            east: { x: 1, y: 0 },\n            south: { x: 0, y: 1 },\n            west: { x: -1, y: 0 },\n            north: { x: 0, y: -1 },\n        },\n        // A penalty received for direction change\n        penaltiesGenerator: (angle) => {\n            if (angle == 45 || angle == 90 || angle == 180)\n                return _a.MANHATTAN_STEP / 2;\n            return 0;\n        },\n        // If a function is provided, it's used to route the link while dragging an end\n        // i.e. function(from, to, opts) { return []; }\n        draggingRoute: null,\n        previousDirAngle: 0,\n    };\n    /**\n     * Map of obstacles\n     * Helper structure to identify whether a point lies in an obstacle.\n     */\n    class ObstacleMap {\n        constructor(opt) {\n            this.options = opt;\n            this.mapGridSize = 100;\n            this.map = new Map();\n        }\n        // Builds a map of all elements for quicker obstacle queries\n        // The svg is divided to  cells, where each of them holds an information which\n        // elements belong to it. When we query whether a point is in an obstacle we don't need\n        // to go through all obstacles, we check only those in a particular cell.\n        build(source, target) {\n            const graph = source?.view.graph || target?.view.graph;\n            if (!graph)\n                return;\n            return Array.from(graph.getView().getCellStates())\n                .filter((s) => s.cell && s.cell.isVertex() && !s.cell.isEdge())\n                .map((s) => getCellAbsoluteBounds(s))\n                .map((bbox) => (bbox ? moveAndExpand(bbox, this.options.paddingBox) : null))\n                .forEach((bbox) => {\n                if (!bbox)\n                    return;\n                const origin = snapPointToGrid(new Point(bbox.x, bbox.y), this.mapGridSize);\n                const corner = snapPointToGrid(new Point(bbox.x + bbox.width, bbox.y + bbox.height), this.mapGridSize);\n                for (let x = origin.x; x <= corner.x; x += this.mapGridSize) {\n                    for (let y = origin.y; y <= corner.y; y += this.mapGridSize) {\n                        const gridKey = x + '@' + y;\n                        const rectArr = this.map.get(gridKey) || [];\n                        if (!this.map.has(gridKey))\n                            this.map.set(gridKey, rectArr);\n                        rectArr.push(bbox);\n                    }\n                }\n            });\n        }\n        isPointAccessible(point) {\n            const mapKey = pointToString(snapPointToGrid(point.clone(), this.mapGridSize));\n            const obstacles = this.map.get(mapKey);\n            if (obstacles) {\n                return obstacles.every((obstacle) => !isPointInRectangle(obstacle, point));\n            }\n            return true;\n        }\n    }\n    class SortedSet {\n        constructor() {\n            this.items = [];\n            this.hash = new Map();\n        }\n        add(key, value) {\n            const hashItem = this.hash.get(key);\n            if (hashItem) {\n                hashItem.value = value;\n                this.items.splice(this.items.indexOf(key), 1);\n            }\n            else {\n                this.hash.set(key, {\n                    value,\n                    open: true,\n                });\n            }\n            this.items.push(key);\n            this.items.sort((i1, i2) => {\n                const hashItem1 = this.hash.get(i1);\n                const hashItem2 = this.hash.get(i2);\n                if (!hashItem1 || !hashItem2)\n                    return 0;\n                return hashItem1.value - hashItem2.value;\n            });\n        }\n        remove(key) {\n            const hashItem = this.hash.get(key);\n            if (hashItem)\n                hashItem.open = false;\n        }\n        isOpen(key) {\n            const hashItem = this.hash.get(key);\n            return hashItem && hashItem.open == true;\n        }\n        isClose(key) {\n            const hashItem = this.hash.get(key);\n            return hashItem && hashItem.open == false;\n        }\n        isEmpty() {\n            return this.items.length == 0;\n        }\n        pop() {\n            const key = this.items.shift();\n            if (key)\n                this.remove(key);\n            return key;\n        }\n    }\n    function reconstructRoute(parents, endPoint, startCenter, endCenter) {\n        const route = [];\n        let previousDirection = normalizePoint(getDifferencePoint(endCenter, endPoint));\n        let current = endPoint;\n        let parent;\n        while (parents[pointToString(current)]) {\n            parent = parents[pointToString(current)];\n            if (!parent)\n                continue;\n            const direction = normalizePoint(getDifferencePoint(current, parent));\n            // Add point in when direction change\n            if (!direction.equals(previousDirection)) {\n                route.unshift(current);\n                previousDirection = direction;\n            }\n            current = parent;\n        }\n        const startDirection = normalizePoint(getDifferencePoint(current, startCenter));\n        if (!startDirection.equals(previousDirection)) {\n            route.unshift(current);\n        }\n        return route;\n    }\n    function getRectPoints(bbox, directionList, opt) {\n        const step = _a.MANHATTAN_STEP;\n        const center = getRectangleCenter(bbox);\n        const res = [];\n        for (const direction of directionList) {\n            const directionPoint = opt.directionMap[direction];\n            const x = (directionPoint.x * bbox.width) / 2;\n            const y = (directionPoint.y * bbox.height) / 2;\n            const point = movePoint(center.clone(), x, y);\n            if (isPointInRectangle(bbox, point)) {\n                movePoint(point, directionPoint.x * step, directionPoint.y * step);\n            }\n            res.push(snapPointToGrid(point, step));\n        }\n        return res;\n    }\n    function normalizeAngle(angle) {\n        return (angle % 360) + (angle < 0 ? 360 : 0);\n    }\n    function getDirectionAngle(start, end, directionLength) {\n        const q = 360 / directionLength;\n        return Math.floor(normalizeAngle(getPointTheta(start, end) + q / 2) / q) * q;\n    }\n    function getDirectionChange(angle1, angle2) {\n        const dirChange = Math.abs(angle1 - angle2);\n        return dirChange > 180 ? 360 - dirChange : dirChange;\n    }\n    function estimateCost(from, endPoints) {\n        let min = Infinity;\n        for (let i = 0, len = endPoints.length; i < len; i++) {\n            const cost = getManhattanDistance(from, endPoints[i]);\n            if (cost < min)\n                min = cost;\n        }\n        return min;\n    }\n    function alignPointToCell(point, edgeState, cellState, isSourceCell) {\n        const cellBounds = getCellAbsoluteBounds(cellState);\n        const y = isSourceCell ? edgeState.style.exitY : edgeState.style.entryY;\n        const onlyHorizontalDirections = isSourceCell\n            ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH)\n            : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.NORTH && d != DIRECTION.SOUTH);\n        if (y != undefined && onlyHorizontalDirections) {\n            const cellHeight = cellBounds?.height || 0;\n            point.y =\n                cellBounds?.y != undefined\n                    ? cellBounds?.y + cellHeight * y\n                    : point.y - cellHeight / 2 + cellHeight * y;\n        }\n        const x = isSourceCell ? edgeState.style.exitX : edgeState.style.entryX;\n        const onlyVerticalDirections = isSourceCell\n            ? _a.MANHATTAN_START_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST)\n            : _a.MANHATTAN_END_DIRECTIONS.every((d) => d != DIRECTION.WEST && d != DIRECTION.EAST);\n        if (x != undefined && onlyVerticalDirections) {\n            const cellWidth = cellBounds?.width || 0;\n            point.x =\n                cellBounds?.x != undefined\n                    ? cellBounds?.x + cellWidth * x\n                    : point.x - cellWidth / 2 + cellWidth * (x || 0);\n        }\n    }\n    function findRoute(start, end, obstacleMap, opt) {\n        // Caculate start points and end points\n        const step = _a.MANHATTAN_STEP;\n        const startPoints = getRectPoints(start, _a.MANHATTAN_START_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));\n        const startCenter = snapPointToGrid(getRectangleCenter(start), step);\n        const endPoints = getRectPoints(end, _a.MANHATTAN_END_DIRECTIONS, opt).filter((p) => obstacleMap.isPointAccessible(p));\n        const endCenter = snapPointToGrid(getRectangleCenter(end), step);\n        if (startPoints.length > 0 && endPoints.length > 0) {\n            // The set of possible  points to be evaluated, initially containing the start points.\n            const openSet = new SortedSet();\n            // Keeps predecessor of given element.\n            const parents = {};\n            // Cost from start to a point along best known path.\n            const costs = {};\n            startPoints.forEach((p) => {\n                const key = pointToString(p);\n                openSet.add(key, estimateCost(p, endPoints));\n                costs[key] = 0;\n            });\n            let loopsRemain = _a.MANHATTAN_MAXIMUM_LOOPS;\n            const endPointsKeys = endPoints.map((p) => pointToString(p));\n            let currentDirectionAngle;\n            let previousDirectionAngle;\n            // Main route finding loop\n            while (!openSet.isEmpty() && loopsRemain > 0) {\n                const currentKey = openSet.pop();\n                if (currentKey == undefined) {\n                    continue;\n                }\n                const currentPoint = toPointFromString(currentKey);\n                const currentCost = costs[currentKey];\n                previousDirectionAngle = currentDirectionAngle;\n                currentDirectionAngle = parents[currentKey]\n                    ? getDirectionAngle(parents[currentKey], currentPoint, opt.directions.length)\n                    : opt.previousDirAngle != 0\n                        ? opt.previousDirAngle\n                        : getDirectionAngle(startCenter, currentPoint, opt.directions.length);\n                // if get the endpoint\n                if (endPointsKeys.indexOf(currentKey) >= 0) {\n                    // stop route to enter the end point in opposite direction.\n                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, getDirectionAngle(currentPoint, endCenter, opt.directions.length));\n                    if (currentPoint.equals(endCenter) || directionChangedAngle < 180) {\n                        opt.previousDirAngle = currentDirectionAngle;\n                        return reconstructRoute(parents, currentPoint, startCenter, endCenter);\n                    }\n                }\n                // Go over all possible directions and find neighbors.\n                for (let i = 0; i < opt.directions.length; i++) {\n                    const direction = opt.directions[i];\n                    const directionChangedAngle = getDirectionChange(currentDirectionAngle, direction.angle);\n                    if (previousDirectionAngle &&\n                        directionChangedAngle > _a.MANHATTAN_MAX_ALLOWED_DIRECTION_CHANGE) {\n                        continue;\n                    }\n                    const neighborPoint = movePoint(currentPoint.clone(), direction.offsetX, direction.offsetY);\n                    const neighborKey = pointToString(neighborPoint);\n                    if (openSet.isClose(neighborKey) ||\n                        !obstacleMap.isPointAccessible(neighborPoint)) {\n                        continue;\n                    }\n                    const costFromStart = currentCost +\n                        direction.cost +\n                        opt.penaltiesGenerator(directionChangedAngle);\n                    if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n                        // Neighbor point has not been processed yet or the cost of the path\n                        // from start is lesser than previously calcluated.\n                        parents[neighborKey] = currentPoint;\n                        costs[neighborKey] = costFromStart;\n                        openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                    }\n                }\n                loopsRemain--;\n            }\n            return null;\n        }\n        return null;\n    }\n    function router(state, source, target, points, result, opt) {\n        // If edge is dragged after calculation, points will be filled, so fallback to SegmentConnector\n        if ((points != null && points.length > 0) || source == null || target == null) {\n            _a.SegmentConnector(state, source, target, points, result);\n            return;\n        }\n        let sourceBBox = getCellAbsoluteBounds(source);\n        sourceBBox = sourceBBox ? moveAndExpand(sourceBBox, opt.paddingBox) : undefined;\n        let targetBBox = getCellAbsoluteBounds(target);\n        targetBBox = targetBBox ? moveAndExpand(targetBBox, opt.paddingBox) : undefined;\n        const obstacleMap = new ObstacleMap(opt);\n        obstacleMap.build(source, target);\n        if (!sourceBBox || !targetBBox) {\n            // Fallback to OrthConnector\n            return _a.OrthConnector(state, source, target, points, result);\n        }\n        const routePoints = findRoute(sourceBBox, targetBBox, obstacleMap, opt);\n        if (routePoints == null || routePoints.length == 0) {\n            // Fallback to OrthConnector\n            return _a.OrthConnector(state, source, target, points, result);\n        }\n        if (state.style) {\n            if (state.visibleSourceState && routePoints.length > 0) {\n                // If there are at least one point, align it to source cell\n                alignPointToCell(routePoints[0], state, state.visibleSourceState, true);\n            }\n            if (state.visibleTargetState && routePoints.length > 1) {\n                // If there are more than one point, align last point to target cell\n                alignPointToCell(routePoints[routePoints.length - 1], state, state.visibleTargetState, false);\n            }\n        }\n        // Scaling and translating result points\n        const scale = state.view.scale;\n        routePoints.forEach((pt) => result.push(new Point(Math.round((pt.x + state.view.translate.x) * scale * 10) / 10, Math.round((pt.y + state.view.translate.y) * scale * 10) / 10)));\n    }\n    router(state, source, target, points, result, config);\n};\nexport default EdgeStyle;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * A helper class to highlight cells. Here is an example for a given cell.\n *\n * ```javascript\n * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\n * highlight.highlight(graph.view.getState(cell)));\n * ```\n */\nclass CellHighlight {\n    constructor(graph, highlightColor, strokeWidth, dashed) {\n        this.strokeWidth = 0;\n        this.dashed = false;\n        this.opacity = 100;\n        this.shape = null;\n        /**\n         * Specifies if the highlights should appear on top of everything else in the overlay pane.\n         * @default false\n         */\n        this.keepOnTop = false;\n        /**\n         * Reference to the {@link CellState}.\n         * @default null\n         */\n        this.state = null;\n        /**\n         * Specifies the spacing between the highlight for vertices and the vertex.\n         * @default 2\n         */\n        this.spacing = 2;\n        this.graph = graph;\n        this.highlightColor = highlightColor ?? DEFAULT_VALID_COLOR;\n        this.strokeWidth = strokeWidth ?? HIGHLIGHT_STROKEWIDTH;\n        this.dashed = dashed ?? false;\n        this.opacity = HIGHLIGHT_OPACITY;\n        // Updates the marker if the graph changes\n        this.repaintHandler = () => {\n            // Updates reference to state\n            if (this.state) {\n                const tmp = this.graph.view.getState(this.state.cell);\n                if (!tmp) {\n                    this.hide();\n                }\n                else {\n                    this.state = tmp;\n                    this.repaint();\n                }\n            }\n        };\n        this.graph.getView().addListener(InternalEvent.SCALE, this.repaintHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.repaintHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.repaintHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.repaintHandler);\n        // Hides the marker if the current root changes\n        this.resetHandler = () => {\n            this.hide();\n        };\n        this.graph.getView().addListener(InternalEvent.DOWN, this.resetHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.resetHandler);\n    }\n    /**\n     * Sets the color of the rectangle used to highlight drop targets.\n     *\n     * @param {string} color - String that represents the new highlight color.\n     */\n    setHighlightColor(color) {\n        this.highlightColor = color;\n        if (this.shape) {\n            this.shape.stroke = color;\n        }\n    }\n    /**\n     * Creates and returns the highlight shape for the given state.\n     */\n    drawHighlight() {\n        this.shape = this.createShape();\n        this.repaint();\n        if (this.shape) {\n            const node = this.shape.node;\n            if (!this.keepOnTop && node?.parentNode?.firstChild !== node && node.parentNode) {\n                node.parentNode.insertBefore(node, node.parentNode.firstChild);\n            }\n        }\n    }\n    /**\n     * Creates and returns the highlight shape for the given state.\n     */\n    createShape() {\n        if (!this.state)\n            return null;\n        const shape = this.graph.cellRenderer.createShape(this.state);\n        shape.svgStrokeTolerance = this.graph.getEventTolerance();\n        shape.points = this.state.absolutePoints;\n        shape.apply(this.state);\n        shape.stroke = this.highlightColor;\n        shape.opacity = this.opacity;\n        shape.isDashed = this.dashed;\n        shape.isShadow = false;\n        shape.dialect = DIALECT.SVG;\n        shape.init(this.graph.getView().getOverlayPane());\n        InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n        if (this.graph.dialect !== DIALECT.SVG) {\n            shape.pointerEvents = false;\n        }\n        else {\n            shape.svgPointerEvents = 'stroke';\n        }\n        return shape;\n    }\n    /**\n     * Updates the highlight after a change of the model or view.\n     */\n    getStrokeWidth(state = null) {\n        return this.strokeWidth;\n    }\n    /**\n     * Updates the highlight after a change of the model or view.\n     */\n    repaint() {\n        if (this.state && this.shape) {\n            this.shape.scale = this.state.view.scale;\n            if (this.state.cell.isEdge()) {\n                this.shape.strokeWidth = this.getStrokeWidth();\n                this.shape.points = this.state.absolutePoints;\n                this.shape.outline = false;\n            }\n            else {\n                this.shape.bounds = new Rectangle(this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n                this.shape.rotation = this.state.style.rotation ?? 0;\n                this.shape.strokeWidth = this.getStrokeWidth() / this.state.view.scale;\n                this.shape.outline = true;\n            }\n            // Uses cursor from shape in highlight\n            if (this.state.shape) {\n                this.shape.setCursor(this.state.shape.getCursor());\n            }\n            this.shape.redraw();\n        }\n    }\n    /**\n     * Resets the state of the cell marker.\n     */\n    hide() {\n        this.highlight(null);\n    }\n    /**\n     * Marks the {@link arkedState} and fires a {@link ark} event.\n     */\n    highlight(state = null) {\n        if (this.state !== state) {\n            if (this.shape) {\n                this.shape.destroy();\n                this.shape = null;\n            }\n            this.state = state;\n            if (this.state) {\n                this.drawHighlight();\n            }\n        }\n    }\n    /**\n     * Returns true if this highlight is at the given position.\n     */\n    isHighlightAt(x, y) {\n        let hit = false;\n        if (this.shape && document.elementFromPoint) {\n            let elt = document.elementFromPoint(x, y);\n            while (elt) {\n                if (elt === this.shape.node) {\n                    hit = true;\n                    break;\n                }\n                elt = elt.parentNode;\n            }\n        }\n        return hit;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    destroy() {\n        const graph = this.graph;\n        graph.getView().removeListener(this.resetHandler);\n        graph.getView().removeListener(this.repaintHandler);\n        graph.getDataModel().removeListener(this.repaintHandler);\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n    }\n}\nexport default CellHighlight;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport { DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, MAX_HOTSPOT_SIZE, MIN_HOTSPOT_SIZE, NONE, } from '../../util/Constants';\nimport CellHighlight from './CellHighlight';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { intersectsHotspot } from '../../util/mathUtils';\n/**\n * A helper class to process mouse locations and highlight cells.\n *\n * Helper class to highlight cells. To add a cell marker to an existing graph\n * for highlighting all cells, the following code is used:\n *\n * ```javascript\n * let marker = new mxCellMarker(graph);\n * graph.addMouseListener({\n *   mouseDown: ()=> {},\n *   mouseMove: (sender, me)=>\n *   {\n *     marker.process(me);\n *   },\n *   mouseUp: ()=> {}\n * });\n * ```\n *\n * Event: mxEvent.MARK\n *\n * Fires after a cell has been marked or unmarked. The <code>state</code>\n * property contains the marked <CellState> or null if no state is marked.\n *\n * Constructor: mxCellMarker\n *\n * Constructs a new cell marker.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param validColor Optional marker color for valid states. Default is\n * {@link Constants#DEFAULT_VALID_COLOR}.\n * @param invalidColor Optional marker color for invalid states. Default is\n * {@link Constants#DEFAULT_INVALID_COLOR}.\n * @param hotspot Portion of the width and hight where a state intersects a\n * given coordinate pair. A value of 0 means always highlight. Default is\n * {@link Constants#DEFAULT_HOTSPOT}.\n */\nclass CellMarker extends EventSource {\n    constructor(graph, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super();\n        /**\n         * Specifies if the marker is enabled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies the portion of the width and height that should trigger\n         * a highlight. The area around the center of the cell to be marked is used\n         * as the hotspot. Possible values are between 0 and 1. Default is\n         * mxConstants.DEFAULT_HOTSPOT.\n         */\n        this.hotspot = DEFAULT_HOTSPOT;\n        /**\n         * Specifies if the hotspot is enabled. Default is false.\n         */\n        this.hotspotEnabled = false;\n        /**\n         * Holds the current marker color.\n         */\n        this.currentColor = NONE;\n        /**\n         * Holds the marked <CellState> if it is valid.\n         */\n        this.validState = null;\n        /**\n         * Holds the marked <CellState>.\n         */\n        this.markedState = null;\n        this.graph = graph;\n        this.validColor = validColor;\n        this.invalidColor = invalidColor;\n        this.hotspot = hotspot;\n        this.highlight = new CellHighlight(graph);\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets the <hotspot>.\n     */\n    setHotspot(hotspot) {\n        this.hotspot = hotspot;\n    }\n    /**\n     * Returns the <hotspot>.\n     */\n    getHotspot() {\n        return this.hotspot;\n    }\n    /**\n     * Specifies whether the hotspot should be used in <intersects>.\n     */\n    setHotspotEnabled(enabled) {\n        this.hotspotEnabled = enabled;\n    }\n    /**\n     * Returns true if hotspot is used in <intersects>.\n     */\n    isHotspotEnabled() {\n        return this.hotspotEnabled;\n    }\n    /**\n     * Returns true if <validState> is not null.\n     */\n    hasValidState() {\n        return !!this.validState;\n    }\n    /**\n     * Returns the <validState>.\n     */\n    getValidState() {\n        return this.validState;\n    }\n    /**\n     * Returns the {@link arkedState}.\n     */\n    getMarkedState() {\n        return this.markedState;\n    }\n    /**\n     * Resets the state of the cell marker.\n     */\n    reset() {\n        this.validState = null;\n        if (this.markedState) {\n            this.markedState = null;\n            this.unmark();\n        }\n    }\n    /**\n     * Processes the given event and cell and marks the state returned by\n     * <getState> with the color returned by <getMarkerColor>. If the\n     * markerColor is not null, then the state is stored in {@link arkedState}. If\n     * <isValidState> returns true, then the state is stored in <validState>\n     * regardless of the marker color. The state is returned regardless of the\n     * marker color and valid state.\n     */\n    process(me) {\n        let state = null;\n        if (this.isEnabled()) {\n            state = this.getState(me);\n            this.setCurrentState(state, me);\n        }\n        return state;\n    }\n    /**\n     * Sets and marks the current valid state.\n     */\n    setCurrentState(state, me, color) {\n        const isValid = state ? this.isValidState(state) : false;\n        color = color ?? this.getMarkerColor(me.getEvent(), state, isValid);\n        if (isValid) {\n            this.validState = state;\n        }\n        else {\n            this.validState = null;\n        }\n        if (state !== this.markedState || color !== this.currentColor) {\n            this.currentColor = color;\n            if (state && this.currentColor !== NONE) {\n                this.markedState = state;\n                this.mark();\n            }\n            else if (this.markedState) {\n                this.markedState = null;\n                this.unmark();\n            }\n        }\n    }\n    /**\n     * Marks the given cell using the given color, or <validColor> if no color is specified.\n     */\n    markCell(cell, color) {\n        const state = this.graph.getView().getState(cell);\n        if (state) {\n            this.currentColor = color ?? this.validColor;\n            this.markedState = state;\n            this.mark();\n        }\n    }\n    /**\n     * Marks the {@link arkedState} and fires a {@link ark} event.\n     */\n    mark() {\n        this.highlight.setHighlightColor(this.currentColor);\n        this.highlight.highlight(this.markedState);\n        this.fireEvent(new EventObject(InternalEvent.MARK, 'state', this.markedState));\n    }\n    /**\n     * Hides the marker and fires a {@link ark} event.\n     */\n    unmark() {\n        this.mark();\n    }\n    /**\n     * Returns true if the given <CellState> is a valid state. If this\n     * returns true, then the state is stored in <validState>. The return value\n     * of this method is used as the argument for <getMarkerColor>.\n     */\n    isValidState(state) {\n        return true;\n    }\n    /**\n     * Returns the valid- or invalidColor depending on the value of isValid.\n     * The given <CellState> is ignored by this implementation.\n     */\n    getMarkerColor(evt, state, isValid) {\n        return isValid ? this.validColor : this.invalidColor;\n    }\n    /**\n     * Uses <getCell>, <getStateToMark> and <intersects> to return the\n     * <CellState> for the given {@link MouseEvent}.\n     */\n    getState(me) {\n        const view = this.graph.getView();\n        const cell = this.getCell(me);\n        if (!cell)\n            return null;\n        const state = this.getStateToMark(view.getState(cell));\n        return state && this.intersects(state, me) ? state : null;\n    }\n    /**\n     * Returns the <Cell> for the given event and cell. This returns the\n     * given cell.\n     */\n    getCell(me) {\n        return me.getCell();\n    }\n    /**\n     * Returns the <CellState> to be marked for the given <CellState> under\n     * the mouse. This returns the given state.\n     */\n    getStateToMark(state) {\n        return state;\n    }\n    /**\n     * Returns true if the given coordinate pair intersects the given state.\n     * This returns true if the <hotspot> is 0 or the coordinates are inside\n     * the hotspot for the given cell state.\n     */\n    intersects(state, me) {\n        const x = me.getGraphX();\n        const y = me.getGraphY();\n        if (this.hotspotEnabled) {\n            return intersectsHotspot(state, x, y, this.hotspot, MIN_HOTSPOT_SIZE, MAX_HOTSPOT_SIZE);\n        }\n        return true;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    destroy() {\n        this.highlight.destroy();\n    }\n}\nexport default CellMarker;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Defines an object that contains the constraints about how to connect one side of an edge to its terminal.\n */\nclass ConnectionConstraint {\n    constructor(point, perimeter = true, name = null, dx = 0, dy = 0) {\n        /**\n         * Boolean that specifies if the point should be projected onto the perimeter\n         * of the terminal.\n         */\n        this.perimeter = true;\n        /**\n         * Optional string that specifies the name of the constraint.\n         */\n        this.name = null;\n        /**\n         * Optional float that specifies the horizontal offset of the constraint.\n         */\n        this.dx = 0;\n        /**\n         * Optional float that specifies the vertical offset of the constraint.\n         */\n        this.dy = 0;\n        this.point = point;\n        this.perimeter = perimeter;\n        this.name = name;\n        this.dx = dx;\n        this.dy = dy;\n    }\n}\nexport default ConnectionConstraint;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport { DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_OPACITY, HIGHLIGHT_SIZE, HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport { intersects } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { isShiftDown } from '../../util/EventUtils';\n/**\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * @class ConstraintHandler\n */\nclass ConstraintHandler {\n    constructor(graph) {\n        /**\n         * {@link Image} to be used as the image for fixed connection points.\n         */\n        this.pointImage = new Image(`${Client.imageBasePath}/point.gif`, 5, 5);\n        this.currentFocus = null;\n        this.currentFocusArea = null;\n        this.focusIcons = [];\n        this.constraints = null;\n        this.currentConstraint = null;\n        this.focusHighlight = null;\n        this.focusPoints = [];\n        this.currentPoint = null;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies the color for the highlight. Default is {@link DEFAULT_VALID_COLOR}.\n         */\n        this.highlightColor = DEFAULT_VALID_COLOR;\n        this.mouseleaveHandler = null;\n        this.graph = graph;\n        // Adds a graph model listener to update the current focus on changes\n        this.resetHandler = () => {\n            if (this.currentFocus && !this.graph.view.getState(this.currentFocus.cell)) {\n                this.reset();\n            }\n            else {\n                this.redraw();\n            }\n        };\n        this.graph.model.addListener(InternalEvent.CHANGE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.TRANSLATE, this.resetHandler);\n        this.graph.view.addListener(InternalEvent.SCALE, this.resetHandler);\n        this.graph.addListener(InternalEvent.ROOT, this.resetHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param {boolean} enabled - Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n        this.currentConstraint = null;\n        this.currentFocusArea = null;\n        this.currentPoint = null;\n        this.currentFocus = null;\n        this.focusPoints = [];\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points. This\n     * implementation returns {@link mxGraph.tolerance}.\n     *\n     * @param me {@link mxMouseEvent} whose tolerance should be returned.\n     */\n    getTolerance(me) {\n        return this.graph.getEventTolerance();\n    }\n    /**\n     * Returns the tolerance to be used for intersecting connection points.\n     */\n    getImageForConstraint(state, constraint, point) {\n        return this.pointImage;\n    }\n    /**\n     * Returns true if the given {@link mxMouseEvent} should be ignored in {@link update}. This\n     * implementation always returns false.\n     */\n    isEventIgnored(me, source = false) {\n        return false;\n    }\n    /**\n     * Returns true if the given state should be ignored. This always returns false.\n     */\n    isStateIgnored(state, source = false) {\n        return false;\n    }\n    /**\n     * Destroys the {@link focusIcons} if they exist.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.focusIcons.length; i += 1) {\n            this.focusIcons[i].destroy();\n        }\n        this.focusIcons = [];\n        this.focusPoints = [];\n    }\n    /**\n     * Destroys the {@link focusHighlight} if one exists.\n     */\n    destroyFocusHighlight() {\n        if (this.focusHighlight) {\n            this.focusHighlight.destroy();\n            this.focusHighlight = null;\n        }\n    }\n    /**\n     * Returns true if the current focused state should not be changed for the given event.\n     * This returns true if shift and alt are pressed.\n     */\n    isKeepFocusEvent(me) {\n        return isShiftDown(me.getEvent());\n    }\n    /**\n     * Returns the cell for the given event.\n     */\n    getCellForEvent(me, point) {\n        let cell = me.getCell();\n        // Gets cell under actual point if different from event location\n        if (!cell && point && (me.getGraphX() !== point.x || me.getGraphY() !== point.y)) {\n            cell = this.graph.getCellAt(point.x, point.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable()) {\n            const parent = cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            return this.graph.isCellLocked(cell) ? null : cell;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Updates the state of this handler based on the given {@link mxMouseEvent}.\n     * Source is a boolean indicating if the cell is a source or target.\n     */\n    update(me, source, existingEdge, point) {\n        if (this.isEnabled() && !this.isEventIgnored(me)) {\n            // Lazy installation of mouseleave handler\n            if (!this.mouseleaveHandler && this.graph.container) {\n                this.mouseleaveHandler = () => {\n                    this.reset();\n                };\n                InternalEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\n            }\n            const tol = this.getTolerance(me);\n            const x = point ? point.x : me.getGraphX();\n            const y = point ? point.y : me.getGraphY();\n            const grid = new Rectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n            const mouse = new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n            const state = this.graph.view.getState(this.getCellForEvent(me, point));\n            // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n            if (!this.isKeepFocusEvent(me) &&\n                (!this.currentFocusArea ||\n                    !this.currentFocus ||\n                    state ||\n                    !this.currentFocus.cell.isVertex() ||\n                    !intersects(this.currentFocusArea, mouse)) &&\n                state !== this.currentFocus) {\n                this.currentFocusArea = null;\n                this.currentFocus = null;\n                this.setFocus(me, state, source);\n            }\n            this.currentConstraint = null;\n            this.currentPoint = null;\n            let minDistSq = null;\n            let tmp;\n            if (this.focusIcons.length > 0 &&\n                this.constraints &&\n                (!state || this.currentFocus === state)) {\n                const cx = mouse.getCenterX();\n                const cy = mouse.getCenterY();\n                for (let i = 0; i < this.focusIcons.length; i += 1) {\n                    const dx = cx - this.focusIcons[i].bounds.getCenterX();\n                    const dy = cy - this.focusIcons[i].bounds.getCenterY();\n                    tmp = dx * dx + dy * dy;\n                    if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) ||\n                        (point &&\n                            this.intersects(this.focusIcons[i], grid, source, existingEdge))) &&\n                        (minDistSq === null || tmp < minDistSq)) {\n                        this.currentConstraint = this.constraints[i];\n                        this.currentPoint = this.focusPoints[i];\n                        minDistSq = tmp;\n                        tmp = this.focusIcons[i].bounds.clone();\n                        tmp.grow(HIGHLIGHT_SIZE + 1);\n                        tmp.width -= 1;\n                        tmp.height -= 1;\n                        if (!this.focusHighlight) {\n                            const hl = this.createHighlightShape();\n                            hl.dialect = DIALECT.SVG;\n                            hl.pointerEvents = false;\n                            hl.init(this.graph.getView().getOverlayPane());\n                            this.focusHighlight = hl;\n                            const getState = () => {\n                                return this.currentFocus ? this.currentFocus : state;\n                            };\n                            InternalEvent.redirectMouseEvents(hl.node, this.graph, getState);\n                        }\n                        this.focusHighlight.bounds = tmp;\n                        this.focusHighlight.redraw();\n                    }\n                }\n            }\n            if (!this.currentConstraint) {\n                this.destroyFocusHighlight();\n            }\n        }\n        else {\n            this.currentConstraint = null;\n            this.currentFocus = null;\n            this.currentPoint = null;\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    redraw() {\n        if (this.currentFocus && this.constraints && this.focusIcons.length > 0) {\n            const state = this.graph.view.getState(this.currentFocus.cell);\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                this.focusIcons[i].bounds = bounds;\n                this.focusIcons[i].redraw();\n                this.currentFocusArea.add(this.focusIcons[i].bounds);\n                this.focusPoints[i] = cp;\n            }\n        }\n    }\n    /**\n     * Transfers the focus to the given state as a source or target terminal. If\n     * the handler is not enabled then the outline is painted, but the constraints\n     * are ignored.\n     */\n    setFocus(me, state, source) {\n        this.constraints =\n            state && !this.isStateIgnored(state, source) && state.cell.isConnectable()\n                ? this.isEnabled()\n                    ? this.graph.getAllConnectionConstraints(state, source) ?? []\n                    : []\n                : null;\n        // Only uses cells which have constraints\n        if (this.constraints && state) {\n            this.currentFocus = state;\n            this.currentFocusArea = new Rectangle(state.x, state.y, state.width, state.height);\n            for (let i = 0; i < this.focusIcons.length; i += 1) {\n                this.focusIcons[i].destroy();\n            }\n            this.focusIcons = [];\n            this.focusPoints = [];\n            for (let i = 0; i < this.constraints.length; i += 1) {\n                const cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n                const img = this.getImageForConstraint(state, this.constraints[i], cp);\n                const { src } = img;\n                const bounds = new Rectangle(Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n                const icon = new ImageShape(bounds, src);\n                icon.dialect =\n                    this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n                icon.preserveImageAspect = false;\n                icon.init(this.graph.getView().getDecoratorPane());\n                // Move the icon behind all other overlays\n                if (icon.node.previousSibling) {\n                    icon.node.parentNode?.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n                const getState = () => {\n                    return this.currentFocus ? this.currentFocus : state;\n                };\n                icon.redraw();\n                InternalEvent.redirectMouseEvents(icon.node, this.graph, getState);\n                this.currentFocusArea.add(icon.bounds);\n                this.focusIcons.push(icon);\n                this.focusPoints.push(cp);\n            }\n            this.currentFocusArea.grow(this.getTolerance(me));\n        }\n        else {\n            this.destroyIcons();\n            this.destroyFocusHighlight();\n        }\n    }\n    /**\n     * Create the shape used to paint the highlight.\n     *\n     * Returns true if the given icon intersects the given point.\n     */\n    createHighlightShape() {\n        const hl = new RectangleShape(new Rectangle(), this.highlightColor, this.highlightColor, HIGHLIGHT_STROKEWIDTH);\n        hl.opacity = HIGHLIGHT_OPACITY;\n        return hl;\n    }\n    /**\n     * Returns true if the given icon intersects the given rectangle.\n     */\n    intersects(icon, mouse, source, existingEdge) {\n        return intersects(icon.bounds, mouse);\n    }\n    /**\n     * Destroy this handler.\n     */\n    onDestroy() {\n        this.reset();\n        this.graph.model.removeListener(this.resetHandler);\n        this.graph.view.removeListener(this.resetHandler);\n        this.graph.removeListener(this.resetHandler);\n        if (this.mouseleaveHandler && this.graph.container) {\n            InternalEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n            this.mouseleaveHandler = null;\n        }\n    }\n}\nexport default ConstraintHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellMarker from '../cell/CellMarker';\nimport Point from '../geometry/Point';\nimport { CONNECT_HANDLE_FILLCOLOR, CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, EDGE_SELECTION_COLOR, EDGE_SELECTION_DASHED, EDGE_SELECTION_STROKEWIDTH, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, HIGHLIGHT_STROKEWIDTH, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, LOCKED_HANDLE_FILLCOLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, } from '../../util/Constants';\nimport { contains, findNearestSegment, intersects, ptSegDistSq, } from '../../util/mathUtils';\nimport { convertPoint, getOffset, setOpacity } from '../../util/styleUtils';\nimport ImageShape from '../geometry/node/ImageShape';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport InternalEvent from '../event/InternalEvent';\nimport ConstraintHandler from './ConstraintHandler';\nimport Rectangle from '../geometry/Rectangle';\nimport Client from '../../Client';\nimport EdgeStyle from '../style/EdgeStyle';\nimport { getClientX, getClientY, isAltDown, isMouseEvent, isShiftDown, } from '../../util/EventUtils';\nimport { equalPoints } from '../../util/arrayUtils';\n/**\n * Graph event handler that reconnects edges and modifies control points and the edge\n * label location.\n * Uses {@link CellMarker} for finding and highlighting new source and target vertices.\n * This handler is automatically created in mxGraph.createHandler for each selected edge.\n * **To enable adding/removing control points, the following code can be used**\n * @example\n * ```\n * mxEdgeHandler.prototype.addEnabled = true;\n * mxEdgeHandler.prototype.removeEnabled = true;\n * ```\n * Note: This experimental feature is not recommended for production use.\n * @class EdgeHandler\n */\nclass EdgeHandler {\n    constructor(state) {\n        /**\n         * Holds the current validation error while a connection is being changed.\n         */\n        this.error = null;\n        /**\n         * Holds the {@link Shapes} that represent the points.\n         */\n        this.bends = [];\n        /**\n         * Specifies if cloning by control-drag is enabled. Default is true.\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if adding bends by shift-click is enabled. Default is false.\n         * Note: This experimental feature is not recommended for production use.\n         */\n        this.addEnabled = false;\n        /**\n         * Specifies if removing bends by shift-click is enabled. Default is false.\n         * Note: This experimental feature is not recommended for production use.\n         */\n        this.removeEnabled = false;\n        /**\n         * Specifies if removing bends by double click is enabled. Default is false.\n         */\n        this.dblClickRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by dropping them on other bends is enabled.\n         * Default is false.\n         */\n        this.mergeRemoveEnabled = false;\n        /**\n         * Specifies if removing bends by creating straight segments should be enabled.\n         * If enabled, this can be overridden by holding down the alt key while moving.\n         * Default is false.\n         */\n        this.straightRemoveEnabled = false;\n        /**\n         * Specifies if virtual bends should be added in the center of each\n         * segments. These bends can then be used to add new waypoints.\n         * Default is false.\n         */\n        this.virtualBendsEnabled = false;\n        /**\n         * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\n         * Default is 20.\n         */\n        this.virtualBendOpacity = 20;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * Default is false.\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if bends should be added to the graph container. This is updated\n         * in <init> based on whether the edge or one of its terminals has an HTML\n         * label in the container.\n         */\n        this.preferHtml = false;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE\n         * Default is true.\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Specifies if waypoints should snap to the routing centers of terminals.\n         * Default is false.\n         */\n        this.snapToTerminals = false;\n        /**\n         * Optional {@link Image} to be used as handles. Default is null.\n         */\n        this.handleImage = null;\n        this.labelHandleImage = null;\n        /**\n         * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n         */\n        // tolerance: number;\n        this.tolerance = 0;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target.\n         * @default false\n         */\n        this.outlineConnect = false;\n        /**\n         * Specifies if the label handle should be moved if it intersects with another\n         * handle. Uses {@link checkLabelHandle} for checking and moving.\n         * @default false\n         */\n        this.manageLabelHandle = false;\n        this.currentPoint = null;\n        this.parentHighlight = null;\n        this.index = null;\n        this.isSource = false;\n        this.isTarget = false;\n        this.isLabel = false;\n        this.points = [];\n        this.snapPoint = null;\n        this.abspoints = [];\n        this.startX = 0;\n        this.startY = 0;\n        this.outline = true;\n        this.active = true;\n        // `state.shape` must exists.\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Clones the original points from the cell\n        // and makes sure at least one point exists\n        this.points = [];\n        // Uses the absolute points of the state\n        // for the initial configuration and preview\n        this.abspoints = this.getSelectionPoints(this.state);\n        this.shape = this.createSelectionShape(this.abspoints);\n        this.shape.dialect =\n            this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n        this.shape.init(this.graph.getView().getOverlayPane());\n        this.shape.pointerEvents = false;\n        this.shape.setCursor(CURSOR.MOVABLE_EDGE);\n        InternalEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n        // Updates preferHtml\n        this.preferHtml =\n            this.state.text != null && this.state.text.node.parentNode === this.graph.container;\n        if (!this.preferHtml) {\n            // Checks source terminal\n            const sourceState = this.state.getVisibleTerminalState(true);\n            if (sourceState != null) {\n                this.preferHtml =\n                    sourceState.text != null &&\n                        sourceState.text.node.parentNode === this.graph.container;\n            }\n            if (!this.preferHtml) {\n                // Checks target terminal\n                const targetState = this.state.getVisibleTerminalState(false);\n                if (targetState != null) {\n                    this.preferHtml =\n                        targetState.text != null &&\n                            targetState.text.node.parentNode === this.graph.container;\n                }\n            }\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Creates bends for the non-routed absolute points\n        // or bends that don't correspond to points\n        if (selectionHandler &&\n            (this.graph.getSelectionCount() < selectionHandler.maxCells ||\n                selectionHandler.maxCells <= 0)) {\n            this.bends = this.createBends();\n            if (this.isVirtualBendsEnabled()) {\n                this.virtualBends = this.createVirtualBends();\n            }\n        }\n        // Adds a rectangular handle for the label position\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape = this.createLabelHandleShape();\n        this.initBend(this.labelShape);\n        this.labelShape.setCursor(CURSOR.LABEL_HANDLE);\n        this.customHandles = this.createCustomHandles();\n        this.updateParentHighlight();\n        this.redraw();\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            const dirty = this.index != null;\n            this.reset();\n            if (dirty) {\n                this.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n            }\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if the parent highlight should be visible. This implementation\n     * always returns true.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : null;\n    }\n    /**\n     * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent && parent.isVertex() && pstate && !pstate.parentHighlight) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    if (pstate.style.rotation) {\n                        this.parentHighlight.rotation = pstate.style.rotation;\n                    }\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Returns an array of custom handles. This implementation returns an empty array.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Returns true if virtual bends should be added. This returns true if\n     * <virtualBendsEnabled> is true and the current style allows and\n     * renders custom waypoints.\n     */\n    isVirtualBendsEnabled(evt) {\n        return (this.virtualBendsEnabled &&\n            (this.state.style.edgeStyle == null ||\n                this.state.style.edgeStyle === NONE ||\n                this.state.style.noEdgeStyle) &&\n            this.state.style.shape !== 'arrow');\n    }\n    /**\n     * Returns true if the given cell allows new connections to be created. This implementation\n     * always returns true.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Returns true if the given event is a trigger to add a new Point. This\n     * implementation returns true if shift is pressed.\n     */\n    isAddPointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns true if the given event is a trigger to remove a point. This\n     * implementation returns true if shift is pressed.\n     */\n    isRemovePointEvent(evt) {\n        return isShiftDown(evt);\n    }\n    /**\n     * Returns the list of points that defines the selection stroke.\n     */\n    getSelectionPoints(state) {\n        return state.absolutePoints;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(points) {\n        const c = this.state.shape.constructor;\n        const shape = new c();\n        shape.outline = true;\n        shape.apply(this.state);\n        shape.isDashed = this.isSelectionDashed();\n        shape.stroke = this.getSelectionColor();\n        shape.isShadow = false;\n        return shape;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_COLOR}.\n     */\n    getSelectionColor() {\n        return EDGE_SELECTION_COLOR;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_STROKEWIDTH}.\n     */\n    getSelectionStrokeWidth() {\n        return EDGE_SELECTION_STROKEWIDTH;\n    }\n    /**\n     * Returns {@link EDGE_SELECTION_DASHED}.\n     */\n    isSelectionDashed() {\n        return EDGE_SELECTION_DASHED;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    getCellAt(x, y) {\n        return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link marker}.\n     */\n    createMarker() {\n        return new EdgeHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source, target pair is not valid. Otherwise it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        return this.graph.getEdgeValidationError(this.state.cell, source, target);\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    createBends() {\n        const { cell } = this.state;\n        const bends = [];\n        for (let i = 0; i < this.abspoints.length; i += 1) {\n            if (this.isHandleVisible(i)) {\n                const source = i === 0;\n                const target = i === this.abspoints.length - 1;\n                const terminal = source || target;\n                if (terminal || this.graph.isCellBendable(cell)) {\n                    ((index) => {\n                        const bend = this.createHandleShape(index);\n                        this.initBend(bend, () => {\n                            if (this.dblClickRemoveEnabled) {\n                                this.removePoint(this.state, index);\n                            }\n                        });\n                        if (this.isHandleEnabled(i)) {\n                            bend.setCursor(terminal ? CURSOR.TERMINAL_HANDLE : CURSOR.BEND_HANDLE);\n                        }\n                        bends.push(bend);\n                        if (!terminal) {\n                            this.points.push(new Point(0, 0));\n                            bend.node.style.visibility = 'hidden';\n                        }\n                    })(i);\n                }\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates and returns the bends used for modifying the edge. This is\n     * typically an array of {@link RectangleShape}.\n     */\n    // createVirtualBends(): mxRectangleShape[];\n    createVirtualBends() {\n        const { cell } = this.state;\n        const last = this.abspoints[0];\n        const bends = [];\n        if (this.graph.isCellBendable(cell)) {\n            for (let i = 1; i < this.abspoints.length; i += 1) {\n                ((bend) => {\n                    this.initBend(bend);\n                    bend.setCursor(CURSOR.VIRTUAL_BEND_HANDLE);\n                    bends.push(bend);\n                })(this.createHandleShape());\n            }\n        }\n        return bends;\n    }\n    /**\n     * Creates the shape used to display the given bend.\n     */\n    isHandleEnabled(index) {\n        return true;\n    }\n    /**\n     * Returns true if the handle at the given index is visible.\n     */\n    isHandleVisible(index) {\n        const source = this.state.getVisibleTerminalState(true);\n        const target = this.state.getVisibleTerminalState(false);\n        const geo = this.state.cell.getGeometry();\n        const edgeStyle = geo\n            ? this.graph.view.getEdgeStyle(this.state, geo.points || undefined, source, target)\n            : null;\n        return (edgeStyle !== EdgeStyle.EntityRelation ||\n            index === 0 ||\n            index === this.abspoints.length - 1);\n    }\n    /**\n     * Creates the shape used to display the given bend. Note that the index may be\n     * null for special cases, such as when called from\n     * {@link ElbowEdgeHandler#createVirtualBend}. Only images and rectangles should be\n     * returned if support for HTML labels with not foreign objects is required.\n     * Index if null for virtual handles.\n     */\n    createHandleShape(index) {\n        if (this.handleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        let s = HANDLE_SIZE;\n        if (this.preferHtml) {\n            s -= 1;\n        }\n        return new RectangleShape(new Rectangle(0, 0, s, s), HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Creates the shape used to display the the label handle.\n     */\n    createLabelHandleShape() {\n        if (this.labelHandleImage) {\n            const shape = new ImageShape(new Rectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        const s = LABEL_HANDLE_SIZE;\n        return new RectangleShape(new Rectangle(0, 0, s, s), LABEL_HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Helper method to initialize the given bend.\n     *\n     * @param bend {@link Shape} that represents the bend to be initialized.\n     */\n    initBend(bend, dblClick) {\n        if (this.preferHtml) {\n            bend.dialect = DIALECT.STRICTHTML;\n            bend.init(this.graph.container);\n        }\n        else {\n            bend.dialect = this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            bend.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);\n        if (Client.IS_TOUCH) {\n            bend.node.setAttribute('pointer-events', 'none');\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event.\n     */\n    getHandleForEvent(me) {\n        let result = null;\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        let minDistSq = Number.POSITIVE_INFINITY;\n        function checkShape(shape) {\n            if (shape &&\n                shape.bounds &&\n                shape.node &&\n                shape.node.style.display !== 'none' &&\n                shape.node.style.visibility !== 'hidden' &&\n                (me.isSource(shape) || (hit && intersects(shape.bounds, hit)))) {\n                const dx = me.getGraphX() - shape.bounds.getCenterX();\n                const dy = me.getGraphY() - shape.bounds.getCenterY();\n                const tmp = dx * dx + dy * dy;\n                if (tmp <= minDistSq) {\n                    minDistSq = tmp;\n                    return true;\n                }\n            }\n            return false;\n        }\n        if (this.isCustomHandleEvent(me) && this.customHandles) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        if (me.isSource(this.state.text) || checkShape(this.labelShape)) {\n            result = InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.bends.length; i += 1) {\n            if (checkShape(this.bends[i])) {\n                result = i;\n            }\n        }\n        if (this.virtualBends && this.isAddVirtualBendEvent(me)) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (checkShape(this.virtualBends[i])) {\n                    result = InternalEvent.VIRTUAL_HANDLE - i;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns true if the given event allows virtual bends to be added. This\n     * implementation returns true.\n     */\n    isAddVirtualBendEvent(me) {\n        return true;\n    }\n    /**\n     * Returns true if the given event allows custom handles to be changed. This\n     * implementation returns true.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event by checking if a special element of the handler\n     * was clicked, in which case the index parameter is non-null. The\n     * indices may be one of <LABEL_HANDLE> or the number of the respective\n     * control point. The source and target points are used for reconnecting\n     * the edge.\n     */\n    mouseDown(sender, me) {\n        const handle = this.getHandleForEvent(me);\n        if (handle !== null && this.bends[handle]) {\n            const b = this.bends[handle].bounds;\n            if (b)\n                this.snapPoint = new Point(b.getCenterX(), b.getCenterY());\n        }\n        if (this.addEnabled && handle === null && this.isAddPointEvent(me.getEvent())) {\n            this.addPoint(this.state, me.getEvent());\n            me.consume();\n        }\n        else if (handle !== null && !me.isConsumed() && this.graph.isEnabled()) {\n            const cell = me.getCell();\n            if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {\n                this.removePoint(this.state, handle);\n            }\n            else if (handle !== InternalEvent.LABEL_HANDLE ||\n                (cell && this.graph.isLabelMovable(cell))) {\n                if (this.virtualBends && handle <= InternalEvent.VIRTUAL_HANDLE) {\n                    setOpacity(this.virtualBends[InternalEvent.VIRTUAL_HANDLE - handle].node, 100);\n                }\n                this.start(me.getX(), me.getY(), handle);\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.startX = x;\n        this.startY = y;\n        this.isSource = this.bends.length === 0 ? false : index === 0;\n        this.isTarget = this.bends.length === 0 ? false : index === this.bends.length - 1;\n        this.isLabel = index === InternalEvent.LABEL_HANDLE;\n        if (this.isSource || this.isTarget) {\n            const { cell } = this.state;\n            const terminal = cell.getTerminal(this.isSource);\n            if ((terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource)) ||\n                (terminal != null &&\n                    this.graph.isCellDisconnectable(cell, terminal, this.isSource))) {\n                this.index = index;\n            }\n        }\n        else {\n            this.index = index;\n        }\n        // Hides other custom handles\n        if (this.index !== null &&\n            this.index <= InternalEvent.CUSTOM_HANDLE &&\n            this.index > InternalEvent.VIRTUAL_HANDLE) {\n            if (this.customHandles != null) {\n                for (let i = 0; i < this.customHandles.length; i += 1) {\n                    if (i !== InternalEvent.CUSTOM_HANDLE - this.index) {\n                        this.customHandles[i].setVisible(false);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns a clone of the current preview state for the given point and terminal.\n     */\n    clonePreviewState(point, terminal) {\n        return this.state.clone();\n    }\n    /**\n     * Returns the tolerance for the guides. Default value is\n     * gridSize * scale / 2.\n     */\n    getSnapToTerminalTolerance() {\n        return (this.graph.getGridSize() * this.graph.getView().scale) / 2;\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me, point) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length);\n    }\n    /**\n     * Returns true if <snapToTerminals> is true and if alt is not pressed.\n     */\n    isSnapToTerminalsEvent(me) {\n        return this.snapToTerminals && !isAltDown(me.getEvent());\n    }\n    /**\n     * Returns the point for the given event.\n     */\n    // getPointForEvent(me: mxMouseEvent): mxPoint;\n    getPointForEvent(me) {\n        const view = this.graph.getView();\n        const { scale } = view;\n        const point = new Point(this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);\n        const tt = this.getSnapToTerminalTolerance();\n        let overrideX = false;\n        let overrideY = false;\n        if (tt > 0 && this.isSnapToTerminalsEvent(me)) {\n            const snapToPoint = (pt) => {\n                if (pt) {\n                    const { x } = pt;\n                    if (Math.abs(point.x - x) < tt) {\n                        point.x = x;\n                        overrideX = true;\n                    }\n                    const { y } = pt;\n                    if (Math.abs(point.y - y) < tt) {\n                        point.y = y;\n                        overrideY = true;\n                    }\n                }\n            };\n            // Temporary function\n            const snapToTerminal = (terminal) => {\n                if (terminal) {\n                    snapToPoint(new Point(view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));\n                }\n            };\n            snapToTerminal(this.state.getVisibleTerminalState(true));\n            snapToTerminal(this.state.getVisibleTerminalState(false));\n            for (let i = 0; i < this.state.absolutePoints.length; i += 1) {\n                snapToPoint(this.state.absolutePoints[i]);\n            }\n        }\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            const tr = view.translate;\n            if (!overrideX) {\n                point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            }\n            if (!overrideY) {\n                point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n            }\n        }\n        return point;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewTerminalState(me) {\n        this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n        if (this.constraintHandler.currentFocus && this.constraintHandler.currentConstraint) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.shape &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            const other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(this.state.cell.getTerminal(!this.isSource)), !this.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;\n            const target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;\n            // Updates the error message of the handler\n            this.error = this.validateConnection(source, target);\n            let result = null;\n            if (this.error === null) {\n                result = this.constraintHandler.currentFocus;\n            }\n            if (this.error !== null || (result && !this.isCellEnabled(result.cell))) {\n                this.constraintHandler.reset();\n            }\n            return result;\n        }\n        if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n            this.marker.process(me);\n            const state = this.marker.getValidState();\n            if (state && !this.isCellEnabled(state.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n            }\n            return this.marker.getValidState();\n        }\n        this.marker.reset();\n        return null;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     *\n     * @param pt {@link Point} that contains the current pointer position.\n     * @param me Optional {@link MouseEvent} that contains the current event.\n     */\n    getPreviewPoints(pt, me) {\n        const geometry = this.state.cell.getGeometry();\n        if (!geometry)\n            return null;\n        let points = (geometry.points || []).slice();\n        const point = new Point(pt.x, pt.y);\n        let result = null;\n        if (!this.isSource && !this.isTarget && this.index !== null) {\n            this.convertPoint(point, false);\n            // Adds point from virtual bend\n            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 0, point);\n            }\n            // Removes point if dragged on terminal point\n            if (!this.isSource && !this.isTarget) {\n                for (let i = 0; i < this.bends.length; i += 1) {\n                    if (i !== this.index) {\n                        const bend = this.bends[i];\n                        if (bend && contains(bend.bounds, pt.x, pt.y)) {\n                            if (this.index <= InternalEvent.VIRTUAL_HANDLE) {\n                                points.splice(InternalEvent.VIRTUAL_HANDLE - this.index, 1);\n                            }\n                            else {\n                                points.splice(this.index - 1, 1);\n                            }\n                            result = points;\n                        }\n                    }\n                }\n                // Removes point if user tries to straighten a segment\n                if (!result && this.straightRemoveEnabled && (!me || !isAltDown(me.getEvent()))) {\n                    const tol = this.graph.getEventTolerance() * this.graph.getEventTolerance();\n                    const abs = this.state.absolutePoints.slice();\n                    abs[this.index] = pt;\n                    // Handes special case where removing waypoint affects tolerance (flickering)\n                    const src = this.state.getVisibleTerminalState(true);\n                    if (src != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, src, true);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(src, c) == null) {\n                            abs[0] = new Point(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n                        }\n                    }\n                    const trg = this.state.getVisibleTerminalState(false);\n                    if (trg != null) {\n                        const c = this.graph.getConnectionConstraint(this.state, trg, false);\n                        // Checks if point is not fixed\n                        if (c == null || this.graph.getConnectionPoint(trg, c) == null) {\n                            abs[abs.length - 1] = new Point(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n                        }\n                    }\n                    const checkRemove = (idx, tmp) => {\n                        if (idx > 0 &&\n                            idx < abs.length - 1 &&\n                            ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {\n                            points.splice(idx - 1, 1);\n                            result = points;\n                        }\n                    };\n                    // LATER: Check if other points can be removed if a segment is made straight\n                    checkRemove(this.index, pt);\n                }\n            }\n            // Updates existing point\n            if (result == null && this.index > InternalEvent.VIRTUAL_HANDLE) {\n                points[this.index - 1] = point;\n            }\n        }\n        else if (this.graph.isResetEdgesOnConnect()) {\n            points = [];\n        }\n        return result != null ? result : points;\n    }\n    /**\n     * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    updatePreviewState(edgeState, point, terminalState, me, outline = false) {\n        // Computes the points for the edge style and terminals\n        const sourceState = this.isSource\n            ? terminalState\n            : this.state.getVisibleTerminalState(true);\n        const targetState = this.isTarget\n            ? terminalState\n            : this.state.getVisibleTerminalState(false);\n        let sourceConstraint = this.graph.getConnectionConstraint(edgeState, sourceState, true);\n        let targetConstraint = this.graph.getConnectionConstraint(edgeState, targetState, false);\n        let constraint = this.constraintHandler.currentConstraint;\n        if (constraint == null && outline) {\n            if (terminalState != null) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                constraint = this.graph.getOutlineConstraint(point, terminalState, me);\n                this.constraintHandler.setFocus(me, terminalState, this.isSource);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            else {\n                constraint = new ConnectionConstraint(null);\n            }\n        }\n        if (this.outlineConnect &&\n            this.marker.highlight != null &&\n            this.marker.highlight.shape != null) {\n            const s = this.graph.view.scale;\n            if (this.constraintHandler.currentConstraint != null &&\n                this.constraintHandler.currentFocus != null) {\n                this.marker.highlight.shape.stroke = outline\n                    ? OUTLINE_HIGHLIGHT_COLOR\n                    : 'transparent';\n                this.marker.highlight.shape.strokeWidth = OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n            else if (this.marker.hasValidState()) {\n                const cell = me.getCell();\n                this.marker.highlight.shape.stroke =\n                    cell && cell.isConnectable() && this.marker.getValidState() !== me.getState()\n                        ? 'transparent'\n                        : DEFAULT_VALID_COLOR;\n                this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                this.marker.highlight.repaint();\n            }\n        }\n        if (this.isSource) {\n            sourceConstraint = constraint;\n        }\n        else if (this.isTarget) {\n            targetConstraint = constraint;\n        }\n        if (this.isSource || this.isTarget) {\n            if (constraint != null && constraint.point != null) {\n                edgeState.style[this.isSource ? 'exitX' : 'entryX'] = constraint.point.x;\n                edgeState.style[this.isSource ? 'exitY' : 'entryY'] = constraint.point.y;\n            }\n            else {\n                delete edgeState.style[this.isSource ? 'exitX' : 'entryX'];\n                delete edgeState.style[this.isSource ? 'exitY' : 'entryY'];\n            }\n        }\n        edgeState.setVisibleTerminalState(sourceState, true);\n        edgeState.setVisibleTerminalState(targetState, false);\n        if (!this.isSource || sourceState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, sourceState, true, sourceConstraint);\n        }\n        if (!this.isTarget || targetState != null) {\n            edgeState.view.updateFixedTerminalPoint(edgeState, targetState, false, targetConstraint);\n        }\n        if ((this.isSource || this.isTarget) && terminalState == null) {\n            edgeState.setAbsoluteTerminalPoint(point, this.isSource);\n            if (this.marker.getMarkedState() == null) {\n                this.error = this.graph.isAllowDanglingEdges() ? null : '';\n            }\n        }\n        edgeState.view.updatePoints(edgeState, this.points, sourceState, targetState);\n        edgeState.view.updateFloatingTerminalPoints(edgeState, sourceState, targetState);\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (this.index != null && this.marker != null) {\n            this.currentPoint = this.getPointForEvent(me);\n            this.error = null;\n            // Uses the current point from the constraint handler if available\n            if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                isShiftDown(me.getEvent()) &&\n                this.snapPoint != null) {\n                if (Math.abs(this.snapPoint.x - this.currentPoint.x) <\n                    Math.abs(this.snapPoint.y - this.currentPoint.y)) {\n                    this.currentPoint.x = this.snapPoint.x;\n                }\n                else {\n                    this.currentPoint.y = this.snapPoint.y;\n                }\n            }\n            if (this.index <= InternalEvent.CUSTOM_HANDLE &&\n                this.index > InternalEvent.VIRTUAL_HANDLE) {\n                if (this.customHandles != null) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                    if (this.shape != null && this.shape.node != null) {\n                        this.shape.node.style.display = 'none';\n                    }\n                }\n            }\n            else if (this.isLabel && this.label) {\n                this.label.x = this.currentPoint.x;\n                this.label.y = this.currentPoint.y;\n            }\n            else {\n                this.points = this.getPreviewPoints(this.currentPoint, me);\n                let terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;\n                if (this.constraintHandler.currentConstraint != null &&\n                    this.constraintHandler.currentFocus != null &&\n                    this.constraintHandler.currentPoint != null) {\n                    this.currentPoint = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.outlineConnect) {\n                    // Need to check outline before cloning terminal state\n                    const outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;\n                    if (outline) {\n                        terminalState = this.marker.highlight.state;\n                    }\n                    else if (terminalState != null &&\n                        terminalState !== me.getState() &&\n                        me.getCell()?.isConnectable() &&\n                        this.marker.highlight.shape != null) {\n                        this.marker.highlight.shape.stroke = 'transparent';\n                        this.marker.highlight.repaint();\n                        terminalState = null;\n                    }\n                }\n                if (terminalState != null && !this.isCellEnabled(terminalState.cell)) {\n                    terminalState = null;\n                    this.marker.reset();\n                }\n                if (this.currentPoint) {\n                    const clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);\n                    this.updatePreviewState(clone, this.currentPoint, terminalState, me, this.outline);\n                    // Sets the color of the preview to valid or invalid, updates the\n                    // points of the preview and redraws\n                    const color = this.error == null ? this.marker.validColor : this.marker.invalidColor;\n                    this.setPreviewColor(color);\n                    this.abspoints = clone.absolutePoints;\n                    this.active = true;\n                    this.updateHint(me, this.currentPoint);\n                }\n            }\n            // This should go before calling isOutlineConnectEvent above. As a workaround\n            // we add an offset of gridSize to the hint to avoid problem with hit detection\n            // in highlight.isHighlightAt (which uses comonentFromPoint)\n            this.drawPreview();\n            InternalEvent.consume(me.getEvent());\n            me.consume();\n        }\n    }\n    /**\n     * Handles the event to applying the previewed changes on the edge by\n     * using {@link moveLabel}, <connect> or <changePoints>.\n     */\n    mouseUp(sender, me) {\n        // Workaround for wrong event source in Webkit\n        if (this.index != null && this.marker != null) {\n            if (this.shape != null && this.shape.node != null) {\n                this.shape.node.style.display = '';\n            }\n            let edge = this.state.cell;\n            const { index } = this;\n            this.index = null;\n            // Ignores event if mouse has not been moved\n            if (me.getX() !== this.startX || me.getY() !== this.startY) {\n                const clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    this.graph.isCloneEvent(me.getEvent()) &&\n                    this.cloneEnabled &&\n                    this.graph.isCellsCloneable();\n                // Displays the reason for not carriying out the change\n                // if there is an error message with non-zero length\n                if (this.error != null) {\n                    if (this.error.length > 0) {\n                        this.graph.validationAlert(this.error);\n                    }\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE &&\n                    index > InternalEvent.VIRTUAL_HANDLE) {\n                    if (this.customHandles != null) {\n                        const model = this.graph.getDataModel();\n                        model.beginUpdate();\n                        try {\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                            if (this.shape != null && this.shape.node != null) {\n                                this.shape.apply(this.state);\n                                this.shape.redraw();\n                            }\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                }\n                else if (this.isLabel && this.label) {\n                    this.moveLabel(this.state, this.label.x, this.label.y);\n                }\n                else if (this.isSource || this.isTarget) {\n                    let terminal = null;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        terminal = this.constraintHandler.currentFocus.cell;\n                    }\n                    if (!terminal &&\n                        this.marker.hasValidState() &&\n                        this.marker.highlight != null &&\n                        this.marker.highlight.shape != null &&\n                        this.marker.highlight.shape.stroke !== 'transparent' &&\n                        this.marker.highlight.shape.stroke !== 'white') {\n                        terminal = this.marker.validState.cell;\n                    }\n                    if (terminal) {\n                        const model = this.graph.getDataModel();\n                        const parent = edge.getParent();\n                        model.beginUpdate();\n                        try {\n                            // Clones and adds the cell\n                            if (clone) {\n                                let geo = edge.getGeometry();\n                                const cloned = this.graph.cloneCell(edge);\n                                model.add(parent, cloned, parent.getChildCount());\n                                if (geo != null) {\n                                    geo = geo.clone();\n                                    model.setGeometry(cloned, geo);\n                                }\n                                const other = edge.getTerminal(!this.isSource);\n                                this.graph.connectCell(cloned, other, !this.isSource);\n                                edge = cloned;\n                            }\n                            edge = this.connect(edge, terminal, this.isSource, clone, me);\n                        }\n                        finally {\n                            model.endUpdate();\n                        }\n                    }\n                    else if (this.graph.isAllowDanglingEdges()) {\n                        const pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n                        pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n                        pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n                        const parent = edge.getParent();\n                        const pstate = parent ? this.graph.getView().getState(parent) : null;\n                        if (pstate != null) {\n                            pt.x -= pstate.origin.x;\n                            pt.y -= pstate.origin.y;\n                        }\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        // Destroys and recreates this handler\n                        edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n                    }\n                }\n                else if (this.active) {\n                    edge = this.changePoints(edge, this.points, clone);\n                }\n                else {\n                    this.graph.getView().invalidate(this.state.cell);\n                    this.graph.getView().validate(this.state.cell);\n                }\n            }\n            else if (this.graph.isToggleEvent(me.getEvent())) {\n                this.graph.selectCellForEvent(this.state.cell, me.getEvent());\n            }\n            // Resets the preview color the state of the handler if this\n            // handler has not been recreated\n            if (this.marker != null) {\n                this.reset();\n                // Updates the selection if the edge has been cloned\n                if (edge !== this.state.cell) {\n                    this.graph.setSelectionCell(edge);\n                }\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.active) {\n            this.refresh();\n        }\n        this.error = null;\n        this.index = null;\n        this.points = [];\n        this.snapPoint = null;\n        this.isLabel = false;\n        this.isSource = false;\n        this.isTarget = false;\n        this.active = false;\n        if (this.marker) {\n            this.marker.reset();\n        }\n        this.constraintHandler.reset();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].reset();\n            }\n        }\n        this.setPreviewColor(EDGE_SELECTION_COLOR);\n        this.removeHint();\n        this.redraw();\n    }\n    /**\n     * Sets the color of the preview to the given value.\n     */\n    setPreviewColor(color) {\n        this.shape.stroke = color;\n    }\n    /**\n     * Converts the given point in-place from screen to unscaled, untranslated\n     * graph coordinates and applies the grid. Returns the given, modified\n     * point instance.\n     *\n     * @param point {@link Point} to be converted.\n     * @param gridEnabled Boolean that specifies if the grid should be applied.\n     */\n    convertPoint(point, gridEnabled) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        if (gridEnabled) {\n            point.x = this.graph.snap(point.x);\n            point.y = this.graph.snap(point.y);\n        }\n        point.x = Math.round(point.x / scale - tr.x);\n        point.y = Math.round(point.y / scale - tr.y);\n        const parent = this.state.cell.getParent();\n        const pstate = parent ? this.graph.getView().getState(parent) : parent;\n        if (pstate) {\n            point.x -= pstate.origin.x;\n            point.y -= pstate.origin.y;\n        }\n        return point;\n    }\n    /**\n     * Changes the coordinates for the label of the given edge.\n     *\n     * @param edge <Cell> that represents the edge.\n     * @param x Integer that specifies the x-coordinate of the new location.\n     * @param y Integer that specifies the y-coordinate of the new location.\n     */\n    moveLabel(edgeState, x, y) {\n        const model = this.graph.getDataModel();\n        let geometry = edgeState.cell.getGeometry();\n        if (geometry != null) {\n            const { scale } = this.graph.getView();\n            geometry = geometry.clone();\n            if (geometry.relative) {\n                // Resets the relative location stored inside the geometry\n                let pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n                geometry.x = Math.round(pt.x * 10000) / 10000;\n                geometry.y = Math.round(pt.y);\n                // Resets the offset inside the geometry to find the offset\n                // from the resulting point\n                geometry.offset = new Point(0, 0);\n                pt = this.graph.view.getPoint(edgeState, geometry);\n                geometry.offset = new Point(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n            }\n            else {\n                const points = edgeState.absolutePoints;\n                const p0 = points[0];\n                const pe = points[points.length - 1];\n                if (p0 != null && pe != null) {\n                    const cx = p0.x + (pe.x - p0.x) / 2;\n                    const cy = p0.y + (pe.y - p0.y) / 2;\n                    geometry.offset = new Point(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n                    geometry.x = 0;\n                    geometry.y = 0;\n                }\n            }\n            model.setGeometry(edgeState.cell, geometry);\n        }\n    }\n    /**\n     * Changes the terminal or terminal point of the given edge in the graph\n     * model.\n     *\n     * @param edge <Cell> that represents the edge to be reconnected.\n     * @param terminal <Cell> that represents the new terminal.\n     * @param isSource Boolean indicating if the new terminal is the source or\n     * target terminal.\n     * @param isClone Boolean indicating if the new connection should be a clone of\n     * the old edge.\n     * @param me {@link MouseEvent} that contains the mouse up event.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const parent = edge.getParent();\n        this.graph.batchUpdate(() => {\n            let constraint = this.constraintHandler.currentConstraint;\n            if (constraint == null) {\n                constraint = new ConnectionConstraint(null);\n            }\n            this.graph.connectCell(edge, terminal, isSource, constraint);\n        });\n        return edge;\n    }\n    /**\n     * Changes the terminal point of the given edge.\n     */\n    changeTerminalPoint(edge, point, isSource, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const terminal = edge.getTerminal(!isSource);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, terminal, !isSource);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.setTerminalPoint(point, isSource);\n                model.setGeometry(edge, geo);\n                this.graph.connectCell(edge, null, isSource, new ConnectionConstraint(null));\n            }\n        });\n        return edge;\n    }\n    /**\n     * Changes the control points of the given edge in the graph model.\n     */\n    changePoints(edge, points, clone) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            if (clone) {\n                const parent = edge.getParent();\n                const source = edge.getTerminal(true);\n                const target = edge.getTerminal(false);\n                edge = this.graph.cloneCell(edge);\n                model.add(parent, edge, parent.getChildCount());\n                model.setTerminal(edge, source, true);\n                model.setTerminal(edge, target, false);\n            }\n            let geo = edge.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.points = points;\n                model.setGeometry(edge, geo);\n            }\n        });\n        return edge;\n    }\n    /**\n     * Adds a control point for the given state and event.\n     */\n    addPoint(state, evt) {\n        const pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n        const gridEnabled = this.graph.isGridEnabledEvent(evt);\n        this.convertPoint(pt, gridEnabled);\n        this.addPointAt(state, pt.x, pt.y);\n        InternalEvent.consume(evt);\n    }\n    /**\n     * Adds a control point at the given point.\n     */\n    addPointAt(state, x, y) {\n        let geo = state.cell.getGeometry();\n        const pt = new Point(x, y);\n        if (geo != null) {\n            geo = geo.clone();\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            let offset = new Point(t.x * s, t.y * s);\n            const parent = this.state.cell.getParent();\n            if (parent && parent.isVertex()) {\n                const pState = this.graph.view.getState(parent);\n                if (pState)\n                    offset = new Point(pState.x, pState.y);\n            }\n            const index = findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n            if (geo.points == null) {\n                geo.points = [pt];\n            }\n            else {\n                geo.points.splice(index, 0, pt);\n            }\n            this.graph.getDataModel().setGeometry(state.cell, geo);\n            this.refresh();\n            this.redraw();\n        }\n    }\n    /**\n     * Removes the control point at the given index from the given state.\n     */\n    removePoint(state, index) {\n        if (index > 0 && index < this.abspoints.length - 1) {\n            let geo = this.state.cell.getGeometry();\n            if (geo != null && geo.points != null) {\n                geo = geo.clone();\n                (geo.points || []).splice(index - 1, 1);\n                this.graph.getDataModel().setGeometry(state.cell, geo);\n                this.refresh();\n                this.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the fillcolor for the handle at the given index.\n     */\n    getHandleFillColor(index) {\n        const isSource = index === 0;\n        const { cell } = this.state;\n        const terminal = cell.getTerminal(isSource);\n        let color = HANDLE_FILLCOLOR;\n        if ((terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||\n            (terminal == null && !this.graph.isTerminalPointMovable(cell, isSource))) {\n            color = LOCKED_HANDLE_FILLCOLOR;\n        }\n        else if (terminal != null &&\n            this.graph.isCellDisconnectable(cell, terminal, isSource)) {\n            color = CONNECT_HANDLE_FILLCOLOR;\n        }\n        return color;\n    }\n    /**\n     * Redraws the preview, and the bends- and label control points.\n     */\n    redraw(ignoreHandles) {\n        this.abspoints = this.state.absolutePoints.slice();\n        const g = this.state.cell.getGeometry();\n        if (g) {\n            const pts = g.points;\n            if (this.bends != null && this.bends.length > 0) {\n                if (pts != null) {\n                    if (this.points == null) {\n                        this.points = [];\n                    }\n                    for (let i = 1; i < this.bends.length - 1; i += 1) {\n                        if (this.bends[i] != null && this.abspoints[i] != null) {\n                            this.points[i - 1] = pts[i - 1];\n                        }\n                    }\n                }\n            }\n        }\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Redraws the handles.\n     */\n    redrawHandles() {\n        const { cell } = this.state;\n        // Updates the handle for the label position\n        let b = this.labelShape.bounds;\n        this.label = new Point(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n        this.labelShape.bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n        // Shows or hides the label handle depending on the label\n        const lab = this.graph.getLabel(cell);\n        this.labelShape.visible =\n            lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);\n        if (this.bends != null && this.bends.length > 0) {\n            const n = this.abspoints.length - 1;\n            const p0 = this.abspoints[0];\n            const x0 = p0.x;\n            const y0 = p0.y;\n            b = this.bends[0].bounds;\n            this.bends[0].bounds = new Rectangle(Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);\n            this.bends[0].fill = this.getHandleFillColor(0);\n            this.bends[0].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[0].bounds);\n            }\n            const pe = this.abspoints[n];\n            const xn = pe.x;\n            const yn = pe.y;\n            const bn = this.bends.length - 1;\n            b = this.bends[bn].bounds;\n            this.bends[bn].bounds = new Rectangle(Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);\n            this.bends[bn].fill = this.getHandleFillColor(bn);\n            this.bends[bn].redraw();\n            if (this.manageLabelHandle) {\n                this.checkLabelHandle(this.bends[bn].bounds);\n            }\n            this.redrawInnerBends(p0, pe);\n        }\n        if (this.virtualBends && this.virtualBends.length > 0) {\n            let last = this.abspoints[0];\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {\n                    const pt = this.abspoints[i + 1];\n                    const b = this.virtualBends[i];\n                    const x = last.x + (pt.x - last.x) / 2;\n                    const y = last.y + (pt.y - last.y) / 2;\n                    if (b.bounds) {\n                        b.bounds = new Rectangle(Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n                        b.redraw();\n                    }\n                    setOpacity(b.node, this.virtualBendOpacity);\n                    last = pt;\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(b.bounds);\n                    }\n                }\n            }\n        }\n        this.labelShape.redraw();\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                const shape = this.customHandles[i].shape;\n                if (shape) {\n                    const temp = shape.node.style.display;\n                    this.customHandles[i].redraw();\n                    shape.node.style.display = temp;\n                    // Hides custom handles during text editing\n                    shape.node.style.visibility = this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return (!this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1);\n    }\n    /**\n     * Shortcut to <hideSizers>.\n     */\n    setHandlesVisible(visible) {\n        for (let i = 0; i < this.bends.length; i += 1) {\n            this.bends[i].node.style.display = visible ? '' : 'none';\n        }\n        if (this.virtualBends) {\n            for (let i = 0; i < this.virtualBends.length; i += 1) {\n                this.virtualBends[i].node.style.display = visible ? '' : 'none';\n            }\n        }\n        this.labelShape.node.style.display = visible ? '' : 'none';\n        if (this.customHandles) {\n            for (let i = 0; i < this.customHandles.length; i += 1) {\n                this.customHandles[i].setVisible(visible);\n            }\n        }\n    }\n    /**\n     * Updates and redraws the inner bends.\n     *\n     * @param p0 {@link Point} that represents the location of the first point.\n     * @param pe {@link Point} that represents the location of the last point.\n     */\n    redrawInnerBends(p0, pe) {\n        for (let i = 1; i < this.bends.length - 1; i += 1) {\n            if (this.bends[i] != null) {\n                if (this.abspoints[i] != null) {\n                    const { x } = this.abspoints[i];\n                    const { y } = this.abspoints[i];\n                    const b = this.bends[i].bounds;\n                    this.bends[i].node.style.visibility = 'visible';\n                    this.bends[i].bounds = new Rectangle(Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);\n                    if (this.manageLabelHandle) {\n                        this.checkLabelHandle(this.bends[i].bounds);\n                    }\n                    else if (this.handleImage == null &&\n                        this.labelShape.visible &&\n                        intersects(this.bends[i].bounds, this.labelShape.bounds)) {\n                        const w = HANDLE_SIZE + 3;\n                        const h = HANDLE_SIZE + 3;\n                        this.bends[i].bounds = new Rectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n                    }\n                    this.bends[i].redraw();\n                }\n                else {\n                    this.bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Checks if the label handle intersects the given bounds and moves it if it\n     * intersects.\n     */\n    checkLabelHandle(b) {\n        const b2 = this.labelShape.bounds;\n        if (intersects(b, b2)) {\n            if (b.getCenterY() < b2.getCenterY()) {\n                b2.y = b.y + b.height;\n            }\n            else {\n                b2.y = b.y - b2.height;\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        try {\n            if (this.isLabel) {\n                const b = this.labelShape.bounds;\n                const bounds = new Rectangle(Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n                if (!b.equals(bounds)) {\n                    this.labelShape.bounds = bounds;\n                    this.labelShape.redraw();\n                }\n            }\n            if (this.shape != null && !equalPoints(this.shape.points, this.abspoints)) {\n                this.shape.apply(this.state);\n                this.shape.points = this.abspoints.slice();\n                this.shape.scale = this.state.view.scale;\n                this.shape.isDashed = this.isSelectionDashed();\n                this.shape.stroke = this.getSelectionColor();\n                this.shape.strokeWidth =\n                    this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n                this.shape.isShadow = false;\n                this.shape.redraw();\n            }\n            this.updateParentHighlight();\n        }\n        catch (e) {\n            // ignore\n        }\n    }\n    /**\n     * Refreshes the bends of this handler.\n     */\n    refresh() {\n        if (this.state != null) {\n            this.abspoints = this.getSelectionPoints(this.state);\n            this.points = [];\n            this.destroyBends(this.bends);\n            this.bends = this.createBends();\n            if (this.virtualBends) {\n                this.destroyBends(this.virtualBends);\n                this.virtualBends = this.createVirtualBends();\n            }\n            if (this.customHandles) {\n                this.destroyBends(this.customHandles);\n                this.customHandles = this.createCustomHandles();\n            }\n            // Puts label node on top of bends\n            if (this.labelShape != null &&\n                this.labelShape.node != null &&\n                this.labelShape.node.parentNode != null) {\n                this.labelShape.node.parentNode.appendChild(this.labelShape.node);\n            }\n        }\n    }\n    /**\n     * Returns true if <destroy> was called.\n     */\n    isDestroyed() {\n        return this.shape == null;\n    }\n    /**\n     * Destroys all elements in <bends>.\n     */\n    destroyBends(bends) {\n        if (bends != null) {\n            for (let i = 0; i < bends.length; i += 1) {\n                if (bends[i] != null) {\n                    bends[i].destroy();\n                }\n            }\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This does\n     * normally not need to be called as handlers are destroyed automatically\n     * when the corresponding cell is deselected.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.marker.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.marker = null;\n        this.shape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.shape = null;\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        this.labelShape.destroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.labelShape = null;\n        this.constraintHandler.onDestroy();\n        // @ts-expect-error Can be null when destroyed.\n        this.constraintHandler = null;\n        if (this.virtualBends) {\n            this.destroyBends(this.virtualBends);\n            this.virtualBends = [];\n        }\n        if (this.customHandles) {\n            this.destroyBends(this.customHandles);\n            this.customHandles = [];\n        }\n        this.destroyBends(this.bends);\n        this.bends = [];\n        this.removeHint();\n    }\n}\nclass EdgeHandlerCellMarker extends CellMarker {\n    constructor(graph, edgeHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        // Only returns edges if they are connectable and never returns\n        // the edge that is currently being modified\n        this.getCell = (me) => {\n            let cell = super.getCell(me);\n            // Checks for cell at preview point (with grid)\n            if ((cell === this.edgeHandler.state.cell || !cell) &&\n                this.edgeHandler.currentPoint) {\n                cell = this.edgeHandler.graph.getCellAt(this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y);\n            }\n            // Uses connectable parent vertex if one exists\n            if (cell && !cell.isConnectable()) {\n                const parent = cell.getParent();\n                if (parent && parent.isVertex() && parent.isConnectable()) {\n                    cell = parent;\n                }\n            }\n            if (cell) {\n                if ((this.graph.isSwimlane(cell) &&\n                    this.edgeHandler.currentPoint &&\n                    this.graph.hitsSwimlaneContent(cell, this.edgeHandler.currentPoint.x, this.edgeHandler.currentPoint.y)) ||\n                    !this.edgeHandler.isConnectableCell(cell) ||\n                    cell === this.edgeHandler.state.cell ||\n                    (cell && !this.edgeHandler.graph.connectableEdges && cell.isEdge()) ||\n                    this.edgeHandler.state.cell.isAncestor(cell)) {\n                    cell = null;\n                }\n            }\n            if (cell && !cell.isConnectable()) {\n                cell = null;\n            }\n            return cell;\n        };\n        // Sets the highlight color according to validateConnection\n        this.isValidState = (state) => {\n            const cell = this.edgeHandler.state.cell.getTerminal(!this.edgeHandler.isSource);\n            const cellState = this.edgeHandler.graph.view.getState(cell);\n            const other = this.edgeHandler.graph.view.getTerminalPort(state, cellState, !this.edgeHandler.isSource);\n            const otherCell = other ? other.cell : null;\n            const source = this.edgeHandler.isSource ? state.cell : otherCell;\n            const target = this.edgeHandler.isSource ? otherCell : state.cell;\n            // Updates the error message of the handler\n            this.edgeHandler.error = this.edgeHandler.validateConnection(source, target);\n            return !this.edgeHandler.error;\n        };\n        this.edgeHandler = edgeHandler;\n    }\n}\nexport default EdgeHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement an ellipse shape.\n * This shape is registered by default under {@link SHAPE.ELLIPSE} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass EllipseShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Paints the ellipse shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.ellipse(x, y, w, h);\n        c.fillAndStroke();\n    }\n}\nexport default EllipseShape;\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Global configuration for {@link VertexHandler}.\n *\n * @experimental subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.12.0\n * @category Configuration\n */\nexport const VertexHandlerConfig = {\n    /**\n     * Enable rotation handle\n     * @default false\n     */\n    rotationEnabled: false,\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { CURSOR, DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, LABEL_HANDLE_FILLCOLOR, LABEL_HANDLE_SIZE, NONE, VERTEX_SELECTION_COLOR, VERTEX_SELECTION_DASHED, VERTEX_SELECTION_STROKEWIDTH, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport Point from '../geometry/Point';\nimport { getRotatedPoint, intersects, mod, toRadians } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isMouseEvent, isShiftDown } from '../../util/EventUtils';\nimport { VertexHandlerConfig } from './config';\n/**\n * Event handler for resizing cells.\n *\n * This handler is automatically created in {@link Graph#createHandler}.\n */\nclass VertexHandler {\n    /**\n     * Specifies if a rotation handle should be visible.\n     *\n     * This implementation returns {@link VertexHandlerConfig.rotationEnabled}.\n     * @since 0.12.0\n     */\n    isRotationEnabled() {\n        return VertexHandlerConfig.rotationEnabled;\n    }\n    /**\n     * Constructs an event handler that allows to resize vertices and groups.\n     *\n     * @param state {@link CellState} of the cell to be resized.\n     */\n    constructor(state) {\n        this.sizers = [];\n        /**\n         * Specifies if only one sizer handle at the bottom, right corner should be used.\n         * @default false\n         */\n        this.singleSizer = false;\n        /**\n         * Holds the index of the current handle.\n         */\n        this.index = null;\n        /**\n         * Specifies if the bounds of handles should be used for hit-detection in IE or if {@link tolerance} > 0.\n         * @default true\n         */\n        this.allowHandleBoundsCheck = true;\n        /**\n         * Optional {@link Image} to be used as handles.\n         * @default null\n         */\n        this.handleImage = null;\n        /**\n         * If handles are currently visible.\n         * @default true\n         */\n        this.handlesVisible = true;\n        /**\n         * Optional tolerance for hit-detection in {@link getHandleForEvent}.\n         * @default 0\n         */\n        this.tolerance = 0;\n        /**\n         * Specifies if the parent should be highlighted if a child cell is selected.\n         * @default false\n         */\n        this.parentHighlightEnabled = false;\n        /**\n         * Specifies if rotation steps should be \"rasterized\" depending on the distance to the handle.\n         * @default true\n         */\n        this.rotationRaster = true;\n        /**\n         * Specifies the cursor for the rotation handle.\n         * @default 'crosshair'.\n         */\n        this.rotationCursor = 'crosshair';\n        /**\n         * Specifies if resize should change the cell in-place. This is an experimental\n         * feature for non-touch devices.\n         * @default false\n         */\n        this.livePreview = false;\n        /**\n         * Specifies if the live preview should be moved to the front.\n         * @default false\n         */\n        this.movePreviewToFront = false;\n        /**\n         * Specifies if sizers should be hidden and spaced if the vertex is small.\n         * @default false\n         */\n        this.manageSizers = false;\n        /**\n         * Specifies if the size of groups should be constrained by the children.\n         * @default false\n         */\n        this.constrainGroupByChildren = false;\n        /**\n         * Vertical spacing for rotation icon.\n         * @default -16\n         */\n        this.rotationHandleVSpacing = -16;\n        /**\n         * The horizontal offset for the handles. This is updated in {@link redrawHandles}\n         * if {@link manageSizers} is `true` and the sizers are offset horizontally.\n         */\n        this.horizontalOffset = 0;\n        /**\n         * The horizontal offset for the handles. This is updated in <redrawHandles>\n         * if {@link manageSizers} is true and the sizers are offset vertically.\n         */\n        this.verticalOffset = 0;\n        this.minBounds = null;\n        this.x0 = 0;\n        this.y0 = 0;\n        this.customHandles = [];\n        this.inTolerance = false;\n        this.startX = 0;\n        this.startY = 0;\n        this.rotationShape = null;\n        this.currentAlpha = 100;\n        this.startAngle = 0;\n        this.startDist = 0;\n        this.ghostPreview = null;\n        this.livePreviewActive = false;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.parentState = null;\n        this.parentHighlight = null;\n        this.unscaledBounds = null;\n        this.preview = null;\n        this.labelShape = null;\n        this.edgeHandlers = [];\n        this.EMPTY_POINT = new Point();\n        this.state = state;\n        this.graph = this.state.view.graph;\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.selectionBorder = this.createSelectionShape(this.bounds);\n        // VML dialect required here for event transparency in IE\n        this.selectionBorder.dialect = DIALECT.SVG;\n        this.selectionBorder.pointerEvents = false;\n        this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        this.selectionBorder.init(this.graph.getView().getOverlayPane());\n        InternalEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n        if (this.graph.isCellMovable(this.state.cell)) {\n            this.selectionBorder.setCursor(CURSOR.MOVABLE_VERTEX);\n        }\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        // Adds the sizer handles\n        if (selectionHandler &&\n            (selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells)) {\n            const resizable = this.graph.isCellResizable(this.state.cell);\n            this.sizers = [];\n            if (resizable ||\n                (this.graph.isLabelMovable(this.state.cell) &&\n                    this.state.width >= 2 &&\n                    this.state.height >= 2)) {\n                let i = 0;\n                if (resizable) {\n                    if (!this.singleSizer) {\n                        this.sizers.push(this.createSizer('nw-resize', i++));\n                        this.sizers.push(this.createSizer('n-resize', i++));\n                        this.sizers.push(this.createSizer('ne-resize', i++));\n                        this.sizers.push(this.createSizer('w-resize', i++));\n                        this.sizers.push(this.createSizer('e-resize', i++));\n                        this.sizers.push(this.createSizer('sw-resize', i++));\n                        this.sizers.push(this.createSizer('s-resize', i++));\n                    }\n                    this.sizers.push(this.createSizer('se-resize', i++));\n                }\n                const geo = this.state.cell.getGeometry();\n                if (geo != null &&\n                    !geo.relative &&\n                    //!this.graph.isSwimlane(this.state.cell) &&      disable for now\n                    this.graph.isLabelMovable(this.state.cell)) {\n                    // Marks this as the label handle for getHandleForEvent\n                    this.labelShape = this.createSizer(CURSOR.LABEL_HANDLE, InternalEvent.LABEL_HANDLE, LABEL_HANDLE_SIZE, LABEL_HANDLE_FILLCOLOR);\n                    this.sizers.push(this.labelShape);\n                }\n            }\n            else if (this.graph.isCellMovable(this.state.cell) &&\n                !this.graph.isCellResizable(this.state.cell) &&\n                this.state.width < 2 &&\n                this.state.height < 2) {\n                this.labelShape = this.createSizer(CURSOR.MOVABLE_VERTEX, InternalEvent.LABEL_HANDLE, undefined, LABEL_HANDLE_FILLCOLOR);\n                this.sizers.push(this.labelShape);\n            }\n        }\n        // Adds the rotation handler\n        if (this.isRotationHandleVisible()) {\n            this.rotationShape = this.createSizer(this.rotationCursor, InternalEvent.ROTATION_HANDLE, HANDLE_SIZE + 3, HANDLE_FILLCOLOR);\n            this.sizers.push(this.rotationShape);\n        }\n        this.customHandles = this.createCustomHandles();\n        this.redraw();\n        if (this.constrainGroupByChildren) {\n            this.updateMinBounds();\n        }\n        // Handles escape keystrokes\n        this.escapeHandler = (_sender, _evt) => {\n            if (this.livePreview && this.index != null) {\n                // Redraws the live preview\n                this.state.view.graph.cellRenderer.redraw(this.state, true);\n                // Redraws connected edges\n                this.state.view.invalidate(this.state.cell);\n                this.state.invalid = false;\n                this.state.view.validate();\n            }\n            this.reset();\n        };\n        this.state.view.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns `true` if the rotation handle should be showing.\n     */\n    isRotationHandleVisible() {\n        const selectionHandler = this.graph.getPlugin('SelectionHandler');\n        const selectionHandlerCheck = selectionHandler\n            ? selectionHandler.maxCells <= 0 ||\n                this.graph.getSelectionCount() < selectionHandler.maxCells\n            : true;\n        return (this.graph.isEnabled() &&\n            this.isRotationEnabled() &&\n            this.graph.isCellRotatable(this.state.cell) &&\n            selectionHandlerCheck);\n    }\n    /**\n     * Returns `true` if the aspect ratio if the cell should be maintained.\n     */\n    isConstrainedEvent(me) {\n        return isShiftDown(me.getEvent()) || this.state.style.aspect === 'fixed';\n    }\n    /**\n     * Returns `true` if the center of the vertex should be maintained during the resize.\n     */\n    isCenteredEvent(state, me) {\n        return false;\n    }\n    /**\n     * Returns an array of custom handles.\n     *\n     * This implementation returns an empty array.\n     */\n    createCustomHandles() {\n        return [];\n    }\n    /**\n     * Initializes the shapes required for this vertex handler.\n     */\n    updateMinBounds() {\n        const children = this.graph.getChildCells(this.state.cell);\n        if (children.length > 0) {\n            this.minBounds = this.graph.view.getBounds(children);\n            if (this.minBounds) {\n                const s = this.state.view.scale;\n                const t = this.state.view.translate;\n                this.minBounds.x -= this.state.x;\n                this.minBounds.y -= this.state.y;\n                this.minBounds.x /= s;\n                this.minBounds.y /= s;\n                this.minBounds.width /= s;\n                this.minBounds.height /= s;\n                this.x0 = this.state.x / s - t.x;\n                this.y0 = this.state.y / s - t.y;\n            }\n        }\n    }\n    /**\n     * Returns the Rectangle that defines the bounds of the selection border.\n     */\n    getSelectionBounds(state) {\n        return new Rectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createParentHighlightShape(bounds) {\n        return this.createSelectionShape(bounds);\n    }\n    /**\n     * Creates the shape used to draw the selection border.\n     */\n    createSelectionShape(bounds) {\n        const shape = new RectangleShape(Rectangle.fromRectangle(bounds), NONE, this.getSelectionColor());\n        shape.strokeWidth = this.getSelectionStrokeWidth();\n        shape.isDashed = this.isSelectionDashed();\n        return shape;\n    }\n    /**\n     * Returns {@link VERTEX_SELECTION_COLOR}.\n     */\n    getSelectionColor() {\n        return VERTEX_SELECTION_COLOR;\n    }\n    /**\n     * Returns {@link VERTEX_SELECTION_STROKEWIDTH}.\n     */\n    getSelectionStrokeWidth() {\n        return VERTEX_SELECTION_STROKEWIDTH;\n    }\n    /**\n     * Returns {@link VERTEX_SELECTION_DASHED}.\n     */\n    isSelectionDashed() {\n        return VERTEX_SELECTION_DASHED;\n    }\n    /**\n     * Creates a sizer handle for the specified cursor and index and returns\n     * the new {@link RectangleShape} that represents the handle.\n     */\n    createSizer(cursor, index, size = HANDLE_SIZE, fillColor = HANDLE_FILLCOLOR) {\n        const bounds = new Rectangle(0, 0, size, size);\n        const sizer = this.createSizerShape(bounds, index, fillColor);\n        if (sizer.bounds &&\n            sizer.isHtmlAllowed() &&\n            this.state.text &&\n            this.state.text.node.parentNode === this.graph.container) {\n            sizer.bounds.height -= 1;\n            sizer.bounds.width -= 1;\n            sizer.dialect = DIALECT.STRICTHTML;\n            sizer.init(this.graph.container);\n        }\n        else {\n            sizer.dialect =\n                this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            sizer.init(this.graph.getView().getOverlayPane());\n        }\n        InternalEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n        if (this.graph.isEnabled()) {\n            sizer.setCursor(cursor);\n        }\n        if (!this.isSizerVisible(index)) {\n            sizer.visible = false;\n        }\n        return sizer;\n    }\n    /**\n     * Returns `true` if the sizer for the given index is visible.\n     *\n     * This implementation returns `true` for all given indices.\n     */\n    isSizerVisible(_index) {\n        return true;\n    }\n    /**\n     * Creates the shape used for the sizer handle for the specified bounds an\n     * index. Only images and rectangles should be returned if support for HTML\n     * labels with not foreign objects is required.\n     */\n    createSizerShape(bounds, index, fillColor = HANDLE_FILLCOLOR) {\n        if (this.handleImage) {\n            bounds = new Rectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n            const shape = new ImageShape(bounds, this.handleImage.src);\n            // Allows HTML rendering of the images\n            shape.preserveImageAspect = false;\n            return shape;\n        }\n        if (index === InternalEvent.ROTATION_HANDLE) {\n            return new EllipseShape(bounds, fillColor, HANDLE_STROKECOLOR);\n        }\n        return new RectangleShape(bounds, fillColor, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Helper method to create an {@link Rectangle} around the given center point\n     * with a width and height of 2*s or 6, if no s is given.\n     */\n    moveSizerTo(shape, x, y) {\n        if (shape && shape.bounds) {\n            shape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n            shape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n            // Fixes visible inactive handles in VML\n            if (shape.node && shape.node.style.display !== 'none') {\n                shape.redraw();\n            }\n        }\n    }\n    /**\n     * Returns the index of the handle for the given event. This returns the index\n     * of the sizer from where the event originated or {@link InternalEvent.LABEL_HANDLE}.\n     */\n    getHandleForEvent(me) {\n        // Connection highlight may consume events before they reach sizer handle\n        const tol = !isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n        const hit = this.allowHandleBoundsCheck && tol > 0\n            ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n            : null;\n        const checkShape = (shape) => {\n            const st = shape && shape.constructor !== ImageShape && this.allowHandleBoundsCheck\n                ? shape.strokeWidth + shape.svgStrokeTolerance\n                : null;\n            const real = st\n                ? new Rectangle(me.getGraphX() - Math.floor(st / 2), me.getGraphY() - Math.floor(st / 2), st, st)\n                : hit;\n            return (shape &&\n                shape.bounds &&\n                (me.isSource(shape) ||\n                    (real &&\n                        intersects(shape.bounds, real) &&\n                        shape.node.style.display !== 'none' &&\n                        shape.node.style.visibility !== 'hidden')));\n        };\n        if (checkShape(this.rotationShape)) {\n            return InternalEvent.ROTATION_HANDLE;\n        }\n        if (checkShape(this.labelShape)) {\n            return InternalEvent.LABEL_HANDLE;\n        }\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            if (checkShape(this.sizers[i])) {\n                return i;\n            }\n        }\n        if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n            // Inverse loop order to match display order\n            for (let i = this.customHandles.length - 1; i >= 0; i--) {\n                if (checkShape(this.customHandles[i].shape)) {\n                    // LATER: Return reference to active shape\n                    return InternalEvent.CUSTOM_HANDLE - i;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns `true` if the given event allows custom handles to be changed.\n     *\n     * This implementation returns `true`.\n     */\n    isCustomHandleEvent(me) {\n        return true;\n    }\n    /**\n     * Handles the event if a handle has been clicked. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() && this.graph.isEnabled()) {\n            const handle = this.getHandleForEvent(me);\n            if (handle) {\n                this.start(me.getGraphX(), me.getGraphY(), handle);\n                me.consume();\n            }\n        }\n    }\n    /**\n     * Called if {@link livePreview} is enabled to check if a border should be painted.\n     *\n     * This implementation returns `true` if the shape is transparent.\n     */\n    isLivePreviewBorder() {\n        return (this.state.shape &&\n            this.state.shape.fill === NONE &&\n            this.state.shape.stroke === NONE);\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(x, y, index) {\n        this.livePreviewActive = this.livePreview && this.state.cell.getChildCount() === 0;\n        this.inTolerance = true;\n        this.childOffsetX = 0;\n        this.childOffsetY = 0;\n        this.index = index;\n        this.startX = x;\n        this.startY = y;\n        if (this.index <= InternalEvent.CUSTOM_HANDLE && this.isGhostPreview()) {\n            this.ghostPreview = this.createGhostPreview();\n        }\n        else {\n            // Saves reference to parent state\n            const { model } = this.state.view.graph;\n            const parent = this.state.cell.getParent();\n            if (this.state.view.currentRoot !== parent &&\n                parent &&\n                (parent.isVertex() || parent.isEdge())) {\n                this.parentState = this.state.view.graph.view.getState(parent);\n            }\n            // Creates a preview that can be on top of any HTML label\n            this.selectionBorder.node.style.display =\n                index === InternalEvent.ROTATION_HANDLE ? 'inline' : 'none';\n            // Creates the border that represents the new bounds\n            if (!this.livePreviewActive || this.isLivePreviewBorder()) {\n                this.preview = this.createSelectionShape(this.bounds);\n                if (!(Client.IS_SVG && Number(this.state.style.rotation || '0') !== 0) &&\n                    this.state.text != null &&\n                    this.state.text.node.parentNode === this.graph.container) {\n                    this.preview.dialect = DIALECT.STRICTHTML;\n                    this.preview.init(this.graph.container);\n                }\n                else {\n                    this.preview.dialect = DIALECT.SVG;\n                    this.preview.init(this.graph.view.getOverlayPane());\n                }\n            }\n            if (index === InternalEvent.ROTATION_HANDLE) {\n                // With the rotation handle in a corner, need the angle and distance\n                const pos = this.getRotationHandlePosition();\n                const dx = pos.x - this.state.getCenterX();\n                const dy = pos.y - this.state.getCenterY();\n                this.startAngle = dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : 0;\n                this.startDist = Math.sqrt(dx * dx + dy * dy);\n            }\n            // Prepares the handles for live preview\n            if (this.livePreviewActive) {\n                this.hideSizers();\n                if (index === InternalEvent.ROTATION_HANDLE && this.rotationShape) {\n                    this.rotationShape.node.style.display = '';\n                }\n                else if (index === InternalEvent.LABEL_HANDLE && this.labelShape) {\n                    this.labelShape.node.style.display = '';\n                }\n                else if (this.sizers[index]) {\n                    this.sizers[index].node.style.display = '';\n                }\n                else if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    this.customHandles[InternalEvent.CUSTOM_HANDLE - index].setVisible(true);\n                }\n                // Gets the array of connected edge handlers for redrawing\n                const edges = this.state.cell.getEdges();\n                this.edgeHandlers = [];\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                for (let i = 0; i < edges.length; i += 1) {\n                    const handler = selectionCellsHandler?.getHandler(edges[i]);\n                    if (handler) {\n                        this.edgeHandlers.push(handler);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    createGhostPreview() {\n        const shape = this.graph.cellRenderer.createShape(this.state);\n        shape.init(this.graph.view.getOverlayPane());\n        shape.scale = this.state.view.scale;\n        shape.bounds = this.bounds;\n        shape.outline = true;\n        return shape;\n    }\n    /**\n     * Shortcut to {@link hideSizers}.\n     */\n    setHandlesVisible(visible) {\n        this.handlesVisible = visible;\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].node.style.display = visible ? '' : 'none';\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].setVisible(visible);\n        }\n    }\n    /**\n     * Hides all sizers except.\n     *\n     * Starts the handling of the mouse gesture.\n     */\n    hideSizers() {\n        this.setHandlesVisible(false);\n    }\n    /**\n     * Checks if the coordinates for the given event are within the\n     * {@link Graph#tolerance}. If the event is a mouse event then the tolerance is\n     * ignored.\n     */\n    checkTolerance(me) {\n        if (this.inTolerance && this.startX !== null && this.startY !== null) {\n            if (isMouseEvent(me.getEvent()) ||\n                Math.abs(me.getGraphX() - this.startX) > this.graph.getEventTolerance() ||\n                Math.abs(me.getGraphY() - this.startY) > this.graph.getEventTolerance()) {\n                this.inTolerance = false;\n            }\n        }\n    }\n    /**\n     * Hook for subclasses do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclasses to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the angle. This uses {@link Math.round}.\n     */\n    roundAngle(angle) {\n        return Math.round(angle * 10) / 10;\n    }\n    /**\n     * Hook for rounding the unscaled width or height. This uses {@link Math.round}.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Handles the event by updating the preview.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() && this.index != null) {\n            // Checks tolerance for ignoring single clicks\n            this.checkTolerance(me);\n            if (!this.inTolerance) {\n                if (this.index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].active = true;\n                        if (this.ghostPreview != null) {\n                            this.ghostPreview.apply(this.state);\n                            this.ghostPreview.strokeWidth =\n                                this.getSelectionStrokeWidth() /\n                                    this.ghostPreview.scale /\n                                    this.ghostPreview.scale;\n                            this.ghostPreview.isDashed = this.isSelectionDashed();\n                            this.ghostPreview.stroke = this.getSelectionColor();\n                            this.ghostPreview.redraw();\n                            if (this.selectionBounds != null) {\n                                this.selectionBorder.node.style.display = 'none';\n                            }\n                        }\n                        else {\n                            if (this.movePreviewToFront) {\n                                this.moveToFront();\n                            }\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - this.index].positionChanged();\n                        }\n                    }\n                }\n                else if (this.index === InternalEvent.LABEL_HANDLE) {\n                    this.moveLabel(me);\n                }\n                else {\n                    if (this.index === InternalEvent.ROTATION_HANDLE) {\n                        this.rotateVertex(me);\n                    }\n                    else {\n                        this.resizeVertex(me);\n                    }\n                    this.updateHint(me);\n                }\n            }\n            me.consume();\n        }\n        // Workaround for disabling the connect highlight when over handle\n        else if (!this.graph.isMouseDown && this.getHandleForEvent(me)) {\n            me.consume(false);\n        }\n    }\n    /**\n     * Returns `true` if a ghost preview should be used for custom handles.\n     */\n    isGhostPreview() {\n        return this.state.cell.getChildCount() > 0;\n    }\n    /**\n     * Moves the vertex.\n     */\n    moveLabel(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        if (this.graph.isGridEnabledEvent(me.getEvent())) {\n            point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n            point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n        }\n        const index = this.rotationShape ? this.sizers.length - 2 : this.sizers.length - 1;\n        this.moveSizerTo(this.sizers[index], point.x, point.y);\n    }\n    /**\n     * Rotates the vertex.\n     */\n    rotateVertex(me) {\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        let dx = this.state.x + this.state.width / 2 - point.x;\n        let dy = this.state.y + this.state.height / 2 - point.y;\n        this.currentAlpha =\n            dx !== 0 ? (Math.atan(dy / dx) * 180) / Math.PI + 90 : dy < 0 ? 180 : 0;\n        if (dx > 0) {\n            this.currentAlpha -= 180;\n        }\n        this.currentAlpha -= this.startAngle;\n        // Rotation raster\n        if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {\n            let raster;\n            dx = point.x - this.state.getCenterX();\n            dy = point.y - this.state.getCenterY();\n            const dist = Math.sqrt(dx * dx + dy * dy);\n            if (dist - this.startDist < 2) {\n                raster = 15;\n            }\n            else if (dist - this.startDist < 25) {\n                raster = 5;\n            }\n            else {\n                raster = 1;\n            }\n            this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n        }\n        else {\n            this.currentAlpha = this.roundAngle(this.currentAlpha);\n        }\n        this.selectionBorder.rotation = this.currentAlpha;\n        this.selectionBorder.redraw();\n        if (this.livePreviewActive) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Resizes the vertex.\n     */\n    resizeVertex(me) {\n        const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n        const alpha = toRadians(this.state.style.rotation ?? 0);\n        const point = new Point(me.getGraphX(), me.getGraphY());\n        const tr = this.graph.view.translate;\n        const { scale } = this.graph.view;\n        let cos = Math.cos(-alpha);\n        let sin = Math.sin(-alpha);\n        let dx = point.x - this.startX;\n        let dy = point.y - this.startY;\n        // Rotates vector for mouse gesture\n        const tx = cos * dx - sin * dy;\n        const ty = sin * dx + cos * dy;\n        dx = tx;\n        dy = ty;\n        const geo = this.state.cell.getGeometry();\n        if (geo && this.index !== null) {\n            this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new Point(0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));\n        }\n        // Keeps vertex within maximum graph or parent bounds\n        if (geo && !geo.relative) {\n            let max = this.graph.getMaximumGraphBounds();\n            // Handles child cells\n            if (max != null && this.parentState != null) {\n                max = Rectangle.fromRectangle(max);\n                max.x -= (this.parentState.x - tr.x * scale) / scale;\n                max.y -= (this.parentState.y - tr.y * scale) / scale;\n            }\n            if (this.graph.isConstrainChild(this.state.cell)) {\n                let tmp = this.graph.getCellContainmentArea(this.state.cell);\n                if (tmp != null) {\n                    const overlap = this.graph.getOverlap(this.state.cell);\n                    if (overlap > 0) {\n                        tmp = Rectangle.fromRectangle(tmp);\n                        tmp.x -= tmp.width * overlap;\n                        tmp.y -= tmp.height * overlap;\n                        tmp.width += 2 * tmp.width * overlap;\n                        tmp.height += 2 * tmp.height * overlap;\n                    }\n                    if (!max) {\n                        max = tmp;\n                    }\n                    else {\n                        max = Rectangle.fromRectangle(max);\n                        max.intersect(tmp);\n                    }\n                }\n            }\n            if (max && this.unscaledBounds) {\n                if (this.unscaledBounds.x < max.x) {\n                    this.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n                    this.unscaledBounds.x = max.x;\n                }\n                if (this.unscaledBounds.y < max.y) {\n                    this.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n                    this.unscaledBounds.y = max.y;\n                }\n                if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {\n                    this.unscaledBounds.width -=\n                        this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;\n                }\n                if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {\n                    this.unscaledBounds.height -=\n                        this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;\n                }\n            }\n        }\n        if (this.unscaledBounds) {\n            const old = this.bounds;\n            this.bounds = new Rectangle((this.parentState ? this.parentState.x : tr.x * scale) +\n                this.unscaledBounds.x * scale, (this.parentState ? this.parentState.y : tr.y * scale) +\n                this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n            if (geo && geo.relative && this.parentState) {\n                this.bounds.x += this.state.x - this.parentState.x;\n                this.bounds.y += this.state.y - this.parentState.y;\n            }\n            cos = Math.cos(alpha);\n            sin = Math.sin(alpha);\n            const c2 = new Point(this.bounds.getCenterX(), this.bounds.getCenterY());\n            dx = c2.x - ct.x;\n            dy = c2.y - ct.y;\n            const dx2 = cos * dx - sin * dy;\n            const dy2 = sin * dx + cos * dy;\n            const dx3 = dx2 - dx;\n            const dy3 = dy2 - dy;\n            const dx4 = this.bounds.x - this.state.x;\n            const dy4 = this.bounds.y - this.state.y;\n            const dx5 = cos * dx4 - sin * dy4;\n            const dy5 = sin * dx4 + cos * dy4;\n            this.bounds.x += dx3;\n            this.bounds.y += dy3;\n            // Rounds unscaled bounds to int\n            this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n            this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n            this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n            this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n            // Shifts the children according to parent offset\n            if (!this.state.cell.isCollapsed() && (dx3 !== 0 || dy3 !== 0)) {\n                this.childOffsetX = this.state.x - this.bounds.x + dx5;\n                this.childOffsetY = this.state.y - this.bounds.y + dy5;\n            }\n            else {\n                this.childOffsetX = 0;\n                this.childOffsetY = 0;\n            }\n            if (!old.equals(this.bounds)) {\n                if (this.livePreviewActive) {\n                    this.updateLivePreview(me);\n                }\n                if (this.preview != null) {\n                    this.drawPreview();\n                }\n                else {\n                    this.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Repaints the live preview.\n     */\n    updateLivePreview(me) {\n        // TODO: Apply child offset to children in live preview\n        const { scale } = this.graph.view;\n        const tr = this.graph.view.translate;\n        // Saves current state\n        const tempState = this.state.clone();\n        // Temporarily changes size and origin\n        this.state.x = this.bounds.x;\n        this.state.y = this.bounds.y;\n        this.state.origin = new Point(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n        this.state.width = this.bounds.width;\n        this.state.height = this.bounds.height;\n        // Redraws cell and handles\n        let off = this.state.absoluteOffset;\n        off = new Point(off.x, off.y);\n        // Required to store and reset absolute offset for updating label position\n        this.state.absoluteOffset.x = 0;\n        this.state.absoluteOffset.y = 0;\n        const geo = this.state.cell.getGeometry();\n        if (geo != null) {\n            const offset = geo.offset || this.EMPTY_POINT;\n            if (offset != null && !geo.relative) {\n                this.state.absoluteOffset.x = this.state.view.scale * offset.x;\n                this.state.absoluteOffset.y = this.state.view.scale * offset.y;\n            }\n            this.state.view.updateVertexLabelOffset(this.state);\n        }\n        // Draws the live preview\n        this.state.view.graph.cellRenderer.redraw(this.state, true);\n        // Redraws connected edges TODO: Include child edges\n        this.state.view.invalidate(this.state.cell);\n        this.state.invalid = false;\n        this.state.view.validate();\n        this.redrawHandles();\n        // Moves live preview to front\n        if (this.movePreviewToFront) {\n            this.moveToFront();\n        }\n        // Hides folding icon\n        if (this.state.control != null && this.state.control.node != null) {\n            this.state.control.node.style.visibility = 'hidden';\n        }\n        // Restores current state\n        this.state.setState(tempState);\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    moveToFront() {\n        if ((this.state.text && this.state.text.node && this.state.text.node.nextSibling) ||\n            (this.state.shape &&\n                this.state.shape.node &&\n                this.state.shape.node.nextSibling &&\n                (!this.state.text || this.state.shape.node.nextSibling !== this.state.text.node))) {\n            if (this.state.shape && this.state.shape.node && this.state.shape.node.parentNode) {\n                this.state.shape.node.parentNode.appendChild(this.state.shape.node);\n            }\n            if (this.state.text && this.state.text.node && this.state.text.node.parentNode) {\n                this.state.text.node.parentNode.appendChild(this.state.text.node);\n            }\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the geometry.\n     */\n    mouseUp(sender, me) {\n        if (this.index != null && this.state != null) {\n            const point = new Point(me.getGraphX(), me.getGraphY());\n            const { index } = this;\n            this.index = null;\n            if (this.ghostPreview == null) {\n                // Required to restore order in case of no change\n                this.state.view.invalidate(this.state.cell, false, false);\n                this.state.view.validate();\n            }\n            this.graph.batchUpdate(() => {\n                if (index <= InternalEvent.CUSTOM_HANDLE) {\n                    if (this.customHandles != null) {\n                        // Creates style before changing cell state\n                        const style = this.state.view.graph.getCellStyle(this.state.cell);\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].active = false;\n                        this.customHandles[InternalEvent.CUSTOM_HANDLE - index].execute(me);\n                        // Sets style and apply on shape to force repaint and\n                        // check if execute has removed custom handles\n                        if (this.customHandles != null &&\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index] != null) {\n                            this.state.style = style;\n                            this.customHandles[InternalEvent.CUSTOM_HANDLE - index].positionChanged();\n                        }\n                    }\n                }\n                else if (index === InternalEvent.ROTATION_HANDLE) {\n                    if (this.currentAlpha != null) {\n                        const delta = this.currentAlpha - (this.state.style.rotation ?? 0);\n                        if (delta !== 0) {\n                            this.rotateCell(this.state.cell, delta);\n                        }\n                    }\n                    else {\n                        this.rotateClick();\n                    }\n                }\n                else {\n                    const gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    let dx = point.x - this.startX;\n                    let dy = point.y - this.startY;\n                    // Rotates vector for mouse gesture\n                    const tx = cos * dx - sin * dy;\n                    const ty = sin * dx + cos * dy;\n                    dx = tx;\n                    dy = ty;\n                    const s = this.graph.view.scale;\n                    const recurse = this.isRecursiveResize(this.state, me);\n                    this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), index, gridEnabled, this.isConstrainedEvent(me), recurse);\n                }\n            });\n            me.consume();\n            this.reset();\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the `recursiveResize` status of the given state.\n     * @param state the given {@link CellState}. This implementation takes the value of this state.\n     * @param me the mouse event.\n     */\n    isRecursiveResize(state, me) {\n        return this.graph.isRecursiveResize(this.state);\n    }\n    /**\n     * Hook for subclasses to implement a single click on the rotation handle.\n     * This code is executed as part of the model transaction.\n     *\n     * This implementation is empty.\n     */\n    rotateClick() {\n        return;\n    }\n    /**\n     * Rotates the given cell and its children by the given angle in degrees.\n     *\n     * @param cell {@link Cell} to be rotated.\n     * @param angle Angle in degrees.\n     * @param parent if set, consider the parent in the rotation computation.\n     */\n    rotateCell(cell, angle, parent) {\n        if (angle !== 0) {\n            const model = this.graph.getDataModel();\n            if (cell.isVertex() || cell.isEdge()) {\n                if (!cell.isEdge()) {\n                    const style = this.graph.getCurrentCellStyle(cell);\n                    const total = (style.rotation || 0) + angle;\n                    this.graph.setCellStyles('rotation', total, [cell]);\n                }\n                let geo = cell.getGeometry();\n                if (geo && parent) {\n                    const pgeo = parent.getGeometry();\n                    if (pgeo != null && !parent.isEdge()) {\n                        geo = geo.clone();\n                        geo.rotate(angle, new Point(pgeo.width / 2, pgeo.height / 2));\n                        model.setGeometry(cell, geo);\n                    }\n                    if ((cell.isVertex() && !geo.relative) || cell.isEdge()) {\n                        // Recursive rotation\n                        const childCount = cell.getChildCount();\n                        for (let i = 0; i < childCount; i += 1) {\n                            this.rotateCell(cell.getChildAt(i), angle, cell);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.index !== null && this.sizers[this.index].node.style.display === 'none') {\n            this.sizers[this.index].node.style.display = '';\n        }\n        this.index = null;\n        // TODO: Reset and redraw cell states for live preview\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.livePreviewActive) {\n            for (let i = 0; i < this.sizers.length; i += 1) {\n                this.sizers[i].node.style.display = '';\n            }\n            // Shows folding icon\n            if (this.state.control && this.state.control.node) {\n                this.state.control.node.style.visibility = '';\n            }\n        }\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            if (this.customHandles[i].active) {\n                this.customHandles[i].active = false;\n                this.customHandles[i].reset();\n            }\n            else {\n                this.customHandles[i].setVisible(true);\n            }\n        }\n        // Checks if handler has been destroyed\n        this.selectionBorder.node.style.display = 'inline';\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        this.removeHint();\n        this.redrawHandles();\n        this.edgeHandlers = [];\n        this.handlesVisible = true;\n        this.unscaledBounds = null;\n    }\n    /**\n     * Uses the given vector to change the bounds of the given cell\n     * in the graph using {@link Graph#resizeCell}.\n     */\n    resizeCell(cell, dx, dy, index, gridEnabled, constrained, recurse) {\n        let geo = cell.getGeometry();\n        if (geo) {\n            if (index === InternalEvent.LABEL_HANDLE &&\n                this.labelShape &&\n                this.labelShape.bounds) {\n                const alpha = -toRadians(this.state.style.rotation ?? 0);\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const { scale } = this.graph.view;\n                const pt = getRotatedPoint(new Point(Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale), Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale)), cos, sin);\n                geo = geo.clone();\n                if (geo.offset == null) {\n                    geo.offset = pt;\n                }\n                else {\n                    geo.offset.x += pt.x;\n                    geo.offset.y += pt.y;\n                }\n                this.graph.model.setGeometry(cell, geo);\n            }\n            else if (this.unscaledBounds) {\n                const { scale } = this.graph.view;\n                if (this.childOffsetX !== 0 || this.childOffsetY !== 0) {\n                    this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n                }\n                this.graph.resizeCell(cell, this.unscaledBounds, recurse);\n            }\n        }\n    }\n    /**\n     * Moves the children of the given cell by the given vector.\n     */\n    moveChildren(cell, dx, dy) {\n        const model = this.graph.getDataModel();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            let geo = child.getGeometry();\n            if (geo != null) {\n                geo = geo.clone();\n                geo.translate(dx, dy);\n                model.setGeometry(child, geo);\n            }\n        }\n    }\n    /**\n     * Returns the union of the given bounds and location for the specified\n     * handle index.\n     *\n     * To override this to limit the size of vertex via a minWidth/-Height style,\n     * the following code can be used.\n     *\n     * ```javascript\n     * let vertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = vertexHandlerUnion.apply(this, arguments);\n     *\n     *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n     *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n     *\n     *   return result;\n     * };\n     * ```\n     *\n     * The minWidth/-Height style can then be used as follows:\n     *\n     * ```javascript\n     * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n     * ```\n     *\n     * To override this to update the height for a wrapped text if the width of a vertex is\n     * changed, the following can be used.\n     *\n     * ```javascript\n     * let mxVertexHandlerUnion = union;\n     * union = (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)=>\n     * {\n     *   let result = mxVertexHandlerUnion.apply(this, arguments);\n     *   let s = this.state;\n     *\n     *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n     *       s.text != null && s.style.whiteSpace == 'wrap')\n     *   {\n     *     let label = this.graph.getLabel(s.cell);\n     *     let fontSize = mxUtils.getNumber(s.style, 'fontSize', mxConstants.DEFAULT_FONTSIZE);\n     *     let ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n     *\n     *     result.height = mxUtils.getSizeForString(label, fontSize, s.style.fontFamily, ww).height;\n     *   }\n     *\n     *   return result;\n     * };\n     * ```\n     */\n    union(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {\n        gridEnabled = gridEnabled && this.graph.isGridEnabled();\n        if (this.singleSizer) {\n            let x = bounds.x + bounds.width + dx;\n            let y = bounds.y + bounds.height + dy;\n            if (gridEnabled) {\n                x = this.graph.snap(x / scale) * scale;\n                y = this.graph.snap(y / scale) * scale;\n            }\n            const rect = new Rectangle(bounds.x, bounds.y, 0, 0);\n            rect.add(new Rectangle(x, y, 0, 0));\n            return rect;\n        }\n        const w0 = bounds.width;\n        const h0 = bounds.height;\n        let left = bounds.x - tr.x * scale;\n        let right = left + w0;\n        let top = bounds.y - tr.y * scale;\n        let bottom = top + h0;\n        const cx = left + w0 / 2;\n        const cy = top + h0 / 2;\n        if (index > 4 /* Bottom Row */) {\n            bottom += dy;\n            if (gridEnabled) {\n                bottom = this.graph.snap(bottom / scale) * scale;\n            }\n            else {\n                bottom = Math.round(bottom / scale) * scale;\n            }\n        }\n        else if (index < 3 /* Top Row */) {\n            top += dy;\n            if (gridEnabled) {\n                top = this.graph.snap(top / scale) * scale;\n            }\n            else {\n                top = Math.round(top / scale) * scale;\n            }\n        }\n        if (index === 0 || index === 3 || index === 5 /* Left */) {\n            left += dx;\n            if (gridEnabled) {\n                left = this.graph.snap(left / scale) * scale;\n            }\n            else {\n                left = Math.round(left / scale) * scale;\n            }\n        }\n        else if (index === 2 || index === 4 || index === 7 /* Right */) {\n            right += dx;\n            if (gridEnabled) {\n                right = this.graph.snap(right / scale) * scale;\n            }\n            else {\n                right = Math.round(right / scale) * scale;\n            }\n        }\n        let width = right - left;\n        let height = bottom - top;\n        if (constrained) {\n            const geo = this.state.cell.getGeometry();\n            if (geo != null) {\n                const aspect = geo.width / geo.height;\n                if (index === 1 || index === 2 || index === 7 || index === 6) {\n                    width = height * aspect;\n                }\n                else {\n                    height = width / aspect;\n                }\n                if (index === 0) {\n                    left = right - width;\n                    top = bottom - height;\n                }\n            }\n        }\n        if (centered) {\n            width += width - w0;\n            height += height - h0;\n            const cdx = cx - (left + width / 2);\n            const cdy = cy - (top + height / 2);\n            left += cdx;\n            top += cdy;\n            right += cdx;\n            bottom += cdy;\n        }\n        // Flips over left side\n        if (width < 0) {\n            left += width;\n            width = Math.abs(width);\n        }\n        // Flips over top side\n        if (height < 0) {\n            top += height;\n            height = Math.abs(height);\n        }\n        const result = new Rectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n        if (this.minBounds != null) {\n            result.width = Math.max(result.width, this.minBounds.x * scale +\n                this.minBounds.width * scale +\n                Math.max(0, this.x0 * scale - result.x));\n            result.height = Math.max(result.height, this.minBounds.y * scale +\n                this.minBounds.height * scale +\n                Math.max(0, this.y0 * scale - result.y));\n        }\n        return result;\n    }\n    /**\n     * Redraws the handles and the preview.\n     */\n    redraw(ignoreHandles) {\n        this.selectionBounds = this.getSelectionBounds(this.state);\n        this.bounds = new Rectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n        this.drawPreview();\n        if (!ignoreHandles) {\n            this.redrawHandles();\n        }\n    }\n    /**\n     * Returns the padding to be used for drawing handles for the current <bounds>.\n     */\n    getHandlePadding() {\n        // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n        const result = new Point(0, 0);\n        let tol = this.tolerance;\n        if (this.sizers.length > 0 &&\n            this.sizers[0].bounds &&\n            (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n            tol /= 2;\n            result.x = this.sizers[0].bounds.width + tol;\n            result.y = this.sizers[0].bounds.height + tol;\n        }\n        return result;\n    }\n    /**\n     * Returns the bounds used to paint the resize handles.\n     */\n    getSizerBounds() {\n        return this.bounds;\n    }\n    /**\n     * Redraws the handles. To hide certain handles the following code can be used.\n     *\n     * ```javascript\n     * redrawHandles()\n     * {\n     *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n     *\n     *   if (this.sizers != null && this.sizers.length > 7)\n     *   {\n     *     this.sizers[1].node.style.display = 'none';\n     *     this.sizers[6].node.style.display = 'none';\n     *   }\n     * };\n     * ```\n     */\n    redrawHandles() {\n        let s = this.getSizerBounds();\n        const tol = this.tolerance;\n        this.horizontalOffset = 0;\n        this.verticalOffset = 0;\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            const shape = this.customHandles[i].shape;\n            if (shape) {\n                const temp = shape.node.style.display;\n                this.customHandles[i].redraw();\n                shape.node.style.display = temp;\n                // Hides custom handles during text editing\n                shape.node.style.visibility =\n                    this.handlesVisible && this.isCustomHandleVisible(this.customHandles[i])\n                        ? ''\n                        : 'hidden';\n            }\n        }\n        if (this.sizers.length > 0 && this.sizers[0]) {\n            if (this.index === null && this.manageSizers && this.sizers.length >= 8) {\n                // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n                const padding = this.getHandlePadding();\n                this.horizontalOffset = padding.x;\n                this.verticalOffset = padding.y;\n                if (this.horizontalOffset !== 0 || this.verticalOffset !== 0) {\n                    s = new Rectangle(s.x, s.y, s.width, s.height);\n                    s.x -= this.horizontalOffset / 2;\n                    s.width += this.horizontalOffset;\n                    s.y -= this.verticalOffset / 2;\n                    s.height += this.verticalOffset;\n                }\n                if (this.sizers.length >= 8) {\n                    if (this.sizers[0].bounds &&\n                        (s.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n                            s.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n                        this.sizers[0].node.style.display = 'none';\n                        this.sizers[2].node.style.display = 'none';\n                        this.sizers[5].node.style.display = 'none';\n                        this.sizers[7].node.style.display = 'none';\n                    }\n                    else if (this.handlesVisible) {\n                        this.sizers[0].node.style.display = '';\n                        this.sizers[2].node.style.display = '';\n                        this.sizers[5].node.style.display = '';\n                        this.sizers[7].node.style.display = '';\n                    }\n                }\n            }\n            const r = s.x + s.width;\n            const b = s.y + s.height;\n            if (this.singleSizer) {\n                this.moveSizerTo(this.sizers[0], r, b);\n            }\n            else {\n                const cx = s.x + s.width / 2;\n                const cy = s.y + s.height / 2;\n                if (this.sizers.length >= 8) {\n                    const crs = [\n                        'nw-resize',\n                        'n-resize',\n                        'ne-resize',\n                        'e-resize',\n                        'se-resize',\n                        's-resize',\n                        'sw-resize',\n                        'w-resize',\n                    ];\n                    const alpha = toRadians(this.state.style.rotation ?? 0);\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const da = Math.round((alpha * 4) / Math.PI);\n                    const ct = new Point(s.getCenterX(), s.getCenterY());\n                    let pt = getRotatedPoint(new Point(s.x, s.y), cos, sin, ct);\n                    this.moveSizerTo(this.sizers[0], pt.x, pt.y);\n                    this.sizers[0].setCursor(crs[mod(0 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[1], pt.x, pt.y);\n                    this.sizers[1].setCursor(crs[mod(1 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = s.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[2], pt.x, pt.y);\n                    this.sizers[2].setCursor(crs[mod(2 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[3], pt.x, pt.y);\n                    this.sizers[3].setCursor(crs[mod(7 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = cy;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[4], pt.x, pt.y);\n                    this.sizers[4].setCursor(crs[mod(3 + da, crs.length)]);\n                    pt.x = s.x;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[5], pt.x, pt.y);\n                    this.sizers[5].setCursor(crs[mod(6 + da, crs.length)]);\n                    pt.x = cx;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[6], pt.x, pt.y);\n                    this.sizers[6].setCursor(crs[mod(5 + da, crs.length)]);\n                    pt.x = r;\n                    pt.y = b;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[7], pt.x, pt.y);\n                    this.sizers[7].setCursor(crs[mod(4 + da, crs.length)]);\n                    pt.x = cx + this.state.absoluteOffset.x;\n                    pt.y = cy + this.state.absoluteOffset.y;\n                    pt = getRotatedPoint(pt, cos, sin, ct);\n                    this.moveSizerTo(this.sizers[8], pt.x, pt.y);\n                }\n                else if (this.state.width >= 2 && this.state.height >= 2) {\n                    this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n                }\n                else {\n                    this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n                }\n            }\n        }\n        if (this.rotationShape) {\n            const alpha = toRadians(this.currentAlpha);\n            const cos = Math.cos(alpha);\n            const sin = Math.sin(alpha);\n            const ct = new Point(this.state.getCenterX(), this.state.getCenterY());\n            const pt = getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n            if (this.rotationShape.node != null) {\n                this.moveSizerTo(this.rotationShape, pt.x, pt.y);\n                // Hides rotation handle during text editing\n                this.rotationShape.node.style.visibility =\n                    this.state.view.graph.isEditing() || !this.handlesVisible ? 'hidden' : '';\n            }\n        }\n        if (this.selectionBorder != null) {\n            this.selectionBorder.rotation = this.state.style.rotation ?? 0;\n        }\n        if (this.edgeHandlers != null) {\n            for (let i = 0; i < this.edgeHandlers.length; i += 1) {\n                this.edgeHandlers[i].redraw();\n            }\n        }\n    }\n    /**\n     * Returns true if the given custom handle is visible.\n     */\n    isCustomHandleVisible(handle) {\n        return (!this.graph.isEditing() && this.state.view.graph.getSelectionCount() === 1);\n    }\n    /**\n     * Returns an {@link Point} that defines the rotation handle position.\n     */\n    getRotationHandlePosition() {\n        return new Point(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing);\n    }\n    /**\n     * Returns `true` if the parent highlight should be visible.\n     *\n     * This implementation always returns `true`.\n     */\n    isParentHighlightVisible() {\n        const parent = this.state.cell.getParent();\n        return parent ? !this.graph.isCellSelected(parent) : false;\n    }\n    /**\n     * Updates the highlight of the parent if {@link parentHighlightEnabled} is `true`.\n     */\n    updateParentHighlight() {\n        if (!this.isDestroyed()) {\n            const visible = this.isParentHighlightVisible();\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (this.parentHighlight) {\n                if (parent && parent.isVertex() && visible) {\n                    const b = this.parentHighlight.bounds;\n                    if (pstate &&\n                        b &&\n                        (b.x !== pstate.x ||\n                            b.y !== pstate.y ||\n                            b.width !== pstate.width ||\n                            b.height !== pstate.height)) {\n                        this.parentHighlight.bounds = Rectangle.fromRectangle(pstate);\n                        this.parentHighlight.redraw();\n                    }\n                }\n                else {\n                    if (pstate != null && pstate.parentHighlight === this.parentHighlight) {\n                        pstate.parentHighlight = null;\n                    }\n                    this.parentHighlight.destroy();\n                    this.parentHighlight = null;\n                }\n            }\n            else if (this.parentHighlightEnabled && visible) {\n                if (parent &&\n                    parent.isVertex() &&\n                    pstate != null &&\n                    pstate.parentHighlight == null) {\n                    this.parentHighlight = this.createParentHighlightShape(pstate);\n                    // VML dialect required here for event transparency in IE\n                    this.parentHighlight.dialect = DIALECT.SVG;\n                    this.parentHighlight.pointerEvents = false;\n                    this.parentHighlight.rotation = pstate.style.rotation ?? 0;\n                    this.parentHighlight.init(this.graph.getView().getOverlayPane());\n                    this.parentHighlight.redraw();\n                    // Shows highlight once per parent\n                    pstate.parentHighlight = this.parentHighlight;\n                }\n            }\n        }\n    }\n    /**\n     * Redraws the preview.\n     */\n    drawPreview() {\n        if (this.preview != null) {\n            this.preview.bounds = this.bounds;\n            if (this.preview.node.parentNode === this.graph.container) {\n                this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n                this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n            }\n            this.preview.rotation = this.state.style.rotation ?? 0;\n            this.preview.redraw();\n        }\n        this.selectionBorder.bounds = this.getSelectionBorderBounds();\n        this.selectionBorder.redraw();\n        this.updateParentHighlight();\n    }\n    /**\n     * Returns the bounds for the selection border.\n     */\n    getSelectionBorderBounds() {\n        return this.bounds;\n    }\n    /**\n     * Returns `true` if this handler was destroyed or not initialized.\n     */\n    isDestroyed() {\n        return this.selectionBorder == null;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.state.view.graph.removeListener(this.escapeHandler);\n        this.escapeHandler = () => {\n            return;\n        };\n        if (this.preview) {\n            this.preview.destroy();\n            this.preview = null;\n        }\n        if (this.parentHighlight) {\n            const parent = this.state.cell.getParent();\n            const pstate = parent ? this.graph.view.getState(parent) : null;\n            if (pstate && pstate.parentHighlight === this.parentHighlight) {\n                pstate.parentHighlight = null;\n            }\n            this.parentHighlight.destroy();\n            this.parentHighlight = null;\n        }\n        if (this.ghostPreview) {\n            this.ghostPreview.destroy();\n            this.ghostPreview = null;\n        }\n        if (this.selectionBorder) {\n            this.selectionBorder.destroy();\n        }\n        this.labelShape = null;\n        this.removeHint();\n        for (let i = 0; i < this.sizers.length; i += 1) {\n            this.sizers[i].destroy();\n        }\n        this.sizers = [];\n        for (let i = 0; i < this.customHandles.length; i += 1) {\n            this.customHandles[i].destroy();\n        }\n        this.customHandles = [];\n    }\n}\nexport default VertexHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { NONE } from './Constants';\nimport { get, load } from './MaxXmlRequest';\n/**\n * Implements internationalization. You can provide any number of\n * resource files on the server using the following format for the\n * filename: name[-en].properties. The en stands for any lowercase\n * 2-character language shortcut (eg. de for german, fr for french).\n *\n * If the optional language extension is omitted, then the file is used as a\n * default resource which is loaded in all cases. If a properties file for a\n * specific language exists, then it is used to override the settings in the\n * default resource. All entries in the file are of the form key=value. The\n * values may then be accessed in code via {@link get}. Lines without\n * equal signs in the properties files are ignored.\n *\n * Resource files may either be added programmatically using\n * {@link add} or via a resource tag in the UI section of the\n * editor configuration file, eg:\n *\n * ```javascript\n * <Editor>\n *   <ui>\n *     <resource basename=\"examples/resources/mxWorkflow\"/>\n * ```\n *\n * The above element will load examples/resources/mxWorkflow.properties as well\n * as the language specific file for the current language, if it exists.\n *\n * Values may contain placeholders of the form {1}...{n} where each placeholder\n * is replaced with the value of the corresponding array element in the params\n * argument passed to {@link get}. The placeholder {1} maps to the first\n * element in the array (at index 0).\n *\n * See {@link Client.language} for more information on specifying the default\n * language or disabling all loading of resources.\n *\n * Lines that start with a # sign will be ignored.\n *\n * ## Special characters\n *\n * To use unicode characters, use the standard notation (eg. \\u8fd1) or %u as a\n * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,\n * use % as a prefix, eg. %F6 will display a \"o umlaut\" (&ouml;).\n *\n * See {@link resourcesEncoded} to disable this. If you disable this, make sure that\n * your files are UTF-8 encoded.\n *\n * ## Asynchronous loading\n *\n * TODO the following is taken from mxGraph and is probably no longer accurate\n *\n * By default, the core adds two resource files synchronously at load time.\n * To load these files asynchronously, set {@link LoadResources} to false\n * before loading Client and use {@link loadResources} instead.\n */\nclass Translations {\n}\n/*\n * Object that maps from keys to values.\n */\nTranslations.resources = {};\n/**\n * Specifies the extension used for language files.\n * @default '.txt'\n */\nTranslations.extension = '.txt';\n/**\n * Specifies whether values in resource files are encoded with \\u or\n * percentage. Default is false.\n */\nTranslations.resourcesEncoded = false;\n/**\n * Specifies if the default file for a given basename should be loaded.\n * Default is true.\n */\nTranslations.loadDefaultBundle = true;\n/**\n * Specifies if the specific language file file for a given basename should\n * be loaded. Default is true.\n */\nTranslations.loadSpecialBundle = true;\n/**\n * Hook for subclassers to disable support for a given language. This\n * implementation returns true if lan is in <Client.languages>.\n *\n * @param lan The current language.\n */\nTranslations.isLanguageSupported = (lan) => {\n    if (Client.languages != null) {\n        return Client.languages.indexOf(lan) >= 0;\n    }\n    return true;\n};\n/**\n * Hook for subclassers to return the URL for the special bundle. This\n * implementation returns basename + <extension> or null if\n * <loadDefaultBundle> is false.\n *\n * @param basename The basename for which the file should be loaded.\n * @param lan The current language.\n */\nTranslations.getDefaultBundle = (basename, lan) => {\n    if (Translations.loadDefaultBundle || !Translations.isLanguageSupported(lan)) {\n        return basename + Translations.extension;\n    }\n    return null;\n};\n/**\n * Hook for subclassers to return the URL for the special bundle. This\n * implementation returns `basename + '_' + lan + <extension>` or `null` if\n * {@link Translations.loadSpecialBundle} is `false` or `lan` equals {@link Client.defaultLanguage}.\n *\n * If {@link Translations#languages} is not null and {@link Client.language} contains\n * a dash, then this method checks if {@link Translations.isLanguageSupported} returns `true`\n * for the full language (including the dash). If that returns false the\n * first part of the language (up to the dash) will be tried as an extension.\n *\n * If {@link Translations#language} is null then the first part of the language is\n * used to maintain backwards compatibility.\n *\n * @param basename The basename for which the file should be loaded.\n * @param lan The language for which the file should be loaded.\n */\nTranslations.getSpecialBundle = (basename, lan) => {\n    if (Client.languages == null || !Translations.isLanguageSupported(lan)) {\n        const dash = lan.indexOf('-');\n        if (dash > 0) {\n            lan = lan.substring(0, dash);\n        }\n    }\n    if (Translations.loadSpecialBundle &&\n        Translations.isLanguageSupported(lan) &&\n        lan != Client.defaultLanguage) {\n        return `${basename}_${lan}${Translations.extension}`;\n    }\n    return null;\n};\n/**\n * Adds the default and current language properties file for the specified\n * basename. Existing keys are overridden as new files are added. If no\n * callback is used then the request is synchronous.\n *\n * Example:\n *\n * At application startup, additional resources may be\n * added using the following code:\n *\n * ```javascript\n * Translations.add('resources/editor');\n * ```\n *\n * @param basename The basename for which the file should be loaded.\n * @param lan The language for which the file should be loaded.\n * @param callback Optional callback for asynchronous loading.\n */\nTranslations.add = (basename, lan = null, callback = null) => {\n    lan =\n        lan != null ? lan : Client.language != null ? Client.language.toLowerCase() : NONE;\n    if (lan !== NONE) {\n        const defaultBundle = Translations.getDefaultBundle(basename, lan);\n        const specialBundle = Translations.getSpecialBundle(basename, lan);\n        const loadSpecialBundle = () => {\n            if (specialBundle != null) {\n                if (callback) {\n                    get(specialBundle, (req) => {\n                        Translations.parse(req.getText());\n                        callback();\n                    }, () => {\n                        callback();\n                    });\n                }\n                else {\n                    try {\n                        const req = load(specialBundle);\n                        if (req.isReady()) {\n                            Translations.parse(req.getText());\n                        }\n                    }\n                    catch (e) {\n                        // ignore\n                    }\n                }\n            }\n            else if (callback != null) {\n                callback();\n            }\n        };\n        if (defaultBundle != null) {\n            if (callback) {\n                get(defaultBundle, (req) => {\n                    Translations.parse(req.getText());\n                    loadSpecialBundle();\n                }, () => {\n                    loadSpecialBundle();\n                });\n            }\n            else {\n                try {\n                    const req = load(defaultBundle);\n                    if (req.isReady()) {\n                        Translations.parse(req.getText());\n                    }\n                    loadSpecialBundle();\n                }\n                catch (e) {\n                    // ignore\n                }\n            }\n        }\n        else {\n            // Overlays the language specific file (_lan-extension)\n            loadSpecialBundle();\n        }\n    }\n};\n/**\n * Parses the key, value pairs in the specified\n * text and stores them as local resources.\n */\nTranslations.parse = (text) => {\n    if (text != null) {\n        const lines = text.split('\\n');\n        for (let i = 0; i < lines.length; i += 1) {\n            if (lines[i].charAt(0) !== '#') {\n                const index = lines[i].indexOf('=');\n                if (index > 0) {\n                    const key = lines[i].substring(0, index);\n                    let idx = lines[i].length;\n                    if (lines[i].charCodeAt(idx - 1) === 13) {\n                        idx--;\n                    }\n                    let value = lines[i].substring(index + 1, idx);\n                    if (Translations.resourcesEncoded) {\n                        value = value.replace(/\\\\(?=u[a-fA-F\\d]{4})/g, '%');\n                        Translations.resources[key] = unescape(value);\n                    }\n                    else {\n                        Translations.resources[key] = value;\n                    }\n                }\n            }\n        }\n    }\n};\n/**\n * Returns the value for the specified resource key.\n *\n * Example:\n * To read the value for 'welcomeMessage', use the following:\n * ```javascript\n * let result = Translations.get('welcomeMessage') || '';\n * ```\n *\n * This would require an entry of the following form in\n * one of the English language resource files:\n * ```javascript\n * welcomeMessage=Welcome to mxGraph!\n * ```\n *\n * The part behind the || is the string value to be used if the given\n * resource is not available.\n *\n * @param key String that represents the key of the resource to be returned.\n * @param params Array of the values for the placeholders of the form {1}...{n}\n * to be replaced with in the resulting string.\n * @param defaultValue Optional string that specifies the default return value.\n */\nTranslations.get = (key, params = null, defaultValue = null) => {\n    let value = Translations.resources[key];\n    // Applies the default value if no resource was found\n    if (value == null) {\n        value = defaultValue;\n    }\n    // Replaces the placeholders with the values in the array\n    if (value != null && params != null) {\n        value = Translations.replacePlaceholders(value, params);\n    }\n    return value;\n};\n/**\n * Replaces the given placeholders with the given parameters.\n *\n * @param value String that contains the placeholders.\n * @param params Array of the values for the placeholders of the form {1}...{n}\n * to be replaced with in the resulting string.\n */\nTranslations.replacePlaceholders = (value, params) => {\n    const result = [];\n    let index = null;\n    for (let i = 0; i < value.length; i += 1) {\n        const c = value.charAt(i);\n        if (c === '{') {\n            index = '';\n        }\n        else if (index != null && c === '}') {\n            index = parseInt(index) - 1;\n            if (index >= 0 && index < params.length) {\n                result.push(params[index]);\n            }\n            index = null;\n        }\n        else if (index != null) {\n            index += c;\n        }\n        else {\n            result.push(c);\n        }\n    }\n    return result.join('');\n};\n/**\n * Loads all required resources asynchronously. Use this to load the graph and editor resources.\n *\n * @param callback Callback function for asynchronous loading.\n */\nTranslations.loadResources = (callback) => {\n    Translations.add(`${Client.basePath}/resources/editor`, null, () => {\n        Translations.add(`${Client.basePath}/resources/graph`, null, callback);\n    });\n};\nexport default Translations;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EdgeHandler from './EdgeHandler';\nimport { CURSOR, EDGESTYLE, ELBOW, HANDLE_SIZE } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\nimport Point from '../geometry/Point';\nimport Translations from '../../util/Translations';\nimport Rectangle from '../geometry/Rectangle';\nimport { intersects } from '../../util/mathUtils';\nimport Client from '../../Client';\nimport { isConsumed } from '../../util/EventUtils';\n/**\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses {@link TerminalMarker} for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in {@link Graph#createHandler}. It extends {@link EdgeHandler}.\n *\n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified <CellState>.\n *\n * @param state <CellState> of the cell to be modified.\n */\nclass ElbowEdgeHandler extends EdgeHandler {\n    constructor(state) {\n        super(state);\n        /**\n         * Specifies if a double click on the middle handle should call\n         * {@link Graph#flipEdge}. Default is true.\n         */\n        this.flipEnabled = true;\n        /**\n         * Specifies the resource key for the tooltip to be displayed on the single\n         * control point for routed edges. If the resource for this key does not\n         * exist then the value is used as the error message. Default is\n         * 'doubleClickOrientation'.\n         */\n        // doubleClickOrientationResource: string;\n        this.doubleClickOrientationResource = Client.language !== 'none' ? 'doubleClickOrientation' : '';\n    }\n    /**\n     * Overrides {@link EdgeHandler#createBends} to create custom bends.\n     */\n    createBends() {\n        const bends = [];\n        // Source\n        let bend = this.createHandleShape(0);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        // Virtual\n        bends.push(this.createVirtualBend((evt) => {\n            if (!isConsumed(evt) && this.flipEnabled) {\n                this.graph.flipEdge(this.state.cell);\n                InternalEvent.consume(evt);\n            }\n        }));\n        this.points.push(new Point(0, 0));\n        // Target\n        bend = this.createHandleShape(2);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        return bends;\n    }\n    /**\n     * Creates a virtual bend that supports double clicking and calls\n     * {@link Graph#flipEdge}.\n     */\n    createVirtualBend(dblClickHandler) {\n        const bend = this.createHandleShape();\n        this.initBend(bend, dblClickHandler);\n        bend.setCursor(this.getCursorForBend());\n        if (!this.graph.isCellBendable(this.state.cell)) {\n            bend.node.style.display = 'none';\n        }\n        return bend;\n    }\n    /**\n     * Returns the cursor to be used for the bend.\n     */\n    getCursorForBend() {\n        return this.state.style.edgeStyle === EDGESTYLE.TOPTOBOTTOM ||\n            (this.state.style.edgeStyle === EDGESTYLE.ELBOW &&\n                this.state.style.elbow === ELBOW.VERTICAL)\n            ? 'row-resize'\n            : 'col-resize';\n    }\n    /**\n     * Returns the tooltip for the given node.\n     */\n    getTooltipForNode(node) {\n        let tip = null;\n        if (this.bends != null &&\n            this.bends[1] != null &&\n            (node === this.bends[1].node || node.parentNode === this.bends[1].node)) {\n            tip = this.doubleClickOrientationResource;\n            tip = Translations.get(tip) || tip; // translate\n        }\n        return tip;\n    }\n    /**\n     * Converts the given point in-place from screen to unscaled, untranslated\n     * graph coordinates and applies the grid.\n     *\n     * @param point {@link Point} to be converted.\n     * @param gridEnabled Boolean that specifies if the grid should be applied.\n     */\n    convertPoint(point, gridEnabled) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        const { origin } = this.state;\n        if (gridEnabled) {\n            point.x = this.graph.snap(point.x);\n            point.y = this.graph.snap(point.y);\n        }\n        point.x = Math.round(point.x / scale - tr.x - origin.x);\n        point.y = Math.round(point.y / scale - tr.y - origin.y);\n        return point;\n    }\n    /**\n     * Updates and redraws the inner bends.\n     *\n     * @param p0 {@link Point} that represents the location of the first point.\n     * @param pe {@link Point} that represents the location of the last point.\n     */\n    redrawInnerBends(p0, pe) {\n        const g = this.state.cell.getGeometry();\n        const pts = this.state.absolutePoints;\n        let pt = null;\n        // Keeps the virtual bend on the edge shape\n        if (pts.length > 1) {\n            p0 = pts[1];\n            pe = pts[pts.length - 2];\n        }\n        else if (g.points != null && g.points.length > 0) {\n            pt = pts[0];\n        }\n        if (pt == null) {\n            pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n        }\n        else {\n            pt = new Point(this.graph.getView().scale *\n                (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale *\n                (pt.y + this.graph.getView().translate.y + this.state.origin.y));\n        }\n        // Makes handle slightly bigger if the yellow  label handle\n        // exists and intersects this green handle\n        const b = this.bends[1].bounds;\n        let w = b.width;\n        let h = b.height;\n        let bounds = new Rectangle(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);\n        if (this.manageLabelHandle) {\n            this.checkLabelHandle(bounds);\n        }\n        else if (this.handleImage == null &&\n            this.labelShape.visible &&\n            this.labelShape.bounds &&\n            intersects(bounds, this.labelShape.bounds)) {\n            w = HANDLE_SIZE + 3;\n            h = HANDLE_SIZE + 3;\n            bounds = new Rectangle(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);\n        }\n        this.bends[1].bounds = bounds;\n        this.bends[1].redraw();\n        if (this.manageLabelHandle) {\n            this.checkLabelHandle(this.bends[1].bounds);\n        }\n    }\n}\nexport default ElbowEdgeHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport { CURSOR } from '../../util/Constants';\nimport Rectangle from '../geometry/Rectangle';\nimport { contains } from '../../util/mathUtils';\nimport { setOpacity } from '../../util/styleUtils';\nimport ElbowEdgeHandler from './ElbowEdgeHandler';\nclass EdgeSegmentHandler extends ElbowEdgeHandler {\n    constructor(state) {\n        super(state);\n        this.points = [];\n    }\n    /**\n     * Returns the current absolute points.\n     */\n    getCurrentPoints() {\n        let pts = this.state.absolutePoints;\n        // Special case for straight edges where we add a virtual middle handle for moving the edge\n        const tol = Math.max(1, this.graph.view.scale);\n        if ((pts.length === 2 && pts[0] && pts[1]) ||\n            (pts.length === 3 &&\n                pts[0] &&\n                pts[1] &&\n                pts[2] &&\n                ((Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol) ||\n                    (Math.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)))) {\n            const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n            const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n            pts = [pts[0], new Point(cx, cy), new Point(cx, cy), pts[pts.length - 1]];\n        }\n        return pts;\n    }\n    /**\n     * Updates the given preview state taking into account the state of the constraint handler.\n     */\n    getPreviewPoints(point) {\n        if (this.isSource || this.isTarget) {\n            return super.getPreviewPoints(point);\n        }\n        const pts = this.getCurrentPoints();\n        let last = this.convertPoint(pts[0].clone(), false);\n        point = this.convertPoint(point.clone(), false);\n        let result = [];\n        for (let i = 1; i < pts.length; i += 1) {\n            const pt = this.convertPoint(pts[i].clone(), false);\n            if (i === this.index) {\n                if (Math.round(last.x - pt.x) === 0) {\n                    last.x = point.x;\n                    pt.x = point.x;\n                }\n                if (Math.round(last.y - pt.y) === 0) {\n                    last.y = point.y;\n                    pt.y = point.y;\n                }\n            }\n            if (i < pts.length - 1) {\n                result.push(pt);\n            }\n            last = pt;\n        }\n        // Replaces single point that intersects with source or target\n        if (result.length === 1) {\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const scale = this.state.view.getScale();\n            const tr = this.state.view.getTranslate();\n            const x = result[0].x * scale + tr.x;\n            const y = result[0].y * scale + tr.y;\n            if ((source != null && contains(source, x, y)) ||\n                (target != null && contains(target, x, y))) {\n                result = [point, point];\n            }\n        }\n        return result;\n    }\n    /**\n     * Overridden to perform optimization of the edge style result.\n     */\n    updatePreviewState(edge, point, terminalState, me) {\n        super.updatePreviewState(edge, point, terminalState, me);\n        // Checks and corrects preview by running edge style again\n        if (!this.isSource && !this.isTarget) {\n            point = this.convertPoint(point.clone(), false);\n            const pts = edge.absolutePoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            let result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if ((Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n            const source = this.state.getVisibleTerminalState(true);\n            const target = this.state.getVisibleTerminalState(false);\n            const rpts = this.state.absolutePoints;\n            const end = pts[pts.length - 1];\n            // A straight line is represented by 3 handles\n            if (result.length === 0 &&\n                pts[0] &&\n                end &&\n                (Math.round(pts[0].x - end.x) === 0 || Math.round(pts[0].y - end.y) === 0)) {\n                result = [point, point];\n            }\n            // Handles special case of transitions from straight vertical to routed\n            else if (pts.length === 5 &&\n                result.length === 2 &&\n                source != null &&\n                target != null &&\n                rpts != null &&\n                Math.round(rpts[0].x - rpts[rpts.length - 1].x) === 0) {\n                const view = this.graph.getView();\n                const scale = view.getScale();\n                const tr = view.getTranslate();\n                let y0 = view.getRoutingCenterY(source) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const sc = this.graph.getConnectionConstraint(edge, source, true);\n                if (sc != null) {\n                    const pt = this.graph.getConnectionPoint(source, sc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        y0 = pt.y;\n                    }\n                }\n                let ye = view.getRoutingCenterY(target) / scale - tr.y;\n                // Use fixed connection point y-coordinate if one exists\n                const tc = this.graph.getConnectionConstraint(edge, target, false);\n                if (tc) {\n                    const pt = this.graph.getConnectionPoint(target, tc);\n                    if (pt != null) {\n                        this.convertPoint(pt, false);\n                        ye = pt.y;\n                    }\n                }\n                result = [new Point(point.x, y0), new Point(point.x, ye)];\n            }\n            this.points = result;\n            // LATER: Check if points and result are different\n            edge.view.updateFixedTerminalPoints(edge, source, target);\n            edge.view.updatePoints(edge, this.points, source, target);\n            edge.view.updateFloatingTerminalPoints(edge, source, target);\n        }\n    }\n    /**\n     * Overriden to merge edge segments.\n     */\n    connect(edge, terminal, isSource, isClone, me) {\n        const model = this.graph.getDataModel();\n        let geo = edge.getGeometry();\n        let result = null;\n        // Merges adjacent edge segments\n        if (geo != null && geo.points != null && geo.points.length > 0) {\n            const pts = this.abspoints;\n            let pt0 = pts[0];\n            let pt1 = pts[1];\n            result = [];\n            for (let i = 2; i < pts.length; i += 1) {\n                const pt2 = pts[i];\n                // Merges adjacent segments only if more than 2 to allow for straight edges\n                if (pt0 &&\n                    pt1 &&\n                    pt2 &&\n                    (Math.round(pt0.x - pt1.x) !== 0 || Math.round(pt1.x - pt2.x) !== 0) &&\n                    (Math.round(pt0.y - pt1.y) !== 0 || Math.round(pt1.y - pt2.y) !== 0)) {\n                    result.push(this.convertPoint(pt1.clone(), false));\n                }\n                pt0 = pt1;\n                pt1 = pt2;\n            }\n        }\n        this.graph.batchUpdate(() => {\n            if (result != null) {\n                geo = edge.getGeometry();\n                if (geo != null) {\n                    geo = geo.clone();\n                    geo.points = result;\n                    model.setGeometry(edge, geo);\n                }\n            }\n            edge = super.connect(edge, terminal, isSource, isClone, me);\n        });\n        return edge;\n    }\n    /**\n     * Returns no tooltips.\n     */\n    getTooltipForNode(node) {\n        return null;\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    start(x, y, index) {\n        super.start(x, y, index);\n        if (this.bends != null &&\n            this.bends[index] != null &&\n            !this.isSource &&\n            !this.isTarget) {\n            setOpacity(this.bends[index].node, 100);\n        }\n    }\n    /**\n     * Adds custom bends for the center of each segment.\n     */\n    createBends() {\n        const bends = [];\n        // Source\n        let bend = this.createHandleShape(0);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        const pts = this.getCurrentPoints();\n        // Waypoints (segment handles)\n        if (this.graph.isCellBendable(this.state.cell)) {\n            if (this.points == null) {\n                this.points = [];\n            }\n            for (let i = 0; i < pts.length - 1; i += 1) {\n                bend = this.createVirtualBend();\n                bends.push(bend);\n                let horizontal = Math.round(pts[i].x - pts[i + 1].x) === 0;\n                // Special case where dy is 0 as well\n                if (Math.round(pts[i].y - pts[i + 1].y) === 0 && i < pts.length - 2) {\n                    horizontal = Math.round(pts[i].x - pts[i + 2].x) === 0;\n                }\n                bend.setCursor(horizontal ? 'col-resize' : 'row-resize');\n                this.points.push(new Point(0, 0));\n            }\n        }\n        // Target\n        bend = this.createHandleShape(pts.length);\n        this.initBend(bend);\n        bend.setCursor(CURSOR.TERMINAL_HANDLE);\n        bends.push(bend);\n        return bends;\n    }\n    /**\n     * Overridden to invoke <refresh> before the redraw.\n     */\n    redraw() {\n        this.refresh();\n        super.redraw();\n    }\n    /**\n     * Updates the position of the custom bends.\n     */\n    redrawInnerBends(p0, pe) {\n        if (this.graph.isCellBendable(this.state.cell)) {\n            const pts = this.getCurrentPoints();\n            if (pts != null && pts.length > 1) {\n                let straight = false;\n                // Puts handle in the center of straight edges\n                if (pts.length === 4 &&\n                    pts[0] &&\n                    pts[1] &&\n                    pts[2] &&\n                    pts[3] &&\n                    Math.round(pts[1].x - pts[2].x) === 0 &&\n                    Math.round(pts[1].y - pts[2].y) === 0) {\n                    straight = true;\n                    if (Math.round(pts[0].y - pts[pts.length - 1].y) === 0) {\n                        const cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n                        pts[1] = new Point(cx, pts[1].y);\n                        pts[2] = new Point(cx, pts[2].y);\n                    }\n                    else {\n                        const cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n                        pts[1] = new Point(pts[1].x, cy);\n                        pts[2] = new Point(pts[2].x, cy);\n                    }\n                }\n                for (let i = 0; i < pts.length - 1; i += 1) {\n                    if (this.bends[i + 1] != null) {\n                        p0 = pts[i];\n                        pe = pts[i + 1];\n                        const pt = new Point(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n                        const b = this.bends[i + 1].bounds;\n                        this.bends[i + 1].bounds = new Rectangle(Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);\n                        this.bends[i + 1].redraw();\n                        if (this.manageLabelHandle) {\n                            this.checkLabelHandle(this.bends[i + 1].bounds);\n                        }\n                    }\n                }\n                if (straight) {\n                    setOpacity(this.bends[1].node, this.virtualBendOpacity);\n                    setOpacity(this.bends[3].node, this.virtualBendOpacity);\n                }\n            }\n        }\n    }\n}\nexport default EdgeSegmentHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Action to change the current root in a view.\n */\nclass SelectionChange {\n    constructor(graph, added = [], removed = []) {\n        this.graph = graph;\n        this.added = added.slice();\n        this.removed = removed.slice();\n    }\n    /**\n     * Changes the current root of the view.\n     */\n    execute() {\n        const selectionModel = this.graph.getSelectionModel();\n        for (const removed of this.removed) {\n            selectionModel.cellRemoved(removed);\n        }\n        for (const added of this.added) {\n            selectionModel.cellAdded(added);\n        }\n        [this.added, this.removed] = [this.removed, this.added];\n        selectionModel.fireEvent(new EventObject(InternalEvent.CHANGE, { added: this.added, removed: this.removed }));\n    }\n}\nexport default SelectionChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport EventSource from '../view/event/EventSource';\nimport SelectionChange from './undoable_changes/SelectionChange';\nimport UndoableEdit from './undoable_changes/UndoableEdit';\nimport EventObject from './event/EventObject';\nimport InternalEvent from './event/InternalEvent';\n/**\n * Class: mxGraphSelectionModel\n *\n * Implements the selection model for a graph. Here is a listener that handles\n * all removed selection cells.\n *\n * (code)\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var cells = evt.getProperty('added');\n *\n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     // Handle cells[i]...\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the selection was changed in <changeSelection>. The\n * <code>edit</code> property contains the {@link UndoableEdit} which contains the\n * {@link SelectionChange}.\n *\n * Event: mxEvent.CHANGE\n *\n * Fires after the selection changes by executing an {@link SelectionChange}. The\n * <code>added</code> and <code>removed</code> properties contain arrays of\n * cells that have been added to or removed from the selection, respectively.\n * The names are inverted due to historic reasons. This cannot be changed.\n *\n * Constructor: mxGraphSelectionModel\n *\n * Constructs a new graph selection model for the given {@link Graph}.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing {@link Graph}.\n */\nclass GraphSelectionModel extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies the resource key for the status message after a long operation.\n         * If the resource for this key does not exist then the value is used as\n         * the status message. Default is 'done'.\n         */\n        this.doneResource = Client.language !== 'none' ? 'done' : '';\n        /**\n         * Specifies the resource key for the status message while the selection is\n         * being updated. If the resource for this key does not exist then the\n         * value is used as the status message. Default is 'updatingSelection'.\n         */\n        this.updatingSelectionResource = Client.language !== 'none' ? 'updatingSelection' : '';\n        /**\n         * Specifies if only one selected item at a time is allowed.\n         * Default is false.\n         */\n        this.singleSelection = false;\n        this.graph = graph;\n        this.cells = [];\n    }\n    /**\n     * Returns {@link singleSelection} as a boolean.\n     */\n    isSingleSelection() {\n        return this.singleSelection;\n    }\n    /**\n     * Sets the {@link singleSelection} flag.\n     *\n     * @param {boolean} singleSelection Boolean that specifies the new value for\n     * {@link singleSelection}.\n     */\n    setSingleSelection(singleSelection) {\n        this.singleSelection = singleSelection;\n    }\n    /**\n     * Returns true if the given {@link Cell} is selected.\n     */\n    isSelected(cell) {\n        return this.cells.indexOf(cell) >= 0;\n    }\n    /**\n     * Returns true if no cells are currently selected.\n     */\n    isEmpty() {\n        return this.cells.length === 0;\n    }\n    /**\n     * Clears the selection and fires a {@link change} event if the selection was not\n     * empty.\n     */\n    clear() {\n        this.changeSelection(null, this.cells);\n    }\n    /**\n     * Selects the specified {@link Cell} using {@link setCells}.\n     *\n     * @param cell {@link mxCell} to be selected.\n     */\n    setCell(cell) {\n        this.setCells(cell ? [cell] : []);\n    }\n    /**\n     * Selects the given array of {@link Cell} and fires a {@link change} event.\n     *\n     * @param cells Array of {@link Cell} to be selected.\n     */\n    setCells(cells) {\n        if (this.singleSelection) {\n            cells = [this.getFirstSelectableCell(cells)];\n        }\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.graph.isCellSelectable(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(tmp, this.cells);\n    }\n    /**\n     * Returns the first selectable cell in the given array of cells.\n     */\n    getFirstSelectableCell(cells) {\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.graph.isCellSelectable(cells[i])) {\n                return cells[i];\n            }\n        }\n        return null;\n    }\n    /**\n     * Adds the given {@link Cell} to the selection and fires a {@link select} event.\n     *\n     * @param cell {@link mxCell} to add to the selection.\n     */\n    addCell(cell) {\n        this.addCells([cell]);\n    }\n    /**\n     * Adds the given array of {@link Cell} to the selection and fires a {@link select}\n     * event.\n     *\n     * @param cells Array of {@link Cell} to add to the selection.\n     */\n    addCells(cells) {\n        let remove = null;\n        if (this.singleSelection) {\n            remove = this.cells;\n            const selectableCell = this.getFirstSelectableCell(cells);\n            cells = selectableCell ? [selectableCell] : [];\n        }\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(tmp, remove);\n    }\n    /**\n     * Removes the specified {@link Cell} from the selection and fires a {@link select}\n     * event for the remaining cells.\n     *\n     * @param cell {@link mxCell} to remove from the selection.\n     */\n    removeCell(cell) {\n        this.removeCells([cell]);\n    }\n    /**\n     * Removes the specified {@link Cell} from the selection and fires a {@link select}\n     * event for the remaining cells.\n     *\n     * @param cells {@link mxCell}s to remove from the selection.\n     */\n    removeCells(cells) {\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (this.isSelected(cells[i])) {\n                tmp.push(cells[i]);\n            }\n        }\n        this.changeSelection(null, tmp);\n    }\n    /**\n     * Adds/removes the specified arrays of {@link Cell} to/from the selection.\n     *\n     * @param added Array of {@link Cell} to add to the selection.\n     * @param remove Array of {@link Cell} to remove from the selection.\n     */\n    changeSelection(added = null, removed = null) {\n        if ((added && added.length > 0 && added[0]) ||\n            (removed && removed.length > 0 && removed[0])) {\n            const change = new SelectionChange(this.graph, added || [], removed || []);\n            change.execute();\n            const edit = new UndoableEdit(this.graph, false);\n            edit.add(change);\n            this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));\n        }\n    }\n    /**\n     * Inner callback to add the specified {@link Cell} to the selection. No event\n     * is fired in this implementation.\n     *\n     * Paramters:\n     *\n     * @param cell {@link mxCell} to add to the selection.\n     */\n    cellAdded(cell) {\n        if (!this.isSelected(cell)) {\n            this.cells.push(cell);\n        }\n    }\n    /**\n     * Inner callback to remove the specified {@link Cell} from the selection. No\n     * event is fired in this implementation.\n     *\n     * @param cell {@link mxCell} to remove from the selection.\n     */\n    cellRemoved(cell) {\n        const index = this.cells.indexOf(cell);\n        if (index >= 0) {\n            this.cells.splice(index, 1);\n        }\n    }\n}\nexport default GraphSelectionModel;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Point from '../Point';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a rhombus (aka diamond) shape.\n * This shape is registered by default under {@link SHAPE.RHOMBUS} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass RhombusShape extends Shape {\n    constructor(bounds, fill, stroke, strokewidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokewidth;\n    }\n    /**\n     * Adds roundable support.\n     */\n    // isRoundable(): boolean;\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Generic painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintVertexShape(c, x, y, w, h) {\n        const hw = w / 2;\n        const hh = h / 2;\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        c.begin();\n        this.addPoints(c, [\n            new Point(x + hw, y),\n            new Point(x + w, y + hh),\n            new Point(x + hw, y + h),\n            new Point(x, y + hh),\n        ], this.isRounded, arcSize, true);\n        c.fillAndStroke();\n    }\n}\nexport default RhombusShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { NONE } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a cylinder shape.\n * This shape is registered by default under {@link SHAPE.CYLINDER} in {@link CellRenderer}.\n *\n * If a custom shape with one filled area and an overlay path is needed, then this shape's {@link redrawPath} should be overridden.\n *\n * @category Vertex Shapes\n */\nclass CylinderShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        /**\n         * Defines the maximum height of the top and bottom part of the cylinder shape.\n         */\n        this.maxHeight = 40;\n        /**\n         * Sets stroke tolerance to 0 for SVG.\n         */\n        this.svgStrokeTolerance = 0;\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.translate(x, y);\n        c.begin();\n        this.redrawPath(c, x, y, w, h, false);\n        c.fillAndStroke();\n        if (!this.outline || !this.style || !(this.style.backgroundOutline ?? false)) {\n            c.setShadow(false);\n            c.begin();\n            this.redrawPath(c, x, y, w, h, true);\n            c.stroke();\n        }\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    getCylinderSize(x, y, w, h) {\n        return Math.min(this.maxHeight, Math.round(h / 5));\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h, isForeground = false) {\n        const dy = this.getCylinderSize(x, y, w, h);\n        if ((isForeground && this.fill !== NONE) || (!isForeground && this.fill === NONE)) {\n            c.moveTo(0, dy);\n            c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);\n            // Needs separate shapes for correct hit-detection\n            if (!isForeground) {\n                c.stroke();\n                c.begin();\n            }\n        }\n        if (!isForeground) {\n            c.moveTo(0, dy);\n            c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);\n            c.lineTo(w, h - dy);\n            c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);\n            c.close();\n        }\n    }\n}\nexport default CylinderShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from './Shape';\nimport { NONE } from '../../util/Constants';\n/**\n * Extends {@link Shape} to implement an actor shape.\n * This shape is registered by default under {@link SHAPE.ACTOR} in {@link CellRenderer}.\n *\n * If a custom shape with one filled area is needed, then this shape's {@link redrawPath} method should be overridden\n * like in the following example:\n *\n * ```typescript\n * class SampleShape extends ActorShape {\n *   redrawPath(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {\n *     path.moveTo(0, 0);\n *     path.lineTo(w, h);\n *     // ...\n *     path.close();\n *   }\n * }\n * ```\n *\n * @category Vertex Shapes\n */\nclass ActorShape extends Shape {\n    constructor(bounds = null, fill = NONE, stroke = NONE, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.translate(x, y);\n        c.begin();\n        this.redrawPath(c, x, y, w, h);\n        c.fillAndStroke();\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        const width = w / 3;\n        c.moveTo(0, h);\n        c.curveTo(0, (3 * h) / 5, 0, (2 * h) / 5, w / 2, (2 * h) / 5);\n        c.curveTo(w / 2 - width, (2 * h) / 5, w / 2 - width, 0, w / 2, 0);\n        c.curveTo(w / 2 + width, 0, w / 2 + width, (2 * h) / 5, w / 2, (2 * h) / 5);\n        c.curveTo(w, (2 * h) / 5, w, (3 * h) / 5, w, h);\n        c.close();\n    }\n}\nexport default ActorShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../Point';\nimport ActorShape from '../ActorShape';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Implementation of the triangle shape.\n *\n * @category Vertex Shapes\n */\nclass TriangleShape extends ActorShape {\n    constructor() {\n        super();\n    }\n    /**\n     * Adds roundable support.\n     * @returns {boolean}\n     */\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Draws the path for this shape.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    redrawPath(c, x, y, w, h) {\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        this.addPoints(c, [new Point(0, 0), new Point(w, 0.5 * h), new Point(0, h)], this.isRounded, arcSize, true);\n    }\n}\nexport default TriangleShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ActorShape from '../ActorShape';\nimport Point from '../Point';\nimport { LINE_ARCSIZE } from '../../../util/Constants';\n/**\n * Implementation of the hexagon shape.\n *\n * @category Vertex Shapes\n */\nclass HexagonShape extends ActorShape {\n    constructor() {\n        super();\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        const arcSize = (this.style?.arcSize ?? LINE_ARCSIZE) / 2;\n        this.addPoints(c, [\n            new Point(0.25 * w, 0),\n            new Point(0.75 * w, 0),\n            new Point(w, 0.5 * h),\n            new Point(0.75 * w, h),\n            new Point(0.25 * w, h),\n            new Point(0, 0.5 * h),\n        ], this.isRounded, arcSize, true);\n    }\n}\nexport default HexagonShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ActorShape from '../ActorShape';\n/**\n * Extends {@link ActorShape} to implement a cloud shape.\n * This shape is registered by default under {@link SHAPE.CLOUD} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass CloudShape extends ActorShape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Draws the path for this shape.\n     */\n    redrawPath(c, x, y, w, h) {\n        c.moveTo(0.25 * w, 0.25 * h);\n        c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);\n        c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);\n        c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);\n        c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);\n        c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);\n        c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);\n        c.close();\n    }\n}\nexport default CloudShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a horizontal line shape.\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.LINE} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass LineShape extends Shape {\n    constructor(bounds, stroke, strokeWidth = 1, vertical = false) {\n        super();\n        this.bounds = bounds;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.vertical = vertical;\n    }\n    /**\n     * Redirects to redrawPath for subclasses to work.\n     * @param {AbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintVertexShape(c, x, y, w, h) {\n        c.begin();\n        if (this.vertical) {\n            const mid = x + w / 2;\n            c.moveTo(mid, y);\n            c.lineTo(mid, y + h);\n        }\n        else {\n            const mid = y + h / 2;\n            c.moveTo(x, mid);\n            c.lineTo(x + w, mid);\n        }\n        c.stroke();\n    }\n}\nexport default LineShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement an arrow shape. The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.ARROW} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ArrowShape extends Shape {\n    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE) {\n        super();\n        this.points = points;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.arrowWidth = arrowWidth;\n        this.spacing = spacing;\n        this.endSize = endSize;\n    }\n    /**\n     * Augments the bounding box with the edge width and markers.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        const w = Math.max(this.arrowWidth, this.endSize);\n        bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // Geometry of arrow\n        const spacing = ARROW_SPACING;\n        const width = ARROW_WIDTH;\n        const arrow = ARROW_SIZE;\n        // Base vector (between end points)\n        const p0 = pts[0];\n        const pe = pts[pts.length - 1];\n        const dx = pe.x - p0.x;\n        const dy = pe.y - p0.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const length = dist - 2 * spacing - arrow;\n        // Computes the norm and the inverse norm\n        const nx = dx / dist;\n        const ny = dy / dist;\n        const basex = length * nx;\n        const basey = length * ny;\n        const floorx = (width * ny) / 3;\n        const floory = (-width * nx) / 3;\n        // Computes points\n        const p0x = p0.x - floorx / 2 + spacing * nx;\n        const p0y = p0.y - floory / 2 + spacing * ny;\n        const p1x = p0x + floorx;\n        const p1y = p0y + floory;\n        const p2x = p1x + basex;\n        const p2y = p1y + basey;\n        const p3x = p2x + floorx;\n        const p3y = p2y + floory;\n        // p4 not necessary\n        const p5x = p3x - 3 * floorx;\n        const p5y = p3y - 3 * floory;\n        c.begin();\n        c.moveTo(p0x, p0y);\n        c.lineTo(p1x, p1y);\n        c.lineTo(p2x, p2y);\n        c.lineTo(p3x, p3y);\n        c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);\n        c.lineTo(p5x, p5y);\n        c.lineTo(p5x + floorx, p5y + floory);\n        c.close();\n        c.fillAndStroke();\n    }\n}\nexport default ArrowShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport { ARROW_SIZE, ARROW_SPACING, ARROW_WIDTH, NONE } from '../../../util/Constants';\nimport { relativeCcw } from '../../../util/mathUtils';\n/**\n * Extends {@link Shape} to implement a new rounded arrow shape with support for waypoints and double arrows.\n *\n * The shape is used to represent edges, not vertices.\n *\n * By default, this shape is registered under {@link SHAPE.ARROW_CONNECTOR} in {@link CellRenderer}.\n *\n * @category Edge Shapes\n */\nclass ArrowConnectorShape extends Shape {\n    constructor(points, fill, stroke, strokeWidth = 1, arrowWidth = ARROW_WIDTH, spacing = ARROW_SPACING, endSize = ARROW_SIZE / 5) {\n        super();\n        /**\n         * Allows to use the SVG bounding box in SVG.\n         * @defaultValue `false` for performance reasons.\n         */\n        this.useSvgBoundingBox = true;\n        this.points = points;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n        this.arrowWidth = arrowWidth;\n        this.arrowSpacing = spacing;\n        this.startSize = ARROW_SIZE / 5;\n        this.endSize = endSize;\n    }\n    /**\n     * Hook for subclassers.\n     */\n    isRoundable() {\n        return true;\n    }\n    /**\n     * Overrides mxShape to reset spacing.\n     */\n    resetStyles() {\n        super.resetStyles();\n        this.arrowSpacing = ARROW_SPACING;\n    }\n    /**\n     * Overrides apply to get smooth transition from default start- and endsize.\n     */\n    apply(state) {\n        super.apply(state);\n        if (this.style && this.style.startSize != null && this.style.endSize != null) {\n            this.startSize = this.style.startSize * 3;\n            this.endSize = this.style.endSize * 3;\n        }\n    }\n    /**\n     * Augments the bounding box with the edge width and markers.\n     */\n    augmentBoundingBox(bbox) {\n        super.augmentBoundingBox(bbox);\n        let w = this.getEdgeWidth();\n        if (this.isMarkerStart()) {\n            w = Math.max(w, this.getStartArrowWidth());\n        }\n        if (this.isMarkerEnd()) {\n            w = Math.max(w, this.getEndArrowWidth());\n        }\n        bbox.grow((w / 2 + this.strokeWidth) * this.scale);\n    }\n    /**\n     * Paints the line shape.\n     */\n    paintEdgeShape(c, pts) {\n        // Geometry of arrow\n        let strokeWidth = this.strokeWidth;\n        if (this.outline) {\n            strokeWidth = Math.max(1, this.style?.strokeWidth ?? 0);\n        }\n        const startWidth = this.getStartArrowWidth() + strokeWidth;\n        const endWidth = this.getEndArrowWidth() + strokeWidth;\n        const edgeWidth = this.outline\n            ? this.getEdgeWidth() + strokeWidth\n            : this.getEdgeWidth();\n        const openEnded = this.isOpenEnded();\n        const markerStart = this.isMarkerStart();\n        const markerEnd = this.isMarkerEnd();\n        const spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;\n        const startSize = this.startSize + strokeWidth;\n        const endSize = this.endSize + strokeWidth;\n        const isRounded = this.isArrowRounded();\n        // Base vector (between first points)\n        const pe = pts[pts.length - 1];\n        // Finds first non-overlapping point\n        let i0 = 1;\n        while (i0 < pts.length - 1 && pts[i0].x === pts[0].x && pts[i0].y === pts[0].y) {\n            i0++;\n        }\n        const dx = pts[i0].x - pts[0].x;\n        const dy = pts[i0].y - pts[0].y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        if (dist === 0) {\n            return;\n        }\n        // Computes the norm and the inverse norm\n        let nx = dx / dist;\n        let nx2;\n        let nx1 = nx;\n        let ny = dy / dist;\n        let ny2;\n        let ny1 = ny;\n        let orthx = edgeWidth * ny;\n        let orthy = -edgeWidth * nx;\n        // Stores the inbound function calls in reverse order in fns\n        const fns = [];\n        if (isRounded) {\n            c.setLineJoin('round');\n        }\n        else if (pts.length > 2) {\n            // Only mitre if there are waypoints\n            c.setMiterLimit(1.42);\n        }\n        c.begin();\n        const startNx = nx;\n        const startNy = ny;\n        if (markerStart && !openEnded) {\n            this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n        }\n        else {\n            const outStartX = pts[0].x + orthx / 2 + spacing * nx;\n            const outStartY = pts[0].y + orthy / 2 + spacing * ny;\n            const inEndX = pts[0].x - orthx / 2 + spacing * nx;\n            const inEndY = pts[0].y - orthy / 2 + spacing * ny;\n            if (openEnded) {\n                c.moveTo(outStartX, outStartY);\n                fns.push(() => {\n                    c.lineTo(inEndX, inEndY);\n                });\n            }\n            else {\n                c.moveTo(inEndX, inEndY);\n                c.lineTo(outStartX, outStartY);\n            }\n        }\n        let dx1 = 0;\n        let dy1 = 0;\n        let dist1 = 0;\n        for (let i = 0; i < pts.length - 2; i += 1) {\n            // Work out in which direction the line is bending\n            const pos = relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);\n            dx1 = pts[i + 2].x - pts[i + 1].x;\n            dy1 = pts[i + 2].y - pts[i + 1].y;\n            dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n            if (dist1 !== 0) {\n                nx1 = dx1 / dist1;\n                ny1 = dy1 / dist1;\n                const tmp1 = nx * nx1 + ny * ny1;\n                const tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n                // Work out the normal orthogonal to the line through the control point and the edge sides intersection\n                nx2 = nx + nx1;\n                ny2 = ny + ny1;\n                const dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n                if (dist2 !== 0) {\n                    nx2 /= dist2;\n                    ny2 /= dist2;\n                    // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n                    const strokeWidthFactor = Math.max(tmp, Math.min(this.strokeWidth / 200 + 0.04, 0.35));\n                    const angleFactor = pos !== 0 && isRounded\n                        ? Math.max(0.1, strokeWidthFactor)\n                        : Math.max(tmp, 0.06);\n                    const outX = pts[i + 1].x + (ny2 * edgeWidth) / 2 / angleFactor;\n                    const outY = pts[i + 1].y - (nx2 * edgeWidth) / 2 / angleFactor;\n                    const inX = pts[i + 1].x - (ny2 * edgeWidth) / 2 / angleFactor;\n                    const inY = pts[i + 1].y + (nx2 * edgeWidth) / 2 / angleFactor;\n                    if (pos === 0 || !isRounded) {\n                        // If the two segments are aligned, or if we're not drawing curved sections between segments\n                        // just draw straight to the intersection point\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else if (pos === -1) {\n                        const c1x = inX + ny * edgeWidth;\n                        const c1y = inY - nx * edgeWidth;\n                        const c2x = inX + ny1 * edgeWidth;\n                        const c2y = inY - nx1 * edgeWidth;\n                        c.lineTo(c1x, c1y);\n                        c.quadTo(outX, outY, c2x, c2y);\n                        ((x, y) => {\n                            fns.push(() => {\n                                c.lineTo(x, y);\n                            });\n                        })(inX, inY);\n                    }\n                    else {\n                        c.lineTo(outX, outY);\n                        ((x, y) => {\n                            const c1x = outX - ny * edgeWidth;\n                            const c1y = outY + nx * edgeWidth;\n                            const c2x = outX - ny1 * edgeWidth;\n                            const c2y = outY + nx1 * edgeWidth;\n                            fns.push(() => {\n                                c.quadTo(x, y, c1x, c1y);\n                            });\n                            fns.push(() => {\n                                c.lineTo(c2x, c2y);\n                            });\n                        })(inX, inY);\n                    }\n                    nx = nx1;\n                    ny = ny1;\n                }\n            }\n        }\n        orthx = edgeWidth * ny1;\n        orthy = -edgeWidth * nx1;\n        if (markerEnd && !openEnded) {\n            this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n        }\n        else {\n            c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n            const inStartX = pe.x - spacing * nx1 - orthx / 2;\n            const inStartY = pe.y - spacing * ny1 - orthy / 2;\n            if (!openEnded) {\n                c.lineTo(inStartX, inStartY);\n            }\n            else {\n                c.moveTo(inStartX, inStartY);\n                fns.splice(0, 0, () => {\n                    c.moveTo(inStartX, inStartY);\n                });\n            }\n        }\n        for (let i = fns.length - 1; i >= 0; i--) {\n            fns[i]();\n        }\n        if (openEnded) {\n            c.end();\n            c.stroke();\n        }\n        else {\n            c.close();\n            c.fillAndStroke();\n        }\n        // Workaround for shadow on top of base arrow\n        c.setShadow(false);\n        // Need to redraw the markers without the low miter limit\n        c.setMiterLimit(4);\n        if (isRounded) {\n            c.setLineJoin('flat');\n        }\n        if (pts.length > 2) {\n            // Only to repaint markers if no waypoints\n            // Need to redraw the markers without the low miter limit\n            c.setMiterLimit(4);\n            if (markerStart && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n            if (markerEnd && !openEnded) {\n                c.begin();\n                this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n                c.stroke();\n                c.end();\n            }\n        }\n    }\n    /**\n     * Paints the marker.\n     */\n    paintMarker(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {\n        const widthArrowRatio = edgeWidth / arrowWidth;\n        const orthx = (edgeWidth * ny) / 2;\n        const orthy = (-edgeWidth * nx) / 2;\n        const spaceX = (spacing + size) * nx;\n        const spaceY = (spacing + size) * ny;\n        if (initialMove) {\n            c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        else {\n            c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n        }\n        c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n        c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n        c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n    }\n    /**\n     * @returns whether the arrow is rounded\n     */\n    isArrowRounded() {\n        return this.isRounded;\n    }\n    /**\n     * @returns the width of the start arrow\n     */\n    getStartArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the end arrow\n     */\n    getEndArrowWidth() {\n        return ARROW_WIDTH;\n    }\n    /**\n     * @returns the width of the body of the edge\n     */\n    getEdgeWidth() {\n        return ARROW_WIDTH / 3;\n    }\n    /**\n     * @returns whether the ends of the shape are drawn\n     */\n    isOpenEnded() {\n        return false;\n    }\n    /**\n     * @returns whether the start marker is drawn\n     */\n    isMarkerStart() {\n        return (this.style?.startArrow ?? NONE) !== NONE;\n    }\n    /**\n     * @returns whether the end marker is drawn\n     */\n    isMarkerEnd() {\n        return (this.style?.endArrow ?? NONE) !== NONE;\n    }\n}\nexport default ArrowConnectorShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../Rectangle';\nimport Shape from '../Shape';\n/**\n * Extends {@link Shape} to implement a double ellipse shape.\n * This shape is registered by default under {@link SHAPE.DOUBLE_ELLIPSE} in {@link CellRenderer}.\n *\n * If a custom shape is needed to only fill the inner ellipse, then this shape's {@link paintVertexShape} method should be overridden\n * like in the following example:\n *\n * ```typescript\n * class SampleShape extends DoubleEllipseShape {\n *   paintVertexShape(c: AbstractCanvas2D, x: number, y: number, w: number, h: number) {\n *     c.ellipse(x, y, w, h);\n *     c.stroke();\n *\n *     const inset = this.style.margin ?? Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5));\n *     x += inset;\n *     y += inset;\n *     w -= 2 * inset;\n *     h -= 2 * inset;\n *\n *     if (w > 0 && h > 0) {\n *       c.ellipse(x, y, w, h);\n *     }\n *\n *     c.fillAndStroke();\n *   }\n * }\n * ```\n *\n * @category Vertex Shapes\n */\nclass DoubleEllipseShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Paints the background.\n     */\n    paintBackground(c, x, y, w, h) {\n        c.ellipse(x, y, w, h);\n        c.fillAndStroke();\n    }\n    /**\n     * Paints the foreground.\n     */\n    paintForeground(c, x, y, w, h) {\n        if (!this.outline) {\n            const margin = this.style?.margin ?? Math.min(3 + this.strokeWidth, Math.min(w / 5, h / 5));\n            x += margin;\n            y += margin;\n            w -= 2 * margin;\n            h -= 2 * margin;\n            // FIXME: Rounding issues in IE8 standards mode (not in 1.x)\n            if (w > 0 && h > 0) {\n                c.ellipse(x, y, w, h);\n            }\n            c.stroke();\n        }\n    }\n    /**\n     * @returns the bounds for the label.\n     */\n    getLabelBounds(rect) {\n        const margin = this.style?.margin ??\n            Math.min(3 + this.strokeWidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)) * this.scale;\n        return new Rectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);\n    }\n}\nexport default DoubleEllipseShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../Shape';\nimport Rectangle from '../Rectangle';\nimport { DEFAULT_STARTSIZE, DIRECTION, LINE_ARCSIZE, NONE, RECTANGLE_ROUNDING_FACTOR, } from '../../../util/Constants';\n/**\n * Extends {@link Shape} to implement a swimlane shape.\n * This shape is registered by default under {@link SHAPE.SWIMLANE} in {@link CellRenderer}.\n *\n * Use:\n * - {@link CellStateStyle.startSize} to define the size of the title region,\n * - {@link CellStateStyle.swimlaneFillColor} for the content area fill,\n * - {@link CellStateStyle.separatorColor} to draw an additional vertical separator,\n * - {@link CellStateStyle.swimlaneLine} to hide the line between the title region and the content area\n *\n * {@link CellStateStyle.horizontal} affects the orientation of this shape, not only its label.\n *\n * @category Vertex Shapes\n */\nclass SwimlaneShape extends Shape {\n    constructor(bounds, fill, stroke, strokeWidth = 1) {\n        super();\n        /**\n         * Default imagewidth and imageheight if an image but no imagewidth\n         * and imageheight are defined in the style. Value is 16.\n         * @type {number}\n         * @default 16\n         */\n        this.imageSize = 16;\n        this.imageSrc = null;\n        this.bounds = bounds;\n        this.fill = fill;\n        this.stroke = stroke;\n        this.strokeWidth = strokeWidth;\n    }\n    /**\n     * Adds roundable support.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @returns {boolean}\n     */\n    isRoundable(c, x, y, w, h) {\n        return true;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getTitleSize() {\n        return Math.max(0, this.style?.startSize ?? DEFAULT_STARTSIZE);\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getLabelBounds(rect) {\n        const start = this.getTitleSize();\n        const bounds = new Rectangle(rect.x, rect.y, rect.width, rect.height);\n        const horizontal = this.isHorizontal();\n        const flipH = this.style?.flipH ?? false;\n        const flipV = this.style?.flipV ?? false;\n        // East is default\n        const shapeVertical = this.direction === DIRECTION.NORTH || this.direction === DIRECTION.SOUTH;\n        const realHorizontal = horizontal == !shapeVertical;\n        const realFlipH = !realHorizontal &&\n            flipH !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        const realFlipV = realHorizontal &&\n            flipV !== (this.direction === DIRECTION.SOUTH || this.direction === DIRECTION.WEST);\n        // Shape is horizontal\n        if (!shapeVertical) {\n            const tmp = Math.min(bounds.height, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.y += bounds.height - tmp;\n            }\n            bounds.height = tmp;\n        }\n        else {\n            const tmp = Math.min(bounds.width, start * this.scale);\n            if (realFlipH || realFlipV) {\n                bounds.x += bounds.width - tmp;\n            }\n            bounds.width = tmp;\n        }\n        return bounds;\n    }\n    /**\n     * Returns the bounding box for the gradient box for this shape.\n     */\n    getGradientBounds(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n            return new Rectangle(x, y, w, start);\n        }\n        start = Math.min(start, w);\n        return new Rectangle(x, y, start, h);\n    }\n    /**\n     * Returns the arcsize for the swimlane.\n     */\n    getSwimlaneArcSize(w, h, start) {\n        if (this.style?.absoluteArcSize ?? false) {\n            return Math.min(w / 2, Math.min(h / 2, this.style?.arcSize ?? LINE_ARCSIZE / 2));\n        }\n        const f = (this.style?.arcSize ?? RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n        return start * f * 3;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    isHorizontal() {\n        return this.style?.horizontal ?? true;\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintVertexShape(c, x, y, w, h) {\n        let start = this.getTitleSize();\n        const fill = this.style?.swimlaneFillColor ?? NONE;\n        const swimlaneLine = this.style?.swimlaneLine ?? true;\n        let r = 0;\n        if (this.isHorizontal()) {\n            start = Math.min(start, h);\n        }\n        else {\n            start = Math.min(start, w);\n        }\n        c.translate(x, y);\n        if (!this.isRounded) {\n            this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n        }\n        else {\n            r = this.getSwimlaneArcSize(w, h, start);\n            r = Math.min((this.isHorizontal() ? h : w) - start, Math.min(start, r));\n            this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n        }\n        const sep = this.style?.separatorColor ?? NONE;\n        this.paintSeparator(c, x, y, w, h, start, sep);\n        if (this.imageSrc) {\n            const bounds = this.getImageBounds(x, y, w, h);\n            c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n        }\n        if (this.glass) {\n            c.setShadow(false);\n            this.paintGlassEffect(c, 0, 0, w, start, r);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(0, 0);\n            c.lineTo(w, 0);\n            c.lineTo(w, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h);\n                c.lineTo(w, h);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(0, 0);\n            c.lineTo(0, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n                c.lineTo(w, h);\n                c.lineTo(start, h);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine) {\n        c.begin();\n        let events = true;\n        if (this.style && this.style.pointerEvents != null) {\n            events = this.style.pointerEvents;\n        }\n        if (!events && this.fill === NONE) {\n            c.pointerEvents = false;\n        }\n        if (this.isHorizontal()) {\n            c.moveTo(w, start);\n            c.lineTo(w, r);\n            c.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n            c.lineTo(Math.min(w / 2, r), 0);\n            c.quadTo(0, 0, 0, r);\n            c.lineTo(0, start);\n            c.fillAndStroke();\n            if (start < h) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(0, start);\n                c.lineTo(0, h - r);\n                c.quadTo(0, h, Math.min(w / 2, r), h);\n                c.lineTo(w - Math.min(w / 2, r), h);\n                c.quadTo(w, h, w, h - r);\n                c.lineTo(w, start);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(r, 0);\n            c.quadTo(0, 0, 0, Math.min(h / 2, r));\n            c.lineTo(0, h - Math.min(h / 2, r));\n            c.quadTo(0, h, r, h);\n            c.lineTo(start, h);\n            c.fillAndStroke();\n            if (start < w) {\n                if (fill === NONE || !events) {\n                    c.pointerEvents = false;\n                }\n                if (fill !== NONE) {\n                    c.setFillColor(fill);\n                }\n                c.begin();\n                c.moveTo(start, h);\n                c.lineTo(w - r, h);\n                c.quadTo(w, h, w, h - Math.min(h / 2, r));\n                c.lineTo(w, Math.min(h / 2, r));\n                c.quadTo(w, 0, w - r, 0);\n                c.lineTo(start, 0);\n                if (fill === NONE) {\n                    c.stroke();\n                }\n                else {\n                    c.fillAndStroke();\n                }\n            }\n        }\n        if (swimlaneLine) {\n            this.paintDivider(c, x, y, w, h, start, fill === NONE);\n        }\n    }\n    /**\n     * Paints the divider between swimlane title and content area.\n     */\n    paintDivider(c, x, y, w, h, start, shadow) {\n        if (!shadow) {\n            c.setShadow(false);\n        }\n        c.begin();\n        if (this.isHorizontal()) {\n            c.moveTo(0, start);\n            c.lineTo(w, start);\n        }\n        else {\n            c.moveTo(start, 0);\n            c.lineTo(start, h);\n        }\n        c.stroke();\n    }\n    /**\n     * Paints the vertical or horizontal separator line between swimlanes.\n     */\n    paintSeparator(c, x, y, w, h, start, color) {\n        if (color !== NONE) {\n            c.setStrokeColor(color);\n            c.setDashed(true);\n            c.begin();\n            if (this.isHorizontal()) {\n                c.moveTo(w, start);\n                c.lineTo(w, h);\n            }\n            else {\n                c.moveTo(start, 0);\n                c.lineTo(w, 0);\n            }\n            c.stroke();\n            c.setDashed(false);\n        }\n    }\n    /**\n     * Paints the swimlane vertex shape.\n     */\n    getImageBounds(x, y, w, h) {\n        if (this.isHorizontal()) {\n            return new Rectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n        }\n        return new Rectangle(x, y, this.imageSize, this.imageSize);\n    }\n}\nexport default SwimlaneShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../Rectangle';\nimport { ALIGN, DEFAULT_IMAGESIZE, NONE } from '../../../util/Constants';\nimport RectangleShape from './RectangleShape';\n/**\n * Extends {@link RectangleShape} to implement an image shape with a label.\n * This shape is registered by default under {@link SHAPE.LABEL} in {@link CellRenderer}.\n *\n * @category Vertex Shapes\n */\nclass LabelShape extends RectangleShape {\n    /**\n     * Constructs a new label shape.\n     *\n     * @param bounds {@link Rectangle} that defines the bounds. This is stored in {@link bounds}.\n     * @param fill String that defines the fill color. This is stored in {@link fill}.\n     * @param stroke String that defines the stroke color. This is stored in {@link stroke}.\n     * @param strokeWidth Optional integer that defines the stroke width. Default is 1. This is stored in {@link strokeWidth}.\n     */\n    constructor(bounds, fill, stroke, strokeWidth) {\n        super(bounds, fill, stroke, strokeWidth);\n        /**\n         * Default width and height for the image.\n         * @default mxConstants.DEFAULT_IMAGESIZE\n         */\n        this.imageSize = DEFAULT_IMAGESIZE;\n        this.imageSrc = null;\n        /**\n         * Default value for image spacing\n         * @type {number}\n         * @default 2\n         */\n        this.spacing = 2;\n        /**\n         * Default width and height for the indicicator.\n         * @type {number}\n         * @default 10\n         */\n        this.indicatorSize = 10;\n        /**\n         * Default spacing between image and indicator\n         * @default 2\n         * @type {number}\n         */\n        this.indicatorSpacing = 2;\n        this.indicatorImageSrc = null;\n    }\n    /**\n     * Initializes the shape and the <indicator>.\n     */\n    init(container) {\n        super.init(container);\n        if (this.indicatorShape) {\n            this.indicator = new this.indicatorShape();\n            this.indicator.dialect = this.dialect;\n            this.indicator.init(this.node);\n        }\n    }\n    /**\n     * Reconfigures this shape. This will update the colors of the indicator\n     * and reconfigure it if required.\n     */\n    redraw() {\n        if (this.indicator) {\n            this.indicator.fill = this.indicatorColor;\n            this.indicator.stroke = this.indicatorStrokeColor;\n            this.indicator.gradient = this.indicatorGradientColor;\n            this.indicator.direction = this.indicatorDirection;\n            this.indicator.redraw();\n        }\n        super.redraw();\n    }\n    /**\n     * Returns true for non-rounded, non-rotated shapes with no glass gradient and\n     * no indicator shape.\n     */\n    isHtmlAllowed() {\n        return super.isHtmlAllowed() && this.indicatorColor === NONE && !!this.indicatorShape;\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintForeground(c, x, y, w, h) {\n        this.paintImage(c, x, y, w, h);\n        this.paintIndicator(c, x, y, w, h);\n        super.paintForeground(c, x, y, w, h);\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintImage(c, x, y, w, h) {\n        if (this.imageSrc) {\n            const bounds = this.getImageBounds(x, y, w, h);\n            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.imageSrc, false, false, false);\n        }\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    getImageBounds(x, y, w, h) {\n        const align = this.style?.imageAlign ?? ALIGN.LEFT;\n        const valign = this.style?.verticalAlign ?? ALIGN.MIDDLE;\n        const width = this.style?.imageWidth ?? DEFAULT_IMAGESIZE;\n        const height = this.style?.imageHeight ?? DEFAULT_IMAGESIZE;\n        const spacing = this.style?.spacing ?? this.spacing + 5;\n        if (align === ALIGN.CENTER) {\n            x += (w - width) / 2;\n        }\n        else if (align === ALIGN.RIGHT) {\n            x += w - width - spacing;\n        } // default is left\n        else {\n            x += spacing;\n        }\n        if (valign === ALIGN.TOP) {\n            y += spacing;\n        }\n        else if (valign === ALIGN.BOTTOM) {\n            y += h - height - spacing;\n        } // default is middle\n        else {\n            y += (h - height) / 2;\n        }\n        return new Rectangle(x, y, width, height);\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {mxAbstractCanvas2D} c\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     */\n    paintIndicator(c, x, y, w, h) {\n        if (this.indicator) {\n            this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);\n            this.indicator.paint(c);\n        }\n        else if (this.indicatorImageSrc) {\n            const bounds = this.getIndicatorBounds(x, y, w, h);\n            c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImageSrc, false, false, false);\n        }\n    }\n    /**\n     * Generic background painting implementation.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} w\n     * @param {number} h\n     * @returns {Rectangle}\n     */\n    getIndicatorBounds(x, y, w, h) {\n        const align = this.style?.imageAlign ?? ALIGN.LEFT;\n        const valign = this.style?.verticalAlign ?? ALIGN.MIDDLE;\n        const width = this.style?.indicatorWidth ?? this.indicatorSize;\n        const height = this.style?.indicatorHeight ?? this.indicatorSize;\n        const spacing = this.spacing + 5;\n        if (align === ALIGN.RIGHT) {\n            x += w - width - spacing;\n        }\n        else if (align === ALIGN.CENTER) {\n            x += (w - width) / 2;\n        } // default is left\n        else {\n            x += spacing;\n        }\n        if (valign === ALIGN.BOTTOM) {\n            y += h - height - spacing;\n        }\n        else if (valign === ALIGN.TOP) {\n            y += spacing;\n        } // default is middle\n        else {\n            y += (h - height) / 2;\n        }\n        return new Rectangle(x, y, width, height);\n    }\n    /**\n     * Generic background painting implementation.\n     */\n    redrawHtmlShape() {\n        super.redrawHtmlShape();\n        // Removes all children\n        while (this.node.hasChildNodes()) {\n            this.node.removeChild(this.node.lastChild);\n        }\n        if (this.imageSrc && this.bounds) {\n            const node = document.createElement('img');\n            node.style.position = 'relative';\n            node.setAttribute('border', '0');\n            const bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n            bounds.x -= this.bounds.x;\n            bounds.y -= this.bounds.y;\n            node.style.left = `${Math.round(bounds.x)}px`;\n            node.style.top = `${Math.round(bounds.y)}px`;\n            node.style.width = `${Math.round(bounds.width)}px`;\n            node.style.height = `${Math.round(bounds.height)}px`;\n            node.src = this.imageSrc;\n            this.node.appendChild(node);\n        }\n    }\n}\nexport default LabelShape;\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellRenderer from './CellRenderer';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport EllipseShape from '../geometry/node/EllipseShape';\nimport RhombusShape from '../geometry/node/RhombusShape';\nimport CylinderShape from '../geometry/node/CylinderShape';\nimport ConnectorShape from '../geometry/edge/ConnectorShape';\nimport ActorShape from '../geometry/ActorShape';\nimport TriangleShape from '../geometry/node/TriangleShape';\nimport HexagonShape from '../geometry/node/HexagonShape';\nimport CloudShape from '../geometry/node/CloudShape';\nimport LineShape from '../geometry/edge/LineShape';\nimport ArrowShape from '../geometry/edge/ArrowShape';\nimport ArrowConnectorShape from '../geometry/edge/ArrowConnectorShape';\nimport DoubleEllipseShape from '../geometry/node/DoubleEllipseShape';\nimport SwimlaneShape from '../geometry/node/SwimlaneShape';\nimport ImageShape from '../geometry/node/ImageShape';\nimport LabelShape from '../geometry/node/LabelShape';\nimport { SHAPE } from '../../util/Constants';\nlet isDefaultElementsRegistered = false;\n/**\n * Add default shapes into `CellRenderer` shapes.\n *\n * @category Configuration\n */\nexport function registerDefaultShapes() {\n    if (!isDefaultElementsRegistered) {\n        const shapesToRegister = [\n            [SHAPE.ACTOR, ActorShape],\n            [SHAPE.ARROW, ArrowShape],\n            [SHAPE.ARROW_CONNECTOR, ArrowConnectorShape],\n            [SHAPE.CONNECTOR, ConnectorShape],\n            [SHAPE.CLOUD, CloudShape],\n            [SHAPE.CYLINDER, CylinderShape],\n            [SHAPE.DOUBLE_ELLIPSE, DoubleEllipseShape],\n            [SHAPE.ELLIPSE, EllipseShape],\n            [SHAPE.HEXAGON, HexagonShape],\n            [SHAPE.IMAGE, ImageShape],\n            [SHAPE.LABEL, LabelShape],\n            [SHAPE.LINE, LineShape],\n            [SHAPE.RECTANGLE, RectangleShape],\n            [SHAPE.RHOMBUS, RhombusShape],\n            [SHAPE.SWIMLANE, SwimlaneShape],\n            [SHAPE.TRIANGLE, TriangleShape],\n        ];\n        for (const [shapeName, shapeClass] of shapesToRegister) {\n            CellRenderer.registerShape(shapeName, shapeClass);\n        }\n        isDefaultElementsRegistered = true;\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * @category Perimeter\n */\nexport const EllipsePerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const a = bounds.width / 2;\n    const b = bounds.height / 2;\n    const cx = x + a;\n    const cy = y + b;\n    const px = next.x;\n    const py = next.y;\n    // Calculates straight line equation through\n    // point and ellipse center y = d * x + h\n    const dx = parseInt(String(px - cx));\n    const dy = parseInt(String(py - cy));\n    if (dx === 0 && dy !== 0) {\n        return new Point(cx, cy + (b * dy) / Math.abs(dy));\n    }\n    if (dx === 0 && dy === 0) {\n        return new Point(px, py);\n    }\n    if (orthogonal) {\n        if (py >= y && py <= y + bounds.height) {\n            const ty = py - cy;\n            let tx = Math.sqrt(a * a * (1 - (ty * ty) / (b * b))) || 0;\n            if (px <= x) {\n                tx = -tx;\n            }\n            return new Point(cx + tx, py);\n        }\n        if (px >= x && px <= x + bounds.width) {\n            const tx = px - cx;\n            let ty = Math.sqrt(b * b * (1 - (tx * tx) / (a * a))) || 0;\n            if (py <= y) {\n                ty = -ty;\n            }\n            return new Point(px, cy + ty);\n        }\n    }\n    // Calculates intersection\n    const d = dy / dx;\n    const h = cy - d * cx;\n    const e = a * a * d * d + b * b;\n    const f = -2 * cx * e;\n    const g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;\n    const det = Math.sqrt(f * f - 4 * e * g);\n    // Two solutions (perimeter points)\n    const xout1 = (-f + det) / (2 * e);\n    const xout2 = (-f - det) / (2 * e);\n    const yout1 = d * xout1 + h;\n    const yout2 = d * xout2 + h;\n    const dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));\n    const dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));\n    // Correct solution\n    let xout = 0;\n    let yout = 0;\n    if (dist1 < dist2) {\n        xout = xout1;\n        yout = yout1;\n    }\n    else {\n        xout = xout2;\n        yout = yout2;\n    }\n    return new Point(xout, yout);\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const HexagonPerimeter = (bounds, vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    const cx = bounds.getCenterX();\n    const cy = bounds.getCenterY();\n    const px = next.x;\n    const py = next.y;\n    const dx = px - cx;\n    const dy = py - cy;\n    const alpha = -Math.atan2(dy, dx);\n    const pi = Math.PI;\n    const pi2 = Math.PI / 2;\n    let result = new Point(cx, cy);\n    const direction = vertex?.style?.direction ?? DIRECTION.EAST;\n    const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n    let a = new Point();\n    let b = new Point();\n    // Only consider corrects quadrants for the orthogonal case.\n    if ((px < x && py < y) ||\n        (px < x && py > y + h) ||\n        (px > x + w && py < y) ||\n        (px > x + w && py > y + h)) {\n        orthogonal = false;\n    }\n    if (orthogonal) {\n        if (vertical) {\n            // Special cases where intersects with hexagon corners\n            if (px === cx) {\n                if (py <= y) {\n                    return new Point(cx, y);\n                }\n                if (py >= y + h) {\n                    return new Point(cx, y + h);\n                }\n            }\n            else if (px < x) {\n                if (py === y + h / 4) {\n                    return new Point(x, y + h / 4);\n                }\n                if (py === y + (3 * h) / 4) {\n                    return new Point(x, y + (3 * h) / 4);\n                }\n            }\n            else if (px > x + w) {\n                if (py === y + h / 4) {\n                    return new Point(x + w, y + h / 4);\n                }\n                if (py === y + (3 * h) / 4) {\n                    return new Point(x + w, y + (3 * h) / 4);\n                }\n            }\n            else if (px === x) {\n                if (py < cy) {\n                    return new Point(x, y + h / 4);\n                }\n                if (py > cy) {\n                    return new Point(x, y + (3 * h) / 4);\n                }\n            }\n            else if (px === x + w) {\n                if (py < cy) {\n                    return new Point(x + w, y + h / 4);\n                }\n                if (py > cy) {\n                    return new Point(x + w, y + (3 * h) / 4);\n                }\n            }\n            if (py === y) {\n                return new Point(cx, y);\n            }\n            if (py === y + h) {\n                return new Point(cx, y + h);\n            }\n            if (px < cx) {\n                if (py > y + h / 4 && py < y + (3 * h) / 4) {\n                    a = new Point(x, y);\n                    b = new Point(x, y + h);\n                }\n                else if (py < y + h / 4) {\n                    a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x + w, y - Math.floor(0.25 * h));\n                }\n                else if (py > y + (3 * h) / 4) {\n                    a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x + w, y + Math.floor(1.25 * h));\n                }\n            }\n            else if (px > cx) {\n                if (py > y + h / 4 && py < y + (3 * h) / 4) {\n                    a = new Point(x + w, y);\n                    b = new Point(x + w, y + h);\n                }\n                else if (py < y + h / 4) {\n                    a = new Point(x, y - Math.floor(0.25 * h));\n                    b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                }\n                else if (py > y + (3 * h) / 4) {\n                    a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                    b = new Point(x, y + Math.floor(1.25 * h));\n                }\n            }\n        }\n        else {\n            // Special cases where intersects with hexagon corners\n            if (py === cy) {\n                if (px <= x) {\n                    return new Point(x, y + h / 2);\n                }\n                if (px >= x + w) {\n                    return new Point(x + w, y + h / 2);\n                }\n            }\n            else if (py < y) {\n                if (px === x + w / 4) {\n                    return new Point(x + w / 4, y);\n                }\n                if (px === x + (3 * w) / 4) {\n                    return new Point(x + (3 * w) / 4, y);\n                }\n            }\n            else if (py > y + h) {\n                if (px === x + w / 4) {\n                    return new Point(x + w / 4, y + h);\n                }\n                if (px === x + (3 * w) / 4) {\n                    return new Point(x + (3 * w) / 4, y + h);\n                }\n            }\n            else if (py === y) {\n                if (px < cx) {\n                    return new Point(x + w / 4, y);\n                }\n                if (px > cx) {\n                    return new Point(x + (3 * w) / 4, y);\n                }\n            }\n            else if (py === y + h) {\n                if (px < cx) {\n                    return new Point(x + w / 4, y + h);\n                }\n                if (py > cy) {\n                    return new Point(x + (3 * w) / 4, y + h);\n                }\n            }\n            if (px === x) {\n                return new Point(x, cy);\n            }\n            if (px === x + w) {\n                return new Point(x + w, cy);\n            }\n            if (py < cy) {\n                if (px > x + w / 4 && px < x + (3 * w) / 4) {\n                    a = new Point(x, y);\n                    b = new Point(x + w, y);\n                }\n                else if (px < x + w / 4) {\n                    a = new Point(x - Math.floor(0.25 * w), y + h);\n                    b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                }\n                else if (px > x + (3 * w) / 4) {\n                    a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                    b = new Point(x + Math.floor(1.25 * w), y + h);\n                }\n            }\n            else if (py > cy) {\n                if (px > x + w / 4 && px < x + (3 * w) / 4) {\n                    a = new Point(x, y + h);\n                    b = new Point(x + w, y + h);\n                }\n                else if (px < x + w / 4) {\n                    a = new Point(x - Math.floor(0.25 * w), y);\n                    b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                }\n                else if (px > x + (3 * w) / 4) {\n                    a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                    b = new Point(x + Math.floor(1.25 * w), y);\n                }\n            }\n        }\n        let tx = cx;\n        let ty = cy;\n        if (px >= x && px <= x + w) {\n            tx = px;\n            if (py < cy) {\n                ty = y + h;\n            }\n            else {\n                ty = y;\n            }\n        }\n        else if (py >= y && py <= y + h) {\n            ty = py;\n            if (px < cx) {\n                tx = x + w;\n            }\n            else {\n                tx = x;\n            }\n        }\n        result = intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);\n    }\n    else {\n        if (vertical) {\n            const beta = Math.atan2(h / 4, w / 2);\n            // Special cases where intersects with hexagon corners\n            if (alpha === beta) {\n                return new Point(x + w, y + Math.floor(0.25 * h));\n            }\n            if (alpha === pi2) {\n                return new Point(x + Math.floor(0.5 * w), y);\n            }\n            if (alpha === pi - beta) {\n                return new Point(x, y + Math.floor(0.25 * h));\n            }\n            if (alpha === -beta) {\n                return new Point(x + w, y + Math.floor(0.75 * h));\n            }\n            if (alpha === -pi2) {\n                return new Point(x + Math.floor(0.5 * w), y + h);\n            }\n            if (alpha === -pi + beta) {\n                return new Point(x, y + Math.floor(0.75 * h));\n            }\n            if (alpha < beta && alpha > -beta) {\n                a = new Point(x + w, y);\n                b = new Point(x + w, y + h);\n            }\n            else if (alpha > beta && alpha < pi2) {\n                a = new Point(x, y - Math.floor(0.25 * h));\n                b = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n            }\n            else if (alpha > pi2 && alpha < pi - beta) {\n                a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x + w, y - Math.floor(0.25 * h));\n            }\n            else if ((alpha > pi - beta && alpha <= pi) ||\n                (alpha < -pi + beta && alpha >= -pi)) {\n                a = new Point(x, y);\n                b = new Point(x, y + h);\n            }\n            else if (alpha < -beta && alpha > -pi2) {\n                a = new Point(x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x, y + Math.floor(1.25 * h));\n            }\n            else if (alpha < -pi2 && alpha > -pi + beta) {\n                a = new Point(x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n                b = new Point(x + w, y + Math.floor(1.25 * h));\n            }\n        }\n        else {\n            const beta = Math.atan2(h / 2, w / 4);\n            // Special cases where intersects with hexagon corners\n            if (alpha === beta) {\n                return new Point(x + Math.floor(0.75 * w), y);\n            }\n            if (alpha === pi - beta) {\n                return new Point(x + Math.floor(0.25 * w), y);\n            }\n            if (alpha === pi || alpha === -pi) {\n                return new Point(x, y + Math.floor(0.5 * h));\n            }\n            if (alpha === 0) {\n                return new Point(x + w, y + Math.floor(0.5 * h));\n            }\n            if (alpha === -beta) {\n                return new Point(x + Math.floor(0.75 * w), y + h);\n            }\n            if (alpha === -pi + beta) {\n                return new Point(x + Math.floor(0.25 * w), y + h);\n            }\n            if (alpha > 0 && alpha < beta) {\n                a = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n                b = new Point(x + Math.floor(1.25 * w), y + h);\n            }\n            else if (alpha > beta && alpha < pi - beta) {\n                a = new Point(x, y);\n                b = new Point(x + w, y);\n            }\n            else if (alpha > pi - beta && alpha < pi) {\n                a = new Point(x - Math.floor(0.25 * w), y + h);\n                b = new Point(x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n            }\n            else if (alpha < 0 && alpha > -beta) {\n                a = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n                b = new Point(x + Math.floor(1.25 * w), y);\n            }\n            else if (alpha < -beta && alpha > -pi + beta) {\n                a = new Point(x, y + h);\n                b = new Point(x + w, y + h);\n            }\n            else if (alpha < -pi + beta && alpha > -pi) {\n                a = new Point(x - Math.floor(0.25 * w), y);\n                b = new Point(x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n            }\n        }\n        result = intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);\n    }\n    if (result == null) {\n        return new Point(cx, cy);\n    }\n    return result;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\n/**\n * Describes a rectangular perimeter for the given bounds.\n *\n * @category Perimeter\n */\nexport const RectanglePerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const cx = bounds.getCenterX();\n    const cy = bounds.getCenterY();\n    const dx = next.x - cx;\n    const dy = next.y - cy;\n    const alpha = Math.atan2(dy, dx);\n    const p = new Point(0, 0);\n    const pi = Math.PI;\n    const pi2 = Math.PI / 2;\n    const beta = pi2 - alpha;\n    const t = Math.atan2(bounds.height, bounds.width);\n    if (alpha < -pi + t || alpha > pi - t) {\n        // Left edge\n        p.x = bounds.x;\n        p.y = cy - (bounds.width * Math.tan(alpha)) / 2;\n    }\n    else if (alpha < -t) {\n        // Top Edge\n        p.y = bounds.y;\n        p.x = cx - (bounds.height * Math.tan(beta)) / 2;\n    }\n    else if (alpha < t) {\n        // Right Edge\n        p.x = bounds.x + bounds.width;\n        p.y = cy + (bounds.width * Math.tan(alpha)) / 2;\n    }\n    else {\n        // Bottom Edge\n        p.y = bounds.y + bounds.height;\n        p.x = cx + (bounds.height * Math.tan(beta)) / 2;\n    }\n    if (orthogonal) {\n        if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {\n            p.x = next.x;\n        }\n        else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {\n            p.y = next.y;\n        }\n        if (next.x < bounds.x) {\n            p.x = bounds.x;\n        }\n        else if (next.x > bounds.x + bounds.width) {\n            p.x = bounds.x + bounds.width;\n        }\n        if (next.y < bounds.y) {\n            p.y = bounds.y;\n        }\n        else if (next.y > bounds.y + bounds.height) {\n            p.y = bounds.y + bounds.height;\n        }\n    }\n    return p;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const RhombusPerimeter = (bounds, _vertex, next, orthogonal = false) => {\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n    const px = next.x;\n    const py = next.y;\n    // Special case for intersecting the diamond's corners\n    if (cx === px) {\n        if (cy > py) {\n            return new Point(cx, y); // top\n        }\n        return new Point(cx, y + h); // bottom\n    }\n    if (cy === py) {\n        if (cx > px) {\n            return new Point(x, cy); // left\n        }\n        return new Point(x + w, cy); // right\n    }\n    let tx = cx;\n    let ty = cy;\n    if (orthogonal) {\n        if (px >= x && px <= x + w) {\n            tx = px;\n        }\n        else if (py >= y && py <= y + h) {\n            ty = py;\n        }\n    }\n    // In which quadrant will the intersection be?\n    // set the slope and offset of the border line accordingly\n    if (px < cx) {\n        if (py < cy) {\n            return intersection(px, py, tx, ty, cx, y, x, cy);\n        }\n        return intersection(px, py, tx, ty, cx, y + h, x, cy);\n    }\n    if (py < cy) {\n        return intersection(px, py, tx, ty, cx, y, x + w, cy);\n    }\n    return intersection(px, py, tx, ty, cx, y + h, x + w, cy);\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../../geometry/Point';\nimport { DIRECTION } from '../../../util/Constants';\nimport { intersection } from '../../../util/mathUtils';\n/**\n * @category Perimeter\n */\nexport const TrianglePerimeter = (bounds, vertex, next, orthogonal = false) => {\n    const direction = vertex != null ? vertex.style.direction : null;\n    const vertical = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n    const { x } = bounds;\n    const { y } = bounds;\n    const w = bounds.width;\n    const h = bounds.height;\n    let cx = x + w / 2;\n    let cy = y + h / 2;\n    let start = new Point(x, y);\n    let corner = new Point(x + w, cy);\n    let end = new Point(x, y + h);\n    if (direction === DIRECTION.NORTH) {\n        start = end;\n        corner = new Point(cx, y);\n        end = new Point(x + w, y + h);\n    }\n    else if (direction === DIRECTION.SOUTH) {\n        corner = new Point(cx, y + h);\n        end = new Point(x + w, y);\n    }\n    else if (direction === DIRECTION.WEST) {\n        start = new Point(x + w, y);\n        corner = new Point(x, cy);\n        end = new Point(x + w, y + h);\n    }\n    let dx = next.x - cx;\n    let dy = next.y - cy;\n    const alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);\n    const t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);\n    let base = false;\n    if (direction === DIRECTION.NORTH || direction === DIRECTION.WEST) {\n        base = alpha > -t && alpha < t;\n    }\n    else {\n        base = alpha < -Math.PI + t || alpha > Math.PI - t;\n    }\n    let result = null;\n    if (base) {\n        if (orthogonal &&\n            ((vertical && next.x >= start.x && next.x <= end.x) ||\n                (!vertical && next.y >= start.y && next.y <= end.y))) {\n            if (vertical) {\n                result = new Point(next.x, start.y);\n            }\n            else {\n                result = new Point(start.x, next.y);\n            }\n        }\n        else if (direction === DIRECTION.NORTH) {\n            result = new Point(x + w / 2 + (h * Math.tan(alpha)) / 2, y + h);\n        }\n        else if (direction === DIRECTION.SOUTH) {\n            result = new Point(x + w / 2 - (h * Math.tan(alpha)) / 2, y);\n        }\n        else if (direction === DIRECTION.WEST) {\n            result = new Point(x + w, y + h / 2 + (w * Math.tan(alpha)) / 2);\n        }\n        else {\n            result = new Point(x, y + h / 2 - (w * Math.tan(alpha)) / 2);\n        }\n    }\n    else {\n        if (orthogonal) {\n            const pt = new Point(cx, cy);\n            if (next.y >= y && next.y <= y + h) {\n                pt.x = vertical ? cx : direction === DIRECTION.WEST ? x + w : x;\n                pt.y = next.y;\n            }\n            else if (next.x >= x && next.x <= x + w) {\n                pt.x = next.x;\n                pt.y = !vertical ? cy : direction === DIRECTION.NORTH ? y + h : y;\n            }\n            // Compute angle\n            dx = next.x - pt.x;\n            dy = next.y - pt.y;\n            cx = pt.x;\n            cy = pt.y;\n        }\n        if ((vertical && next.x <= x + w / 2) || (!vertical && next.y <= y + h / 2)) {\n            result = intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);\n        }\n        else {\n            result = intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);\n        }\n    }\n    if (result == null) {\n        result = new Point(cx, cy);\n    }\n    return result;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { EllipsePerimeter as EllipsePerimeterFunction } from './perimeter/EllipsePerimeter';\nimport { HexagonPerimeter as HexagonPerimeterFunction } from './perimeter/HexagonPerimeter';\nimport { RectanglePerimeter as RectanglePerimeterFunction } from './perimeter/RectanglePerimeter';\nimport { RhombusPerimeter as RhombusPerimeterFunction } from './perimeter/RhombusPerimeter';\nimport { TrianglePerimeter as TrianglePerimeterFunction } from './perimeter/TrianglePerimeter';\n/**\n * Provides various perimeter functions to be used in a style as the value of {@link CellStateStyle.perimeter}.\n *\n * @category Perimeter\n */\nconst Perimeter = {\n    /**\n     * Describes a rectangular perimeter.\n     */\n    RectanglePerimeter: RectanglePerimeterFunction,\n    /**\n     * Describes an elliptic perimeter.\n     */\n    EllipsePerimeter: EllipsePerimeterFunction,\n    /**\n     * Describes a rhombus (aka diamond) perimeter.\n     */\n    RhombusPerimeter: RhombusPerimeterFunction,\n    /**\n     * Describes a triangle perimeter.\n     */\n    TrianglePerimeter: TrianglePerimeterFunction,\n    /**\n     * Describes a hexagon perimeter.\n     */\n    HexagonPerimeter: HexagonPerimeterFunction,\n};\nexport default Perimeter;\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { EDGESTYLE, PERIMETER } from '../../util/Constants';\nimport EdgeStyle from './EdgeStyle';\nimport Perimeter from './Perimeter';\nimport StyleRegistry from './StyleRegistry';\nlet isDefaultsRegistered = false;\n/**\n * Register style elements for \"EdgeStyle\" and \"Perimeters\".\n *\n * @category Configuration\n */\nexport const registerDefaultStyleElements = () => {\n    if (!isDefaultsRegistered) {\n        // Edge styles\n        StyleRegistry.putValue(EDGESTYLE.ELBOW, EdgeStyle.ElbowConnector);\n        StyleRegistry.putValue(EDGESTYLE.ENTITY_RELATION, EdgeStyle.EntityRelation);\n        StyleRegistry.putValue(EDGESTYLE.LOOP, EdgeStyle.Loop);\n        StyleRegistry.putValue(EDGESTYLE.MANHATTAN, EdgeStyle.ManhattanConnector);\n        StyleRegistry.putValue(EDGESTYLE.ORTHOGONAL, EdgeStyle.OrthConnector);\n        StyleRegistry.putValue(EDGESTYLE.SEGMENT, EdgeStyle.SegmentConnector);\n        StyleRegistry.putValue(EDGESTYLE.SIDETOSIDE, EdgeStyle.SideToSide);\n        StyleRegistry.putValue(EDGESTYLE.TOPTOBOTTOM, EdgeStyle.TopToBottom);\n        // Perimeters\n        StyleRegistry.putValue(PERIMETER.ELLIPSE, Perimeter.EllipsePerimeter);\n        StyleRegistry.putValue(PERIMETER.HEXAGON, Perimeter.HexagonPerimeter);\n        StyleRegistry.putValue(PERIMETER.RECTANGLE, Perimeter.RectanglePerimeter);\n        StyleRegistry.putValue(PERIMETER.RHOMBUS, Perimeter.RhombusPerimeter);\n        StyleRegistry.putValue(PERIMETER.TRIANGLE, Perimeter.TrianglePerimeter);\n        isDefaultsRegistered = true;\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { contains, getBoundingBox, getRotatedPoint, intersects, ptSegDistSq, toRadians, } from '../../util/mathUtils';\nimport { getSizeForString, setCellStyleFlags, setCellStyles, } from '../../util/styleUtils';\nimport { ALIGN, DEFAULT_FONTSIZE, DEFAULT_IMAGESIZE, DIRECTION, SHAPE, } from '../../util/Constants';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport Dictionary from '../../util/Dictionary';\nimport Point from '../geometry/Point';\nimport { htmlEntities } from '../../util/StringUtils';\nimport { cloneCells, getTopmostCells } from '../../util/cellArrayUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const CellsMixin = {\n    cellsResizable: true,\n    cellsBendable: true,\n    cellsSelectable: true,\n    cellsDisconnectable: true,\n    autoSizeCells: false,\n    autoSizeCellsOnAdd: false,\n    cellsLocked: false,\n    cellsCloneable: true,\n    cellsDeletable: true,\n    cellsMovable: true,\n    extendParents: true,\n    extendParentsOnAdd: true,\n    extendParentsOnMove: false,\n    getBoundingBox(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (const cell of cells) {\n                if (cell.isVertex() || cell.isEdge()) {\n                    const bbox = this.getView().getBoundingBox(this.getView().getState(cell), true);\n                    if (bbox) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(bbox);\n                        }\n                        else {\n                            result.add(bbox);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    removeStateForCell(cell) {\n        for (const child of cell.getChildren()) {\n            this.removeStateForCell(child);\n        }\n        this.getView().invalidate(cell, false, true);\n        this.getView().removeState(cell);\n    },\n    /*****************************************************************************\n     * Group: Cell styles\n     *****************************************************************************/\n    getCurrentCellStyle(cell, ignoreState = false) {\n        const state = ignoreState ? null : this.getView().getState(cell);\n        return state ? state.style : this.getCellStyle(cell);\n    },\n    getCellStyle(cell) {\n        const cellStyle = cell.getStyle();\n        const stylesheet = this.getStylesheet();\n        // Gets the default style for the cell\n        const defaultStyle = cell.isEdge()\n            ? stylesheet.getDefaultEdgeStyle()\n            : stylesheet.getDefaultVertexStyle();\n        // Resolves the stylename using the above as the default\n        const style = this.postProcessCellStyle(stylesheet.getCellStyle(cellStyle, defaultStyle ?? {}));\n        return style;\n    },\n    postProcessCellStyle(style) {\n        if (!style.image) {\n            return style;\n        }\n        const key = style.image;\n        let image = this.getImageFromBundles(key);\n        if (image) {\n            style.image = image;\n        }\n        else {\n            image = key;\n        }\n        // Converts short data uris to normal data uris\n        if (image && image.substring(0, 11) === 'data:image/') {\n            if (image.substring(0, 20) === 'data:image/svg+xml,<') {\n                // Required for FF and IE11\n                image = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n            }\n            else if (image.substring(0, 22) !== 'data:image/svg+xml,%3C') {\n                const comma = image.indexOf(',');\n                // Adds base64 encoding prefix if needed\n                if (comma > 0 && image.substring(comma - 7, comma + 1) !== ';base64,') {\n                    image = `${image.substring(0, comma)};base64,${image.substring(comma + 1)}`;\n                }\n            }\n            style.image = image;\n        }\n        return style;\n    },\n    setCellStyle(style, cells) {\n        cells = cells ?? this.getSelectionCells();\n        this.batchUpdate(() => {\n            for (const cell of cells) {\n                this.getDataModel().setStyle(cell, style);\n            }\n        });\n    },\n    toggleCellStyle(key, defaultValue = false, cell) {\n        cell = cell ?? this.getSelectionCell();\n        return this.toggleCellStyles(key, defaultValue, [cell]);\n    },\n    toggleCellStyles(key, defaultValue = false, cells) {\n        let value = false;\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 0) {\n            const style = this.getCurrentCellStyle(cells[0]);\n            value = style[key] ?? defaultValue ? false : true;\n            this.setCellStyles(key, value, cells);\n        }\n        return value;\n    },\n    setCellStyles(key, value, cells) {\n        cells = cells ?? this.getSelectionCells();\n        setCellStyles(this.getDataModel(), cells, key, value);\n    },\n    toggleCellStyleFlags(key, flag, cells) {\n        cells = cells ?? this.getSelectionCells();\n        this.setCellStyleFlags(key, flag, null, cells);\n    },\n    setCellStyleFlags(key, flag, value = null, cells) {\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 0) {\n            if (value === null) {\n                const style = this.getCurrentCellStyle(cells[0]);\n                const current = style[key] || 0;\n                value = !((current & flag) === flag);\n            }\n            setCellStyleFlags(this.getDataModel(), cells, key, flag, value);\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell alignment and orientation\n     *****************************************************************************/\n    alignCells(align, cells, param = null) {\n        cells = cells ?? this.getSelectionCells();\n        if (cells.length > 1) {\n            // Finds the required coordinate for the alignment\n            if (param === null) {\n                for (const cell of cells) {\n                    const state = this.getView().getState(cell);\n                    if (state && !cell.isEdge()) {\n                        if (param === null) {\n                            if (align === ALIGN.CENTER) {\n                                param = state.x + state.width / 2;\n                                break;\n                            }\n                            else if (align === ALIGN.RIGHT) {\n                                param = state.x + state.width;\n                            }\n                            else if (align === ALIGN.TOP) {\n                                param = state.y;\n                            }\n                            else if (align === ALIGN.MIDDLE) {\n                                param = state.y + state.height / 2;\n                                break;\n                            }\n                            else if (align === ALIGN.BOTTOM) {\n                                param = state.y + state.height;\n                            }\n                            else {\n                                param = state.x;\n                            }\n                        }\n                        else if (align === ALIGN.RIGHT) {\n                            param = Math.max(param, state.x + state.width);\n                        }\n                        else if (align === ALIGN.TOP) {\n                            param = Math.min(param, state.y);\n                        }\n                        else if (align === ALIGN.BOTTOM) {\n                            param = Math.max(param, state.y + state.height);\n                        }\n                        else {\n                            param = Math.min(param, state.x);\n                        }\n                    }\n                }\n            }\n            // Aligns the cells to the coordinate\n            if (param !== null) {\n                const s = this.getView().scale;\n                this.batchUpdate(() => {\n                    const p = param;\n                    for (const cell of cells) {\n                        const state = this.getView().getState(cell);\n                        if (state != null) {\n                            let geo = cell.getGeometry();\n                            if (geo != null && !cell.isEdge()) {\n                                geo = geo.clone();\n                                if (align === ALIGN.CENTER) {\n                                    geo.x += (p - state.x - state.width / 2) / s;\n                                }\n                                else if (align === ALIGN.RIGHT) {\n                                    geo.x += (p - state.x - state.width) / s;\n                                }\n                                else if (align === ALIGN.TOP) {\n                                    geo.y += (p - state.y) / s;\n                                }\n                                else if (align === ALIGN.MIDDLE) {\n                                    geo.y += (p - state.y - state.height / 2) / s;\n                                }\n                                else if (align === ALIGN.BOTTOM) {\n                                    geo.y += (p - state.y - state.height) / s;\n                                }\n                                else {\n                                    geo.x += (p - state.x) / s;\n                                }\n                                this.resizeCell(cell, geo);\n                            }\n                        }\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.ALIGN_CELLS, { align, cells }));\n                });\n            }\n        }\n        return cells;\n    },\n    /*****************************************************************************\n     * Group: Cell cloning, insertion and removal\n     *****************************************************************************/\n    cloneCell(cell, allowInvalidEdges = false, mapping = {}, keepPosition = false) {\n        return this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];\n    },\n    cloneCells(cells, allowInvalidEdges = true, mapping = {}, keepPosition = false) {\n        let clones;\n        // Creates a dictionary for fast lookups\n        const dict = new Dictionary();\n        const tmp = [];\n        for (const cell of cells) {\n            dict.put(cell, true);\n            tmp.push(cell);\n        }\n        if (tmp.length > 0) {\n            const { scale } = this.getView();\n            const trans = this.getView().translate;\n            const out = [];\n            clones = cloneCells(cells, true, mapping);\n            for (let i = 0; i < cells.length; i += 1) {\n                const cell = cells[i];\n                const clone = clones[i];\n                if (!allowInvalidEdges &&\n                    clone.isEdge() &&\n                    this.getEdgeValidationError(clone, clone.getTerminal(true), clone.getTerminal(false)) !== null) {\n                    //clones[i] = null;\n                }\n                else {\n                    out.push(clone);\n                    const g = clone.getGeometry();\n                    if (g) {\n                        const state = this.getView().getState(cell);\n                        const parent = cell.getParent();\n                        const pstate = parent ? this.getView().getState(parent) : null;\n                        if (state && pstate) {\n                            const dx = keepPosition ? 0 : pstate.origin.x;\n                            const dy = keepPosition ? 0 : pstate.origin.y;\n                            if (clone.isEdge()) {\n                                const pts = state.absolutePoints;\n                                // Checks if the source is cloned or sets the terminal point\n                                let src = cell.getTerminal(true);\n                                while (src && !dict.get(src)) {\n                                    src = src.getParent();\n                                }\n                                if (!src && pts[0]) {\n                                    g.setTerminalPoint(new Point(pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);\n                                }\n                                // Checks if the target is cloned or sets the terminal point\n                                let trg = cell.getTerminal(false);\n                                while (trg && !dict.get(trg)) {\n                                    trg = trg.getParent();\n                                }\n                                const n = pts.length - 1;\n                                const p = pts[n];\n                                if (!trg && p) {\n                                    g.setTerminalPoint(new Point(p.x / scale - trans.x, p.y / scale - trans.y), false);\n                                }\n                                // Translates the control points\n                                const { points } = g;\n                                if (points) {\n                                    for (const point of points) {\n                                        point.x += dx;\n                                        point.y += dy;\n                                    }\n                                }\n                            }\n                            else {\n                                g.translate(dx, dy);\n                            }\n                        }\n                    }\n                }\n            }\n            clones = out;\n        }\n        else {\n            clones = [];\n        }\n        return clones;\n    },\n    addCell(cell, parent = null, index = null, source = null, target = null) {\n        return this.addCells([cell], parent, index, source, target)[0];\n    },\n    addCells(cells, parent = null, index = null, source = null, target = null, absolute = false) {\n        const p = parent ?? this.getDefaultParent();\n        const i = index ?? p.getChildCount();\n        this.batchUpdate(() => {\n            this.cellsAdded(cells, p, i, source, target, absolute, true);\n            this.fireEvent(new EventObject(InternalEvent.ADD_CELLS, { cells, p, i, source, target }));\n        });\n        return cells;\n    },\n    cellsAdded(cells, parent, index, source = null, target = null, absolute = false, constrain = false, extend = true) {\n        this.batchUpdate(() => {\n            const parentState = absolute ? this.getView().getState(parent) : null;\n            const o1 = parentState ? parentState.origin : null;\n            const zero = new Point(0, 0);\n            cells.forEach((cell, i) => {\n                /* Can cells include null values?\n                if (cell == null) {\n                  index--;\n                } else {\n                */\n                const previous = cell.getParent();\n                // Keeps the cell at its absolute location\n                if (o1 && cell !== parent && parent !== previous) {\n                    const oldState = previous ? this.getView().getState(previous) : null;\n                    const o2 = oldState ? oldState.origin : zero;\n                    let geo = cell.getGeometry();\n                    if (geo) {\n                        const dx = o2.x - o1.x;\n                        const dy = o2.y - o1.y;\n                        // FIXME: Cells should always be inserted first before any other edit\n                        // to avoid forward references in sessions.\n                        geo = geo.clone();\n                        geo.translate(dx, dy);\n                        if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                            geo.x = Math.max(0, geo.x);\n                            geo.y = Math.max(0, geo.y);\n                        }\n                        this.getDataModel().setGeometry(cell, geo);\n                    }\n                }\n                // Decrements all following indices\n                // if cell is already in parent\n                if (parent === previous && index + i > parent.getChildCount()) {\n                    index--;\n                }\n                this.getDataModel().add(parent, cell, index + i);\n                if (this.autoSizeCellsOnAdd) {\n                    this.autoSizeCell(cell, true);\n                }\n                // Extends the parent or constrains the child\n                if ((!extend || extend) &&\n                    this.isExtendParentsOnAdd(cell) &&\n                    this.isExtendParent(cell)) {\n                    this.extendParent(cell);\n                }\n                // Additionally constrains the child after extending the parent\n                if (!constrain || constrain) {\n                    this.constrainChild(cell);\n                }\n                // Sets the source terminal\n                if (source) {\n                    this.cellConnected(cell, source, true);\n                }\n                // Sets the target terminal\n                if (target) {\n                    this.cellConnected(cell, target, false);\n                }\n                /*}*/\n            });\n            this.fireEvent(new EventObject(InternalEvent.CELLS_ADDED, {\n                cells,\n                parent,\n                index,\n                source,\n                target,\n                absolute,\n            }));\n        });\n    },\n    autoSizeCell(cell, recurse = true) {\n        if (recurse) {\n            for (const child of cell.getChildren()) {\n                this.autoSizeCell(child);\n            }\n        }\n        if (cell.isVertex() && this.isAutoSizeCell(cell)) {\n            this.updateCellSize(cell);\n        }\n    },\n    removeCells(cells = null, includeEdges = true) {\n        if (!cells) {\n            cells = this.getDeletableCells(this.getSelectionCells());\n        }\n        // Adds all edges to the cells\n        if (includeEdges) {\n            // FIXME: Remove duplicate cells in result or do not add if\n            // in cells or descendant of cells\n            cells = this.getDeletableCells(this.addAllEdges(cells));\n        }\n        else {\n            cells = cells.slice();\n            // Removes edges that are currently not\n            // visible as those cannot be updated\n            const edges = this.getDeletableCells(this.getAllEdges(cells));\n            const dict = new Dictionary();\n            for (const cell of cells) {\n                dict.put(cell, true);\n            }\n            for (const edge of edges) {\n                if (!this.getView().getState(edge) && !dict.get(edge)) {\n                    dict.put(edge, true);\n                    cells.push(edge);\n                }\n            }\n        }\n        this.batchUpdate(() => {\n            this.cellsRemoved(cells);\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS, { cells, includeEdges }));\n        });\n        return cells ?? [];\n    },\n    cellsRemoved(cells) {\n        if (cells.length > 0) {\n            const { scale } = this.getView();\n            const tr = this.getView().translate;\n            this.batchUpdate(() => {\n                // Creates hashtable for faster lookup\n                const dict = new Dictionary();\n                for (const cell of cells) {\n                    dict.put(cell, true);\n                }\n                for (const cell of cells) {\n                    // Disconnects edges which are not being removed\n                    const edges = this.getAllEdges([cell]);\n                    const disconnectTerminal = (edge, source) => {\n                        let geo = edge.getGeometry();\n                        if (geo) {\n                            // Checks if terminal is being removed\n                            const terminal = edge.getTerminal(source);\n                            let connected = false;\n                            let tmp = terminal;\n                            while (tmp) {\n                                if (cell === tmp) {\n                                    connected = true;\n                                    break;\n                                }\n                                tmp = tmp.getParent();\n                            }\n                            if (connected) {\n                                geo = geo.clone();\n                                const state = this.getView().getState(edge);\n                                if (state) {\n                                    const pts = state.absolutePoints;\n                                    const n = source ? 0 : pts.length - 1;\n                                    const p = pts[n];\n                                    geo.setTerminalPoint(new Point(p.x / scale - tr.x - state.origin.x, p.y / scale - tr.y - state.origin.y), source);\n                                }\n                                else if (terminal) {\n                                    // Fallback to center of terminal if routing\n                                    // points are not available to add new point\n                                    // KNOWN: Should recurse to find parent offset\n                                    // of edge for nested groups but invisible edges\n                                    // should be removed in removeCells step\n                                    const tstate = this.getView().getState(terminal);\n                                    if (tstate) {\n                                        geo.setTerminalPoint(new Point(tstate.getCenterX() / scale - tr.x, tstate.getCenterY() / scale - tr.y), source);\n                                    }\n                                }\n                                this.getDataModel().setGeometry(edge, geo);\n                                this.getDataModel().setTerminal(edge, null, source);\n                            }\n                        }\n                    };\n                    for (const edge of edges) {\n                        if (!dict.get(edge)) {\n                            dict.put(edge, true);\n                            disconnectTerminal(edge, true);\n                            disconnectTerminal(edge, false);\n                        }\n                    }\n                    this.getDataModel().remove(cell);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_REMOVED, { cells }));\n            });\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell visibility\n     *****************************************************************************/\n    toggleCells(show = false, cells, includeEdges = true) {\n        cells = cells ?? this.getSelectionCells();\n        // Adds all connected edges recursively\n        if (includeEdges) {\n            cells = this.addAllEdges(cells);\n        }\n        this.batchUpdate(() => {\n            this.cellsToggled(cells, show);\n            this.fireEvent(new EventObject(InternalEvent.TOGGLE_CELLS, { show, cells, includeEdges }));\n        });\n        return cells;\n    },\n    cellsToggled(cells, show = false) {\n        if (cells.length > 0) {\n            this.batchUpdate(() => {\n                for (const cell of cells) {\n                    this.getDataModel().setVisible(cell, show);\n                }\n            });\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell sizing\n     *****************************************************************************/\n    updateCellSize(cell, ignoreChildren = false) {\n        this.batchUpdate(() => {\n            this.cellSizeUpdated(cell, ignoreChildren);\n            this.fireEvent(new EventObject(InternalEvent.UPDATE_CELL_SIZE, { cell, ignoreChildren }));\n        });\n        return cell;\n    },\n    cellSizeUpdated(cell, ignoreChildren = false) {\n        this.batchUpdate(() => {\n            const size = this.getPreferredSizeForCell(cell);\n            let geo = cell.getGeometry();\n            if (size && geo) {\n                const collapsed = cell.isCollapsed();\n                geo = geo.clone();\n                if (this.isSwimlane(cell)) {\n                    const style = this.getCellStyle(cell);\n                    const cellStyle = cell.getStyle();\n                    if (style.horizontal ?? true) {\n                        cellStyle.startSize = size.height + 8;\n                        if (collapsed) {\n                            geo.height = size.height + 8;\n                        }\n                        geo.width = size.width;\n                    }\n                    else {\n                        cellStyle.startSize = size.width + 8;\n                        if (collapsed) {\n                            geo.width = size.width + 8;\n                        }\n                        geo.height = size.height;\n                    }\n                    this.getDataModel().setStyle(cell, cellStyle);\n                }\n                else {\n                    const state = this.getView().createState(cell);\n                    const align = state.style.align ?? ALIGN.CENTER;\n                    if (align === ALIGN.RIGHT) {\n                        geo.x += geo.width - size.width;\n                    }\n                    else if (align === ALIGN.CENTER) {\n                        geo.x += Math.round((geo.width - size.width) / 2);\n                    }\n                    const valign = state.getVerticalAlign();\n                    if (valign === ALIGN.BOTTOM) {\n                        geo.y += geo.height - size.height;\n                    }\n                    else if (valign === ALIGN.MIDDLE) {\n                        geo.y += Math.round((geo.height - size.height) / 2);\n                    }\n                    geo.width = size.width;\n                    geo.height = size.height;\n                }\n                if (!ignoreChildren && !collapsed) {\n                    const bounds = this.getView().getBounds(cell.getChildren());\n                    if (bounds != null) {\n                        const tr = this.getView().translate;\n                        const { scale } = this.getView();\n                        const width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n                        const height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n                        geo.width = Math.max(geo.width, width);\n                        geo.height = Math.max(geo.height, height);\n                    }\n                }\n                this.cellsResized([cell], [geo], false);\n            }\n        });\n    },\n    getPreferredSizeForCell(cell, textWidth = null) {\n        let result = null;\n        const state = this.getView().createState(cell);\n        const { style } = state;\n        if (!cell.isEdge()) {\n            const fontSize = style.fontSize || DEFAULT_FONTSIZE;\n            let dx = 0;\n            let dy = 0;\n            // Adds dimension of image if shape is a label\n            if (state.getImageSrc() || style.image) {\n                if (style.shape === SHAPE.LABEL) {\n                    if (style.verticalAlign === ALIGN.MIDDLE) {\n                        dx += style.imageWidth || DEFAULT_IMAGESIZE;\n                    }\n                    if (style.align !== ALIGN.CENTER) {\n                        dy += style.imageHeight || DEFAULT_IMAGESIZE;\n                    }\n                }\n            }\n            // Adds spacings\n            dx += 2 * (style.spacing || 0);\n            dx += style.spacingLeft || 0;\n            dx += style.spacingRight || 0;\n            dy += 2 * (style.spacing || 0);\n            dy += style.spacingTop || 0;\n            dy += style.spacingBottom || 0;\n            // Add spacing for collapse/expand icon\n            // LATER: Check alignment and use constants\n            // for image spacing\n            const image = this.getFoldingImage(state);\n            if (image) {\n                dx += image.width + 8;\n            }\n            // Adds space for label\n            let value = this.getCellRenderer().getLabelValue(state);\n            if (value && value.length > 0) {\n                if (!this.isHtmlLabel(state.cell)) {\n                    value = htmlEntities(value, false);\n                }\n                value = value.replace(/\\n/g, '<br>');\n                const size = getSizeForString(value, fontSize, style.fontFamily, textWidth, style.fontStyle);\n                let width = size.width + dx;\n                let height = size.height + dy;\n                if (!(style.horizontal ?? true)) {\n                    const tmp = height;\n                    height = width;\n                    width = tmp;\n                }\n                if (this.isGridEnabled()) {\n                    width = this.snap(width + this.getGridSize() / 2);\n                    height = this.snap(height + this.getGridSize() / 2);\n                }\n                result = new Rectangle(0, 0, width, height);\n            }\n            else {\n                const gs2 = 4 * this.getGridSize();\n                result = new Rectangle(0, 0, gs2, gs2);\n            }\n        }\n        return result;\n    },\n    resizeCell(cell, bounds, recurse = false) {\n        return this.resizeCells([cell], [bounds], recurse)[0];\n    },\n    resizeCells(cells, bounds, recurse) {\n        recurse = recurse ?? this.isRecursiveResize();\n        this.batchUpdate(() => {\n            const prev = this.cellsResized(cells, bounds, recurse);\n            this.fireEvent(new EventObject(InternalEvent.RESIZE_CELLS, { cells, bounds, prev }));\n        });\n        return cells;\n    },\n    cellsResized(cells, bounds, recurse = false) {\n        const prev = [];\n        if (cells.length === bounds.length) {\n            this.batchUpdate(() => {\n                cells.forEach((cell, i) => {\n                    prev.push(this.cellResized(cell, bounds[i], false, recurse));\n                    if (this.isExtendParent(cell)) {\n                        this.extendParent(cell);\n                    }\n                    this.constrainChild(cell);\n                });\n                if (this.isResetEdgesOnResize()) {\n                    this.resetEdges(cells);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_RESIZED, { cells, bounds, prev }));\n            });\n        }\n        return prev;\n    },\n    cellResized(cell, bounds, ignoreRelative = false, recurse = false) {\n        const prev = cell.getGeometry();\n        if (prev &&\n            (prev.x !== bounds.x ||\n                prev.y !== bounds.y ||\n                prev.width !== bounds.width ||\n                prev.height !== bounds.height)) {\n            const geo = prev.clone();\n            if (!ignoreRelative && geo.relative) {\n                const { offset } = geo;\n                if (offset) {\n                    offset.x += bounds.x - geo.x;\n                    offset.y += bounds.y - geo.y;\n                }\n            }\n            else {\n                geo.x = bounds.x;\n                geo.y = bounds.y;\n            }\n            geo.width = bounds.width;\n            geo.height = bounds.height;\n            if (!geo.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                geo.x = Math.max(0, geo.x);\n                geo.y = Math.max(0, geo.y);\n            }\n            this.batchUpdate(() => {\n                if (recurse) {\n                    this.resizeChildCells(cell, geo);\n                }\n                this.getDataModel().setGeometry(cell, geo);\n                this.constrainChildCells(cell);\n            });\n        }\n        return prev;\n    },\n    resizeChildCells(cell, newGeo) {\n        const geo = cell.getGeometry();\n        if (geo) {\n            const dx = geo.width !== 0 ? newGeo.width / geo.width : 1;\n            const dy = geo.height !== 0 ? newGeo.height / geo.height : 1;\n            for (const child of cell.getChildren()) {\n                this.scaleCell(child, dx, dy, true);\n            }\n        }\n    },\n    constrainChildCells(cell) {\n        for (const child of cell.getChildren()) {\n            this.constrainChild(child);\n        }\n    },\n    scaleCell(cell, dx, dy, recurse = false) {\n        let geo = cell.getGeometry();\n        if (geo) {\n            const style = this.getCurrentCellStyle(cell);\n            geo = geo.clone();\n            // Stores values for restoring based on style\n            const { x } = geo;\n            const { y } = geo;\n            const w = geo.width;\n            const h = geo.height;\n            geo.scale(dx, dy, style.aspect === 'fixed');\n            if (style.resizeWidth) {\n                geo.width = w * dx;\n            }\n            else if (!style.resizeWidth) {\n                geo.width = w;\n            }\n            if (style.resizeHeight) {\n                geo.height = h * dy;\n            }\n            else if (!style.resizeHeight) {\n                geo.height = h;\n            }\n            if (!this.isCellMovable(cell)) {\n                geo.x = x;\n                geo.y = y;\n            }\n            if (!this.isCellResizable(cell)) {\n                geo.width = w;\n                geo.height = h;\n            }\n            if (cell.isVertex()) {\n                this.cellResized(cell, geo, true, recurse);\n            }\n            else {\n                this.getDataModel().setGeometry(cell, geo);\n            }\n        }\n    },\n    extendParent(cell) {\n        const parent = cell.getParent();\n        let p = parent ? parent.getGeometry() : null;\n        if (parent && p && !parent.isCollapsed()) {\n            const geo = cell.getGeometry();\n            if (geo &&\n                !geo.relative &&\n                (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {\n                p = p.clone();\n                p.width = Math.max(p.width, geo.x + geo.width);\n                p.height = Math.max(p.height, geo.y + geo.height);\n                this.cellsResized([parent], [p], false);\n            }\n        }\n    },\n    // *************************************************************************************\n    // Group: Cell moving\n    // *************************************************************************************\n    importCells(cells, dx, dy, target = null, evt = null, mapping = {}) {\n        return this.moveCells(cells, dx, dy, true, target, evt, mapping);\n    },\n    moveCells(cells, dx = 0, dy = 0, clone = false, target = null, evt = null, mapping = {}) {\n        if (dx !== 0 || dy !== 0 || clone || target) {\n            // Removes descendants with ancestors in cells to avoid multiple moving\n            cells = getTopmostCells(cells);\n            const origCells = cells;\n            this.batchUpdate(() => {\n                // Faster cell lookups to remove relative edge labels with selected\n                // terminals to avoid explicit and implicit move at same time\n                const dict = new Dictionary();\n                for (const cell of cells) {\n                    dict.put(cell, true);\n                }\n                const isSelected = (cell) => {\n                    while (cell) {\n                        if (dict.get(cell)) {\n                            return true;\n                        }\n                        cell = cell.getParent();\n                    }\n                    return false;\n                };\n                // Removes relative edge labels with selected terminals\n                const checked = [];\n                for (const cell of cells) {\n                    const geo = cell.getGeometry();\n                    const parent = cell.getParent();\n                    if (!geo ||\n                        !geo.relative ||\n                        (parent && !parent.isEdge()) ||\n                        (parent &&\n                            !isSelected(parent.getTerminal(true)) &&\n                            !isSelected(parent.getTerminal(false)))) {\n                        checked.push(cell);\n                    }\n                }\n                cells = checked;\n                if (clone) {\n                    cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n                    if (!target) {\n                        target = this.getDefaultParent();\n                    }\n                }\n                // FIXME: Cells should always be inserted first before any other edit\n                // to avoid forward references in sessions.\n                // Need to disable allowNegativeCoordinates if target not null to\n                // allow for temporary negative numbers until cellsAdded is called.\n                const previous = this.isAllowNegativeCoordinates();\n                if (target) {\n                    this.setAllowNegativeCoordinates(true);\n                }\n                this.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), !target, this.isExtendParentsOnMove() && !target);\n                this.setAllowNegativeCoordinates(previous);\n                if (target) {\n                    const index = target.getChildCount();\n                    this.cellsAdded(cells, target, index, null, null, true);\n                    // Restores parent edge on cloned edge labels\n                    if (clone) {\n                        cells.forEach((cell, i) => {\n                            const geo = cell.getGeometry();\n                            const parent = origCells[i].getParent();\n                            if (geo &&\n                                geo.relative &&\n                                parent &&\n                                parent.isEdge() &&\n                                this.getDataModel().contains(parent)) {\n                                this.getDataModel().add(parent, cell);\n                            }\n                        });\n                    }\n                }\n                // Dispatches a move event\n                this.fireEvent(new EventObject(InternalEvent.MOVE_CELLS, {\n                    cells,\n                    dx,\n                    dy,\n                    clone,\n                    target,\n                    event: evt,\n                }));\n            });\n        }\n        return cells;\n    },\n    cellsMoved(cells, dx, dy, disconnect = false, constrain = false, extend = false) {\n        if (dx !== 0 || dy !== 0) {\n            this.batchUpdate(() => {\n                if (disconnect) {\n                    this.disconnectGraph(cells);\n                }\n                for (const cell of cells) {\n                    this.translateCell(cell, dx, dy);\n                    if (extend && this.isExtendParent(cell)) {\n                        this.extendParent(cell);\n                    }\n                    else if (constrain) {\n                        this.constrainChild(cell);\n                    }\n                }\n                if (this.isResetEdgesOnMove()) {\n                    this.resetEdges(cells);\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_MOVED, { cells, dx, dy, disconnect }));\n            });\n        }\n    },\n    translateCell(cell, dx, dy) {\n        let geometry = cell.getGeometry();\n        if (geometry) {\n            geometry = geometry.clone();\n            geometry.translate(dx, dy);\n            if (!geometry.relative && cell.isVertex() && !this.isAllowNegativeCoordinates()) {\n                geometry.x = Math.max(0, geometry.x);\n                geometry.y = Math.max(0, geometry.y);\n            }\n            if (geometry.relative && !cell.isEdge()) {\n                const parent = cell.getParent();\n                let angle = 0;\n                if (parent.isVertex()) {\n                    const style = this.getCurrentCellStyle(parent);\n                    angle = style.rotation ?? 0;\n                }\n                if (angle !== 0) {\n                    const rad = toRadians(-angle);\n                    const cos = Math.cos(rad);\n                    const sin = Math.sin(rad);\n                    const pt = getRotatedPoint(new Point(dx, dy), cos, sin, new Point(0, 0));\n                    dx = pt.x;\n                    dy = pt.y;\n                }\n                if (!geometry.offset) {\n                    geometry.offset = new Point(dx, dy);\n                }\n                else {\n                    geometry.offset.x = geometry.offset.x + dx;\n                    geometry.offset.y = geometry.offset.y + dy;\n                }\n            }\n            this.getDataModel().setGeometry(cell, geometry);\n        }\n    },\n    getCellContainmentArea(cell) {\n        if (!cell.isEdge()) {\n            const parent = cell.getParent();\n            if (parent && parent !== this.getDefaultParent()) {\n                const g = parent.getGeometry();\n                if (g) {\n                    let x = 0;\n                    let y = 0;\n                    let w = g.width;\n                    let h = g.height;\n                    if (this.isSwimlane(parent)) {\n                        const size = this.getStartSize(parent);\n                        const style = this.getCurrentCellStyle(parent);\n                        const dir = style.direction ?? DIRECTION.EAST;\n                        const flipH = style.flipH ?? false;\n                        const flipV = style.flipV ?? false;\n                        if (dir === DIRECTION.SOUTH || dir === DIRECTION.NORTH) {\n                            const tmp = size.width;\n                            size.width = size.height;\n                            size.height = tmp;\n                        }\n                        if ((dir === DIRECTION.EAST && !flipV) ||\n                            (dir === DIRECTION.NORTH && !flipH) ||\n                            (dir === DIRECTION.WEST && flipV) ||\n                            (dir === DIRECTION.SOUTH && flipH)) {\n                            x = size.width;\n                            y = size.height;\n                        }\n                        w -= size.width;\n                        h -= size.height;\n                    }\n                    return new Rectangle(x, y, w, h);\n                }\n            }\n        }\n        return null;\n    },\n    constrainChild(cell, sizeFirst = true) {\n        let geo = cell.getGeometry();\n        if (geo && (this.isConstrainRelativeChildren() || !geo.relative)) {\n            const parent = cell.getParent();\n            let max = this.getMaximumGraphBounds();\n            // Finds parent offset\n            if (max && parent) {\n                const off = this.getBoundingBoxFromGeometry([parent], false);\n                if (off) {\n                    max = Rectangle.fromRectangle(max);\n                    max.x -= off.x;\n                    max.y -= off.y;\n                }\n            }\n            if (this.isConstrainChild(cell)) {\n                let tmp = this.getCellContainmentArea(cell);\n                if (tmp) {\n                    const overlap = this.getOverlap(cell);\n                    if (overlap > 0) {\n                        tmp = Rectangle.fromRectangle(tmp);\n                        tmp.x -= tmp.width * overlap;\n                        tmp.y -= tmp.height * overlap;\n                        tmp.width += 2 * tmp.width * overlap;\n                        tmp.height += 2 * tmp.height * overlap;\n                    }\n                    // Find the intersection between max and tmp\n                    if (!max) {\n                        max = tmp;\n                    }\n                    else {\n                        max = Rectangle.fromRectangle(max);\n                        max.intersect(tmp);\n                    }\n                }\n            }\n            if (max) {\n                const cells = [cell];\n                if (!cell.isCollapsed()) {\n                    const desc = cell.getDescendants();\n                    for (const descItem of desc) {\n                        if (descItem.isVisible()) {\n                            cells.push(descItem);\n                        }\n                    }\n                }\n                const bbox = this.getBoundingBoxFromGeometry(cells, false);\n                if (bbox) {\n                    geo = geo.clone();\n                    // Cumulative horizontal movement\n                    let dx = 0;\n                    if (geo.width > max.width) {\n                        dx = geo.width - max.width;\n                        geo.width -= dx;\n                    }\n                    if (bbox.x + bbox.width > max.x + max.width) {\n                        dx -= bbox.x + bbox.width - max.x - max.width - dx;\n                    }\n                    // Cumulative vertical movement\n                    let dy = 0;\n                    if (geo.height > max.height) {\n                        dy = geo.height - max.height;\n                        geo.height -= dy;\n                    }\n                    if (bbox.y + bbox.height > max.y + max.height) {\n                        dy -= bbox.y + bbox.height - max.y - max.height - dy;\n                    }\n                    if (bbox.x < max.x) {\n                        dx -= bbox.x - max.x;\n                    }\n                    if (bbox.y < max.y) {\n                        dy -= bbox.y - max.y;\n                    }\n                    if (dx !== 0 || dy !== 0) {\n                        if (geo.relative) {\n                            // Relative geometries are moved via absolute offset\n                            if (!geo.offset) {\n                                geo.offset = new Point();\n                            }\n                            geo.offset.x += dx;\n                            geo.offset.y += dy;\n                        }\n                        else {\n                            geo.x += dx;\n                            geo.y += dy;\n                        }\n                    }\n                    this.getDataModel().setGeometry(cell, geo);\n                }\n            }\n        }\n    },\n    /*****************************************************************************\n     * Group: Cell retrieval\n     *****************************************************************************/\n    getChildCells(parent, vertices = false, edges = false) {\n        parent = parent ?? this.getDefaultParent();\n        const cells = parent.getChildCells(vertices, edges);\n        const result = [];\n        // Filters out the non-visible child cells\n        for (const cell of cells) {\n            if (cell.isVisible()) {\n                result.push(cell);\n            }\n        }\n        return result;\n    },\n    getCellAt(x, y, parent = null, vertices = true, edges = true, ignoreFn = null) {\n        if (!parent) {\n            parent = this.getCurrentRoot();\n            if (!parent) {\n                parent = this.getDataModel().getRoot();\n            }\n        }\n        if (parent) {\n            const childCount = parent.getChildCount();\n            for (let i = childCount - 1; i >= 0; i--) {\n                const cell = parent.getChildAt(i);\n                const result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n                if (result) {\n                    return result;\n                }\n                if (cell.isVisible() &&\n                    ((edges && cell.isEdge()) || (vertices && cell.isVertex()))) {\n                    const state = this.getView().getState(cell);\n                    if (state &&\n                        (!ignoreFn || !ignoreFn(state, x, y)) &&\n                        this.intersects(state, x, y)) {\n                        return cell;\n                    }\n                }\n            }\n        }\n        return null;\n    },\n    getCells(x, y, width, height, parent = null, result = [], intersection = null, ignoreFn = null, includeDescendants = false) {\n        if (width > 0 || height > 0 || intersection) {\n            const model = this.getDataModel();\n            const right = x + width;\n            const bottom = y + height;\n            if (!parent) {\n                parent = this.getCurrentRoot();\n                if (!parent) {\n                    parent = model.getRoot();\n                }\n            }\n            if (parent) {\n                for (const cell of parent.getChildren()) {\n                    const state = this.getView().getState(cell);\n                    if (state && cell.isVisible() && (!ignoreFn || !ignoreFn(state))) {\n                        const deg = state.style.rotation ?? 0;\n                        let box = state; // TODO: CHECK ME!!!! ==========================================================\n                        if (deg !== 0) {\n                            box = getBoundingBox(box, deg);\n                        }\n                        const hit = (intersection && cell.isVertex() && intersects(intersection, box)) ||\n                            (!intersection &&\n                                (cell.isEdge() || cell.isVertex()) &&\n                                box.x >= x &&\n                                box.y + box.height <= bottom &&\n                                box.y >= y &&\n                                box.x + box.width <= right);\n                        if (hit) {\n                            result.push(cell);\n                        }\n                        if (!hit || includeDescendants) {\n                            this.getCells(x, y, width, height, cell, result, intersection, ignoreFn, includeDescendants);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    getCellsBeyond(x0, y0, parent = null, rightHalfpane = false, bottomHalfpane = false) {\n        const result = [];\n        if (rightHalfpane || bottomHalfpane) {\n            if (!parent) {\n                parent = this.getDefaultParent();\n            }\n            if (parent) {\n                for (const child of parent.getChildren()) {\n                    const state = this.getView().getState(child);\n                    if (child.isVisible() && state) {\n                        if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {\n                            result.push(child);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n    intersects(state, x, y) {\n        const pts = state.absolutePoints;\n        if (pts.length > 0) {\n            const t2 = this.getEventTolerance() * this.getEventTolerance();\n            let pt = pts[0];\n            for (let i = 1; i < pts.length; i += 1) {\n                const next = pts[i];\n                if (pt && next) {\n                    const dist = ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n                    if (dist <= t2) {\n                        return true;\n                    }\n                }\n                pt = next;\n            }\n        }\n        else {\n            const alpha = toRadians(state.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(-alpha);\n                const sin = Math.sin(-alpha);\n                const cx = new Point(state.getCenterX(), state.getCenterY());\n                const pt = getRotatedPoint(new Point(x, y), cos, sin, cx);\n                x = pt.x;\n                y = pt.y;\n            }\n            if (contains(state, x, y)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    isValidAncestor(cell, parent, recurse = false) {\n        return recurse ? parent.isAncestor(cell) : cell.getParent() === parent;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isCellLocked(cell) {\n        const geometry = cell.getGeometry();\n        return this.isCellsLocked() || (!!geometry && cell.isVertex() && geometry.relative);\n    },\n    isCellsLocked() {\n        return this.cellsLocked;\n    },\n    setCellsLocked(value) {\n        this.cellsLocked = value;\n    },\n    getCloneableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellCloneable(cell);\n        });\n    },\n    isCellCloneable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        const cloneable = style.cloneable == null ? true : style.cloneable;\n        return this.isCellsCloneable() && cloneable;\n    },\n    isCellsCloneable() {\n        return this.cellsCloneable;\n    },\n    setCellsCloneable(value) {\n        this.cellsCloneable = value;\n    },\n    getExportableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.canExportCell(cell);\n        });\n    },\n    canExportCell(_cell = null) {\n        return this.isExportEnabled();\n    },\n    getImportableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.canImportCell(cell);\n        });\n    },\n    canImportCell(cell = null) {\n        return this.isImportEnabled();\n    },\n    isCellSelectable(_cell) {\n        return this.isCellsSelectable();\n    },\n    isCellsSelectable() {\n        return this.cellsSelectable;\n    },\n    setCellsSelectable(value) {\n        this.cellsSelectable = value;\n    },\n    getDeletableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellDeletable(cell);\n        });\n    },\n    isCellDeletable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        const deletable = style.deletable == null ? true : style.deletable;\n        return this.isCellsDeletable() && deletable;\n    },\n    isCellsDeletable() {\n        return this.cellsDeletable;\n    },\n    setCellsDeletable(value) {\n        this.cellsDeletable = value;\n    },\n    isCellRotatable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return style.rotatable == null ? true : style.rotatable;\n    },\n    getMovableCells(cells) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellMovable(cell);\n        });\n    },\n    isCellMovable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return this.isCellsMovable() && !this.isCellLocked(cell) && (style.movable ?? true);\n    },\n    isCellsMovable() {\n        return this.cellsMovable;\n    },\n    setCellsMovable(value) {\n        this.cellsMovable = value;\n    },\n    isCellResizable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return (this.isCellsResizable() && !this.isCellLocked(cell) && (style.resizable ?? true));\n    },\n    isCellsResizable() {\n        return this.cellsResizable;\n    },\n    setCellsResizable(value) {\n        this.cellsResizable = value;\n    },\n    isCellBendable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return this.isCellsBendable() && !this.isCellLocked(cell) && style.bendable != false;\n    },\n    isCellsBendable() {\n        return this.cellsBendable;\n    },\n    setCellsBendable(value) {\n        this.cellsBendable = value;\n    },\n    isAutoSizeCell(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return this.isAutoSizeCells() || (style.autoSize ?? false);\n    },\n    isAutoSizeCells() {\n        return this.autoSizeCells;\n    },\n    setAutoSizeCells(value) {\n        this.autoSizeCells = value;\n    },\n    isExtendParent(cell) {\n        return !cell.isEdge() && this.isExtendParents();\n    },\n    isExtendParents() {\n        return this.extendParents;\n    },\n    setExtendParents(value) {\n        this.extendParents = value;\n    },\n    isExtendParentsOnAdd(cell) {\n        return this.extendParentsOnAdd;\n    },\n    setExtendParentsOnAdd(value) {\n        this.extendParentsOnAdd = value;\n    },\n    isExtendParentsOnMove() {\n        return this.extendParentsOnMove;\n    },\n    setExtendParentsOnMove(value) {\n        this.extendParentsOnMove = value;\n    },\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    getCursorForCell(_cell) {\n        return null;\n    },\n    /*****************************************************************************\n     * Group: Graph display\n     *****************************************************************************/\n    getCellBounds(cell, includeEdges = false, includeDescendants = false) {\n        let cells = [cell];\n        // Includes all connected edges\n        if (includeEdges) {\n            cells = cells.concat(cell.getEdges());\n        }\n        let result = this.getView().getBounds(cells);\n        // Recursively includes the bounds of the children\n        if (includeDescendants) {\n            for (const child of cell.getChildren()) {\n                const tmp = this.getCellBounds(child, includeEdges, true);\n                if (result && tmp) {\n                    result.add(tmp);\n                }\n                else {\n                    result = tmp;\n                }\n            }\n        }\n        return result;\n    },\n    getBoundingBoxFromGeometry(cells, includeEdges = false) {\n        let result = null;\n        let tmp = null;\n        for (const cell of cells) {\n            if (includeEdges || cell.isVertex()) {\n                // Computes the bounding box for the points in the geometry\n                const geo = cell.getGeometry();\n                if (geo) {\n                    let bbox = null;\n                    if (cell.isEdge()) {\n                        const addPoint = (pt) => {\n                            if (pt) {\n                                if (!tmp) {\n                                    tmp = new Rectangle(pt.x, pt.y, 0, 0);\n                                }\n                                else {\n                                    tmp.add(new Rectangle(pt.x, pt.y, 0, 0));\n                                }\n                            }\n                        };\n                        if (!cell.getTerminal(true)) {\n                            addPoint(geo.getTerminalPoint(true));\n                        }\n                        if (!cell.getTerminal(false)) {\n                            addPoint(geo.getTerminalPoint(false));\n                        }\n                        const pts = geo.points;\n                        if (pts && pts.length > 0) {\n                            tmp = new Rectangle(pts[0].x, pts[0].y, 0, 0);\n                            for (let j = 1; j < pts.length; j++) {\n                                addPoint(pts[j]);\n                            }\n                        }\n                        bbox = tmp;\n                    }\n                    else {\n                        const parent = cell.getParent();\n                        if (geo.relative && parent) {\n                            if (parent.isVertex() && parent !== this.getView().currentRoot) {\n                                tmp = this.getBoundingBoxFromGeometry([parent], false);\n                                if (tmp) {\n                                    bbox = new Rectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n                                    if (cells.indexOf(parent) >= 0) {\n                                        bbox.x += tmp.x;\n                                        bbox.y += tmp.y;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            bbox = Rectangle.fromRectangle(geo);\n                            if (parent && parent.isVertex() && cells.indexOf(parent) >= 0) {\n                                tmp = this.getBoundingBoxFromGeometry([parent], false);\n                                if (tmp) {\n                                    bbox.x += tmp.x;\n                                    bbox.y += tmp.y;\n                                }\n                            }\n                        }\n                        if (bbox && geo.offset) {\n                            bbox.x += geo.offset.x;\n                            bbox.y += geo.offset.y;\n                        }\n                        const style = this.getCurrentCellStyle(cell);\n                        if (bbox) {\n                            const angle = style.rotation ?? 0;\n                            if (angle !== 0) {\n                                bbox = getBoundingBox(bbox, angle);\n                            }\n                        }\n                    }\n                    if (bbox) {\n                        if (!result) {\n                            result = Rectangle.fromRectangle(bbox);\n                        }\n                        else {\n                            result.add(bbox);\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport ConnectionConstraint from '../other/ConnectionConstraint';\nimport { DIRECTION } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Dictionary from '../../util/Dictionary';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ConnectionsMixin = {\n    /*****************************************************************************\n     * Group: Cell connecting and connection constraints\n     *****************************************************************************/\n    constrainChildren: true,\n    constrainRelativeChildren: false,\n    disconnectOnMove: true,\n    cellsDisconnectable: true,\n    getOutlineConstraint(point, terminalState, me) {\n        if (terminalState.shape) {\n            const bounds = this.getView().getPerimeterBounds(terminalState);\n            const direction = terminalState.style.direction;\n            if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                bounds.x += bounds.width / 2 - bounds.height / 2;\n                bounds.y += bounds.height / 2 - bounds.width / 2;\n                const tmp = bounds.width;\n                bounds.width = bounds.height;\n                bounds.height = tmp;\n            }\n            const alpha = toRadians(terminalState.shape.getShapeRotation());\n            if (alpha !== 0) {\n                const cos = Math.cos(-alpha);\n                const sin = Math.sin(-alpha);\n                const ct = new Point(bounds.getCenterX(), bounds.getCenterY());\n                point = getRotatedPoint(point, cos, sin, ct);\n            }\n            let sx = 1;\n            let sy = 1;\n            let dx = 0;\n            let dy = 0;\n            // LATER: Add flipping support for image shapes\n            if (terminalState.cell.isVertex()) {\n                let flipH = terminalState.style.flipH;\n                let flipV = terminalState.style.flipV;\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    const tmp = flipH;\n                    flipH = flipV;\n                    flipV = tmp;\n                }\n                if (flipH) {\n                    sx = -1;\n                    dx = -bounds.width;\n                }\n                if (flipV) {\n                    sy = -1;\n                    dy = -bounds.height;\n                }\n            }\n            point = new Point((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n            const x = bounds.width === 0\n                ? 0\n                : Math.round(((point.x - bounds.x) * 1000) / bounds.width) / 1000;\n            const y = bounds.height === 0\n                ? 0\n                : Math.round(((point.y - bounds.y) * 1000) / bounds.height) / 1000;\n            return new ConnectionConstraint(new Point(x, y), false);\n        }\n        return null;\n    },\n    getAllConnectionConstraints(terminal, source) {\n        return terminal?.shape?.stencil?.constraints ?? null;\n    },\n    getConnectionConstraint(edge, terminal, source = false) {\n        let point = null;\n        const x = edge.style[source ? 'exitX' : 'entryX'];\n        if (x !== undefined) {\n            const y = edge.style[source ? 'exitY' : 'entryY'];\n            if (y !== undefined) {\n                point = new Point(x, y);\n            }\n        }\n        let perimeter = false;\n        let dx = 0;\n        let dy = 0;\n        if (point) {\n            perimeter = edge.style[source ? 'exitPerimeter' : 'entryPerimeter'] || false;\n            // Add entry/exit offset\n            dx = edge.style[source ? 'exitDx' : 'entryDx'];\n            dy = edge.style[source ? 'exitDy' : 'entryDy'];\n            dx = Number.isFinite(dx) ? dx : 0;\n            dy = Number.isFinite(dy) ? dy : 0;\n        }\n        return new ConnectionConstraint(point, perimeter, null, dx, dy);\n    },\n    setConnectionConstraint(edge, terminal, source = false, constraint = null) {\n        if (constraint) {\n            this.batchUpdate(() => {\n                if (!constraint || !constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', null, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', null, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', null, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', null, [edge]);\n                    this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                }\n                else if (constraint.point) {\n                    this.setCellStyles(source ? 'exitX' : 'entryX', constraint.point.x, [edge]);\n                    this.setCellStyles(source ? 'exitY' : 'entryY', constraint.point.y, [edge]);\n                    this.setCellStyles(source ? 'exitDx' : 'entryDx', constraint.dx, [edge]);\n                    this.setCellStyles(source ? 'exitDy' : 'entryDy', constraint.dy, [edge]);\n                    // Only writes 0 since 1 is default\n                    if (!constraint.perimeter) {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', '0', [edge]);\n                    }\n                    else {\n                        this.setCellStyles(source ? 'exitPerimeter' : 'entryPerimeter', null, [edge]);\n                    }\n                }\n            });\n        }\n    },\n    getConnectionPoint(vertex, constraint, round = true) {\n        let point = null;\n        if (constraint.point) {\n            const bounds = this.getView().getPerimeterBounds(vertex);\n            const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n            const direction = vertex.style.direction;\n            let r1 = 0;\n            // Bounds need to be rotated by 90 degrees for further computation\n            if (vertex.style.anchorPointDirection) {\n                if (direction === DIRECTION.NORTH) {\n                    r1 += 270;\n                }\n                else if (direction === DIRECTION.WEST) {\n                    r1 += 180;\n                }\n                else if (direction === DIRECTION.SOUTH) {\n                    r1 += 90;\n                }\n                // Bounds need to be rotated by 90 degrees for further computation\n                if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                    bounds.rotate90();\n                }\n            }\n            const { scale } = this.getView();\n            point = new Point(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale, bounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n            // Rotation for direction before projection on perimeter\n            let r2 = vertex.style.rotation || 0;\n            if (constraint.perimeter) {\n                if (r1 !== 0) {\n                    // Only 90 degrees steps possible here so no trig needed\n                    let cos = 0;\n                    let sin = 0;\n                    if (r1 === 90) {\n                        sin = 1;\n                    }\n                    else if (r1 === 180) {\n                        cos = -1;\n                    }\n                    else if (r1 === 270) {\n                        sin = -1;\n                    }\n                    point = getRotatedPoint(point, cos, sin, cx);\n                }\n                point = this.getView().getPerimeterPoint(vertex, point, false);\n            }\n            else {\n                r2 += r1;\n                if (vertex.cell.isVertex()) {\n                    let flipH = vertex.style.flipH;\n                    let flipV = vertex.style.flipV;\n                    if (direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH) {\n                        const temp = flipH;\n                        flipH = flipV;\n                        flipV = temp;\n                    }\n                    if (flipH) {\n                        point.x = 2 * bounds.getCenterX() - point.x;\n                    }\n                    if (flipV) {\n                        point.y = 2 * bounds.getCenterY() - point.y;\n                    }\n                }\n            }\n            // Generic rotation after projection on perimeter\n            if (r2 !== 0 && point) {\n                const rad = toRadians(r2);\n                const cos = Math.cos(rad);\n                const sin = Math.sin(rad);\n                point = getRotatedPoint(point, cos, sin, cx);\n            }\n        }\n        if (round && point) {\n            point.x = Math.round(point.x);\n            point.y = Math.round(point.y);\n        }\n        return point;\n    },\n    connectCell(edge, terminal = null, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            this.cellConnected(edge, terminal, source, constraint);\n            this.fireEvent(new EventObject(InternalEvent.CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n        return edge;\n    },\n    cellConnected(edge, terminal, source = false, constraint = null) {\n        this.batchUpdate(() => {\n            const previous = edge.getTerminal(source);\n            // Updates the constraint\n            this.setConnectionConstraint(edge, terminal, source, constraint);\n            // Checks if the new terminal is a port, uses the ID of the port in the\n            // style and the parent of the port as the actual terminal of the edge.\n            if (this.isPortsEnabled()) {\n                let id = null;\n                if (terminal && this.isPort(terminal)) {\n                    id = terminal.getId();\n                    terminal = this.getTerminalForPort(terminal, source);\n                }\n                // Sets or resets all previous information for connecting to a child port\n                const key = source ? 'sourcePort' : 'targetPort';\n                this.setCellStyles(key, id, [edge]);\n            }\n            this.getDataModel().setTerminal(edge, terminal, source);\n            if (this.isResetEdgesOnConnect()) {\n                this.resetEdge(edge);\n            }\n            this.fireEvent(new EventObject(InternalEvent.CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n        });\n    },\n    disconnectGraph(cells) {\n        this.batchUpdate(() => {\n            const { scale, translate: tr } = this.getView();\n            // Fast lookup for finding cells in array\n            const dict = new Dictionary();\n            for (let i = 0; i < cells.length; i += 1) {\n                dict.put(cells[i], true);\n            }\n            for (const cell of cells) {\n                if (cell.isEdge()) {\n                    let geo = cell.getGeometry();\n                    if (geo) {\n                        const state = this.getView().getState(cell);\n                        const parent = cell.getParent();\n                        const pstate = parent ? this.getView().getState(parent) : null;\n                        if (state && pstate) {\n                            geo = geo.clone();\n                            const dx = -pstate.origin.x;\n                            const dy = -pstate.origin.y;\n                            const pts = state.absolutePoints;\n                            let src = cell.getTerminal(true);\n                            if (src && this.isCellDisconnectable(cell, src, true)) {\n                                while (src && !dict.get(src)) {\n                                    src = src.getParent();\n                                }\n                                if (!src && pts[0]) {\n                                    geo.setTerminalPoint(new Point(pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);\n                                    this.getDataModel().setTerminal(cell, null, true);\n                                }\n                            }\n                            let trg = cell.getTerminal(false);\n                            if (trg && this.isCellDisconnectable(cell, trg, false)) {\n                                while (trg && !dict.get(trg)) {\n                                    trg = trg.getParent();\n                                }\n                                if (!trg) {\n                                    const n = pts.length - 1;\n                                    const p = pts[n];\n                                    if (p) {\n                                        geo.setTerminalPoint(new Point(p.x / scale - tr.x + dx, p.y / scale - tr.y + dy), false);\n                                        this.getDataModel().setTerminal(cell, null, false);\n                                    }\n                                }\n                            }\n                            this.getDataModel().setGeometry(cell, geo);\n                        }\n                    }\n                }\n            }\n        });\n    },\n    getConnections(cell, parent = null) {\n        return this.getEdges(cell, parent, true, true, false);\n    },\n    isConstrainChild(cell) {\n        return (this.isConstrainChildren() &&\n            !!cell.getParent() &&\n            !cell.getParent().isEdge());\n    },\n    isConstrainChildren() {\n        return this.constrainChildren;\n    },\n    setConstrainChildren(value) {\n        this.constrainChildren = value;\n    },\n    isConstrainRelativeChildren() {\n        return this.constrainRelativeChildren;\n    },\n    setConstrainRelativeChildren(value) {\n        this.constrainRelativeChildren = value;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isDisconnectOnMove() {\n        return this.disconnectOnMove;\n    },\n    setDisconnectOnMove(value) {\n        this.disconnectOnMove = value;\n    },\n    isCellDisconnectable(cell, terminal = null, source = false) {\n        return this.isCellsDisconnectable() && !this.isCellLocked(cell);\n    },\n    isCellsDisconnectable() {\n        return this.cellsDisconnectable;\n    },\n    setCellsDisconnectable(value) {\n        this.cellsDisconnectable = value;\n    },\n    isValidSource(cell) {\n        return ((cell == null && this.isAllowDanglingEdges()) ||\n            (cell != null &&\n                (!cell.isEdge() || this.isConnectableEdges()) &&\n                cell.isConnectable()));\n    },\n    isValidTarget(cell) {\n        return this.isValidSource(cell);\n    },\n    isValidConnection(source, target) {\n        return this.isValidSource(source) && this.isValidTarget(target);\n    },\n    setConnectable(connectable) {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        connectionHandler?.setEnabled(connectable);\n    },\n    isConnectable() {\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        return connectionHandler?.isEnabled() ?? false;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const DragDropMixin = {\n    dropEnabled: false,\n    splitEnabled: true,\n    autoScroll: true,\n    isAutoScroll() {\n        return this.autoScroll;\n    },\n    autoExtend: true,\n    isAutoExtend() {\n        return this.autoExtend;\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isDropEnabled() {\n        return this.dropEnabled;\n    },\n    setDropEnabled(value) {\n        this.dropEnabled = value;\n    },\n    /*****************************************************************************\n     * Group: Split behaviour\n     *****************************************************************************/\n    isSplitEnabled() {\n        return this.splitEnabled;\n    },\n    setSplitEnabled(value) {\n        this.splitEnabled = value;\n    },\n    isSplitTarget(target, cells = [], evt) {\n        if (target.isEdge() &&\n            cells.length === 1 &&\n            cells[0].isConnectable() &&\n            !this.getEdgeValidationError(target, target.getTerminal(true), cells[0])) {\n            const src = target.getTerminal(true);\n            const trg = target.getTerminal(false);\n            return !cells[0].isAncestor(src) && !cells[0].isAncestor(trg);\n        }\n        return false;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport { removeDuplicates } from '../../util/arrayUtils';\nimport { findNearestSegment } from '../../util/mathUtils';\nimport Cell from '../cell/Cell';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EdgeMixin = {\n    resetEdgesOnResize: false,\n    isResetEdgesOnResize() {\n        return this.resetEdgesOnResize;\n    },\n    resetEdgesOnMove: false,\n    isResetEdgesOnMove() {\n        return this.resetEdgesOnMove;\n    },\n    resetEdgesOnConnect: true,\n    isResetEdgesOnConnect() {\n        return this.resetEdgesOnConnect;\n    },\n    connectableEdges: false,\n    allowDanglingEdges: true,\n    cloneInvalidEdges: false,\n    alternateEdgeStyle: {},\n    edgeLabelsMovable: true,\n    // ***************************************************************************\n    // Group: Graph Behaviour\n    // ***************************************************************************\n    isEdgeLabelsMovable() {\n        return this.edgeLabelsMovable;\n    },\n    setEdgeLabelsMovable(value) {\n        this.edgeLabelsMovable = value;\n    },\n    setAllowDanglingEdges(value) {\n        this.allowDanglingEdges = value;\n    },\n    isAllowDanglingEdges() {\n        return this.allowDanglingEdges;\n    },\n    setConnectableEdges(value) {\n        this.connectableEdges = value;\n    },\n    isConnectableEdges() {\n        return this.connectableEdges;\n    },\n    setCloneInvalidEdges(value) {\n        this.cloneInvalidEdges = value;\n    },\n    isCloneInvalidEdges() {\n        return this.cloneInvalidEdges;\n    },\n    // ***************************************************************************\n    // Group: Cell alignment and orientation\n    // ***************************************************************************\n    flipEdge(edge) {\n        if (this.alternateEdgeStyle) {\n            this.batchUpdate(() => {\n                const style = edge.getStyle();\n                if (Object.keys(style).length) {\n                    this.getDataModel().setStyle(edge, this.alternateEdgeStyle);\n                }\n                else {\n                    this.getDataModel().setStyle(edge, {});\n                }\n                // Removes all existing control points\n                this.resetEdge(edge);\n                this.fireEvent(new EventObject(InternalEvent.FLIP_EDGE, { edge }));\n            });\n        }\n        return edge;\n    },\n    splitEdge(edge, cells, newEdge, dx = 0, dy = 0, x, y, parent = null) {\n        parent = parent ?? edge.getParent();\n        const source = edge.getTerminal(true);\n        this.batchUpdate(() => {\n            if (!newEdge) {\n                newEdge = this.cloneCell(edge);\n                // Removes waypoints before/after new cell\n                const state = this.getView().getState(edge);\n                let geo = newEdge.getGeometry();\n                if (geo && state) {\n                    const t = this.getView().translate;\n                    const s = this.getView().scale;\n                    const idx = findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n                    geo.points = geo.points.slice(0, idx);\n                    geo = edge.getGeometry();\n                    if (geo) {\n                        geo = geo.clone();\n                        geo.points = geo.points.slice(idx);\n                        this.getDataModel().setGeometry(edge, geo);\n                    }\n                }\n            }\n            this.cellsMoved(cells, dx, dy, false, false);\n            this.cellsAdded(cells, parent, parent ? parent.getChildCount() : 0, null, null, true);\n            this.cellsAdded([newEdge], parent, parent ? parent.getChildCount() : 0, source, cells[0], false);\n            this.cellConnected(edge, cells[0], true);\n            this.fireEvent(new EventObject(InternalEvent.SPLIT_EDGE, { edge, cells, newEdge, dx, dy }));\n        });\n        return newEdge;\n    },\n    insertEdge(...args) {\n        let parent;\n        let id;\n        let value;\n        let source;\n        let target;\n        let style;\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const params = args[0];\n            parent = params.parent;\n            id = params.id;\n            value = params.value;\n            source = params.source;\n            target = params.target;\n            style = params.style;\n        }\n        else {\n            // otherwise treat as individual arguments\n            [parent, id, value, source, target, style] = args;\n        }\n        const edge = this.createEdge(parent, id, value, source, target, style);\n        return this.addEdge(edge, parent, source, target);\n    },\n    createEdge(parent = null, id, value, source = null, target = null, style = {}) {\n        // Creates the edge\n        const edge = new Cell(value, new Geometry(), style);\n        edge.setId(id);\n        edge.setEdge(true);\n        edge.geometry.relative = true;\n        return edge;\n    },\n    addEdge(edge, parent = null, source = null, target = null, index = null) {\n        return this.addCell(edge, parent, index, source, target);\n    },\n    // ***************************************************************************\n    // Group: Folding\n    // ***************************************************************************\n    addAllEdges(cells) {\n        const allCells = cells.slice();\n        return removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n    },\n    getAllEdges(cells) {\n        let edges = [];\n        if (cells) {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edgeCount = cells[i].getEdgeCount();\n                for (let j = 0; j < edgeCount; j++) {\n                    edges.push(cells[i].getEdgeAt(j));\n                }\n                // Recurses\n                const children = cells[i].getChildren();\n                edges = edges.concat(this.getAllEdges(children));\n            }\n        }\n        return edges;\n    },\n    getIncomingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, true, false, false);\n    },\n    getOutgoingEdges(cell, parent = null) {\n        return this.getEdges(cell, parent, false, true, false);\n    },\n    getEdges(cell, parent = null, incoming = true, outgoing = true, includeLoops = true, recurse = false) {\n        let edges = [];\n        const isCollapsed = cell.isCollapsed();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            if (isCollapsed || !child.isVisible()) {\n                edges = edges.concat(child.getEdges(incoming, outgoing));\n            }\n        }\n        edges = edges.concat(cell.getEdges(incoming, outgoing));\n        const result = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((includeLoops && source === target) ||\n                (source !== target &&\n                    ((incoming &&\n                        target === cell &&\n                        (!parent || this.isValidAncestor(source, parent, recurse))) ||\n                        (outgoing &&\n                            source === cell &&\n                            (!parent || this.isValidAncestor(target, parent, recurse)))))) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell retrieval\n    // ***************************************************************************\n    getChildEdges(parent) {\n        return this.getChildCells(parent, false, true);\n    },\n    getEdgesBetween(source, target, directed = false) {\n        const edges = this.getEdges(source);\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const src = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const trg = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) ||\n                (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    },\n    // ***************************************************************************\n    // Group: Cell moving\n    // ***************************************************************************\n    resetEdges(cells) {\n        // Prepares faster cells lookup\n        const dict = new Dictionary();\n        for (let i = 0; i < cells.length; i += 1) {\n            dict.put(cells[i], true);\n        }\n        this.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const edges = cells[i].getEdges();\n                for (let j = 0; j < edges.length; j++) {\n                    const state = this.getView().getState(edges[j]);\n                    const source = state\n                        ? state.getVisibleTerminal(true)\n                        : this.getView().getVisibleTerminal(edges[j], true);\n                    const target = state\n                        ? state.getVisibleTerminal(false)\n                        : this.getView().getVisibleTerminal(edges[j], false);\n                    // Checks if one of the terminals is not in the given array\n                    if (!dict.get(source) || !dict.get(target)) {\n                        this.resetEdge(edges[j]);\n                    }\n                }\n                this.resetEdges(cells[i].getChildren());\n            }\n        });\n    },\n    resetEdge(edge) {\n        let geo = edge.getGeometry();\n        // Resets the control points\n        if (geo && geo.points && geo.points.length > 0) {\n            geo = geo.clone();\n            geo.points = [];\n            this.getDataModel().setGeometry(edge, geo);\n        }\n        return edge;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isMultiTouchEvent } from '../../util/EventUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EditingMixin = {\n    cellsEditable: true,\n    /*****************************************************************************\n     * Group: Cell in-place editing\n     *****************************************************************************/\n    startEditing(evt) {\n        this.startEditingAtCell(null, evt);\n    },\n    startEditingAtCell(cell = null, evt) {\n        if (!evt || !isMultiTouchEvent(evt)) {\n            if (!cell) {\n                cell = this.getSelectionCell();\n                if (cell && !this.isCellEditable(cell)) {\n                    cell = null;\n                }\n            }\n            else {\n                this.fireEvent(new EventObject(InternalEvent.START_EDITING, { cell, event: evt }));\n                const cellEditorHandler = this.getPlugin('CellEditorHandler');\n                cellEditorHandler?.startEditing(cell, evt);\n                this.fireEvent(new EventObject(InternalEvent.EDITING_STARTED, { cell, event: evt }));\n            }\n        }\n    },\n    getEditingValue(cell, evt) {\n        return this.convertValueToString(cell);\n    },\n    stopEditing(cancel = false) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        cellEditorHandler?.stopEditing(cancel);\n        this.fireEvent(new EventObject(InternalEvent.EDITING_STOPPED, { cancel }));\n    },\n    labelChanged(cell, value, evt) {\n        this.batchUpdate(() => {\n            const old = cell.value;\n            this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n            this.fireEvent(new EventObject(InternalEvent.LABEL_CHANGED, {\n                cell: cell,\n                value: value,\n                old: old,\n                event: evt,\n            }));\n        });\n        return cell;\n    },\n    cellLabelChanged(cell, value, autoSize = false) {\n        this.batchUpdate(() => {\n            this.getDataModel().setValue(cell, value);\n            if (autoSize) {\n                this.cellSizeUpdated(cell, false);\n            }\n        });\n    },\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    isEditing(cell = null) {\n        const cellEditorHandler = this.getPlugin('CellEditorHandler');\n        const editingCell = cellEditorHandler?.getEditingCell();\n        return !cell ? !!editingCell : cell === editingCell;\n    },\n    isCellEditable(cell) {\n        const style = this.getCurrentCellStyle(cell);\n        return (this.isCellsEditable() && !this.isCellLocked(cell) && (style.editable || false));\n    },\n    isCellsEditable() {\n        return this.cellsEditable;\n    },\n    setCellsEditable(value) {\n        this.cellsEditable = value;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getClientX, getClientY, isAltDown, isConsumed, isControlDown, isLeftMouseButton, isMetaDown, isMouseEvent, isMultiTouchEvent, isPenEvent, isPopupTrigger, isShiftDown, isTouchEvent, } from '../../util/EventUtils';\nimport Point from '../geometry/Point';\nimport { convertPoint } from '../../util/styleUtils';\nimport { NONE } from '../../util/Constants';\nimport Client from '../../Client';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const EventsMixin = {\n    // TODO: Document me!\n    lastTouchEvent: null,\n    doubleClickCounter: 0,\n    lastTouchCell: null,\n    fireDoubleClick: null,\n    tapAndHoldThread: null,\n    lastMouseX: null,\n    lastMouseY: null,\n    isMouseTrigger: null,\n    ignoreMouseEvents: null,\n    mouseMoveRedirect: null,\n    mouseUpRedirect: null,\n    lastEvent: null, // FIXME: Check if this can be more specific - DOM events or mxEventObjects!\n    escapeEnabled: true,\n    invokesStopCellEditing: true,\n    enterStopsCellEditing: false,\n    isMouseDown: false,\n    nativeDblClickEnabled: true,\n    doubleTapEnabled: true,\n    doubleTapTimeout: 500,\n    doubleTapTolerance: 25,\n    lastTouchX: 0,\n    lastTouchY: 0,\n    lastTouchTime: 0,\n    tapAndHoldEnabled: true,\n    tapAndHoldDelay: 500,\n    tapAndHoldInProgress: false,\n    tapAndHoldValid: false,\n    initialTouchX: 0,\n    initialTouchY: 0,\n    tolerance: 4,\n    isNativeDblClickEnabled() {\n        return this.nativeDblClickEnabled;\n    },\n    getEventTolerance() {\n        return this.tolerance;\n    },\n    setEventTolerance(tolerance) {\n        this.tolerance = tolerance;\n    },\n    escape(evt) {\n        this.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));\n    },\n    click(me) {\n        const evt = me.getEvent();\n        let cell = me.getCell();\n        const mxe = new EventObject(InternalEvent.CLICK, { event: evt, cell });\n        if (me.isConsumed()) {\n            mxe.consume();\n        }\n        this.fireEvent(mxe);\n        if (this.isEnabled() && !isConsumed(evt) && !mxe.isConsumed()) {\n            if (cell) {\n                if (this.isTransparentClickEvent(evt)) {\n                    let active = false;\n                    const tmp = this.getCellAt(me.graphX, me.graphY, null, false, false, (state) => {\n                        const selected = this.isCellSelected(state.cell);\n                        active = active || selected;\n                        return (!active ||\n                            selected ||\n                            (state.cell !== cell && state.cell.isAncestor(cell)));\n                    });\n                    if (tmp) {\n                        cell = tmp;\n                    }\n                }\n            }\n            else if (this.isSwimlaneSelectionEnabled()) {\n                cell = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n                if (cell != null && (!this.isToggleEvent(evt) || !isAltDown(evt))) {\n                    let temp = cell;\n                    let swimlanes = [];\n                    while (temp != null) {\n                        temp = temp.getParent();\n                        const state = this.getView().getState(temp);\n                        if (this.isSwimlane(temp) && state != null) {\n                            swimlanes.push(temp);\n                        }\n                    }\n                    // Selects ancestors for selected swimlanes\n                    if (swimlanes.length > 0) {\n                        swimlanes = swimlanes.reverse();\n                        swimlanes.splice(0, 0, cell);\n                        swimlanes.push(cell);\n                        for (let i = 0; i < swimlanes.length - 1; i += 1) {\n                            if (this.isCellSelected(swimlanes[i])) {\n                                cell = swimlanes[this.isToggleEvent(evt) ? i : i + 1];\n                            }\n                        }\n                    }\n                }\n            }\n            if (cell) {\n                this.selectCellForEvent(cell, evt);\n            }\n            else if (!this.isToggleEvent(evt)) {\n                this.clearSelection();\n            }\n        }\n        return false;\n    },\n    dblClick(evt, cell = null) {\n        const mxe = new EventObject(InternalEvent.DOUBLE_CLICK, { event: evt, cell });\n        this.fireEvent(mxe);\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            cell &&\n            this.isCellEditable(cell) &&\n            !this.isEditing(cell)) {\n            this.startEditingAtCell(cell, evt);\n            InternalEvent.consume(evt);\n        }\n    },\n    tapAndHold(me) {\n        const evt = me.getEvent();\n        const mxe = new EventObject(InternalEvent.TAP_AND_HOLD, {\n            event: evt,\n            cell: me.getCell(),\n        });\n        const panningHandler = this.getPlugin('PanningHandler');\n        const connectionHandler = this.getPlugin('ConnectionHandler');\n        // LATER: Check if event should be consumed if me is consumed\n        this.fireEvent(mxe);\n        if (mxe.isConsumed()) {\n            // Resets the state of the panning handler\n            panningHandler && (panningHandler.panningTrigger = false);\n        }\n        // Handles the event if it has not been consumed\n        if (this.isEnabled() &&\n            !isConsumed(evt) &&\n            !mxe.isConsumed() &&\n            connectionHandler &&\n            connectionHandler.isEnabled()) {\n            const cell = connectionHandler.marker.getCell(me);\n            if (cell) {\n                const state = this.getView().getState(cell);\n                if (state) {\n                    connectionHandler.marker.currentColor = connectionHandler.marker.validColor;\n                    connectionHandler.marker.markedState = state;\n                    connectionHandler.marker.mark();\n                    connectionHandler.first = new Point(me.getGraphX(), me.getGraphY());\n                    connectionHandler.edgeState = connectionHandler.createEdgeState(me);\n                    connectionHandler.previous = state;\n                    connectionHandler.fireEvent(new EventObject(InternalEvent.START, { state: connectionHandler.previous }));\n                }\n            }\n        }\n    },\n    addMouseListener(listener) {\n        this.mouseListeners.push(listener);\n    },\n    removeMouseListener(listener) {\n        for (let i = 0; i < this.mouseListeners.length; i += 1) {\n            if (this.mouseListeners[i] === listener) {\n                this.mouseListeners.splice(i, 1);\n                break;\n            }\n        }\n    },\n    updateMouseEvent(me, evtName) {\n        const pt = convertPoint(this.getContainer(), me.getX(), me.getY());\n        me.graphX = pt.x - this.getPanDx();\n        me.graphY = pt.y - this.getPanDy();\n        // Searches for rectangles using method if native hit detection is disabled on shape\n        if (!me.getCell() && this.isMouseDown && evtName === InternalEvent.MOUSE_MOVE) {\n            const cell = this.getCellAt(pt.x, pt.y, null, true, true, (state) => {\n                return (!state.shape ||\n                    state.shape.paintBackground !== this.paintBackground ||\n                    state.style.pointerEvents ||\n                    state.shape.fill !== NONE);\n            });\n            me.state = cell ? this.getView().getState(cell) : null;\n        }\n        return me;\n    },\n    getStateForTouchEvent(evt) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        const pt = convertPoint(this.getContainer(), x, y);\n        const cell = this.getCellAt(pt.x, pt.y);\n        return cell ? this.getView().getState(cell) : null;\n    },\n    isEventIgnored(evtName, me, sender) {\n        const mouseEvent = isMouseEvent(me.getEvent());\n        let result = false;\n        // Drops events that are fired more than once\n        if (me.getEvent() === this.lastEvent) {\n            result = true;\n        }\n        else {\n            this.lastEvent = me.getEvent();\n        }\n        // Installs event listeners to capture the complete gesture from the event source\n        // for non-MS touch events as a workaround for all events for the same geture being\n        // fired from the event source even if that was removed from the DOM.\n        const eventSource = this.getEventSource();\n        if (eventSource && evtName !== InternalEvent.MOUSE_MOVE) {\n            InternalEvent.removeGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n            this.mouseMoveRedirect = null;\n            this.mouseUpRedirect = null;\n            this.setEventSource(null);\n        }\n        else if (!Client.IS_GC && eventSource && me.getSource() !== eventSource) {\n            result = true;\n        }\n        else if (eventSource &&\n            Client.IS_TOUCH &&\n            evtName === InternalEvent.MOUSE_DOWN &&\n            !mouseEvent &&\n            !isPenEvent(me.getEvent())) {\n            this.setEventSource(me.getSource());\n            (this.mouseMoveRedirect = (evt) => {\n                this.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n            }),\n                (this.mouseUpRedirect = (evt) => {\n                    this.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt, this.getStateForTouchEvent(evt)));\n                }),\n                InternalEvent.addGestureListeners(eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n        }\n        // Factored out the workarounds for FF to make it easier to override/remove\n        // Note this method has side-effects!\n        if (this.isSyntheticEventIgnored(evtName, me, sender)) {\n            result = true;\n        }\n        // Never fires mouseUp/-Down for double clicks\n        if (!isPopupTrigger(this.lastEvent) &&\n            evtName !== InternalEvent.MOUSE_MOVE &&\n            this.lastEvent.detail === 2) {\n            return true;\n        }\n        // Filters out of sequence events or mixed event types during a gesture\n        if (evtName === InternalEvent.MOUSE_UP && this.isMouseDown) {\n            this.isMouseDown = false;\n        }\n        else if (evtName === InternalEvent.MOUSE_DOWN && !this.isMouseDown) {\n            this.isMouseDown = true;\n            this.isMouseTrigger = mouseEvent;\n        }\n        // Drops mouse events that are fired during touch gestures as a workaround for Webkit\n        // and mouse events that are not in sync with the current internal button state\n        else if (!result &&\n            (((!Client.IS_FF || evtName !== InternalEvent.MOUSE_MOVE) &&\n                this.isMouseDown &&\n                this.isMouseTrigger !== mouseEvent) ||\n                (evtName === InternalEvent.MOUSE_DOWN && this.isMouseDown) ||\n                (evtName === InternalEvent.MOUSE_UP && !this.isMouseDown))) {\n            result = true;\n        }\n        if (!result && evtName === InternalEvent.MOUSE_DOWN) {\n            this.lastMouseX = me.getX();\n            this.lastMouseY = me.getY();\n        }\n        return result;\n    },\n    isSyntheticEventIgnored(evtName, me, sender) {\n        let result = false;\n        const mouseEvent = isMouseEvent(me.getEvent());\n        // LATER: This does not cover all possible cases that can go wrong in FF\n        if (this.ignoreMouseEvents && mouseEvent && evtName !== InternalEvent.MOUSE_MOVE) {\n            this.ignoreMouseEvents = evtName !== InternalEvent.MOUSE_UP;\n            result = true;\n        }\n        else if (Client.IS_FF && !mouseEvent && evtName === InternalEvent.MOUSE_UP) {\n            this.ignoreMouseEvents = true;\n        }\n        return result;\n    },\n    isEventSourceIgnored(evtName, me) {\n        const source = me.getSource();\n        if (!source)\n            return true;\n        // @ts-ignore nodeName could exist\n        const name = source.nodeName ? source.nodeName.toLowerCase() : '';\n        const candidate = !isMouseEvent(me.getEvent()) || isLeftMouseButton(me.getEvent());\n        return (evtName === InternalEvent.MOUSE_DOWN &&\n            candidate &&\n            (name === 'select' ||\n                name === 'option' ||\n                (name === 'input' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'checkbox' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'radio' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'button' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'submit' &&\n                    // @ts-ignore type could exist\n                    source.type !== 'file')));\n    },\n    getEventState(state) {\n        return state;\n    },\n    fireMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        if (this.isEventSourceIgnored(evtName, me)) {\n            const tooltipHandler = this.getPlugin('TooltipHandler');\n            if (tooltipHandler) {\n                tooltipHandler.hide();\n            }\n            return;\n        }\n        // Updates the graph coordinates in the event\n        me = this.updateMouseEvent(me, evtName);\n        // Detects and processes double taps for touch-based devices which do not have native double click events\n        // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n        // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n        // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n        // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n        if ((!this.nativeDblClickEnabled && !isPopupTrigger(me.getEvent())) ||\n            (this.doubleTapEnabled &&\n                Client.IS_TOUCH &&\n                (isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())))) {\n            const currentTime = new Date().getTime();\n            if (evtName === InternalEvent.MOUSE_DOWN) {\n                if (this.lastTouchEvent &&\n                    this.lastTouchEvent !== me.getEvent() &&\n                    currentTime - this.lastTouchTime < this.doubleTapTimeout &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n                    this.doubleClickCounter < 2) {\n                    this.doubleClickCounter += 1;\n                    let doubleClickFired = false;\n                    if (evtName === InternalEvent.MOUSE_UP) {\n                        if (me.getCell() === this.lastTouchCell && this.lastTouchCell) {\n                            this.lastTouchTime = 0;\n                            const cell = this.lastTouchCell;\n                            this.lastTouchCell = null;\n                            this.dblClick(me.getEvent(), cell);\n                            doubleClickFired = true;\n                        }\n                    }\n                    else {\n                        this.fireDoubleClick = true;\n                        this.lastTouchTime = 0;\n                    }\n                    if (doubleClickFired) {\n                        InternalEvent.consume(me.getEvent());\n                        return;\n                    }\n                }\n                else if (!this.lastTouchEvent || this.lastTouchEvent !== me.getEvent()) {\n                    this.lastTouchCell = me.getCell();\n                    this.lastTouchX = me.getX();\n                    this.lastTouchY = me.getY();\n                    this.lastTouchTime = currentTime;\n                    this.lastTouchEvent = me.getEvent();\n                    this.doubleClickCounter = 0;\n                }\n            }\n            else if ((this.isMouseDown || evtName === InternalEvent.MOUSE_UP) &&\n                this.fireDoubleClick) {\n                this.fireDoubleClick = false;\n                const cell = this.lastTouchCell;\n                this.lastTouchCell = null;\n                this.isMouseDown = false;\n                // Workaround for Chrome/Safari not firing native double click events for double touch on background\n                const valid = cell ||\n                    ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                        (Client.IS_GC || Client.IS_SF));\n                if (valid &&\n                    Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n                    Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {\n                    this.dblClick(me.getEvent(), cell);\n                }\n                else {\n                    InternalEvent.consume(me.getEvent());\n                }\n                return;\n            }\n        }\n        if (!this.isEventIgnored(evtName, me, sender)) {\n            const state = me.getState();\n            // Updates the event state via getEventState\n            me.state = state ? this.getEventState(state) : null;\n            this.fireEvent(new EventObject(InternalEvent.FIRE_MOUSE_EVENT, { eventName: evtName, event: me }));\n            if (Client.IS_SF || Client.IS_GC || me.getEvent().target !== this.getContainer()) {\n                const container = this.getContainer();\n                if (evtName === InternalEvent.MOUSE_MOVE &&\n                    this.isMouseDown &&\n                    this.isAutoScroll() &&\n                    !isMultiTouchEvent(me.getEvent())) {\n                    this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.isAutoExtend());\n                }\n                else if (evtName === InternalEvent.MOUSE_UP &&\n                    this.isIgnoreScrollbars() &&\n                    this.isTranslateToScrollPosition() &&\n                    (container.scrollLeft !== 0 || container.scrollTop !== 0)) {\n                    const s = this.getView().scale;\n                    const tr = this.getView().translate;\n                    this.getView().setTranslate(tr.x - container.scrollLeft / s, tr.y - container.scrollTop / s);\n                    container.scrollLeft = 0;\n                    container.scrollTop = 0;\n                }\n                const mouseListeners = this.mouseListeners;\n                // Does not change returnValue in Opera\n                if (!me.getEvent().preventDefault) {\n                    me.getEvent().returnValue = true;\n                }\n                for (const l of mouseListeners) {\n                    if (evtName === InternalEvent.MOUSE_DOWN) {\n                        l.mouseDown(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_MOVE) {\n                        l.mouseMove(sender, me);\n                    }\n                    else if (evtName === InternalEvent.MOUSE_UP) {\n                        l.mouseUp(sender, me);\n                    }\n                }\n                // Invokes the click handler\n                if (evtName === InternalEvent.MOUSE_UP) {\n                    this.click(me);\n                }\n            }\n            // Detects tapAndHold events using a timer\n            if ((isTouchEvent(me.getEvent()) || isPenEvent(me.getEvent())) &&\n                evtName === InternalEvent.MOUSE_DOWN &&\n                this.tapAndHoldEnabled &&\n                !this.tapAndHoldInProgress) {\n                this.tapAndHoldInProgress = true;\n                this.initialTouchX = me.getGraphX();\n                this.initialTouchY = me.getGraphY();\n                const handler = () => {\n                    if (this.tapAndHoldValid) {\n                        this.tapAndHold(me);\n                    }\n                    this.tapAndHoldInProgress = false;\n                    this.tapAndHoldValid = false;\n                };\n                if (this.tapAndHoldThread) {\n                    window.clearTimeout(this.tapAndHoldThread);\n                }\n                this.tapAndHoldThread = window.setTimeout(handler, this.tapAndHoldDelay);\n                this.tapAndHoldValid = true;\n            }\n            else if (evtName === InternalEvent.MOUSE_UP) {\n                this.tapAndHoldInProgress = false;\n                this.tapAndHoldValid = false;\n            }\n            else if (this.tapAndHoldValid) {\n                this.tapAndHoldValid =\n                    Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n                        Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n            }\n            const cellEditorHandler = this.getPlugin('CellEditorHandler');\n            // Stops editing for all events other than from cellEditorHandler\n            if (evtName === InternalEvent.MOUSE_DOWN &&\n                this.isEditing() &&\n                !cellEditorHandler?.isEventSource(me.getEvent())) {\n                this.stopEditing(!this.isInvokesStopCellEditing());\n            }\n            this.consumeMouseEvent(evtName, me, sender);\n        }\n    },\n    consumeMouseEvent(evtName, me, sender) {\n        sender = sender ?? this;\n        // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n        if (evtName === InternalEvent.MOUSE_DOWN && isTouchEvent(me.getEvent())) {\n            me.consume(false);\n        }\n    },\n    fireGestureEvent(evt, cell = null) {\n        // Resets double tap event handling when gestures take place\n        this.lastTouchTime = 0;\n        this.fireEvent(new EventObject(InternalEvent.GESTURE, { event: evt, cell }));\n    },\n    sizeDidChange() {\n        const bounds = this.getGraphBounds();\n        const border = this.getBorder();\n        let width = Math.max(0, bounds.x) + bounds.width + 2 * border;\n        let height = Math.max(0, bounds.y) + bounds.height + 2 * border;\n        const minimumContainerSize = this.getMinimumContainerSize();\n        if (minimumContainerSize) {\n            width = Math.max(width, minimumContainerSize.width);\n            height = Math.max(height, minimumContainerSize.height);\n        }\n        if (this.isResizeContainer()) {\n            this.doResizeContainer(width, height);\n        }\n        if (this.isPreferPageSize() || this.isPageVisible()) {\n            const size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n            width = size.width * this.getView().scale;\n            height = size.height * this.getView().scale;\n        }\n        const minimumGraphSize = this.getMinimumGraphSize();\n        if (minimumGraphSize) {\n            width = Math.max(width, minimumGraphSize.width * this.getView().scale);\n            height = Math.max(height, minimumGraphSize.height * this.getView().scale);\n        }\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n        // @ts-ignore\n        const root = this.getView().getDrawPane().ownerSVGElement;\n        if (root) {\n            root.style.minWidth = `${Math.max(1, width)}px`;\n            root.style.minHeight = `${Math.max(1, height)}px`;\n            root.style.width = '100%';\n            root.style.height = '100%';\n        }\n        this.updatePageBreaks(this.isPageBreaksVisible(), width, height);\n        this.fireEvent(new EventObject(InternalEvent.SIZE, { bounds }));\n    },\n    isCloneEvent(evt) {\n        return isControlDown(evt);\n    },\n    isTransparentClickEvent(evt) {\n        return false;\n    },\n    isToggleEvent(evt) {\n        return Client.IS_MAC ? isMetaDown(evt) : isControlDown(evt);\n    },\n    isGridEnabledEvent(evt) {\n        return !isAltDown(evt);\n    },\n    isConstrainedEvent(evt) {\n        return isShiftDown(evt);\n    },\n    isIgnoreTerminalEvent(_evt) {\n        return false;\n    },\n    getPointForEvent(evt, addOffset = true) {\n        const p = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        const s = this.getView().scale;\n        const tr = this.getView().translate;\n        const off = addOffset ? this.getGridSize() / 2 : 0;\n        p.x = this.snap(p.x / s - tr.x - off);\n        p.y = this.snap(p.y / s - tr.y - off);\n        return p;\n    },\n    isEscapeEnabled() {\n        return this.escapeEnabled;\n    },\n    setEscapeEnabled(value) {\n        this.escapeEnabled = value;\n    },\n    isInvokesStopCellEditing() {\n        return this.invokesStopCellEditing;\n    },\n    setInvokesStopCellEditing(value) {\n        this.invokesStopCellEditing = value;\n    },\n    isEnterStopsCellEditing() {\n        return this.enterStopsCellEditing;\n    },\n    setEnterStopsCellEditing(value) {\n        this.enterStopsCellEditing = value;\n    },\n    getCursorForMouseEvent(me) {\n        const cell = me.getCell();\n        return cell ? this.getCursorForCell(cell) : null;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from '../image/ImageBox';\nimport Client from '../../Client';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { getValue } from '../../util/Utils';\nimport { toRadians } from '../../util/mathUtils';\nimport Rectangle from '../geometry/Rectangle';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const FoldingMixin = {\n    options: {\n        foldingEnabled: true,\n        collapsedImage: new Image(`${Client.imageBasePath}/collapsed.gif`, 9, 9),\n        expandedImage: new Image(`${Client.imageBasePath}/expanded.gif`, 9, 9),\n        collapseToPreferredSize: true,\n    },\n    collapseExpandResource: Client.language != 'none' ? 'collapse-expand' : '',\n    getCollapseExpandResource() {\n        return this.collapseExpandResource;\n    },\n    isFoldingEnabled() {\n        return this.options.foldingEnabled;\n    },\n    getFoldableCells(cells, collapse = false) {\n        return this.getDataModel().filterCells(cells, (cell) => {\n            return this.isCellFoldable(cell, collapse);\n        });\n    },\n    isCellFoldable(cell, collapse) {\n        const style = this.getCurrentCellStyle(cell);\n        return cell.getChildCount() > 0 && (style.foldable ?? true);\n    },\n    getFoldingImage(state) {\n        if (state != null && this.isFoldingEnabled() && !state.cell.isEdge()) {\n            const tmp = state.cell.isCollapsed();\n            if (this.isCellFoldable(state.cell, !tmp)) {\n                return tmp ? this.options.collapsedImage : this.options.expandedImage;\n            }\n        }\n        return null;\n    },\n    foldCells(collapse = false, recurse = false, cells = null, checkFoldable = false, _evt = null) {\n        if (cells == null) {\n            cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n        }\n        this.stopEditing(false);\n        this.batchUpdate(() => {\n            this.cellsFolded(cells, collapse, recurse, checkFoldable);\n            this.fireEvent(new EventObject(InternalEvent.FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));\n        });\n        return cells;\n    },\n    cellsFolded(cells = null, collapse = false, recurse = false, checkFoldable = false) {\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                for (let i = 0; i < cells.length; i += 1) {\n                    if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n                        collapse !== cells[i].isCollapsed()) {\n                        this.getDataModel().setCollapsed(cells[i], collapse);\n                        this.swapBounds(cells[i], collapse);\n                        if (this.isExtendParent(cells[i])) {\n                            this.extendParent(cells[i]);\n                        }\n                        if (recurse) {\n                            const children = cells[i].getChildren();\n                            this.cellsFolded(children, collapse, recurse);\n                        }\n                        this.constrainChild(cells[i]);\n                    }\n                }\n                this.fireEvent(new EventObject(InternalEvent.CELLS_FOLDED, { cells, collapse, recurse }));\n            });\n        }\n    },\n    swapBounds(cell, willCollapse = false) {\n        let geo = cell.getGeometry();\n        if (geo != null) {\n            geo = geo.clone();\n            this.updateAlternateBounds(cell, geo, willCollapse);\n            geo.swap();\n            this.getDataModel().setGeometry(cell, geo);\n        }\n    },\n    updateAlternateBounds(cell = null, geo = null, willCollapse = false) {\n        if (cell != null && geo != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (geo.alternateBounds == null) {\n                let bounds = geo;\n                if (this.options.collapseToPreferredSize) {\n                    const tmp = this.getPreferredSizeForCell(cell);\n                    if (tmp != null) {\n                        bounds = tmp;\n                        const startSize = getValue(style, 'startSize');\n                        if (startSize > 0) {\n                            bounds.height = Math.max(bounds.height, startSize);\n                        }\n                    }\n                }\n                geo.alternateBounds = new Rectangle(0, 0, bounds.width, bounds.height);\n            }\n            if (geo.alternateBounds != null) {\n                geo.alternateBounds.x = geo.x;\n                geo.alternateBounds.y = geo.y;\n                const alpha = toRadians(style.rotation || 0);\n                if (alpha !== 0) {\n                    const dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n                    const dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n                    const cos = Math.cos(alpha);\n                    const sin = Math.sin(alpha);\n                    const dx2 = cos * dx - sin * dy;\n                    const dy2 = sin * dx + cos * dy;\n                    geo.alternateBounds.x += dx2 - dx;\n                    geo.alternateBounds.y += dy2 - dy;\n                }\n            }\n        }\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport { sortCells } from '../../util/styleUtils';\nimport Geometry from '../geometry/Geometry';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const GroupingMixin = {\n    groupCells(group, border = 0, cells) {\n        if (!cells)\n            cells = sortCells(this.getSelectionCells(), true);\n        if (!cells)\n            cells = this.getCellsForGroup(cells);\n        if (group == null) {\n            group = this.createGroupCell(cells);\n        }\n        const bounds = this.getBoundsForGroup(group, cells, border);\n        if (cells.length > 1 && bounds != null) {\n            // Uses parent of group or previous parent of first child\n            let parent = group.getParent();\n            if (parent == null) {\n                parent = cells[0].getParent();\n            }\n            this.batchUpdate(() => {\n                // Checks if the group has a geometry and\n                // creates one if one does not exist\n                if (group.getGeometry() == null) {\n                    this.getDataModel().setGeometry(group, new Geometry());\n                }\n                // Adds the group into the parent\n                let index = parent.getChildCount();\n                this.cellsAdded([group], parent, index, null, null, false, false, false);\n                // Adds the children into the group and moves\n                index = group.getChildCount();\n                this.cellsAdded(cells, group, index, null, null, false, false, false);\n                this.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n                // Resizes the group\n                this.cellsResized([group], [bounds], false);\n                this.fireEvent(new EventObject(InternalEvent.GROUP_CELLS, { group, border, cells }));\n            });\n        }\n        return group;\n    },\n    getCellsForGroup(cells) {\n        const result = [];\n        if (cells != null && cells.length > 0) {\n            const parent = cells[0].getParent();\n            result.push(cells[0]);\n            // Filters selection cells with the same parent\n            for (let i = 1; i < cells.length; i += 1) {\n                if (cells[i].getParent() === parent) {\n                    result.push(cells[i]);\n                }\n            }\n        }\n        return result;\n    },\n    getBoundsForGroup(group, children, border) {\n        const result = this.getBoundingBoxFromGeometry(children, true);\n        if (result != null) {\n            if (this.isSwimlane(group)) {\n                const size = this.getStartSize(group);\n                result.x -= size.width;\n                result.y -= size.height;\n                result.width += size.width;\n                result.height += size.height;\n            }\n            // Adds the border\n            if (border != null) {\n                result.x -= border;\n                result.y -= border;\n                result.width += 2 * border;\n                result.height += 2 * border;\n            }\n        }\n        return result;\n    },\n    createGroupCell(cells) {\n        const group = new Cell('');\n        group.setVertex(true);\n        group.setConnectable(false);\n        return group;\n    },\n    ungroupCells(cells) {\n        let result = [];\n        if (cells == null) {\n            cells = this.getCellsForUngroup();\n        }\n        if (cells != null && cells.length > 0) {\n            this.batchUpdate(() => {\n                const _cells = cells;\n                for (let i = 0; i < _cells.length; i += 1) {\n                    let children = _cells[i].getChildren();\n                    if (children != null && children.length > 0) {\n                        children = children.slice();\n                        const parent = _cells[i].getParent();\n                        const index = parent.getChildCount();\n                        this.cellsAdded(children, parent, index, null, null, true);\n                        result = result.concat(children);\n                        // Fix relative child cells\n                        for (const child of children) {\n                            const state = this.getView().getState(child);\n                            let geo = child.getGeometry();\n                            if (state != null && geo != null && geo.relative) {\n                                geo = geo.clone();\n                                geo.x = state.origin.x;\n                                geo.y = state.origin.y;\n                                geo.relative = false;\n                                this.getDataModel().setGeometry(child, geo);\n                            }\n                        }\n                    }\n                }\n                this.removeCellsAfterUngroup(_cells);\n                this.fireEvent(new EventObject(InternalEvent.UNGROUP_CELLS, { cells }));\n            });\n        }\n        return result;\n    },\n    getCellsForUngroup() {\n        const cells = this.getSelectionCells();\n        // Finds the cells with children\n        const tmp = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            if (cells[i].isVertex() && cells[i].getChildCount() > 0) {\n                tmp.push(cells[i]);\n            }\n        }\n        return tmp;\n    },\n    removeCellsAfterUngroup(cells) {\n        this.cellsRemoved(this.addAllEdges(cells));\n    },\n    removeCellsFromParent(cells) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        this.batchUpdate(() => {\n            const parent = this.getDefaultParent();\n            const index = parent.getChildCount();\n            this.cellsAdded(cells, parent, index, null, null, true);\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_CELLS_FROM_PARENT, { cells }));\n        });\n        return cells;\n    },\n    updateGroupBounds(cells, border = 0, moveGroup = false, topBorder = 0, rightBorder = 0, bottomBorder = 0, leftBorder = 0) {\n        if (cells == null) {\n            cells = this.getSelectionCells();\n        }\n        border = border != null ? border : 0;\n        moveGroup = moveGroup != null ? moveGroup : false;\n        topBorder = topBorder != null ? topBorder : 0;\n        rightBorder = rightBorder != null ? rightBorder : 0;\n        bottomBorder = bottomBorder != null ? bottomBorder : 0;\n        leftBorder = leftBorder != null ? leftBorder : 0;\n        this.batchUpdate(() => {\n            for (let i = cells.length - 1; i >= 0; i--) {\n                let geo = cells[i].getGeometry();\n                if (geo == null) {\n                    continue;\n                }\n                const children = this.getChildCells(cells[i]);\n                if (children != null && children.length > 0) {\n                    const bounds = this.getBoundingBoxFromGeometry(children, true);\n                    if (bounds != null && bounds.width > 0 && bounds.height > 0) {\n                        // Adds the size of the title area for swimlanes\n                        const size = ((this.isSwimlane(cells[i])\n                            ? this.getActualStartSize(cells[i], true)\n                            : new Rectangle()));\n                        geo = geo.clone();\n                        if (moveGroup) {\n                            geo.x = Math.round(geo.x + bounds.x - border - size.x - leftBorder);\n                            geo.y = Math.round(geo.y + bounds.y - border - size.y - topBorder);\n                        }\n                        geo.width = Math.round(bounds.width + 2 * border + size.x + leftBorder + rightBorder + size.width);\n                        geo.height = Math.round(bounds.height + 2 * border + size.y + topBorder + bottomBorder + size.height);\n                        this.getDataModel().setGeometry(cells[i], geo);\n                        this.moveCells(children, border + size.x - bounds.x + leftBorder, border + size.y - bounds.y + topBorder);\n                    }\n                }\n            }\n        });\n        return cells;\n    },\n    /*****************************************************************************\n     * Group: Drilldown\n     *****************************************************************************/\n    enterGroup(cell) {\n        cell = cell || this.getSelectionCell();\n        if (cell != null && this.isValidRoot(cell)) {\n            this.getView().setCurrentRoot(cell);\n            this.clearSelection();\n        }\n    },\n    exitGroup() {\n        const root = this.getDataModel().getRoot();\n        const current = this.getCurrentRoot();\n        if (current != null) {\n            let next = current.getParent();\n            // Finds the next valid root in the hierarchy\n            while (next !== root && !this.isValidRoot(next) && next.getParent() !== root) {\n                next = next.getParent();\n            }\n            // Clears the current root if the new root is\n            // the model's root or one of the layers.\n            if (next === root || next.getParent() === root) {\n                this.getView().setCurrentRoot(null);\n            }\n            else {\n                this.getView().setCurrentRoot(next);\n            }\n            const state = this.getView().getState(current);\n            // Selects the previous root in the graph\n            if (state != null) {\n                this.setSelectionCell(current);\n            }\n        }\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ImageMixin = {\n    addImageBundle(bundle) {\n        this.imageBundles.push(bundle);\n    },\n    removeImageBundle(bundle) {\n        const tmp = [];\n        for (let i = 0; i < this.imageBundles.length; i += 1) {\n            if (this.imageBundles[i] !== bundle) {\n                tmp.push(this.imageBundles[i]);\n            }\n        }\n        this.imageBundles = tmp;\n    },\n    getImageFromBundles(key) {\n        if (key) {\n            for (let i = 0; i < this.imageBundles.length; i += 1) {\n                const image = this.imageBundles[i].getImage(key);\n                if (image) {\n                    return image;\n                }\n            }\n        }\n        return null;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const LabelMixin = {\n    getLabel(cell) {\n        let result = '';\n        if (this.isLabelsVisible() && cell != null) {\n            const style = this.getCurrentCellStyle(cell);\n            if (!(style.noLabel ?? false)) {\n                result = this.convertValueToString(cell);\n            }\n        }\n        return result;\n    },\n    isHtmlLabel(_cell) {\n        return this.isHtmlLabels();\n    },\n    labelsVisible: true,\n    isLabelsVisible() {\n        return this.labelsVisible;\n    },\n    htmlLabels: false,\n    isHtmlLabels() {\n        return this.htmlLabels;\n    },\n    setHtmlLabels(value) {\n        this.htmlLabels = value;\n    },\n    isWrapping(cell) {\n        return this.getCurrentCellStyle(cell).whiteSpace === 'wrap';\n    },\n    isLabelClipped(cell) {\n        return this.getCurrentCellStyle(cell).overflow === 'hidden';\n    },\n    isLabelMovable(cell) {\n        return (!this.isCellLocked(cell) &&\n            ((cell.isEdge() && this.isEdgeLabelsMovable()) ||\n                (cell.isVertex() && this.isVertexLabelsMovable())));\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { sortCells } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const OrderMixin = {\n    orderCells(back = false, cells) {\n        if (!cells)\n            cells = this.getSelectionCells();\n        if (!cells) {\n            cells = sortCells(this.getSelectionCells(), true);\n        }\n        this.batchUpdate(() => {\n            this.cellsOrdered(cells, back);\n            const event = new EventObject(InternalEvent.ORDER_CELLS, 'back', back, 'cells', cells);\n            this.fireEvent(event);\n        });\n        return cells;\n    },\n    cellsOrdered(cells, back = false) {\n        this.batchUpdate(() => {\n            for (let i = 0; i < cells.length; i += 1) {\n                const parent = cells[i].getParent();\n                if (back) {\n                    this.getDataModel().add(parent, cells[i], i);\n                }\n                else {\n                    this.getDataModel().add(parent, cells[i], parent ? parent.getChildCount() - 1 : 0);\n                }\n            }\n            this.fireEvent(new EventObject(InternalEvent.CELLS_ORDERED, { back, cells }));\n        });\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport EventSource from '../event/EventSource';\n/**\n * Extends {@link EventSource} to implement a graph overlay, represented by an icon\n * and a tooltip. Overlays can handle and fire <click> events and are added to\n * the graph using {@link Graph#addCellOverlay}, and removed using\n * {@link Graph#removeCellOverlay}, or {@link Graph#removeCellOverlays} to remove all overlays.\n * The {@link Graph#getCellOverlays} function returns the array of overlays for a given\n * cell in a graph. If multiple overlays exist for the same cell, then\n * <getBounds> should be overridden in at least one of the overlays.\n *\n * Overlays appear on top of all cells in a special layer. If this is not\n * desirable, then the image must be rendered as part of the shape or label of\n * the cell instead.\n *\n * Example:\n *\n * The following adds a new overlays for a given vertex and selects the cell\n * if the overlay is clicked.\n *\n * ```javascript\n * let overlay = new CellOverlay(img, html);\n * graph.addCellOverlay(vertex, overlay);\n * overlay.addListener(mxEvent.CLICK, (sender, evt)=>\n * {\n *   let cell = evt.getProperty('cell');\n *   graph.setSelectionCell(cell);\n * });\n * ```\n *\n * For cell overlays to be printed use {@link PrintPreview#printOverlays}.\n *\n * Event: mxEvent.CLICK\n *\n * Fires when the user clicks on the overlay. The <code>event</code> property\n * contains the corresponding mouse event and the <code>cell</code> property\n * contains the cell. For touch devices this is fired if the element receives\n * a touchend event.\n *\n * Constructor: CellOverlay\n *\n * Constructs a new overlay using the given image and tooltip.\n *\n * @param image {@link Image} that represents the icon to be displayed.\n * @param tooltip Optional string that specifies the tooltip.\n * @param align Optional horizontal alignment for the overlay. Possible\n * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\n * (default).\n * @param verticalAlign Vertical alignment for the overlay. Possible\n * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\n * (default).\n */\nclass CellOverlay extends EventSource {\n    constructor(image, tooltip = null, align = 'right', verticalAlign = 'bottom', offset = new Point(), cursor = 'help') {\n        super();\n        /**\n         * Holds the horizontal alignment for the overlay.\n         *\n         * For edges, the overlay always appears in the center of the edge.\n         * @default 'right'\n         */\n        this.align = 'right';\n        /**\n         * Holds the vertical alignment for the overlay.\n         *\n         * For edges, the overlay always appears in the center of the edge.\n         * @default 'bottom'\n         */\n        this.verticalAlign = 'bottom';\n        /**\n         * Holds the offset as an {@link Point}. The offset will be scaled according to the\n         * current scale.\n         */\n        this.offset = new Point();\n        /**\n         * Holds the cursor for the overlay.\n         * @default 'help'.\n         */\n        this.cursor = 'help';\n        /**\n         * Defines the overlapping for the overlay, that is, the proportional distance\n         * from the origin to the point defined by the alignment. Default is 0.5.\n         */\n        this.defaultOverlap = 0.5;\n        this.image = image;\n        this.tooltip = tooltip;\n        this.align = align;\n        this.verticalAlign = verticalAlign;\n        this.offset = offset;\n        this.cursor = cursor;\n    }\n    /**\n     * Returns the bounds of the overlay for the given <CellState> as an\n     * {@link Rectangle}. This should be overridden when using multiple overlays\n     * per cell so that the overlays do not overlap.\n     *\n     * The following example will place the overlay along an edge (where\n     * x=[-1..1] from the start to the end of the edge and y is the\n     * orthogonal offset in px).\n     *\n     * ```javascript\n     * overlay.getBounds = function(state)\n     * {\n     *   var bounds = getBounds.apply(this, arguments);\n     *\n     *   if (state.view.graph.getDataModel().isEdge(state.cell))\n     *   {\n     *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\n     *\n     *     bounds.x = pt.x - bounds.width / 2;\n     *     bounds.y = pt.y - bounds.height / 2;\n     *   }\n     *\n     *   return bounds;\n     * };\n     * ```\n     *\n     * @param state <CellState> that represents the current state of the\n     * associated cell.\n     */\n    getBounds(state) {\n        const isEdge = state.cell.isEdge();\n        const s = state.view.scale;\n        let pt = null;\n        const image = this.image;\n        const w = image.width;\n        const h = image.height;\n        if (isEdge) {\n            const pts = state.absolutePoints;\n            if (pts.length % 2 === 1) {\n                pt = pts[Math.floor(pts.length / 2)];\n            }\n            else {\n                const idx = pts.length / 2;\n                const p0 = pts[idx - 1];\n                const p1 = pts[idx];\n                pt = new Point(p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);\n            }\n        }\n        else {\n            pt = new Point();\n            if (this.align === 'left') {\n                pt.x = state.x;\n            }\n            else if (this.align === 'center') {\n                pt.x = state.x + state.width / 2;\n            }\n            else if (this.align === 'right') {\n                pt.x = state.x + state.width;\n            }\n            else {\n                throw new Error();\n            }\n            if (this.verticalAlign === 'top') {\n                pt.y = state.y;\n            }\n            else if (this.verticalAlign === 'middle') {\n                pt.y = state.y + state.height / 2;\n            }\n            else if (this.verticalAlign === 'bottom') {\n                pt.y = state.y + state.height;\n            }\n            else {\n                throw new Error();\n            }\n        }\n        return new Rectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);\n    }\n    /**\n     * Returns the textual representation of the overlay to be used as the\n     * tooltip. This implementation returns <tooltip>.\n     */\n    toString() {\n        return this.tooltip;\n    }\n}\nexport default CellOverlay;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellOverlay from '../cell/CellOverlay';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const OverlaysMixin = {\n    addCellOverlay(cell, overlay) {\n        cell.overlays.push(overlay);\n        // Immediately update the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        this.fireEvent(new EventObject(InternalEvent.ADD_OVERLAY, { cell, overlay }));\n        return overlay;\n    },\n    getCellOverlays(cell) {\n        return cell.overlays;\n    },\n    removeCellOverlay(cell, overlay = null) {\n        if (!overlay) {\n            this.removeCellOverlays(cell);\n        }\n        else {\n            const index = cell.overlays.indexOf(overlay);\n            if (index >= 0) {\n                cell.overlays.splice(index, 1);\n                // Immediately updates the cell display if the state exists\n                const state = this.getView().getState(cell);\n                if (state) {\n                    this.getCellRenderer().redraw(state);\n                }\n                this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, { cell, overlay }));\n            }\n            else {\n                overlay = null;\n            }\n        }\n        return overlay;\n    },\n    removeCellOverlays(cell) {\n        const { overlays } = cell;\n        cell.overlays = [];\n        // Immediately updates the cell display if the state exists\n        const state = this.getView().getState(cell);\n        if (state) {\n            this.getCellRenderer().redraw(state);\n        }\n        for (let i = 0; i < overlays.length; i += 1) {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));\n        }\n        return overlays;\n    },\n    clearCellOverlays(cell = null) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell)\n            return;\n        this.removeCellOverlays(cell);\n        // Recursively removes all overlays from the children\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            this.clearCellOverlays(child); // recurse\n        }\n    },\n    setCellWarning(cell, warning = null, img, isSelect = false) {\n        img = img ?? this.getWarningImage();\n        if (warning && warning.length > 0) {\n            // Creates the overlay with the image and warning\n            const overlay = new CellOverlay(img, `<font color=red>${warning}</font>`);\n            // Adds a handler for single mouseclicks to select the cell\n            if (isSelect) {\n                overlay.addListener(InternalEvent.CLICK, (sender, evt) => {\n                    if (this.isEnabled()) {\n                        this.setSelectionCell(cell);\n                    }\n                });\n            }\n            // Sets and returns the overlay in the graph\n            return this.addCellOverlay(cell, overlay);\n        }\n        this.removeCellOverlays(cell);\n        return null;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\nimport PolylineShape from '../geometry/edge/PolylineShape';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const PageBreaksMixin = {\n    horizontalPageBreaks: null,\n    verticalPageBreaks: null,\n    updatePageBreaks(visible, _width, _height) {\n        const { scale, translate: tr } = this.getView();\n        const fmt = this.getPageFormat();\n        const ps = scale * this.getPageScale();\n        const bounds = new Rectangle(0, 0, fmt.width * ps, fmt.height * ps);\n        const gb = Rectangle.fromRectangle(this.getGraphBounds());\n        gb.width = Math.max(1, gb.width);\n        gb.height = Math.max(1, gb.height);\n        bounds.x =\n            Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n        bounds.y =\n            Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n        gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n        gb.height =\n            Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n        // Does not show page breaks if the scale is too small\n        visible =\n            visible && Math.min(bounds.width, bounds.height) > this.getMinPageBreakDist();\n        const horizontalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n        const verticalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n        const right = (verticalCount - 1) * bounds.width;\n        const bottom = (horizontalCount - 1) * bounds.height;\n        if (this.horizontalPageBreaks == null && horizontalCount > 0) {\n            this.horizontalPageBreaks = [];\n        }\n        if (this.verticalPageBreaks == null && verticalCount > 0) {\n            this.verticalPageBreaks = [];\n        }\n        const drawPageBreaks = (breaks) => {\n            if (breaks != null) {\n                const count = breaks === this.horizontalPageBreaks ? horizontalCount : verticalCount;\n                for (let i = 0; i <= count; i += 1) {\n                    const pts = breaks === this.horizontalPageBreaks\n                        ? [\n                            new Point(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),\n                            new Point(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height)),\n                        ]\n                        : [\n                            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),\n                            new Point(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom)),\n                        ];\n                    if (breaks[i] != null) {\n                        breaks[i].points = pts;\n                        breaks[i].redraw();\n                    }\n                    else {\n                        const pageBreak = new PolylineShape(pts, this.getPageBreakColor());\n                        pageBreak.dialect = this.getDialect();\n                        pageBreak.pointerEvents = false;\n                        pageBreak.isDashed = this.isPageBreakDashed();\n                        pageBreak.init(this.getView().backgroundPane);\n                        pageBreak.redraw();\n                        breaks[i] = pageBreak;\n                    }\n                }\n                for (let i = count; i < breaks.length; i += 1) {\n                    breaks[i].destroy();\n                }\n                breaks.splice(count, breaks.length - count);\n            }\n        };\n        drawPageBreaks(this.horizontalPageBreaks);\n        drawPageBreaks(this.verticalPageBreaks);\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\nimport Point from '../geometry/Point';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const PanningMixin = {\n    shiftPreview1: null,\n    shiftPreview2: null,\n    useScrollbarsForPanning: true,\n    isUseScrollbarsForPanning() {\n        return this.useScrollbarsForPanning;\n    },\n    timerAutoScroll: false,\n    isTimerAutoScroll() {\n        return this.timerAutoScroll;\n    },\n    allowAutoPanning: false,\n    isAllowAutoPanning() {\n        return this.allowAutoPanning;\n    },\n    panDx: 0,\n    getPanDx() {\n        return this.panDx;\n    },\n    setPanDx(dx) {\n        this.panDx = dx;\n    },\n    panDy: 0,\n    getPanDy() {\n        return this.panDy;\n    },\n    setPanDy(dy) {\n        this.panDy = dy;\n    },\n    panGraph(dx, dy) {\n        const container = this.getContainer();\n        if (this.useScrollbarsForPanning && hasScrollbars(container)) {\n            container.scrollLeft = -dx;\n            container.scrollTop = -dy;\n        }\n        else {\n            const canvas = this.getView().getCanvas();\n            // Puts everything inside the container in a DIV so that it\n            // can be moved without changing the state of the container\n            if (dx === 0 && dy === 0) {\n                canvas.removeAttribute('transform');\n                if (this.shiftPreview1) {\n                    let child = this.shiftPreview1.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (this.shiftPreview1.parentNode) {\n                        this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n                    }\n                    this.shiftPreview1 = null;\n                    container.appendChild(canvas.parentNode);\n                    const shiftPreview2 = this.shiftPreview2;\n                    child = shiftPreview2.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        container.appendChild(child);\n                        child = next;\n                    }\n                    if (shiftPreview2.parentNode) {\n                        shiftPreview2.parentNode.removeChild(shiftPreview2);\n                    }\n                    this.shiftPreview2 = null;\n                }\n            }\n            else {\n                canvas.setAttribute('transform', `translate(${dx},${dy})`);\n                if (!this.shiftPreview1) {\n                    // Needs two divs for stuff before and after the SVG element\n                    this.shiftPreview1 = document.createElement('div');\n                    this.shiftPreview1.style.position = 'absolute';\n                    this.shiftPreview1.style.overflow = 'visible';\n                    this.shiftPreview2 = document.createElement('div');\n                    this.shiftPreview2.style.position = 'absolute';\n                    this.shiftPreview2.style.overflow = 'visible';\n                    let current = this.shiftPreview1;\n                    let child = container.firstChild;\n                    while (child) {\n                        const next = child.nextSibling;\n                        // SVG element is moved via transform attribute\n                        // @ts-ignore\n                        if (child !== canvas.parentNode) {\n                            current.appendChild(child);\n                        }\n                        else {\n                            current = this.shiftPreview2;\n                        }\n                        child = next;\n                    }\n                    // Inserts elements only if not empty\n                    if (this.shiftPreview1.firstChild) {\n                        container.insertBefore(this.shiftPreview1, canvas.parentNode);\n                    }\n                    if (this.shiftPreview2.firstChild) {\n                        container.appendChild(this.shiftPreview2);\n                    }\n                }\n                this.shiftPreview1.style.left = `${dx}px`;\n                this.shiftPreview1.style.top = `${dy}px`;\n                if (this.shiftPreview2) {\n                    this.shiftPreview2.style.left = `${dx}px`;\n                    this.shiftPreview2.style.top = `${dy}px`;\n                }\n            }\n            this.panDx = dx;\n            this.panDy = dy;\n            this.fireEvent(new EventObject(InternalEvent.PAN));\n        }\n    },\n    scrollCellToVisible(cell, center = false) {\n        const x = -this.getView().translate.x;\n        const y = -this.getView().translate.y;\n        const state = this.getView().getState(cell);\n        if (state) {\n            const bounds = new Rectangle(x + state.x, y + state.y, state.width, state.height);\n            if (center && this.getContainer()) {\n                const w = this.getContainer().clientWidth;\n                const h = this.getContainer().clientHeight;\n                bounds.x = bounds.getCenterX() - w / 2;\n                bounds.width = w;\n                bounds.y = bounds.getCenterY() - h / 2;\n                bounds.height = h;\n            }\n            const tr = new Point(this.getView().translate.x, this.getView().translate.y);\n            if (this.scrollRectToVisible(bounds)) {\n                // Triggers an update via the view's event source\n                const tr2 = new Point(this.getView().translate.x, this.getView().translate.y);\n                this.getView().translate.x = tr.x;\n                this.getView().translate.y = tr.y;\n                this.getView().setTranslate(tr2.x, tr2.y);\n            }\n        }\n    },\n    scrollRectToVisible(rect) {\n        let isChanged = false;\n        const container = this.getContainer();\n        const w = container.offsetWidth;\n        const h = container.offsetHeight;\n        const widthLimit = Math.min(w, rect.width);\n        const heightLimit = Math.min(h, rect.height);\n        if (hasScrollbars(container)) {\n            rect.x += this.getView().translate.x;\n            rect.y += this.getView().translate.y;\n            let dx = container.scrollLeft - rect.x;\n            const ddx = Math.max(dx - container.scrollLeft, 0);\n            if (dx > 0) {\n                container.scrollLeft -= dx + 2;\n            }\n            else {\n                dx = rect.x + widthLimit - container.scrollLeft - container.clientWidth;\n                if (dx > 0) {\n                    container.scrollLeft += dx + 2;\n                }\n            }\n            let dy = container.scrollTop - rect.y;\n            const ddy = Math.max(0, dy - container.scrollTop);\n            if (dy > 0) {\n                container.scrollTop -= dy + 2;\n            }\n            else {\n                dy = rect.y + heightLimit - container.scrollTop - container.clientHeight;\n                if (dy > 0) {\n                    container.scrollTop += dy + 2;\n                }\n            }\n            if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {\n                this.getView().setTranslate(ddx, ddy);\n            }\n        }\n        else {\n            const x = -this.getView().translate.x;\n            const y = -this.getView().translate.y;\n            const s = this.getView().scale;\n            if (rect.x + widthLimit > x + w) {\n                this.getView().translate.x -= (rect.x + widthLimit - w - x) / s;\n                isChanged = true;\n            }\n            if (rect.y + heightLimit > y + h) {\n                this.getView().translate.y -= (rect.y + heightLimit - h - y) / s;\n                isChanged = true;\n            }\n            if (rect.x < x) {\n                this.getView().translate.x += (x - rect.x) / s;\n                isChanged = true;\n            }\n            if (rect.y < y) {\n                this.getView().translate.y += (y - rect.y) / s;\n                isChanged = true;\n            }\n            if (isChanged) {\n                this.getView().refresh();\n                const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n                // Repaints selection marker (ticket 18)\n                if (selectionCellsHandler) {\n                    selectionCellsHandler.refresh();\n                }\n            }\n        }\n        return isChanged;\n    },\n    setPanning(enabled) {\n        const panningHandler = this.getPlugin('PanningHandler');\n        panningHandler && (panningHandler.panningEnabled = enabled);\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nexport const PortsMixin = {\n    portsEnabled: true,\n    isPort(cell) {\n        return false;\n    },\n    getTerminalForPort(cell, _source = false) {\n        return cell.getParent();\n    },\n    isPortsEnabled() {\n        return this.portsEnabled;\n    },\n    setPortsEnabled(value) {\n        this.portsEnabled = value;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Dictionary from '../../util/Dictionary';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SelectionMixin = {\n    selectionModel: null,\n    getSelectionModel() {\n        return this.selectionModel;\n    },\n    setSelectionModel(selectionModel) {\n        this.selectionModel = selectionModel;\n    },\n    /*****************************************************************************\n     * Selection\n     *****************************************************************************/\n    isCellSelected(cell) {\n        return this.selectionModel.isSelected(cell);\n    },\n    isSelectionEmpty() {\n        return this.selectionModel.isEmpty();\n    },\n    clearSelection() {\n        this.selectionModel.clear();\n    },\n    getSelectionCount() {\n        return this.selectionModel.cells.length;\n    },\n    getSelectionCell() {\n        return this.selectionModel.cells[0];\n    },\n    getSelectionCells() {\n        return this.selectionModel.cells.slice();\n    },\n    setSelectionCell(cell) {\n        this.selectionModel.setCell(cell);\n    },\n    setSelectionCells(cells) {\n        this.selectionModel.setCells(cells);\n    },\n    addSelectionCell(cell) {\n        this.selectionModel.addCell(cell);\n    },\n    addSelectionCells(cells) {\n        this.selectionModel.addCells(cells);\n    },\n    removeSelectionCell(cell) {\n        this.selectionModel.removeCell(cell);\n    },\n    removeSelectionCells(cells) {\n        this.selectionModel.removeCells(cells);\n    },\n    selectRegion(rect, evt) {\n        const cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n        this.selectCellsForEvent(cells, evt);\n        return cells;\n    },\n    selectNextCell() {\n        this.selectCell(true);\n    },\n    selectPreviousCell() {\n        this.selectCell();\n    },\n    selectParentCell() {\n        this.selectCell(false, true);\n    },\n    selectChildCell() {\n        this.selectCell(false, false, true);\n    },\n    selectCell(isNext = false, isParent = false, isChild = false) {\n        const cell = this.selectionModel.cells.length > 0 ? this.selectionModel.cells[0] : null;\n        if (this.selectionModel.cells.length > 1) {\n            this.selectionModel.clear();\n        }\n        const parent = cell ? cell.getParent() : this.getDefaultParent();\n        const childCount = parent.getChildCount();\n        if (!cell && childCount > 0) {\n            const child = parent.getChildAt(0);\n            this.setSelectionCell(child);\n        }\n        else if (parent &&\n            (!cell || isParent) &&\n            this.getView().getState(parent) &&\n            parent.getGeometry()) {\n            if (this.getCurrentRoot() !== parent) {\n                this.setSelectionCell(parent);\n            }\n        }\n        else if (cell && isChild) {\n            const tmp = cell.getChildCount();\n            if (tmp > 0) {\n                const child = cell.getChildAt(0);\n                this.setSelectionCell(child);\n            }\n        }\n        else if (childCount > 0) {\n            let i = parent.getIndex(cell);\n            if (isNext) {\n                i++;\n                const child = parent.getChildAt(i % childCount);\n                this.setSelectionCell(child);\n            }\n            else {\n                i--;\n                const index = i < 0 ? childCount - 1 : i;\n                const child = parent.getChildAt(index);\n                this.setSelectionCell(child);\n            }\n        }\n    },\n    selectAll(parent, descendants = false) {\n        parent = parent ?? this.getDefaultParent();\n        const cells = descendants\n            ? parent.filterDescendants((cell) => {\n                return cell !== parent && !!this.getView().getState(cell);\n            })\n            : parent.getChildren();\n        this.setSelectionCells(cells);\n    },\n    selectVertices(parent, selectGroups = false) {\n        this.selectCells(true, false, parent, selectGroups);\n    },\n    selectEdges(parent) {\n        this.selectCells(false, true, parent);\n    },\n    selectCells(vertices = false, edges = false, parent, selectGroups = false) {\n        parent = parent ?? this.getDefaultParent();\n        const filter = (cell) => {\n            const p = cell.getParent();\n            return (!!this.getView().getState(cell) &&\n                (((selectGroups || cell.getChildCount() === 0) &&\n                    cell.isVertex() &&\n                    vertices &&\n                    p &&\n                    !p.isEdge()) ||\n                    (cell.isEdge() && edges)));\n        };\n        const cells = parent.filterDescendants(filter);\n        this.setSelectionCells(cells);\n    },\n    selectCellForEvent(cell, evt) {\n        const isSelected = this.isCellSelected(cell);\n        if (this.isToggleEvent(evt)) {\n            if (isSelected) {\n                this.removeSelectionCell(cell);\n            }\n            else {\n                this.addSelectionCell(cell);\n            }\n        }\n        else if (!isSelected || this.getSelectionCount() !== 1) {\n            this.setSelectionCell(cell);\n        }\n    },\n    selectCellsForEvent(cells, evt) {\n        if (this.isToggleEvent(evt)) {\n            this.addSelectionCells(cells);\n        }\n        else {\n            this.setSelectionCells(cells);\n        }\n    },\n    isSiblingSelected(cell) {\n        const parent = cell.getParent();\n        const childCount = parent.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (cell !== child && this.isCellSelected(child)) {\n                return true;\n            }\n        }\n        return false;\n    },\n    /*****************************************************************************\n     * Selection state\n     *****************************************************************************/\n    getSelectionCellsForChanges(changes, ignoreFn = null) {\n        const dict = new Dictionary();\n        const cells = [];\n        const addCell = (cell) => {\n            if (!dict.get(cell) && this.getDataModel().contains(cell)) {\n                if (cell.isEdge() || cell.isVertex()) {\n                    dict.put(cell, true);\n                    cells.push(cell);\n                }\n                else {\n                    const childCount = cell.getChildCount();\n                    for (let i = 0; i < childCount; i += 1) {\n                        addCell(cell.getChildAt(i));\n                    }\n                }\n            }\n        };\n        for (let i = 0; i < changes.length; i += 1) {\n            const change = changes[i];\n            if (change.constructor !== RootChange && (!ignoreFn || !ignoreFn(change))) {\n                let cell = null;\n                if (change instanceof ChildChange) {\n                    cell = change.child;\n                }\n                else if (change.cell && change.cell instanceof Cell) {\n                    cell = change.cell;\n                }\n                if (cell) {\n                    addCell(cell);\n                }\n            }\n        }\n        return cells;\n    },\n    updateSelection() {\n        const cells = this.getSelectionCells();\n        const removed = [];\n        for (const cell of cells) {\n            if (!this.getDataModel().contains(cell) || !cell.isVisible()) {\n                removed.push(cell);\n            }\n            else {\n                let par = cell.getParent();\n                while (par && par !== this.getView().currentRoot) {\n                    if (par.isCollapsed() || !par.isVisible()) {\n                        removed.push(cell);\n                        break;\n                    }\n                    par = par.getParent();\n                }\n            }\n        }\n        this.removeSelectionCells(removed);\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SnapMixin = {\n    snapTolerance: 0,\n    getSnapTolerance() {\n        return this.snapTolerance;\n    },\n    gridSize: 10,\n    gridEnabled: true,\n    snap(value) {\n        if (this.gridEnabled) {\n            value = Math.round(value / this.gridSize) * this.gridSize;\n        }\n        return value;\n    },\n    snapDelta(delta, bounds, ignoreGrid = false, ignoreHorizontal = false, ignoreVertical = false) {\n        const t = this.getView().translate;\n        const s = this.getView().scale;\n        if (!ignoreGrid && this.gridEnabled) {\n            const tol = this.gridSize * s * 0.5;\n            if (!ignoreHorizontal) {\n                const tx = bounds.x - (this.snap(bounds.x / s - t.x) + t.x) * s;\n                if (Math.abs(delta.x - tx) < tol) {\n                    delta.x = 0;\n                }\n                else {\n                    delta.x = this.snap(delta.x / s) * s - tx;\n                }\n            }\n            if (!ignoreVertical) {\n                const ty = bounds.y - (this.snap(bounds.y / s - t.y) + t.y) * s;\n                if (Math.abs(delta.y - ty) < tol) {\n                    delta.y = 0;\n                }\n                else {\n                    delta.y = this.snap(delta.y / s) * s - ty;\n                }\n            }\n        }\n        else {\n            const tol = 0.5 * s;\n            if (!ignoreHorizontal) {\n                const tx = bounds.x - (Math.round(bounds.x / s - t.x) + t.x) * s;\n                if (Math.abs(delta.x - tx) < tol) {\n                    delta.x = 0;\n                }\n                else {\n                    delta.x = Math.round(delta.x / s) * s - tx;\n                }\n            }\n            if (!ignoreVertical) {\n                const ty = bounds.y - (Math.round(bounds.y / s - t.y) + t.y) * s;\n                if (Math.abs(delta.y - ty) < tol) {\n                    delta.y = 0;\n                }\n                else {\n                    delta.y = Math.round(delta.y / s) * s - ty;\n                }\n            }\n        }\n        return delta;\n    },\n    isGridEnabled() {\n        return this.gridEnabled;\n    },\n    setGridEnabled(value) {\n        this.gridEnabled = value;\n    },\n    getGridSize() {\n        return this.gridSize;\n    },\n    setGridSize(value) {\n        this.gridSize = value;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { convertPoint } from '../../util/styleUtils';\nimport { mod } from '../../util/mathUtils';\nimport { DEFAULT_STARTSIZE, DIRECTION, SHAPE } from '../../util/Constants';\nimport { getClientX, getClientY } from '../../util/EventUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const SwimlaneMixin = {\n    swimlaneSelectionEnabled: true,\n    swimlaneNesting: true,\n    swimlaneIndicatorColorAttribute: 'fillColor',\n    getSwimlane(cell = null) {\n        while (cell && !this.isSwimlane(cell)) {\n            cell = cell.getParent();\n        }\n        return cell;\n    },\n    getSwimlaneAt(x, y, parent) {\n        if (!parent) {\n            parent = this.getCurrentRoot();\n            if (!parent) {\n                parent = this.getDataModel().getRoot();\n            }\n        }\n        if (parent) {\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (child) {\n                    const result = this.getSwimlaneAt(x, y, child);\n                    if (result != null) {\n                        return result;\n                    }\n                    if (child.isVisible() && this.isSwimlane(child)) {\n                        const state = this.getView().getState(child);\n                        if (state && this.intersects(state, x, y)) {\n                            return child;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    },\n    hitsSwimlaneContent(swimlane, x, y) {\n        const state = this.getView().getState(swimlane);\n        const size = this.getStartSize(swimlane);\n        if (state) {\n            const scale = this.getView().getScale();\n            x -= state.x;\n            y -= state.y;\n            if (size.width > 0 && x > 0 && x > size.width * scale) {\n                return true;\n            }\n            if (size.height > 0 && y > 0 && y > size.height * scale) {\n                return true;\n            }\n        }\n        return false;\n    },\n    getStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        const style = this.getCurrentCellStyle(swimlane, ignoreState);\n        const size = style.startSize ?? DEFAULT_STARTSIZE;\n        if (style.horizontal ?? true) {\n            result.height = size;\n        }\n        else {\n            result.width = size;\n        }\n        return result;\n    },\n    getSwimlaneDirection(style) {\n        const dir = style.direction ?? DIRECTION.EAST;\n        const flipH = style.flipH;\n        const flipV = style.flipV;\n        const h = style.horizontal ?? true;\n        let n = h ? 0 : 3;\n        if (dir === DIRECTION.NORTH) {\n            n--;\n        }\n        else if (dir === DIRECTION.WEST) {\n            n += 2;\n        }\n        else if (dir === DIRECTION.SOUTH) {\n            n += 1;\n        }\n        const _mod = mod(n, 2);\n        if (flipH && _mod === 1) {\n            n += 2;\n        }\n        if (flipV && _mod === 0) {\n            n += 2;\n        }\n        return [DIRECTION.NORTH, DIRECTION.EAST, DIRECTION.SOUTH, DIRECTION.WEST][mod(n, 4)];\n    },\n    getActualStartSize(swimlane, ignoreState = false) {\n        const result = new Rectangle();\n        if (this.isSwimlane(swimlane, ignoreState)) {\n            const style = this.getCurrentCellStyle(swimlane, ignoreState);\n            const size = style.startSize ?? DEFAULT_STARTSIZE;\n            const dir = this.getSwimlaneDirection(style);\n            if (dir === DIRECTION.NORTH) {\n                result.y = size;\n            }\n            else if (dir === DIRECTION.WEST) {\n                result.x = size;\n            }\n            else if (dir === DIRECTION.SOUTH) {\n                result.height = size;\n            }\n            else {\n                result.width = size;\n            }\n        }\n        return result;\n    },\n    isSwimlane(cell, ignoreState = false) {\n        if (cell && cell.getParent() !== this.getDataModel().getRoot() && !cell.isEdge()) {\n            return this.getCurrentCellStyle(cell, ignoreState).shape === SHAPE.SWIMLANE;\n        }\n        return false;\n    },\n    isValidDropTarget(cell, cells, evt) {\n        return (cell &&\n            ((this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt)) ||\n                (!cell.isEdge() &&\n                    (this.isSwimlane(cell) || (cell.getChildCount() > 0 && !cell.isCollapsed())))));\n    },\n    getDropTarget(cells, evt, cell = null, clone = false) {\n        if (!this.isSwimlaneNesting()) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (this.isSwimlane(cells[i])) {\n                    return null;\n                }\n            }\n        }\n        const pt = convertPoint(this.getContainer(), getClientX(evt), getClientY(evt));\n        pt.x -= this.getPanDx();\n        pt.y -= this.getPanDy();\n        const swimlane = this.getSwimlaneAt(pt.x, pt.y);\n        if (!cell) {\n            cell = swimlane;\n        }\n        else if (swimlane) {\n            // Checks if the cell is an ancestor of the swimlane\n            // under the mouse and uses the swimlane in that case\n            let tmp = swimlane.getParent();\n            while (tmp && this.isSwimlane(tmp) && tmp !== cell) {\n                tmp = tmp.getParent();\n            }\n            if (tmp === cell) {\n                cell = swimlane;\n            }\n        }\n        while (cell &&\n            !this.isValidDropTarget(cell, cells, evt) &&\n            !this.getDataModel().isLayer(cell)) {\n            cell = cell.getParent();\n        }\n        // Checks if parent is dropped into child if not cloning\n        let parentCell = cell;\n        if (!clone) {\n            while (parentCell && cells.indexOf(parentCell) < 0) {\n                parentCell = parentCell.getParent();\n            }\n        }\n        return !this.getDataModel().isLayer(cell) && !parentCell ? cell : null;\n    },\n    isSwimlaneNesting() {\n        return this.swimlaneNesting;\n    },\n    setSwimlaneNesting(value) {\n        this.swimlaneNesting = value;\n    },\n    isSwimlaneSelectionEnabled() {\n        return this.swimlaneSelectionEnabled;\n    },\n    setSwimlaneSelectionEnabled(value) {\n        this.swimlaneSelectionEnabled = value;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const TerminalMixin = {\n    isTerminalPointMovable(cell, source) {\n        return true;\n    },\n    getOpposites(edges, terminal = null, includeSources = true, includeTargets = true) {\n        const terminals = [];\n        // Fast lookup to avoid duplicates in terminals array\n        const dict = new Dictionary();\n        for (let i = 0; i < edges.length; i += 1) {\n            const state = this.getView().getState(edges[i]);\n            const source = state\n                ? state.getVisibleTerminal(true)\n                : this.getView().getVisibleTerminal(edges[i], true);\n            const target = state\n                ? state.getVisibleTerminal(false)\n                : this.getView().getVisibleTerminal(edges[i], false);\n            // Checks if the terminal is the source of the edge and if the\n            // target should be stored in the result\n            if (source === terminal && target && target !== terminal && includeTargets) {\n                if (!dict.get(target)) {\n                    dict.put(target, true);\n                    terminals.push(target);\n                }\n            }\n            // Checks if the terminal is the taget of the edge and if the\n            // source should be stored in the result\n            else if (target === terminal && source && source !== terminal && includeSources) {\n                if (!dict.get(source)) {\n                    dict.put(source, true);\n                    terminals.push(source);\n                }\n            }\n        }\n        return terminals;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { htmlEntities } from '../../util/StringUtils';\nimport Translations from '../../util/Translations';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const TooltipMixin = {\n    getTooltip(state, node, x, y) {\n        let tip = null;\n        // Checks if the mouse is over the folding icon\n        if (state.control &&\n            (node === state.control.node || node.parentNode === state.control.node)) {\n            tip = this.getCollapseExpandResource();\n            tip = htmlEntities(Translations.get(tip) || tip, true).replace(/\\\\n/g, '<br>');\n        }\n        if (!tip && state.overlays) {\n            state.overlays.visit((id, shape) => {\n                // LATER: Exit loop if tip is not null\n                if (!tip && (node === shape.node || node.parentNode === shape.node)) {\n                    tip = shape.overlay ? shape.overlay.toString() ?? null : null;\n                }\n            });\n        }\n        if (!tip) {\n            const selectionCellsHandler = this.getPlugin('SelectionCellsHandler');\n            const handler = selectionCellsHandler?.getHandler(state.cell);\n            if (handler &&\n                'getTooltipForNode' in handler &&\n                typeof handler.getTooltipForNode === 'function') {\n                tip = handler.getTooltipForNode(node);\n            }\n        }\n        if (!tip) {\n            tip = this.getTooltipForCell(state.cell);\n        }\n        return tip;\n    },\n    getTooltipForCell(cell) {\n        let tip = null;\n        if (cell && 'getTooltip' in cell) {\n            // @ts-ignore getTooltip() must exists.\n            tip = cell.getTooltip();\n        }\n        else {\n            tip = this.convertValueToString(cell);\n        }\n        return tip;\n    },\n    setTooltips(enabled) {\n        const tooltipHandler = this.getPlugin('TooltipHandler');\n        tooltipHandler?.setEnabled(enabled);\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ValidationMixin = {\n    validationAlert(message) {\n        alert(message);\n    },\n    isEdgeValid(edge, source, target) {\n        return !this.getEdgeValidationError(edge, source, target);\n    },\n    getEdgeValidationError(edge = null, source = null, target = null) {\n        if (edge && !this.isAllowDanglingEdges() && (!source || !target)) {\n            return '';\n        }\n        if (edge && !edge.getTerminal(true) && !edge.getTerminal(false)) {\n            return null;\n        }\n        // Checks if we're dealing with a loop\n        if (!this.isAllowLoops() && source === target && source) {\n            return '';\n        }\n        // Checks if the connection is generally allowed\n        if (!this.isValidConnection(source, target)) {\n            return '';\n        }\n        if (source && target) {\n            let error = '';\n            // Checks if the cells are already connected\n            // and adds an error message if required\n            if (!this.isMultigraph()) {\n                const tmp = this.getDataModel().getEdgesBetween(source, target, true);\n                // Checks if the source and target are not connected by another edge\n                if (tmp.length > 1 || (tmp.length === 1 && tmp[0] !== edge)) {\n                    error += `${Translations.get(this.getAlreadyConnectedResource()) ||\n                        this.getAlreadyConnectedResource()}\\n`;\n                }\n            }\n            // Gets the number of outgoing edges from the source\n            // and the number of incoming edges from the target\n            // without counting the edge being currently changed.\n            const sourceOut = source.getDirectedEdgeCount(true, edge);\n            const targetIn = target.getDirectedEdgeCount(false, edge);\n            // Checks the change against each multiplicity rule\n            for (const multiplicity of this.multiplicities) {\n                const err = multiplicity.check(this, // needs to cast to Graph\n                edge, source, target, sourceOut, targetIn);\n                if (err != null) {\n                    error += err;\n                }\n            }\n            // Validates the source and target terminals independently\n            const err = this.validateEdge(edge, source, target);\n            if (err != null) {\n                error += err;\n            }\n            return error.length > 0 ? error : null;\n        }\n        return this.isAllowDanglingEdges() ? null : '';\n    },\n    validateEdge(edge = null, source = null, target = null) {\n        return null;\n    },\n    validateGraph(cell = null, context) {\n        cell = cell ?? this.getDataModel().getRoot();\n        if (!cell) {\n            return 'The root does not exist!';\n        }\n        context = context ?? {};\n        let isValid = true;\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const tmp = cell.getChildAt(i);\n            let ctx = context;\n            if (this.isValidRoot(tmp)) {\n                ctx = {};\n            }\n            const warn = this.validateGraph(tmp, ctx);\n            if (warn) {\n                this.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n            }\n            else {\n                this.setCellWarning(tmp, null);\n            }\n            isValid = isValid && warn == null;\n        }\n        let warning = '';\n        // Adds error for invalid children if collapsed (children invisible)\n        if (cell && cell.isCollapsed() && !isValid) {\n            warning += `${Translations.get(this.getContainsValidationErrorsResource()) ||\n                this.getContainsValidationErrorsResource()}\\n`;\n        }\n        // Checks edges and cells using the defined multiplicities\n        if (cell && cell.isEdge()) {\n            warning +=\n                this.getEdgeValidationError(cell, cell.getTerminal(true), cell.getTerminal(false)) || '';\n        }\n        else {\n            warning += this.getCellValidationError(cell) || '';\n        }\n        // Checks custom validation rules\n        const err = this.validateCell(cell, context);\n        if (err != null) {\n            warning += err;\n        }\n        // Updates the display with the warning icons\n        // before any potential alerts are displayed.\n        // LATER: Move this into addCellOverlay. Redraw\n        // should check if overlay was added or removed.\n        if (cell.getParent() == null) {\n            this.getView().validate();\n        }\n        return warning.length > 0 || !isValid ? warning : null;\n    },\n    getCellValidationError(cell) {\n        const outCount = cell.getDirectedEdgeCount(true);\n        const inCount = cell.getDirectedEdgeCount(false);\n        const value = cell.getValue();\n        let error = '';\n        for (let i = 0; i < this.multiplicities.length; i += 1) {\n            const rule = this.multiplicities[i];\n            if (rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (outCount > rule.max || outCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n            else if (!rule.source &&\n                isNode(value, rule.type, rule.attr, rule.value) &&\n                (inCount > rule.max || inCount < rule.min)) {\n                error += `${rule.countError}\\n`;\n            }\n        }\n        return error.length > 0 ? error : null;\n    },\n    validateCell(cell, context) {\n        return null;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../cell/Cell';\nimport Geometry from '../geometry/Geometry';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const VertexMixin = {\n    vertexLabelsMovable: false,\n    allowNegativeCoordinates: true,\n    isAllowNegativeCoordinates() {\n        return this.allowNegativeCoordinates;\n    },\n    setAllowNegativeCoordinates(value) {\n        this.allowNegativeCoordinates = value;\n    },\n    insertVertex(...args) {\n        let parent;\n        let id;\n        let value;\n        let x;\n        let y;\n        let width;\n        let height;\n        let style;\n        let relative;\n        let geometryClass;\n        if (args.length === 1 && typeof args[0] === 'object') {\n            const params = args[0];\n            parent = params.parent;\n            id = params.id;\n            value = params.value;\n            x = 'x' in params ? params.x : params.position?.[0];\n            y = 'y' in params ? params.y : params.position?.[1];\n            width = 'width' in params ? params.width : params.size?.[0];\n            height = 'height' in params ? params.height : params.size?.[1];\n            style = params.style;\n            relative = params.relative;\n            geometryClass = params.geometryClass;\n        }\n        else {\n            // Otherwise treat as arguments\n            [parent, id, value, x, y, width, height, style, relative, geometryClass] = args;\n        }\n        const vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative, geometryClass);\n        return this.addCell(vertex, parent);\n    },\n    createVertex(_parent, id, value, x, y, width, height, style, relative = false, geometryClass = Geometry) {\n        // Creates the geometry for the vertex\n        const geometry = new geometryClass(x, y, width, height);\n        geometry.relative = relative;\n        // Creates the vertex\n        const vertex = new Cell(value, geometry, style);\n        vertex.setId(id);\n        vertex.setVertex(true);\n        vertex.setConnectable(true);\n        return vertex;\n    },\n    getChildVertices(parent) {\n        return this.getChildCells(parent, true, false);\n    },\n    isVertexLabelsMovable() {\n        return this.vertexLabelsMovable;\n    },\n    setVertexLabelsMovable(value) {\n        this.vertexLabelsMovable = value;\n    },\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport { hasScrollbars } from '../../util/styleUtils';\n// @ts-expect-error The properties of PartialGraph are defined elsewhere.\nexport const ZoomMixin = {\n    zoomFactor: 1.2,\n    keepSelectionVisibleOnZoom: false,\n    centerZoom: true,\n    zoomIn() {\n        this.zoom(this.zoomFactor);\n    },\n    zoomOut() {\n        this.zoom(1 / this.zoomFactor);\n    },\n    zoomActual() {\n        if (this.getView().scale === 1) {\n            this.getView().setTranslate(0, 0);\n        }\n        else {\n            this.getView().translate.x = 0;\n            this.getView().translate.y = 0;\n            this.getView().setScale(1);\n        }\n    },\n    zoomTo(scale, center = false) {\n        this.zoom(scale / this.getView().scale, center);\n    },\n    zoom(factor, center) {\n        center = center ?? this.centerZoom;\n        const scale = Math.round(this.getView().scale * factor * 100) / 100;\n        const state = this.getView().getState(this.getSelectionCell());\n        const container = this.getContainer();\n        factor = scale / this.getView().scale;\n        if (this.keepSelectionVisibleOnZoom && state != null) {\n            const rect = new Rectangle(state.x * factor, state.y * factor, state.width * factor, state.height * factor);\n            // Refreshes the display only once if a scroll is carried out\n            this.getView().scale = scale;\n            if (!this.scrollRectToVisible(rect)) {\n                this.getView().revalidate();\n                // Forces an event to be fired but does not revalidate again\n                this.getView().setScale(scale);\n            }\n        }\n        else {\n            const _hasScrollbars = hasScrollbars(this.getContainer());\n            if (center && !_hasScrollbars) {\n                let dx = container.offsetWidth;\n                let dy = container.offsetHeight;\n                if (factor > 1) {\n                    const f = (factor - 1) / (scale * 2);\n                    dx *= -f;\n                    dy *= -f;\n                }\n                else {\n                    const f = (1 / factor - 1) / (this.getView().scale * 2);\n                    dx *= f;\n                    dy *= f;\n                }\n                this.getView().scaleAndTranslate(scale, this.getView().translate.x + dx, this.getView().translate.y + dy);\n            }\n            else {\n                // Allows for changes of translate and scrollbars during setscale\n                const tx = this.getView().translate.x;\n                const ty = this.getView().translate.y;\n                const sl = container.scrollLeft;\n                const st = container.scrollTop;\n                this.getView().setScale(scale);\n                if (_hasScrollbars) {\n                    let dx = 0;\n                    let dy = 0;\n                    if (center) {\n                        dx = (container.offsetWidth * (factor - 1)) / 2;\n                        dy = (container.offsetHeight * (factor - 1)) / 2;\n                    }\n                    container.scrollLeft =\n                        (this.getView().translate.x - tx) * this.getView().scale +\n                            Math.round(sl * factor + dx);\n                    container.scrollTop =\n                        (this.getView().translate.y - ty) * this.getView().scale +\n                            Math.round(st * factor + dy);\n                }\n            }\n        }\n    },\n    zoomToRect(rect) {\n        const container = this.getContainer();\n        const scaleX = container.clientWidth / rect.width;\n        const scaleY = container.clientHeight / rect.height;\n        const aspectFactor = scaleX / scaleY;\n        // Remove any overlap of the rect outside the client area\n        rect.x = Math.max(0, rect.x);\n        rect.y = Math.max(0, rect.y);\n        let rectRight = Math.min(container.scrollWidth, rect.x + rect.width);\n        let rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);\n        rect.width = rectRight - rect.x;\n        rect.height = rectBottom - rect.y;\n        // The selection area has to be increased to the same aspect\n        // ratio as the container, centred around the centre point of the\n        // original rect passed in.\n        if (aspectFactor < 1.0) {\n            // Height needs increasing\n            const newHeight = rect.height / aspectFactor;\n            const deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n            rect.height = newHeight;\n            // Assign up to half the buffer to the upper part of the rect, not crossing 0\n            // put the rest on the bottom\n            const upperBuffer = Math.min(rect.y, deltaHeightBuffer);\n            rect.y -= upperBuffer;\n            // Check if the bottom has extended too far\n            rectBottom = Math.min(container.scrollHeight, rect.y + rect.height);\n            rect.height = rectBottom - rect.y;\n        }\n        else {\n            // Width needs increasing\n            const newWidth = rect.width * aspectFactor;\n            const deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n            rect.width = newWidth;\n            // Assign up to half the buffer to the upper part of the rect, not crossing 0\n            // put the rest on the bottom\n            const leftBuffer = Math.min(rect.x, deltaWidthBuffer);\n            rect.x -= leftBuffer;\n            // Check if the right hand side has extended too far\n            rectRight = Math.min(container.scrollWidth, rect.x + rect.width);\n            rect.width = rectRight - rect.x;\n        }\n        const scale = container.clientWidth / rect.width;\n        const newScale = this.getView().scale * scale;\n        if (!hasScrollbars(this.getContainer())) {\n            this.getView().scaleAndTranslate(newScale, this.getView().translate.x - rect.x / this.getView().scale, this.getView().translate.y - rect.y / this.getView().scale);\n        }\n        else {\n            this.getView().setScale(newScale);\n            container.scrollLeft = Math.round(rect.x * scale);\n            container.scrollTop = Math.round(rect.y * scale);\n        }\n    },\n};\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { mixInto } from '../../util/Utils';\nimport { Graph } from '../Graph';\nimport { CellsMixin } from './CellsMixin';\nimport { ConnectionsMixin } from './ConnectionsMixin';\nimport { DragDropMixin } from './DragDropMixin';\nimport { EdgeMixin } from './EdgeMixin';\nimport { EditingMixin } from './EditingMixin';\nimport { EventsMixin } from './EventsMixin';\nimport { FoldingMixin } from './FoldingMixin';\nimport { GroupingMixin } from './GroupingMixin';\nimport { ImageMixin } from './ImageMixin';\nimport { LabelMixin } from './LabelMixin';\nimport { OrderMixin } from './OrderMixin';\nimport { OverlaysMixin } from './OverlaysMixin';\nimport { PageBreaksMixin } from './PageBreaksMixin';\nimport { PanningMixin } from './PanningMixin';\nimport { PortsMixin } from './PortsMixin';\nimport { SelectionMixin } from './SelectionMixin';\nimport { SnapMixin } from './SnapMixin';\nimport { SwimlaneMixin } from './SwimlaneMixin';\nimport { TerminalMixin } from './TerminalMixin';\nimport { TooltipMixin } from './TooltipMixin';\nimport { ValidationMixin } from './ValidationMixin';\nimport { VertexMixin } from './VertexMixin';\nimport { ZoomMixin } from './ZoomMixin';\nexport const applyGraphMixins = () => {\n    const mixIntoGraph = mixInto(Graph);\n    // Apply the mixins in alphabetic order to ease maintenance.\n    // The order should have no influence of the resulting Graph prototype.\n    for (const mixin of [\n        CellsMixin,\n        ConnectionsMixin,\n        DragDropMixin,\n        EdgeMixin,\n        EditingMixin,\n        EventsMixin,\n        FoldingMixin,\n        GroupingMixin,\n        ImageMixin,\n        LabelMixin,\n        OrderMixin,\n        PageBreaksMixin,\n        OverlaysMixin,\n        PanningMixin,\n        PortsMixin,\n        SelectionMixin,\n        SnapMixin,\n        SwimlaneMixin,\n        TerminalMixin,\n        TooltipMixin,\n        ValidationMixin,\n        VertexMixin,\n        ZoomMixin,\n    ]) {\n        mixIntoGraph(mixin);\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getValue } from '../../util/Utils';\nimport { getAlignmentAsPoint, setPrefixedStyle } from '../../util/styleUtils';\nimport Rectangle from '../geometry/Rectangle';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { ABSOLUTE_LINE_HEIGHT, ALIGN, DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, DEFAULT_TEXT_DIRECTION, DIALECT, FONT, LINE_HEIGHT, NONE, WORD_WRAP, } from '../../util/Constants';\nimport TextShape from '../geometry/node/TextShape';\nimport { clearSelection, extractTextWithWhitespace, isNode } from '../../util/domUtils';\nimport { getStringValue, htmlEntities, replaceTrailingNewlines, } from '../../util/StringUtils';\nimport { getSource, isConsumed, isControlDown, isMetaDown, isShiftDown, } from '../../util/EventUtils';\n/**\n * In-place editor for the graph. To control this editor, use\n * {@link Graph#invokesStopCellEditing}, {@link Graph#enterStopsCellEditing} and\n * {@link Graph#escapeEnabled}. If {@link Graph#enterStopsCellEditing} is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n *\n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n *\n * ```javascript\n * graph.cellEditor.getEditorBounds = (state)=>\n * {\n *   let result = getEditorBounds.apply(this, arguments);\n *\n *   if (this.graph.getDataModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *\n *   return result;\n * };\n * ```\n *\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then {@link Shape#getLabelBounds} is used to compute the current bounds of the textbox.\n *\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n *\n * To only allow numeric input in the in-place editor, use the following code.\n *\n * ```javascript\n * let text = graph.cellEditor.textarea;\n *\n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * });\n * ```\n *\n * Placeholder:\n *\n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n *\n * Resize in Chrome:\n *\n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n *\n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n *\n * ```javascript\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, (evt)=>\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *\n *     if (Client.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * ```\n *\n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n *\n * ```javascript\n * let graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = (evtName, me, sender)=>\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *\n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * ```\n *\n * @category Plugin\n */\nclass CellEditorHandler {\n    constructor(graph) {\n        this.clearOnChange = false;\n        this.bounds = null;\n        this.resizeThread = null;\n        this.textDirection = null;\n        /**\n         * Holds the DIV that is used for text editing. Note that this may be null before the first\n         * edit. Instantiated in <init>.\n         */\n        this.textarea = null;\n        /**\n         * Reference to the <Cell> that is currently being edited.\n         */\n        // editingCell: mxCell;\n        this.editingCell = null;\n        /**\n         * Reference to the event that was used to start editing.\n         */\n        // trigger: MouseEvent;\n        this.trigger = null;\n        /**\n         * Specifies if the label has been modified.\n         */\n        // modified: boolean;\n        this.modified = false;\n        /**\n         * Specifies if the textarea should be resized while the text is being edited.\n         * Default is true.\n         */\n        // autoSize: boolean;\n        this.autoSize = true;\n        /**\n         * Specifies if the text should be selected when editing starts. Default is\n         * true.\n         */\n        // selectText: boolean;\n        this.selectText = true;\n        /**\n         * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n         * a workaround for the missing cursor bug for empty content editable. This can\n         * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n         * value is only displayed before the first keystroke and is never used as the\n         * actual editing value.\n         */\n        // emptyLabelText: '<br>' | '';\n        this.emptyLabelText = Client.IS_FF ? '<br>' : '';\n        /**\n         * If true, pressing the escape key will stop editing and not accept the new\n         * value. Change this to false to accept the new value on escape, and cancel\n         * editing on Shift+Escape instead. Default is true.\n         */\n        // escapeCancelsEditing: boolean;\n        this.escapeCancelsEditing = true;\n        /**\n         * Reference to the label DOM node that has been hidden.\n         */\n        // textNode: string;\n        this.textNode = null;\n        /**\n         * Specifies the zIndex for the textarea. Default is 5.\n         */\n        // zIndex: number;\n        this.zIndex = 5;\n        /**\n         * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n         */\n        // minResize: mxRectangle;\n        this.minResize = new Rectangle(0, 20);\n        /**\n         * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n         * 11 and 1 in all other browsers and modes.\n         */\n        // wordWrapPadding: 2 | 1 | 0;\n        this.wordWrapPadding = 0;\n        /**\n         * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n         */\n        // blurEnabled: boolean;\n        this.blurEnabled = false;\n        /**\n         * Holds the initial editing value to check if the current value was modified.\n         */\n        // initialValue: string;\n        this.initialValue = null;\n        /**\n         * Holds the current temporary horizontal alignment for the cell style. If this\n         * is modified then the current text alignment is changed and the cell style is\n         * updated when the value is applied.\n         */\n        this.align = null;\n        this.graph = graph;\n        // Stops editing after zoom changes\n        this.zoomHandler = () => {\n            if (this.graph.isEditing()) {\n                this.resize();\n            }\n        };\n        // Handling of deleted cells while editing\n        this.changeHandler = (sender) => {\n            if (this.editingCell && !this.graph.getView().getState(this.editingCell, false)) {\n                this.stopEditing(true);\n            }\n        };\n        this.graph.getView().addListener(InternalEvent.SCALE, this.zoomHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n    }\n    /**\n     * Creates the <textarea> and installs the event listeners. The key handler\n     * updates the {@link odified} state.\n     */\n    init() {\n        this.textarea = document.createElement('div');\n        this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n        this.textarea.contentEditable = String(true);\n        // Workaround for selection outside of DIV if height is 0\n        if (Client.IS_GC) {\n            this.textarea.style.minHeight = '1em';\n        }\n        this.textarea.style.position = 'relative';\n        this.installListeners(this.textarea);\n    }\n    /**\n     * Called in <stopEditing> if cancel is false to invoke {@link Graph#labelChanged}.\n     */\n    // applyValue(state: CellState, value: string): void;\n    applyValue(state, value) {\n        this.graph.labelChanged(state.cell, value, this.trigger);\n    }\n    /**\n     * Sets the temporary horizontal alignment for the current editing session.\n     */\n    setAlign(align) {\n        if (this.textarea) {\n            this.textarea.style.textAlign = align;\n        }\n        this.align = align;\n        this.resize();\n    }\n    /**\n     * Gets the initial editing value for the given cell.\n     */\n    getInitialValue(state, trigger) {\n        let result = htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n        result = replaceTrailingNewlines(result, '<div><br></div>');\n        return result.replace(/\\n/g, '<br>');\n    }\n    /**\n     * Returns the current editing value.\n     */\n    getCurrentValue(state) {\n        if (!this.textarea)\n            return null;\n        return extractTextWithWhitespace(Array.from(this.textarea.childNodes));\n    }\n    /**\n     * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n     * are not pressed.\n     */\n    // isCancelEditingKeyEvent(evt: Event): boolean;\n    isCancelEditingKeyEvent(evt) {\n        return (this.escapeCancelsEditing ||\n            isShiftDown(evt) ||\n            isControlDown(evt) ||\n            isMetaDown(evt));\n    }\n    /**\n     * Installs listeners for focus, change and standard key event handling.\n     */\n    // installListeners(elt: Element): void;\n    installListeners(elt) {\n        // Applies value if text is dragged\n        // LATER: Gesture mouse events ignored for starting move\n        InternalEvent.addListener(elt, 'dragstart', (evt) => {\n            this.graph.stopEditing(false);\n            InternalEvent.consume(evt);\n        });\n        // Applies value if focus is lost\n        InternalEvent.addListener(elt, 'blur', (evt) => {\n            if (this.blurEnabled) {\n                this.focusLost();\n            }\n        });\n        // Updates modified state and handles placeholder text\n        InternalEvent.addListener(elt, 'keydown', (evt) => {\n            if (!isConsumed(evt)) {\n                if (this.isStopEditingEvent(evt)) {\n                    this.graph.stopEditing(false);\n                    InternalEvent.consume(evt);\n                }\n                else if (evt.keyCode === 27 /* Escape */) {\n                    this.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n                    InternalEvent.consume(evt);\n                }\n            }\n        });\n        // Keypress only fires if printable key was pressed and handles removing the empty placeholder\n        const keypressHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Clears the initial empty label on the first keystroke\n                // and workaround for FF which fires keypress for delete and backspace\n                if (this.clearOnChange &&\n                    elt.innerHTML === this.getEmptyLabelText() &&\n                    (!Client.IS_FF ||\n                        (evt.keyCode !== 8 /* Backspace */ && evt.keyCode !== 46)) /* Delete */) {\n                    this.clearOnChange = false;\n                    elt.innerHTML = '';\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'keypress', keypressHandler);\n        InternalEvent.addListener(elt, 'paste', keypressHandler);\n        // Handler for updating the empty label text value after a change\n        const keyupHandler = (evt) => {\n            if (this.editingCell != null) {\n                // Uses an optional text value for sempty labels which is cleared\n                // when the first keystroke appears. This makes it easier to see\n                // that a label is being edited even if the label is empty.\n                // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n                const textarea = this.textarea;\n                if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                    textarea.innerHTML = this.getEmptyLabelText();\n                    this.clearOnChange = textarea.innerHTML.length > 0;\n                }\n                else {\n                    this.clearOnChange = false;\n                }\n            }\n        };\n        InternalEvent.addListener(elt, 'input', keyupHandler);\n        InternalEvent.addListener(elt, 'cut', keyupHandler);\n        InternalEvent.addListener(elt, 'paste', keyupHandler);\n        // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n        const evtName = 'input';\n        const resizeHandler = (evt) => {\n            if (this.editingCell != null && this.autoSize && !isConsumed(evt)) {\n                // Asynchronous is needed for keydown and shows better results for input events overall\n                // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n                if (this.resizeThread != null) {\n                    window.clearTimeout(this.resizeThread);\n                }\n                this.resizeThread = window.setTimeout(() => {\n                    this.resizeThread = null;\n                    this.resize();\n                }, 0);\n            }\n        };\n        InternalEvent.addListener(elt, evtName, resizeHandler);\n        InternalEvent.addListener(window, 'resize', resizeHandler);\n        InternalEvent.addListener(elt, 'cut', resizeHandler);\n        InternalEvent.addListener(elt, 'paste', resizeHandler);\n    }\n    /**\n     * Returns true if the given keydown event should stop cell editing. This\n     * returns true if F2 is pressed of if {@link Graph#enterStopsCellEditing} is true\n     * and enter is pressed without control or shift.\n     */\n    isStopEditingEvent(evt) {\n        return (evt.keyCode === 113 /* F2 */ ||\n            (this.graph.isEnterStopsCellEditing() &&\n                evt.keyCode === 13 /* Enter */ &&\n                !isControlDown(evt) &&\n                !isShiftDown(evt)));\n    }\n    /**\n     * Returns true if this editor is the source for the given native event.\n     */\n    isEventSource(evt) {\n        return getSource(evt) === this.textarea;\n    }\n    /**\n     * Returns {@link odified}.\n     */\n    resize() {\n        const state = this.editingCell\n            ? this.graph.getView().getState(this.editingCell)\n            : null;\n        if (!state) {\n            this.stopEditing(true);\n        }\n        else if (this.textarea != null) {\n            const isEdge = state.cell.isEdge();\n            const { scale } = this.graph.getView();\n            let m = null;\n            if (!this.autoSize || state.style.overflow === 'fill') {\n                // Specifies the bounds of the editor box\n                this.bounds = this.getEditorBounds(state);\n                this.textarea.style.width = `${Math.round(this.bounds.width / scale)}px`;\n                this.textarea.style.height = `${Math.round(this.bounds.height / scale)}px`;\n                // FIXME: Offset when scaled\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x + 1))}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y + 1))}px`;\n                // Installs native word wrapping and avoids word wrap for empty label placeholder\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = `${Math.round(this.bounds.width / scale) + this.wordWrapPadding}px`;\n                    }\n                }\n                else {\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    if (state.style.overflow !== 'fill') {\n                        this.textarea.style.width = '';\n                    }\n                }\n            }\n            else {\n                const lw = getValue(state.style, 'labelWidth', null);\n                m = state.text != null && this.align == null ? state.text.margin : null;\n                if (m == null) {\n                    m = getAlignmentAsPoint(this.align || getValue(state.style, 'align', ALIGN.CENTER), getValue(state.style, 'verticalAlign', ALIGN.MIDDLE));\n                }\n                if (isEdge) {\n                    this.bounds = new Rectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n                    if (lw != null) {\n                        const tmp = (parseFloat(lw) + 2) * scale;\n                        this.bounds.width = tmp;\n                        this.bounds.x += m.x * tmp;\n                    }\n                }\n                else {\n                    let bounds = Rectangle.fromRectangle(state);\n                    let hpos = getValue(state.style, 'labelPosition', ALIGN.CENTER);\n                    let vpos = getValue(state.style, 'verticalLabelPosition', ALIGN.MIDDLE);\n                    bounds =\n                        state.shape != null && hpos === 'center' && vpos === 'middle'\n                            ? state.shape.getLabelBounds(bounds)\n                            : bounds;\n                    if (lw != null) {\n                        bounds.width = parseFloat(lw) * scale;\n                    }\n                    if (!state.view.graph.cellRenderer.legacySpacing ||\n                        state.style.overflow !== 'width') {\n                        // @ts-ignore\n                        const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n                        const spacing = (state.style.spacing ?? 2) * scale;\n                        const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n                        const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale +\n                            spacing;\n                        const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale +\n                            spacing;\n                        const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n                        hpos =\n                            state.style.labelPosition != null ? state.style.labelPosition : 'center';\n                        vpos =\n                            state.style.verticalLabelPosition != null\n                                ? state.style.verticalLabelPosition\n                                : 'middle';\n                        bounds = new Rectangle(bounds.x + spacingLeft, bounds.y + spacingTop, bounds.width -\n                            (hpos === ALIGN.CENTER && lw == null ? spacingLeft + spacingRight : 0), bounds.height - (vpos === ALIGN.MIDDLE ? spacingTop + spacingBottom : 0));\n                    }\n                    this.bounds = new Rectangle(bounds.x + state.absoluteOffset.x, bounds.y + state.absoluteOffset.y, bounds.width, bounds.height);\n                }\n                // Needed for word wrap inside text blocks with oversize lines to match the final result where\n                // the width of the longest line is used as the reference for text alignment in the cell\n                // TODO: Fix word wrapping preview for edge labels in helloworld.html\n                if (this.graph.isWrapping(state.cell) &&\n                    (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n                    this.textarea.innerHTML !== this.getEmptyLabelText()) {\n                    this.textarea.style.wordWrap = WORD_WRAP;\n                    this.textarea.style.whiteSpace = 'normal';\n                    // Forces automatic reflow if text is removed from an oversize label and normal word wrap\n                    const tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;\n                    if (this.textarea.style.position !== 'relative') {\n                        this.textarea.style.width = `${tmp}px`;\n                        if (this.textarea.scrollWidth > tmp) {\n                            this.textarea.style.width = `${this.textarea.scrollWidth}px`;\n                        }\n                    }\n                    else {\n                        this.textarea.style.maxWidth = `${tmp}px`;\n                    }\n                }\n                else {\n                    // KNOWN: Trailing cursor in IE9 quirks mode is not visible\n                    this.textarea.style.whiteSpace = 'nowrap';\n                    this.textarea.style.width = '';\n                }\n                const ow = this.textarea.scrollWidth;\n                const oh = this.textarea.scrollHeight;\n                // TODO: Update CSS width and height if smaller than minResize or remove minResize\n                // if (this.minResize != null)\n                // {\n                //  ow = Math.max(ow, this.minResize.width);\n                //  oh = Math.max(oh, this.minResize.height);\n                // }\n                // LATER: Keep in visible area, add fine tuning for pixel precision\n                this.textarea.style.left = `${Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1)}px`;\n                this.textarea.style.top = `${Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y === -1 ? 3 : 0)) + 1)}px`;\n            }\n            setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n            setPrefixedStyle(this.textarea.style, 'transform', `scale(${scale},${scale})${m == null ? '' : ` translate(${m.x * 100}%,${m.y * 100}%)`}`);\n        }\n    }\n    /**\n     * Called if the textarea has lost focus.\n     */\n    focusLost() {\n        this.stopEditing(!this.graph.isInvokesStopCellEditing());\n    }\n    /**\n     * Returns the background color for the in-place editor. This implementation\n     * always returns NONE.\n     */\n    getBackgroundColor(state) {\n        return NONE;\n    }\n    /**\n     * Starts the editor for the given cell.\n     *\n     * @param cell <Cell> to start editing.\n     * @param trigger Optional mouse event that triggered the editor.\n     */\n    startEditing(cell, trigger = null) {\n        this.stopEditing(true);\n        this.align = null;\n        // Creates new textarea instance\n        if (this.textarea == null) {\n            this.init();\n        }\n        const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n        tooltipHandler?.hideTooltip();\n        const state = this.graph.getView().getState(cell);\n        if (state) {\n            // Configures the style of the in-place editor\n            const { scale } = this.graph.getView();\n            const size = state.style.fontSize ?? DEFAULT_FONTSIZE;\n            const family = state.style.fontFamily ?? DEFAULT_FONTFAMILY;\n            const color = state.style.fontColor ?? 'black';\n            const align = state.style.align ?? ALIGN.LEFT;\n            const bold = (state.style.fontStyle || 0) & FONT.BOLD;\n            const italic = (state.style.fontStyle || 0) & FONT.ITALIC;\n            const txtDecor = [];\n            if ((state.style.fontStyle || 0) & FONT.UNDERLINE) {\n                txtDecor.push('underline');\n            }\n            if ((state.style.fontStyle || 0) & FONT.STRIKETHROUGH) {\n                txtDecor.push('line-through');\n            }\n            const textarea = this.textarea;\n            textarea.style.lineHeight = ABSOLUTE_LINE_HEIGHT\n                ? `${Math.round(size * LINE_HEIGHT)}px`\n                : String(LINE_HEIGHT);\n            textarea.style.backgroundColor = this.getBackgroundColor(state) || 'transparent';\n            textarea.style.textDecoration = txtDecor.join(' ');\n            textarea.style.fontWeight = bold ? 'bold' : 'normal';\n            textarea.style.fontStyle = italic ? 'italic' : '';\n            textarea.style.fontSize = `${Math.round(size)}px`;\n            textarea.style.zIndex = String(this.zIndex);\n            textarea.style.fontFamily = family;\n            textarea.style.textAlign = align;\n            textarea.style.outline = 'none';\n            textarea.style.color = color;\n            let dir = (this.textDirection =\n                state.style.textDirection ?? DEFAULT_TEXT_DIRECTION);\n            if (dir === 'auto') {\n                if (state.text !== null &&\n                    state.text.dialect !== DIALECT.STRICTHTML &&\n                    !isNode(state.text.value)) {\n                    dir = state.text.getAutoDirection();\n                }\n            }\n            if (dir === 'ltr' || dir === 'rtl') {\n                textarea.setAttribute('dir', dir);\n            }\n            else {\n                textarea.removeAttribute('dir');\n            }\n            // Sets the initial editing value\n            textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n            this.initialValue = textarea.innerHTML;\n            // Uses an optional text value for empty labels which is cleared\n            // when the first keystroke appears. This makes it easier to see\n            // that a label is being edited even if the label is empty.\n            if (textarea.innerHTML.length === 0 || textarea.innerHTML === '<br>') {\n                textarea.innerHTML = this.getEmptyLabelText();\n                this.clearOnChange = true;\n            }\n            else {\n                this.clearOnChange = textarea.innerHTML === this.getEmptyLabelText();\n            }\n            // @ts-ignore\n            this.graph.container.appendChild(textarea);\n            // Update this after firing all potential events that could update the cleanOnChange flag\n            this.editingCell = cell;\n            this.trigger = trigger;\n            this.textNode = null;\n            if (state.text !== null && this.isHideLabel(state)) {\n                this.textNode = state.text.node;\n                this.textNode.style.visibility = 'hidden';\n            }\n            // Workaround for initial offsetHeight not ready for heading in markup\n            if (this.autoSize && (state.cell.isEdge() || state.style.overflow !== 'fill')) {\n                window.setTimeout(() => {\n                    this.resize();\n                }, 0);\n            }\n            this.resize();\n            // Workaround for NS_ERROR_FAILURE in FF\n            try {\n                // Prefers blinking cursor over no selected text if empty\n                textarea.focus();\n                if (this.isSelectText() &&\n                    textarea.innerHTML.length > 0 &&\n                    (textarea.innerHTML !== this.getEmptyLabelText() || !this.clearOnChange)) {\n                    document.execCommand('selectAll', false);\n                }\n            }\n            catch (e) {\n                // ignore\n            }\n        }\n    }\n    /**\n     * Returns <selectText>.\n     */\n    isSelectText() {\n        return this.selectText;\n    }\n    /**\n    clearSelection() {\n      const selection = window.getSelection();\n  \n      if (selection) {\n        if (selection.empty) {\n          selection.empty();\n        } else if (selection.removeAllRanges) {\n          selection.removeAllRanges();\n        }\n      }\n    }\n  \n    /**\n     * Stops the editor and applies the value if cancel is false.\n     */\n    stopEditing(cancel = false) {\n        if (this.editingCell) {\n            if (this.textNode) {\n                this.textNode.style.visibility = 'visible';\n                this.textNode = null;\n            }\n            const state = !cancel ? this.graph.view.getState(this.editingCell) : null;\n            const textarea = this.textarea;\n            const initial = this.initialValue;\n            this.initialValue = null;\n            this.editingCell = null;\n            this.trigger = null;\n            this.bounds = null;\n            textarea.blur();\n            clearSelection();\n            if (textarea.parentNode) {\n                textarea.parentNode.removeChild(textarea);\n            }\n            if (this.clearOnChange && textarea.innerHTML === this.getEmptyLabelText()) {\n                textarea.innerHTML = '';\n                this.clearOnChange = false;\n            }\n            if (state && (textarea.innerHTML !== initial || this.align !== null)) {\n                this.prepareTextarea();\n                const value = this.getCurrentValue(state);\n                this.graph.batchUpdate(() => {\n                    if (value !== null) {\n                        this.applyValue(state, value);\n                    }\n                    if (this.align !== null) {\n                        this.graph.setCellStyles('align', this.align, [state.cell]);\n                    }\n                });\n            }\n            // Forces new instance on next edit for undo history reset\n            if (this.textarea)\n                InternalEvent.release(this.textarea);\n            this.textarea = null;\n            this.align = null;\n        }\n    }\n    /**\n     * Prepares the textarea for getting its value in <stopEditing>.\n     * This implementation removes the extra trailing linefeed in Firefox.\n     */\n    prepareTextarea() {\n        const textarea = this.textarea;\n        if (textarea.lastChild && textarea.lastChild.nodeName === 'BR') {\n            textarea.removeChild(textarea.lastChild);\n        }\n    }\n    /**\n     * Returns true if the label should be hidden while the cell is being\n     * edited.\n     */\n    isHideLabel(state = null) {\n        return true;\n    }\n    /**\n     * Returns the minimum width and height for editing the given state.\n     */\n    getMinimumSize(state) {\n        const { scale } = this.graph.getView();\n        const textarea = this.textarea;\n        return new Rectangle(0, 0, state.text === null ? 30 : state.text.size * scale + 20, textarea.style.textAlign === 'left' ? 120 : 40);\n    }\n    /**\n     * Returns the {@link Rectangle} that defines the bounds of the editor.\n     */\n    getEditorBounds(state) {\n        const isEdge = state.cell.isEdge();\n        const { scale } = this.graph.getView();\n        const minSize = this.getMinimumSize(state);\n        const minWidth = minSize.width;\n        const minHeight = minSize.height;\n        let result = null;\n        if (!isEdge &&\n            state.view.graph.cellRenderer.legacySpacing &&\n            state.style.overflow === 'fill') {\n            result = state.shape.getLabelBounds(Rectangle.fromRectangle(state));\n        }\n        else {\n            // @ts-ignore\n            const dummy = new TextShape(); // FIXME!!!! ===================================================================================================\n            const spacing = (state.style.spacing ?? 0) * scale;\n            const spacingTop = ((state.style.spacingTop ?? 0) + dummy.baseSpacingTop) * scale + spacing;\n            const spacingRight = ((state.style.spacingRight ?? 0) + dummy.baseSpacingRight) * scale + spacing;\n            const spacingBottom = ((state.style.spacingBottom ?? 0) + dummy.baseSpacingBottom) * scale + spacing;\n            const spacingLeft = ((state.style.spacingLeft ?? 0) + dummy.baseSpacingLeft) * scale + spacing;\n            result = new Rectangle(state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));\n            const hpos = state.style.labelPosition != null ? state.style.labelPosition : 'center';\n            const vpos = state.style.verticalLabelPosition != null\n                ? state.style.verticalLabelPosition\n                : 'middle';\n            result =\n                state.shape != null && hpos === 'center' && vpos === 'middle'\n                    ? state.shape.getLabelBounds(result)\n                    : result;\n            if (isEdge) {\n                result.x = state.absoluteOffset.x;\n                result.y = state.absoluteOffset.y;\n                if (state.text != null && state.text.boundingBox != null) {\n                    // Workaround for label containing just spaces in which case\n                    // the bounding box location contains negative numbers\n                    if (state.text.boundingBox.x > 0) {\n                        result.x = state.text.boundingBox.x;\n                    }\n                    if (state.text.boundingBox.y > 0) {\n                        result.y = state.text.boundingBox.y;\n                    }\n                }\n            }\n            else if (state.text != null && state.text.boundingBox != null) {\n                result.x = Math.min(result.x, state.text.boundingBox.x);\n                result.y = Math.min(result.y, state.text.boundingBox.y);\n            }\n            result.x += spacingLeft;\n            result.y += spacingTop;\n            if (state.text != null && state.text.boundingBox != null) {\n                if (!isEdge) {\n                    result.width = Math.max(result.width, state.text.boundingBox.width);\n                    result.height = Math.max(result.height, state.text.boundingBox.height);\n                }\n                else {\n                    result.width = Math.max(minWidth, state.text.boundingBox.width);\n                    result.height = Math.max(minHeight, state.text.boundingBox.height);\n                }\n            }\n            // Applies the horizontal and vertical label positions\n            if (state.cell.isVertex()) {\n                const horizontal = (getStringValue(state.style, 'labelPosition', ALIGN.CENTER));\n                if (horizontal === 'left') {\n                    result.x -= state.width;\n                }\n                else if (horizontal === 'right') {\n                    result.x += state.width;\n                }\n                const vertical = state.style.verticalLabelPosition != null\n                    ? state.style.verticalLabelPosition\n                    : 'middle';\n                if (vertical === 'top') {\n                    result.y -= state.height;\n                }\n                else if (vertical === 'bottom') {\n                    result.y += state.height;\n                }\n            }\n        }\n        return new Rectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n    }\n    /**\n     * Returns the initial label value to be used of the label of the given\n     * cell is empty. This label is displayed and cleared on the first keystroke.\n     * This implementation returns <emptyLabelText>.\n     *\n     * @param cell <Cell> for which a text for an empty editing box should be\n     * returned.\n     */\n    getEmptyLabelText(cell = null) {\n        return this.emptyLabelText ?? '';\n    }\n    /**\n     * Returns the cell that is currently being edited or null if no cell is\n     * being edited.\n     */\n    getEditingCell() {\n        return this.editingCell;\n    }\n    /**\n     * Destroys the editor and removes all associated resources.\n     */\n    onDestroy() {\n        if (this.textarea) {\n            InternalEvent.release(this.textarea);\n            if (this.textarea.parentNode) {\n                this.textarea.parentNode.removeChild(this.textarea);\n            }\n            this.textarea = null;\n        }\n        this.graph.getDataModel().removeListener(this.changeHandler);\n        this.graph.getView().removeListener(this.zoomHandler);\n    }\n}\nCellEditorHandler.pluginId = 'CellEditorHandler';\nexport default CellEditorHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport { fit, getScrollOrigin } from '../../util/styleUtils';\nimport { TOOLTIP_VERTICAL_OFFSET } from '../../util/Constants';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { isNode } from '../../util/domUtils';\n/**\n * Graph event handler that displays tooltips.\n *\n * {@link Graph#getTooltip} is used to get the tooltip for a cell or handle.\n *\n * This handler is generally enabled using {@link Graph#setTooltips}.\n *\n * @category Plugin\n */\nclass TooltipHandler {\n    /**\n     * Constructs an event handler that displays tooltips.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     */\n    constructor(graph) {\n        /**\n         * Specifies the zIndex for the tooltip and its shadow.\n         * @default 10005\n         */\n        this.zIndex = 10005;\n        /**\n         * Delay to show the tooltip in milliseconds.\n         * @default 500\n         */\n        this.delay = 500;\n        /**\n         * Specifies if touch and pen events should be ignored.\n         * @default true\n         */\n        this.ignoreTouchEvents = true;\n        /**\n         * Specifies if the tooltip should be hidden if the mouse is moved over the current cell.\n         * @default false\n         */\n        this.hideOnHover = false;\n        /**\n         * `true` if this handler was destroyed using {@link onDestroy}.\n         */\n        this.destroyed = false;\n        this.lastX = 0;\n        this.lastY = 0;\n        this.state = null;\n        this.stateSource = false;\n        this.thread = null;\n        /**\n         * Specifies if events are handled.\n         * @default false\n         */\n        this.enabled = false;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        this.div = document.createElement('div');\n        this.div.className = 'mxTooltip';\n        this.div.style.visibility = 'hidden';\n        document.body.appendChild(this.div);\n        InternalEvent.addGestureListeners(this.div, (evt) => {\n            const source = getSource(evt);\n            // @ts-ignore nodeName may exist\n            if (source && source.nodeName !== 'A') {\n                this.hideTooltip();\n            }\n        });\n        // Hides tooltips and resets tooltip timer if mouse leaves container\n        InternalEvent.addListener(this.graph.getContainer(), 'mouseleave', (evt) => {\n            if (this.div !== evt.relatedTarget) {\n                this.hide();\n            }\n        });\n    }\n    /**\n     * Returns `true` if events are handled.\n     *\n     * This implementation returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling.\n     *\n     * This implementation updates {@link enabled}.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns {@link hideOnHover}.\n     */\n    isHideOnHover() {\n        return this.hideOnHover;\n    }\n    /**\n     * Sets <hideOnHover>.\n     */\n    setHideOnHover(value) {\n        this.hideOnHover = value;\n    }\n    /**\n     * Returns the <CellState> to be used for showing a tooltip for this event.\n     */\n    getStateForEvent(me) {\n        return me.getState();\n    }\n    /**\n     * Handles the event by initiating a rubberband selection. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        this.reset(me, false);\n        this.hideTooltip();\n    }\n    /**\n     * Handles the event by updating the rubberband selection.\n     */\n    mouseMove(sender, me) {\n        if (me.getX() !== this.lastX || me.getY() !== this.lastY) {\n            this.reset(me, true);\n            const state = this.getStateForEvent(me);\n            if (this.isHideOnHover() ||\n                state !== this.state ||\n                (me.getSource() !== this.node &&\n                    (!this.stateSource ||\n                        (state != null &&\n                            this.stateSource ===\n                                (me.isSource(state.shape) || !me.isSource(state.text)))))) {\n                this.hideTooltip();\n            }\n        }\n        this.lastX = me.getX();\n        this.lastY = me.getY();\n    }\n    /**\n     * Handles the event by resetting the tooltip timer or hiding the existing\n     * tooltip.\n     */\n    mouseUp(sender, me) {\n        this.reset(me, true);\n        this.hideTooltip();\n    }\n    /**\n     * Resets the timer.\n     */\n    resetTimer() {\n        if (this.thread) {\n            window.clearTimeout(this.thread);\n            this.thread = null;\n        }\n    }\n    /**\n     * Resets and/or restarts the timer to trigger the display of the tooltip.\n     */\n    reset(me, restart, state = null) {\n        if (!this.ignoreTouchEvents || isMouseEvent(me.getEvent())) {\n            this.resetTimer();\n            state = state ?? this.getStateForEvent(me);\n            if (restart &&\n                this.isEnabled() &&\n                state &&\n                this.div.style.visibility === 'hidden') {\n                const node = me.getSource();\n                const x = me.getX();\n                const y = me.getY();\n                const stateSource = me.isSource(state.shape) || me.isSource(state.text);\n                const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n                this.thread = window.setTimeout(() => {\n                    if (state &&\n                        node &&\n                        !this.graph.isEditing() &&\n                        popupMenuHandler &&\n                        !popupMenuHandler.isMenuShowing() &&\n                        !this.graph.isMouseDown) {\n                        // Uses information from inside event cause using the event at\n                        // this (delayed) point in time is not possible in IE as it no\n                        // longer contains the required information (member not found)\n                        const tip = this.graph.getTooltip(state, node, x, y);\n                        this.show(tip, x, y);\n                        this.state = state;\n                        this.node = node;\n                        this.stateSource = stateSource;\n                    }\n                }, this.delay);\n            }\n        }\n    }\n    /**\n     * Hides the tooltip and resets the timer.\n     */\n    hide() {\n        this.resetTimer();\n        this.hideTooltip();\n    }\n    /**\n     * Hides the tooltip.\n     */\n    hideTooltip() {\n        this.div.style.visibility = 'hidden';\n        this.div.innerHTML = '';\n    }\n    /**\n     * Shows the tooltip for the specified cell and optional index at the\n     * specified location (with a vertical offset of 10 pixels).\n     */\n    show(tip, x, y) {\n        if (!this.destroyed && tip && tip !== '') {\n            const origin = getScrollOrigin();\n            this.div.style.zIndex = String(this.zIndex);\n            this.div.style.left = `${x + origin.x}px`;\n            this.div.style.top = `${y + TOOLTIP_VERTICAL_OFFSET + origin.y}px`;\n            if (!isNode(tip)) {\n                this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n            }\n            else {\n                this.div.innerHTML = '';\n                this.div.appendChild(tip);\n            }\n            this.div.style.visibility = '';\n            fit(this.div);\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        if (!this.destroyed) {\n            this.graph.removeMouseListener(this);\n            InternalEvent.release(this.div);\n            if (this.div.parentNode) {\n                this.div.parentNode.removeChild(this.div);\n            }\n            this.destroyed = true;\n        }\n    }\n}\nTooltipHandler.pluginId = 'TooltipHandler';\nexport default TooltipHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport Dictionary from '../../util/Dictionary';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { sortCells } from '../../util/styleUtils';\n/**\n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n *\n * Group: Events\n *\n * Event: mxEvent.ADD\n *\n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <CellState> that has been added.\n *\n * Event: mxEvent.REMOVE\n *\n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <CellState> that has been removed.\n *\n * @category Plugin\n */\nclass SelectionCellsHandler extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Defines the maximum number of handlers to paint individually. Default is 100.\n         */\n        this.maxHandlers = 100;\n        this.graph = graph;\n        this.handlers = new Dictionary();\n        this.graph.addMouseListener(this);\n        this.refreshHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.refresh();\n            }\n        };\n        this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.refreshHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.refreshHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.refreshHandler);\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns the handler for the given cell.\n     */\n    getHandler(cell) {\n        return this.handlers.get(cell);\n    }\n    /**\n     * Returns true if the given cell has a handler.\n     */\n    isHandled(cell) {\n        return !!this.getHandler(cell);\n    }\n    /**\n     * Resets all handlers.\n     */\n    reset() {\n        this.handlers.visit((key, handler) => {\n            handler.reset.apply(handler);\n        });\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    getHandledSelectionCells() {\n        return this.graph.getSelectionCells();\n    }\n    /**\n     * Reloads or updates all handlers.\n     */\n    refresh() {\n        // Removes all existing handlers\n        const oldHandlers = this.handlers;\n        this.handlers = new Dictionary();\n        // Creates handles for all selection cells\n        const tmp = sortCells(this.getHandledSelectionCells(), false);\n        // Destroys or updates old handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = oldHandlers.remove(tmp[i]);\n                if (handler) {\n                    if (handler.state !== state) {\n                        handler.onDestroy();\n                        handler = null;\n                    }\n                    else if (!this.isHandlerActive(handler)) {\n                        // @ts-ignore refresh may exist\n                        if (handler.refresh)\n                            handler.refresh();\n                        handler.redraw();\n                    }\n                }\n                if (handler) {\n                    this.handlers.put(tmp[i], handler);\n                }\n            }\n        }\n        // Destroys unused handlers\n        oldHandlers.visit((key, handler) => {\n            this.fireEvent(new EventObject(InternalEvent.REMOVE, { state: handler.state }));\n            handler.onDestroy();\n        });\n        // Creates new handlers and updates parent highlight on existing handlers\n        for (let i = 0; i < tmp.length; i += 1) {\n            const state = this.graph.view.getState(tmp[i]);\n            if (state) {\n                let handler = this.handlers.get(tmp[i]);\n                if (!handler) {\n                    handler = this.graph.createHandler(state);\n                    this.fireEvent(new EventObject(InternalEvent.ADD, { state }));\n                    this.handlers.put(tmp[i], handler);\n                }\n                else {\n                    handler.updateParentHighlight();\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given handler is active and should not be redrawn.\n     */\n    isHandlerActive(handler) {\n        return handler.index !== null;\n    }\n    /**\n     * Updates the handler for the given shape if one exists.\n     */\n    updateHandler(state) {\n        let handler = this.handlers.remove(state.cell);\n        if (handler) {\n            // Transfers the current state to the new handler\n            const { index } = handler;\n            const x = handler.startX;\n            const y = handler.startY;\n            handler.onDestroy();\n            handler = this.graph.createHandler(state);\n            if (handler) {\n                this.handlers.put(state.cell, handler);\n                if (index !== null) {\n                    handler.start(x, y, index);\n                }\n            }\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseDown(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseDown(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseMove(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseMove(sender, me);\n            });\n        }\n    }\n    /**\n     * Redirects the given event to the handlers.\n     */\n    mouseUp(sender, me) {\n        if (this.graph.isEnabled() && this.isEnabled()) {\n            this.handlers.visit((key, handler) => {\n                handler.mouseUp(sender, me);\n            });\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.refreshHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.getView().removeListener(this.refreshHandler);\n    }\n}\nSelectionCellsHandler.pluginId = 'SelectionCellsHandler';\nexport default SelectionCellsHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../view/event/EventSource';\nimport { fit, getDocumentScrollOrigin } from '../util/styleUtils';\nimport EventObject from '../view/event/EventObject';\nimport Client from '../Client';\nimport InternalEvent from '../view/event/InternalEvent';\nimport { write } from '../util/domUtils';\nimport { isLeftMouseButton } from '../util/EventUtils';\n/**\n * Basic popup menu.\n *\n * To add a vertical scrollbar to a given submenu, the following code can be used:\n *\n * ```javascript\n * const popupMenu = new MaxPopupMenu(...);\n * const popupMenuShowMenu = popupMenu.showMenu;\n * popupMenu.showMenu = function() {\n *   popupMenuShowMenu.apply(this, []);\n *\n *   this.div.style.overflowY = 'auto';\n *   this.div.style.overflowX = 'hidden';\n *   this.div.style.maxHeight = '160px';\n * };\n * ```\n *\n * ### `InternalEvent.SHOW`\n *\n * Fires after the menu has been shown in {@link popup}.\n */\nclass MaxPopupMenu extends EventSource {\n    constructor(factoryMethod) {\n        super();\n        this.activeRow = null;\n        this.eventReceiver = null;\n        /**\n         * URL of the image to be used for the submenu icon.\n         */\n        this.submenuImage = `${Client.imageBasePath}/submenu.gif`;\n        /**\n         * Specifies the zIndex for the popupmenu and its shadow. Default is 1006.\n         */\n        this.zIndex = 10006;\n        /**\n         * Specifies if popupmenus should be activated by clicking the left mouse\n         * button. Default is false.\n         */\n        this.useLeftButtonForPopup = false;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Contains the number of times <addItem> has been called for a new menu.\n         */\n        this.itemCount = 0;\n        /**\n         * Specifies if submenus should be expanded on mouseover. Default is false.\n         */\n        this.autoExpand = false;\n        /**\n         * Specifies if separators should only be added if a menu item follows them.\n         * Default is false.\n         */\n        this.smartSeparators = false;\n        /**\n         * Specifies if any labels should be visible. Default is true.\n         */\n        this.labels = true;\n        this.willAddSeparator = false;\n        this.containsItems = false;\n        if (factoryMethod) {\n            this.factoryMethod = factoryMethod;\n        }\n        // Adds the inner table\n        this.table = document.createElement('table');\n        this.table.className = 'mxPopupMenu';\n        this.tbody = document.createElement('tbody');\n        this.table.appendChild(this.tbody);\n        // Adds the outer div\n        this.div = document.createElement('div');\n        this.div.className = 'mxPopupMenu';\n        this.div.style.display = 'inline';\n        this.div.style.zIndex = String(this.zIndex);\n        this.div.appendChild(this.table);\n        // Disables the context menu on the outer div\n        InternalEvent.disableContextMenu(this.div);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns true if the given event is a popupmenu trigger for the optional\n     * given cell.\n     *\n     * @param me {@link MouseEvent} that represents the mouse event.\n     */\n    isPopupTrigger(me) {\n        return (me.isPopupTrigger() ||\n            (this.useLeftButtonForPopup && isLeftMouseButton(me.getEvent())));\n    }\n    /**\n     * Adds the given item to the given parent item. If no parent item is specified\n     * then the item is added to the top-level menu. The return value may be used\n     * as the parent argument, ie. as a submenu item. The return value is the table\n     * row that represents the item.\n     *\n     * Paramters:\n     *\n     * title - String that represents the title of the menu item.\n     * image - Optional URL for the image icon.\n     * funct - Function associated that takes a mouseup or touchend event.\n     * parent - Optional item returned by <addItem>.\n     * iconCls - Optional string that represents the CSS class for the image icon.\n     * IconsCls is ignored if image is given.\n     * enabled - Optional boolean indicating if the item is enabled. Default is true.\n     * active - Optional boolean indicating if the menu should implement any event handling.\n     * Default is true.\n     * noHover - Optional boolean to disable hover state.\n     */\n    addItem(title, image, funct, parent = null, iconCls = null, enabled = true, active = true, noHover = false) {\n        parent = (parent ?? this);\n        this.itemCount++;\n        // Smart separators only added if element contains items\n        if (parent.willAddSeparator) {\n            if (parent.containsItems) {\n                this.addSeparator(parent, true);\n            }\n            parent.willAddSeparator = false;\n        }\n        parent.containsItems = true;\n        const tr = document.createElement('tr');\n        tr.className = 'mxPopupMenuItem';\n        const col1 = document.createElement('td');\n        col1.className = 'mxPopupMenuIcon';\n        // Adds the given image into the first column\n        if (image) {\n            const img = document.createElement('img');\n            img.src = image;\n            col1.appendChild(img);\n        }\n        else if (iconCls) {\n            const div = document.createElement('div');\n            div.className = iconCls;\n            col1.appendChild(div);\n        }\n        tr.appendChild(col1);\n        if (this.labels) {\n            const col2 = document.createElement('td');\n            col2.className = `mxPopupMenuItem${!enabled ? ' mxDisabled' : ''}`;\n            write(col2, title);\n            col2.align = 'left';\n            tr.appendChild(col2);\n            const col3 = document.createElement('td');\n            col3.className = `mxPopupMenuItem${!enabled ? ' mxDisabled' : ''}`;\n            col3.style.paddingRight = '6px';\n            col3.style.textAlign = 'right';\n            tr.appendChild(col3);\n            if (parent.div == null) {\n                this.createSubmenu(parent);\n            }\n        }\n        parent.tbody?.appendChild(tr);\n        if (active && enabled) {\n            InternalEvent.addGestureListeners(tr, (evt) => {\n                this.eventReceiver = tr;\n                if (parent && parent.activeRow != tr && parent.activeRow != parent) {\n                    if (parent.activeRow && parent.activeRow.div.parentNode) {\n                        this.hideSubmenu(parent);\n                    }\n                    if (tr.div) {\n                        this.showSubmenu(parent, tr);\n                        parent.activeRow = tr;\n                    }\n                }\n                InternalEvent.consume(evt);\n            }, (_evt) => {\n                if (parent && parent.activeRow != tr && parent.activeRow != parent) {\n                    if (parent.activeRow && parent.activeRow.div.parentNode) {\n                        this.hideSubmenu(parent);\n                    }\n                    if (this.autoExpand && tr.div) {\n                        this.showSubmenu(parent, tr);\n                        parent.activeRow = tr;\n                    }\n                }\n                // Sets hover style because TR in IE doesn't have hover\n                if (!noHover) {\n                    tr.className = 'mxPopupMenuItemHover';\n                }\n            }, (evt) => {\n                // EventReceiver avoids clicks on a submenu item\n                // which has just been shown in the mousedown\n                if (this.eventReceiver == tr) {\n                    if (parent && parent.activeRow != tr) {\n                        this.hideMenu();\n                    }\n                    funct?.(evt);\n                }\n                this.eventReceiver = null;\n                InternalEvent.consume(evt);\n            });\n            // Resets hover style because TR in IE doesn't have hover\n            if (!noHover) {\n                InternalEvent.addListener(tr, 'mouseout', (_evt) => {\n                    tr.className = 'mxPopupMenuItem';\n                });\n            }\n        }\n        return tr;\n    }\n    /**\n     * Adds a checkmark to the given menuitem.\n     */\n    addCheckmark(item, img) {\n        if (item.firstChild) {\n            const td = item.firstChild.nextSibling;\n            td.style.backgroundImage = `url('${img}')`;\n            td.style.backgroundRepeat = 'no-repeat';\n            td.style.backgroundPosition = '2px 50%';\n        }\n    }\n    /**\n     * Creates the nodes required to add submenu items inside the given parent\n     * item. This is called in <addItem> if a parent item is used for the first\n     * time. This adds various DOM nodes and a <submenuImage> to the parent.\n     *\n     * @param parent An item returned by <addItem>.\n     */\n    createSubmenu(parent) {\n        parent.table = document.createElement('table');\n        parent.table.className = 'mxPopupMenu';\n        parent.tbody = document.createElement('tbody');\n        parent.table.appendChild(parent.tbody);\n        parent.div = document.createElement('div');\n        parent.div.className = 'mxPopupMenu';\n        parent.div.style.position = 'absolute';\n        parent.div.style.display = 'inline';\n        parent.div.style.zIndex = String(this.zIndex);\n        parent.div.appendChild(parent.table);\n        const img = document.createElement('img');\n        img.setAttribute('src', this.submenuImage);\n        // Last column of the submenu item in the parent menu\n        if (parent.firstChild?.nextSibling?.nextSibling) {\n            const td = parent.firstChild.nextSibling.nextSibling;\n            td.appendChild(img);\n        }\n    }\n    /**\n     * Shows the submenu inside the given parent row.\n     */\n    showSubmenu(parent, row) {\n        if (row.div) {\n            row.div.style.left = `${parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1}px`;\n            row.div.style.top = `${parent.div.offsetTop + row.offsetTop}px`;\n            document.body.appendChild(row.div);\n            // Moves the submenu to the left side if there is no space\n            const left = row.div.offsetLeft;\n            const width = row.div.offsetWidth;\n            const offset = getDocumentScrollOrigin(document);\n            const b = document.body;\n            const d = document.documentElement;\n            const right = offset.x + (b.clientWidth || d.clientWidth);\n            if (left + width > right) {\n                row.div.style.left = `${Math.max(0, parent.div.offsetLeft - width - 6)}px`;\n            }\n            fit(row.div);\n        }\n    }\n    /**\n     * Adds a horizontal separator in the given parent item or the top-level menu\n     * if no parent is specified.\n     *\n     * @param parent Optional item returned by <addItem>.\n     * @param force Optional boolean to ignore <smartSeparators>. Default is false.\n     */\n    addSeparator(parent = null, force = false) {\n        // Defaults to this instance if no parent (submenu) specified, but\n        // all the necessary DOM elements are present as in PopupMenuItem\n        parent = (parent || this);\n        if (this.smartSeparators && !force) {\n            parent.willAddSeparator = true;\n        }\n        else if (parent.tbody) {\n            parent.willAddSeparator = false;\n            const tr = document.createElement('tr');\n            const col1 = document.createElement('td');\n            col1.className = 'mxPopupMenuIcon';\n            col1.style.padding = '0 0 0 0px';\n            tr.appendChild(col1);\n            const col2 = document.createElement('td');\n            col2.style.padding = '0 0 0 0px';\n            col2.setAttribute('colSpan', '2');\n            const hr = document.createElement('hr');\n            hr.setAttribute('size', '1');\n            col2.appendChild(hr);\n            tr.appendChild(col2);\n            parent.tbody.appendChild(tr);\n        }\n    }\n    /**\n     * Shows the popup menu for the given event and cell.\n     *\n     * Example:\n     *\n     * ```javascript\n     * graph.getPlugin('PanningHandler').popup(x, y, cell, evt)\n     * {\n     *   mxUtils.alert('Hello, World!');\n     * }\n     * ```\n     */\n    popup(x, y, cell, evt) {\n        if (this.div && this.tbody && this.factoryMethod) {\n            this.div.style.left = `${x}px`;\n            this.div.style.top = `${y}px`;\n            // Removes all child nodes from the existing menu\n            while (this.tbody.firstChild) {\n                InternalEvent.release(this.tbody.firstChild);\n                this.tbody.removeChild(this.tbody.firstChild);\n            }\n            this.itemCount = 0;\n            this.factoryMethod(this, cell, evt);\n            if (this.itemCount > 0) {\n                this.showMenu();\n                this.fireEvent(new EventObject(InternalEvent.SHOW));\n            }\n        }\n    }\n    /**\n     * Returns true if the menu is showing.\n     */\n    isMenuShowing() {\n        return this.div && this.div.parentNode == document.body;\n    }\n    /**\n     * Shows the menu.\n     */\n    showMenu() {\n        // Fits the div inside the viewport\n        document.body.appendChild(this.div);\n        fit(this.div);\n    }\n    /**\n     * Removes the menu and all submenus.\n     */\n    hideMenu() {\n        if (this.div) {\n            this.div.parentNode?.removeChild(this.div);\n            this.hideSubmenu(this);\n            this.containsItems = false;\n            this.fireEvent(new EventObject(InternalEvent.HIDE));\n        }\n    }\n    /**\n     * Removes all submenus inside the given parent.\n     *\n     * @param parent An item returned by <addItem>.\n     */\n    hideSubmenu(parent) {\n        if (parent.activeRow) {\n            this.hideSubmenu(parent.activeRow);\n            parent.activeRow.div.parentNode?.removeChild(parent.activeRow.div);\n            parent.activeRow = null;\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    destroy() {\n        if (this.div) {\n            InternalEvent.release(this.div);\n            this.div.parentNode?.removeChild(this.div);\n        }\n    }\n}\nexport default MaxPopupMenu;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport MaxPopupMenu from '../../gui/MaxPopupMenu';\nimport InternalEvent from '../event/InternalEvent';\nimport { getScrollOrigin } from '../../util/styleUtils';\nimport { getMainEvent, isMultiTouchEvent } from '../../util/EventUtils';\n/**\n * Event handler that creates popupmenus.\n *\n * Relates to {@link MaxPopupMenu}.\n *\n * @category Plugin\n */\nclass PopupMenuHandler extends MaxPopupMenu {\n    constructor(graph) {\n        super();\n        this.inTolerance = false;\n        this.popupTrigger = false;\n        /**\n         * Specifies if cells should be selected if a popupmenu is displayed for\n         * them. Default is true.\n         */\n        this.selectOnPopup = true;\n        /**\n         * Specifies if cells should be deselected if a popupmenu is displayed for\n         * the diagram background. Default is true.\n         */\n        this.clearSelectionOnBackground = true;\n        /**\n         * X-coordinate of the mouse down event.\n         */\n        this.triggerX = null;\n        /**\n         * Y-coordinate of the mouse down event.\n         */\n        this.triggerY = null;\n        /**\n         * Screen X-coordinate of the mouse down event.\n         */\n        this.screenX = null;\n        /**\n         * Screen Y-coordinate of the mouse down event.\n         */\n        this.screenY = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Does not show menu if any touch gestures take place after the trigger\n        this.gestureHandler = (sender, eo) => {\n            this.inTolerance = false;\n        };\n        this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);\n        this.init();\n    }\n    /**\n     * Initializes the shapes required for this vertex handler.\n     */\n    init() {\n        // Hides the tooltip if the mouse is over the context menu\n        InternalEvent.addGestureListeners(this.div, (evt) => {\n            const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n            tooltipHandler?.hide();\n        });\n    }\n    /**\n     * Hook for returning if a cell should be selected for a given {@link MouseEvent}.\n     * This implementation returns <selectOnPopup>.\n     */\n    isSelectOnPopup(me) {\n        return this.selectOnPopup;\n    }\n    /**\n     * Handles the event by initiating the panning. By consuming the event all\n     * subsequent events of the gesture are redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        if (this.isEnabled() && !isMultiTouchEvent(me.getEvent())) {\n            // Hides the popupmenu if is is being displayed\n            this.hideMenu();\n            this.triggerX = me.getGraphX();\n            this.triggerY = me.getGraphY();\n            this.screenX = getMainEvent(me.getEvent()).screenX;\n            this.screenY = getMainEvent(me.getEvent()).screenY;\n            this.popupTrigger = this.isPopupTrigger(me);\n            this.inTolerance = true;\n        }\n    }\n    /**\n     * Handles the event by updating the panning on the graph.\n     */\n    mouseMove(sender, me) {\n        // Popup trigger may change on mouseUp so ignore it\n        if (this.inTolerance && this.screenX != null && this.screenY != null) {\n            if (Math.abs(getMainEvent(me.getEvent()).screenX - this.screenX) >\n                this.graph.getEventTolerance() ||\n                Math.abs(getMainEvent(me.getEvent()).screenY - this.screenY) >\n                    this.graph.getEventTolerance()) {\n                this.inTolerance = false;\n            }\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    mouseUp(sender, me) {\n        if (this.popupTrigger &&\n            this.inTolerance &&\n            this.triggerX != null &&\n            this.triggerY != null) {\n            const cell = this.getCellForPopupEvent(me);\n            // Selects the cell for which the context menu is being displayed\n            if (this.graph.isEnabled() &&\n                this.isSelectOnPopup(me) &&\n                cell != null &&\n                !this.graph.isCellSelected(cell)) {\n                this.graph.setSelectionCell(cell);\n            }\n            else if (this.clearSelectionOnBackground && cell == null) {\n                this.graph.clearSelection();\n            }\n            // Hides the tooltip if there is one\n            const tooltipHandler = this.graph.getPlugin('TooltipHandler');\n            tooltipHandler?.hide();\n            // Menu is shifted by 1 pixel so that the mouse up event\n            // is routed via the underlying shape instead of the DIV\n            const origin = getScrollOrigin();\n            this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());\n            me.consume();\n        }\n        this.popupTrigger = false;\n        this.inTolerance = false;\n    }\n    /**\n     * Hook to return the cell for the mouse up popup trigger handling.\n     */\n    getCellForPopupEvent(me) {\n        return me.getCell();\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.gestureHandler);\n        // Supercall\n        super.destroy();\n    }\n}\nPopupMenuHandler.pluginId = 'PopupMenuHandler';\nexport default PopupMenuHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Geometry from '../geometry/Geometry';\nimport Cell from '../cell/Cell';\nimport Point from '../geometry/Point';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { CURSOR, DEFAULT_HOTSPOT, DEFAULT_INVALID_COLOR, DEFAULT_VALID_COLOR, DIALECT, HIGHLIGHT_STROKEWIDTH, INVALID_COLOR, NONE, OUTLINE_HIGHLIGHT_COLOR, OUTLINE_HIGHLIGHT_STROKEWIDTH, TOOLTIP_VERTICAL_OFFSET, VALID_COLOR, } from '../../util/Constants';\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport { convertPoint, getOffset } from '../../util/styleUtils';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport ImageShape from '../geometry/node/ImageShape';\nimport CellMarker from '../cell/CellMarker';\nimport ConstraintHandler from './ConstraintHandler';\nimport PolylineShape from '../geometry/edge/PolylineShape';\nimport EventSource from '../event/EventSource';\nimport Rectangle from '../geometry/Rectangle';\nimport { GlobalConfig } from '../../util/config';\nimport { getClientX, getClientY, isAltDown, isConsumed, isShiftDown, } from '../../util/EventUtils';\n/**\n * Graph event handler that creates new connections. Uses {@link TerminalMarker}\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * {@link Graph#connectionHandler} and enabled using {@link Graph#setConnectable}.\n *\n * Example:\n *\n * ```javascript\n * new mxConnectionHandler(graph, (source, target, style)=>\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * ```\n *\n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * ```javascript\n * mxConnectionHandlerInsertEdge = insertEdge;\n * insertEdge = (parent, id, value, source, target, style)=>\n * {\n *   value = 'Test';\n *\n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * ```\n *\n * Using images to trigger connections:\n *\n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n *\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * {@link Constants#DEFAULT_HOTSPOT} is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * {@link Constants#MIN_HOTSPOT_SIZE} defines the minimum number of pixels for the\n * width and height of the hotspot.\n *\n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n *\n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * {@link ImageShape} for creating new connections, but the default implementation\n * supports one image and is used as follows:\n *\n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n *\n * ```javascript\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * ```\n *\n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n *\n * ```javascript\n * mxConstants.HIGHLIGHT_COLOR = null;\n * ```\n *\n * To install the image, the connectImage field of the ConnectionHandler must\n * be assigned a new {@link Image} instance:\n *\n * ```javascript\n * connectImage = new ImageBox('images/green-dot.gif', 14, 14);\n * ```\n *\n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n *\n * Event: mxEvent.START\n *\n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n *\n * Event: mxEvent.CONNECT\n *\n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code>\n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n *\n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, {@link Graph#getConnectionConstraint} can be used. To resolve\n * the port IDs, use <Transactions.getCell>.\n *\n * ```javascript\n * graph.getPlugin('ConnectionHandler')?.addListener(mxEvent.CONNECT, (sender, evt) =>\n * {\n *   let edge = evt.getProperty('cell');\n *   let source = graph.getDataModel().getTerminal(edge, true);\n *   let target = graph.getDataModel().getTerminal(edge, false);\n *\n *   let style = graph.getCellStyle(edge);\n *   let sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   let targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *\n *   GlobalConfig.logger.show();\n *   GlobalConfig.logger.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * ```\n *\n * Event: mxEvent.RESET\n *\n * Fires when the <reset> method is invoked.\n *\n * @category Plugin\n */\nclass ConnectionHandler extends EventSource {\n    /**\n     * Constructs an event handler that connects vertices using the specified\n     * factory method to create the new edges.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     * @param factoryMethod Optional function to create the edge. The function takes\n     * the source and target {@link Cell} as the first and second argument and an\n     * optional cell style from the preview as the third argument. It returns\n     * the {@link Cell} that represents the new edge.\n     */\n    constructor(graph, factoryMethod = null) {\n        super();\n        this.previous = null;\n        this.iconState = null;\n        this.icons = [];\n        this.cell = null;\n        this.currentPoint = null;\n        this.sourceConstraint = null;\n        this.shape = null;\n        this.icon = null;\n        this.originalPoint = null;\n        this.currentState = null;\n        this.selectedIcon = null;\n        this.waypoints = [];\n        /**\n         * Function that is used for creating new edges. The function takes the\n         * source and target <Cell> as the first and second argument and returns\n         * a new <Cell> that represents the edge. This is used in <createEdge>.\n         */\n        this.factoryMethod = null;\n        /**\n         * Specifies if icons should be displayed inside the graph container instead\n         * of the overlay pane. This is used for HTML labels on vertices which hide\n         * the connect icon. This has precedence over {@link moveIconBack} when set\n         * to true.\n         * @default `false`\n         */\n        this.moveIconFront = false;\n        /**\n         * Specifies if icons should be moved to the back of the overlay pane. This can\n         * be set to true if the icons of the connection handler conflict with other\n         * handles, such as the vertex label move handle. Default is false.\n         */\n        this.moveIconBack = false;\n        /**\n         * {@link Image} that is used to trigger the creation of a new connection.\n         * This is used in {@link createIcons}.\n         * @default null\n         */\n        this.connectImage = null;\n        /**\n         * Specifies if the connect icon should be centered on the target state\n         * while connections are being previewed. Default is false.\n         */\n        this.targetConnectImage = false;\n        /**\n         * Specifies if events are handled. Default is false.\n         */\n        this.enabled = false;\n        /**\n         * Specifies if new edges should be selected. Default is true.\n         */\n        this.select = true;\n        /**\n         * Specifies if <createTargetVertex> should be called if no target was under the\n         * mouse for the new connection. Setting this to true means the connection\n         * will be drawn as valid if no target is under the mouse, and\n         * <createTargetVertex> will be called before the connection is created between\n         * the source cell and the newly created vertex in <createTargetVertex>, which\n         * can be overridden to create a new target. Default is false.\n         */\n        this.createTarget = false;\n        /**\n         * Holds the current validation error while connections are being created.\n         */\n        this.error = null;\n        /**\n         * Specifies if single clicks should add waypoints on the new edge. Default is\n         * false.\n         */\n        this.waypointsEnabled = false;\n        /**\n         * Specifies if the connection handler should ignore the state of the mouse\n         * button when highlighting the source. Default is false, that is, the\n         * handler only highlights the source if no button is being pressed.\n         */\n        this.ignoreMouseDown = false;\n        /**\n         * Holds the {@link Point} where the mouseDown took place while the handler is\n         * active.\n         */\n        this.first = null;\n        /**\n         * Holds the offset for connect icons during connection preview.\n         * Default is mxPoint(0, {@link Constants#TOOLTIP_VERTICAL_OFFSET}).\n         * Note that placing the icon under the mouse pointer with an\n         * offset of (0,0) will affect hit detection.\n         */\n        this.connectIconOffset = new Point(0, TOOLTIP_VERTICAL_OFFSET);\n        /**\n         * Optional <CellState> that represents the preview edge while the\n         * handler is active. This is created in <createEdgeState>.\n         */\n        this.edgeState = null;\n        /**\n         * Counts the number of mouseDown events since the start. The initial mouse\n         * down event counts as 1.\n         */\n        this.mouseDownCounter = 0;\n        /**\n         * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n         * where the preview cannot be made transparent to events and if the built-in hit detection on\n         * the HTML elements in the page should be used.\n         * @default false\n         */\n        this.movePreviewAway = false;\n        /**\n         * Specifies if connections to the outline of a highlighted target should be\n         * enabled. This will allow to place the connection point along the outline of\n         * the highlighted target.\n         * @default false\n         */\n        this.outlineConnect = false;\n        /**\n         * Specifies if the actual shape of the edge state should be used for the preview.\n         * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n         */\n        this.livePreview = false;\n        /**\n         * Specifies the cursor to be used while the handler is active. Default is null.\n         */\n        this.cursor = null;\n        /**\n         * Specifies if new edges should be inserted before the source vertex in the\n         * cell hierarchy. Default is false for backwards compatibility.\n         */\n        this.insertBeforeSource = false;\n        this.graph = graph;\n        this.factoryMethod = factoryMethod;\n        this.graph.addMouseListener(this);\n        this.marker = this.createMarker();\n        this.constraintHandler = new ConstraintHandler(this.graph);\n        // Redraws the icons if the graph changes\n        this.changeHandler = (sender) => {\n            if (this.iconState) {\n                this.iconState = this.graph.getView().getState(this.iconState.cell);\n            }\n            if (this.iconState) {\n                this.redrawIcons(this.icons, this.iconState);\n                this.constraintHandler.reset();\n            }\n            else if (this.previous && !this.graph.view.getState(this.previous.cell)) {\n                this.reset();\n            }\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.SCALE, this.changeHandler);\n        this.graph.getView().addListener(InternalEvent.TRANSLATE, this.changeHandler);\n        this.graph\n            .getView()\n            .addListener(InternalEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n        // Removes the icon if we step into/up or start editing\n        this.drillHandler = (sender) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.START_EDITING, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.DOWN, this.drillHandler);\n        this.graph.getView().addListener(InternalEvent.UP, this.drillHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = () => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns <insertBeforeSource> for non-loops and false for loops.\n     *\n     * @param edge <Cell> that represents the edge to be inserted.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    isInsertBefore(edge, source, target, evt, dropTarget) {\n        return this.insertBeforeSource && source !== target;\n    }\n    /**\n     * Returns <createTarget>.\n     *\n     * @param evt Current active native pointer event.\n     */\n    isCreateTarget(evt) {\n        return this.createTarget;\n    }\n    /**\n     * Sets <createTarget>.\n     */\n    setCreateTarget(value) {\n        this.createTarget = value;\n    }\n    /**\n     * Creates the preview shape for new connections.\n     */\n    createShape() {\n        // Creates the edge preview\n        const shape = this.livePreview && this.edgeState\n            ? this.graph.cellRenderer.createShape(this.edgeState)\n            : new PolylineShape([], INVALID_COLOR);\n        if (shape && shape.node) {\n            shape.dialect = DIALECT.SVG;\n            shape.scale = this.graph.view.scale;\n            shape.pointerEvents = false;\n            shape.isDashed = true;\n            shape.init(this.graph.getView().getOverlayPane());\n            InternalEvent.redirectMouseEvents(shape.node, this.graph, null);\n        }\n        return shape;\n    }\n    /**\n     * Returns true if the given cell is connectable. This is a hook to\n     * disable floating connections. This implementation returns true.\n     */\n    isConnectableCell(cell) {\n        return true;\n    }\n    /**\n     * Creates and returns the {@link CellMarker} used in {@link arker}.\n     */\n    createMarker() {\n        return new ConnectionHandlerCellMarker(this.graph, this);\n    }\n    /**\n     * Starts a new connection for the given state and coordinates.\n     */\n    start(state, x, y, edgeState) {\n        this.previous = state;\n        this.first = new Point(x, y);\n        this.edgeState = edgeState ?? this.createEdgeState();\n        // Marks the source state\n        this.marker.currentColor = this.marker.validColor;\n        this.marker.markedState = state;\n        this.marker.mark();\n        this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n    }\n    /**\n     * Returns true if the source terminal has been clicked and a new\n     * connection is currently being previewed.\n     */\n    isConnecting() {\n        return !!this.first && !!this.shape;\n    }\n    /**\n     * Returns {@link Graph#isValidSource} for the given source terminal.\n     *\n     * @param cell <Cell> that represents the source terminal.\n     * @param me {@link MouseEvent} that is associated with this call.\n     */\n    isValidSource(cell, me) {\n        return this.graph.isValidSource(cell);\n    }\n    /**\n     * Returns true. The call to {@link Graph#isValidTarget} is implicit by calling\n     * {@link Graph#getEdgeValidationError} in <validateConnection>. This is an\n     * additional hook for disabling certain targets in this specific handler.\n     *\n     * @param cell <Cell> that represents the target terminal.\n     */\n    isValidTarget(cell) {\n        return true;\n    }\n    /**\n     * Returns the error message or an empty string if the connection for the\n     * given source target pair is not valid. Otherwise it returns null. This\n     * implementation uses {@link Graph#getEdgeValidationError}.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     */\n    validateConnection(source, target) {\n        if (!this.isValidTarget(target)) {\n            return '';\n        }\n        return this.graph.getEdgeValidationError(null, source, target);\n    }\n    /**\n     * Hook to return the {@link Image} used for the connection icon of the given\n     * {@link CellState}. This implementation returns {@link connectImage}.\n     *\n     * @param state {@link CellState} whose connect image should be returned.\n     */\n    getConnectImage(state) {\n        return this.connectImage;\n    }\n    /**\n     * Returns true if the state has a HTML label in the graph's container, otherwise\n     * it returns {@link oveIconFront}.\n     *\n     * @param state <CellState> whose connect icons should be returned.\n     */\n    isMoveIconToFrontForState(state) {\n        if (state.text && state.text.node.parentNode === this.graph.container) {\n            return true;\n        }\n        return this.moveIconFront;\n    }\n    /**\n     * Creates the array {@link ImageShape}s that represent the connect icons for\n     * the given {@link CellState}.\n     *\n     * @param state {@link CellState} whose connect icons should be returned.\n     */\n    createIcons(state) {\n        const image = this.getConnectImage(state);\n        if (image) {\n            this.iconState = state;\n            const icons = [];\n            // Cannot use HTML for the connect icons because the icon receives all\n            // mouse move events in IE, must use VML and SVG instead even if the\n            // connect-icon appears behind the selection border and the selection\n            // border consumes the events before the icon gets a chance\n            const bounds = new Rectangle(0, 0, image.width, image.height);\n            const icon = new ImageShape(bounds, image.src, undefined, undefined, 0);\n            icon.preserveImageAspect = false;\n            if (this.isMoveIconToFrontForState(state)) {\n                icon.dialect = DIALECT.STRICTHTML;\n                icon.init(this.graph.container);\n            }\n            else {\n                icon.dialect = DIALECT.SVG;\n                icon.init(this.graph.getView().getOverlayPane());\n                // Move the icon back in the overlay pane\n                if (this.moveIconBack && icon.node.parentNode && icon.node.previousSibling) {\n                    icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n                }\n            }\n            icon.node.style.cursor = CURSOR.CONNECT;\n            // Events transparency\n            const getState = () => {\n                return this.currentState ?? state;\n            };\n            // Updates the local icon before firing the mouse down event.\n            const mouseDown = (evt) => {\n                if (!isConsumed(evt)) {\n                    this.icon = icon;\n                    this.graph.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt, getState()));\n                }\n            };\n            InternalEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n            icons.push(icon);\n            this.redrawIcons(icons, this.iconState);\n            return icons;\n        }\n        return [];\n    }\n    /**\n     * Redraws the given array of {@link ImageShapes}.\n     *\n     * @param icons Array of {@link ImageShapes} to be redrawn.\n     */\n    redrawIcons(icons, state) {\n        if (icons[0] && icons[0].bounds) {\n            const pos = this.getIconPosition(icons[0], state);\n            icons[0].bounds.x = pos.x;\n            icons[0].bounds.y = pos.y;\n            icons[0].redraw();\n        }\n    }\n    // TODO: Document me! ===========================================================================================================\n    getIconPosition(icon, state) {\n        const { scale } = this.graph.getView();\n        let cx = state.getCenterX();\n        let cy = state.getCenterY();\n        if (this.graph.isSwimlane(state.cell)) {\n            const size = this.graph.getStartSize(state.cell);\n            cx = size.width !== 0 ? state.x + (size.width * scale) / 2 : cx;\n            cy = size.height !== 0 ? state.y + (size.height * scale) / 2 : cy;\n            const alpha = toRadians(state.style.rotation ?? 0);\n            if (alpha !== 0) {\n                const cos = Math.cos(alpha);\n                const sin = Math.sin(alpha);\n                const ct = new Point(state.getCenterX(), state.getCenterY());\n                const pt = getRotatedPoint(new Point(cx, cy), cos, sin, ct);\n                cx = pt.x;\n                cy = pt.y;\n            }\n        }\n        return new Point(cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);\n    }\n    /**\n     * Destroys the connect icons and resets the respective state.\n     */\n    destroyIcons() {\n        for (let i = 0; i < this.icons.length; i += 1) {\n            this.icons[i].destroy();\n        }\n        this.icons = [];\n        this.icon = null;\n        this.selectedIcon = null;\n        this.iconState = null;\n    }\n    /**\n     * Returns true if the given mouse down event should start this handler. The\n     * This implementation returns true if the event does not force marquee\n     * selection, and the currentConstraint and currentFocus of the\n     * <constraintHandler> are not null, or <previous> and <error> are not null and\n     * <icons> is null or <icons> and <icon> are not null.\n     */\n    isStartEvent(me) {\n        return ((this.constraintHandler.currentFocus !== null &&\n            this.constraintHandler.currentConstraint !== null) ||\n            (this.previous !== null &&\n                this.error === null &&\n                (this.icons.length === 0 || this.icon !== null)));\n    }\n    /**\n     * Handles the event by initiating a new connection.\n     */\n    mouseDown(sender, me) {\n        this.mouseDownCounter += 1;\n        if (this.isEnabled() &&\n            this.graph.isEnabled() &&\n            !me.isConsumed() &&\n            !this.isConnecting() &&\n            this.isStartEvent(me)) {\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus &&\n                this.constraintHandler.currentPoint) {\n                this.sourceConstraint = this.constraintHandler.currentConstraint;\n                this.previous = this.constraintHandler.currentFocus;\n                this.first = this.constraintHandler.currentPoint.clone();\n            }\n            else {\n                // Stores the location of the initial mousedown\n                this.first = new Point(me.getGraphX(), me.getGraphY());\n            }\n            this.edgeState = this.createEdgeState(me);\n            this.mouseDownCounter = 1;\n            if (this.waypointsEnabled && !this.shape) {\n                this.waypoints = [];\n                this.shape = this.createShape();\n                if (this.edgeState) {\n                    this.shape.apply(this.edgeState);\n                }\n            }\n            // Stores the starting point in the geometry of the preview\n            if (!this.previous && this.edgeState && this.edgeState.cell.geometry) {\n                const pt = this.graph.getPointForEvent(me.getEvent());\n                this.edgeState.cell.geometry.setTerminalPoint(pt, true);\n            }\n            this.fireEvent(new EventObject(InternalEvent.START, { state: this.previous }));\n            me.consume();\n        }\n        this.selectedIcon = this.icon;\n        this.icon = null;\n    }\n    /**\n     * Returns true if a tap on the given source state should immediately start\n     * connecting. This implementation returns true if the state is not movable\n     * in the graph.\n     */\n    isImmediateConnectSource(state) {\n        return !this.graph.isCellMovable(state.cell);\n    }\n    /**\n     * Hook to return an <CellState> which may be used during the preview.\n     * This implementation returns null.\n     *\n     * Use the following code to create a preview for an existing edge style:\n     *\n     * ```javascript\n     * graph.getPlugin('ConnectionHandler').createEdgeState(me)\n     * {\n     *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n     *\n     *   return new CellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n     * };\n     * ```\n     */\n    createEdgeState(me) {\n        return null;\n    }\n    /**\n     * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n     * or shift is pressed.\n     */\n    isOutlineConnectEvent(me) {\n        if (!this.currentPoint)\n            return false;\n        const offset = getOffset(this.graph.container);\n        const evt = me.getEvent();\n        const clientX = getClientX(evt);\n        const clientY = getClientY(evt);\n        const doc = document.documentElement;\n        const left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n        const top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n        const gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n        const gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n        return (this.outlineConnect &&\n            !isShiftDown(me.getEvent()) &&\n            (me.isSource(this.marker.highlight.shape) ||\n                (isAltDown(me.getEvent()) && me.getState() != null) ||\n                this.marker.highlight.isHighlightAt(clientX, clientY) ||\n                ((gridX !== clientX || gridY !== clientY) &&\n                    me.getState() == null &&\n                    this.marker.highlight.isHighlightAt(gridX, gridY))));\n    }\n    /**\n     * Updates the current state for a given mouse move event by using\n     * the {@link arker}.\n     */\n    updateCurrentState(me, point) {\n        this.constraintHandler.update(me, !this.first, false, !this.first || me.isSource(this.marker.highlight.shape) ? null : point);\n        if (this.constraintHandler.currentFocus != null &&\n            this.constraintHandler.currentConstraint != null) {\n            // Handles special case where grid is large and connection point is at actual point in which\n            // case the outline is not followed as long as we're < gridSize / 2 away from that point\n            if (this.marker.highlight &&\n                this.marker.highlight.state &&\n                this.marker.highlight.state.cell === this.constraintHandler.currentFocus.cell &&\n                this.marker.highlight.shape) {\n                // Direct repaint needed if cell already highlighted\n                if (this.marker.highlight.shape.stroke !== 'transparent') {\n                    this.marker.highlight.shape.stroke = 'transparent';\n                    this.marker.highlight.repaint();\n                }\n            }\n            else {\n                this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n            }\n            // Updates validation state\n            if (this.previous) {\n                this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n                if (!this.error) {\n                    this.currentState = this.constraintHandler.currentFocus;\n                }\n                if (this.error ||\n                    (this.currentState && !this.isCellEnabled(this.currentState.cell))) {\n                    this.constraintHandler.reset();\n                }\n            }\n        }\n        else {\n            if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n                this.marker.reset();\n                this.currentState = null;\n            }\n            else {\n                this.marker.process(me);\n                this.currentState = this.marker.getValidState();\n            }\n            if (this.currentState != null && !this.isCellEnabled(this.currentState.cell)) {\n                this.constraintHandler.reset();\n                this.marker.reset();\n                this.currentState = null;\n            }\n            const outline = this.isOutlineConnectEvent(me);\n            if (this.currentState != null && outline) {\n                // Handles special case where mouse is on outline away from actual end point\n                // in which case the grid is ignored and mouse point is used instead\n                if (me.isSource(this.marker.highlight.shape)) {\n                    point = new Point(me.getGraphX(), me.getGraphY());\n                }\n                const constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n                this.constraintHandler.setFocus(me, this.currentState, false);\n                this.constraintHandler.currentConstraint = constraint;\n                this.constraintHandler.currentPoint = point;\n            }\n            if (this.outlineConnect) {\n                if (this.marker.highlight != null && this.marker.highlight.shape != null) {\n                    const s = this.graph.view.scale;\n                    if (this.constraintHandler.currentConstraint != null &&\n                        this.constraintHandler.currentFocus != null) {\n                        this.marker.highlight.shape.stroke = OUTLINE_HIGHLIGHT_COLOR;\n                        this.marker.highlight.shape.strokeWidth =\n                            OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                    else if (this.marker.hasValidState()) {\n                        const cell = me.getCell();\n                        // Handles special case where actual end point of edge and current mouse point\n                        // are not equal (due to grid snapping) and there is no hit on shape or highlight\n                        // but ignores cases where parent is used for non-connectable child cells\n                        if (cell &&\n                            cell.isConnectable() &&\n                            this.marker.getValidState() !== me.getState()) {\n                            this.marker.highlight.shape.stroke = 'transparent';\n                            this.currentState = null;\n                        }\n                        else {\n                            this.marker.highlight.shape.stroke = DEFAULT_VALID_COLOR;\n                        }\n                        this.marker.highlight.shape.strokeWidth = HIGHLIGHT_STROKEWIDTH / s / s;\n                        this.marker.highlight.repaint();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell does not allow new connections to be created.\n     */\n    isCellEnabled(cell) {\n        return true;\n    }\n    /**\n     * Converts the given point from screen coordinates to model coordinates.\n     */\n    convertWaypoint(point) {\n        const scale = this.graph.getView().getScale();\n        const tr = this.graph.getView().getTranslate();\n        point.x = point.x / scale - tr.x;\n        point.y = point.y / scale - tr.y;\n    }\n    /**\n     * Called to snap the given point to the current preview. This snaps to the\n     * first point of the preview if alt is not pressed.\n     */\n    snapToPreview(me, point) {\n        if (!isAltDown(me.getEvent()) && this.previous) {\n            const tol = (this.graph.getGridSize() * this.graph.view.scale) / 2;\n            const tmp = this.sourceConstraint && this.first\n                ? this.first\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            if (Math.abs(tmp.x - me.getGraphX()) < tol) {\n                point.x = tmp.x;\n            }\n            if (Math.abs(tmp.y - me.getGraphY()) < tol) {\n                point.y = tmp.y;\n            }\n        }\n    }\n    /**\n     * Handles the event by updating the preview edge or by highlighting\n     * a possible source or target terminal.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() &&\n            (this.ignoreMouseDown || this.first || !this.graph.isMouseDown)) {\n            // Handles special case when handler is disabled during highlight\n            if (!this.isEnabled() && this.currentState) {\n                this.destroyIcons();\n                this.currentState = null;\n            }\n            const view = this.graph.getView();\n            const { scale } = view;\n            const tr = view.translate;\n            let point = new Point(me.getGraphX(), me.getGraphY());\n            this.error = null;\n            if (this.graph.isGridEnabledEvent(me.getEvent())) {\n                point = new Point((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n            }\n            this.snapToPreview(me, point);\n            this.currentPoint = point;\n            if ((this.first || (this.isEnabled() && this.graph.isEnabled())) &&\n                (this.shape ||\n                    !this.first ||\n                    Math.abs(me.getGraphX() - this.first.x) > this.graph.getEventTolerance() ||\n                    Math.abs(me.getGraphY() - this.first.y) > this.graph.getEventTolerance())) {\n                this.updateCurrentState(me, point);\n            }\n            if (this.first) {\n                let constraint = null;\n                let current = point;\n                // Uses the current point from the constraint handler if available\n                if (this.constraintHandler.currentConstraint &&\n                    this.constraintHandler.currentFocus &&\n                    this.constraintHandler.currentPoint) {\n                    constraint = this.constraintHandler.currentConstraint;\n                    current = this.constraintHandler.currentPoint.clone();\n                }\n                else if (this.previous &&\n                    !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n                    isShiftDown(me.getEvent())) {\n                    if (Math.abs(this.previous.getCenterX() - point.x) <\n                        Math.abs(this.previous.getCenterY() - point.y)) {\n                        point.x = this.previous.getCenterX();\n                    }\n                    else {\n                        point.y = this.previous.getCenterY();\n                    }\n                }\n                let pt2 = this.first;\n                // Moves the connect icon with the mouse\n                if (this.selectedIcon && this.selectedIcon.bounds) {\n                    const w = this.selectedIcon.bounds.width;\n                    const h = this.selectedIcon.bounds.height;\n                    if (this.currentState && this.targetConnectImage) {\n                        const pos = this.getIconPosition(this.selectedIcon, this.currentState);\n                        this.selectedIcon.bounds.x = pos.x;\n                        this.selectedIcon.bounds.y = pos.y;\n                    }\n                    else {\n                        const bounds = new Rectangle(me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);\n                        this.selectedIcon.bounds = bounds;\n                    }\n                    this.selectedIcon.redraw();\n                }\n                // Uses edge state to compute the terminal points\n                if (this.edgeState) {\n                    this.updateEdgeState(current, constraint);\n                    current =\n                        this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n                    pt2 = this.edgeState.absolutePoints[0];\n                }\n                else {\n                    if (this.currentState) {\n                        if (!this.constraintHandler.currentConstraint) {\n                            const tmp = this.getTargetPerimeterPoint(this.currentState, me);\n                            if (tmp != null) {\n                                current = tmp;\n                            }\n                        }\n                    }\n                    // Computes the source perimeter point\n                    if (!this.sourceConstraint && this.previous) {\n                        const next = this.waypoints.length > 0 ? this.waypoints[0] : current;\n                        const tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n                        if (tmp) {\n                            pt2 = tmp;\n                        }\n                    }\n                }\n                // Makes sure the cell under the mousepointer can be detected\n                // by moving the preview shape away from the mouse. This\n                // makes sure the preview shape does not prevent the detection\n                // of the cell under the mousepointer even for slow gestures.\n                if (!this.currentState && this.movePreviewAway && current) {\n                    let tmp = pt2;\n                    if (this.edgeState && this.edgeState.absolutePoints.length >= 2) {\n                        const tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n                        if (tmp2) {\n                            tmp = tmp2;\n                        }\n                    }\n                    if (tmp) {\n                        const dx = current.x - tmp.x;\n                        const dy = current.y - tmp.y;\n                        const len = Math.sqrt(dx * dx + dy * dy);\n                        if (len === 0) {\n                            return;\n                        }\n                        // Stores old point to reuse when creating edge\n                        this.originalPoint = current.clone();\n                        current.x -= (dx * 4) / len;\n                        current.y -= (dy * 4) / len;\n                    }\n                }\n                else {\n                    this.originalPoint = null;\n                }\n                // Creates the preview shape (lazy)\n                if (!this.shape) {\n                    const dx = Math.abs(me.getGraphX() - this.first.x);\n                    const dy = Math.abs(me.getGraphY() - this.first.y);\n                    if (dx > this.graph.getEventTolerance() ||\n                        dy > this.graph.getEventTolerance()) {\n                        this.shape = this.createShape();\n                        if (this.edgeState) {\n                            this.shape.apply(this.edgeState);\n                        }\n                        // Revalidates current connection\n                        this.updateCurrentState(me, point);\n                    }\n                }\n                // Updates the points in the preview edge\n                if (this.shape) {\n                    if (this.edgeState) {\n                        this.shape.points = this.edgeState.absolutePoints;\n                    }\n                    else {\n                        let pts = [pt2];\n                        if (this.waypoints.length > 0) {\n                            pts = pts.concat(this.waypoints);\n                        }\n                        pts.push(current);\n                        this.shape.points = pts;\n                    }\n                    this.drawPreview();\n                }\n                // Makes sure endpoint of edge is visible during connect\n                if (this.cursor) {\n                    this.graph.container.style.cursor = this.cursor;\n                }\n                InternalEvent.consume(me.getEvent());\n                me.consume();\n            }\n            else if (!this.isEnabled() || !this.graph.isEnabled()) {\n                this.constraintHandler.reset();\n            }\n            else if (this.previous !== this.currentState && !this.edgeState) {\n                this.destroyIcons();\n                // Sets the cursor on the current shape\n                if (this.currentState &&\n                    !this.error &&\n                    !this.constraintHandler.currentConstraint) {\n                    this.icons = this.createIcons(this.currentState);\n                    if (this.icons.length === 0) {\n                        this.currentState.setCursor(CURSOR.CONNECT);\n                        me.consume();\n                    }\n                }\n                this.previous = this.currentState;\n            }\n            else if (this.previous === this.currentState &&\n                this.currentState != null &&\n                this.icons.length === 0 &&\n                !this.graph.isMouseDown) {\n                // Makes sure that no cursors are changed\n                me.consume();\n            }\n            if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {\n                let hitsIcon = false;\n                const target = me.getSource();\n                for (let i = 0; i < this.icons.length && !hitsIcon; i += 1) {\n                    hitsIcon =\n                        target === this.icons[i].node ||\n                            // @ts-ignore parentNode should exist.\n                            (!!target && target.parentNode === this.icons[i].node);\n                }\n                if (!hitsIcon) {\n                    this.updateIcons(this.currentState, this.icons, me);\n                }\n            }\n        }\n        else {\n            this.constraintHandler.reset();\n        }\n    }\n    /**\n     * Updates <edgeState>.\n     */\n    updateEdgeState(current, constraint) {\n        if (!this.edgeState)\n            return;\n        // TODO: Use generic method for writing constraint to style\n        if (this.sourceConstraint && this.sourceConstraint.point) {\n            this.edgeState.style.exitX = this.sourceConstraint.point.x;\n            this.edgeState.style.exitY = this.sourceConstraint.point.y;\n        }\n        if (constraint && constraint.point) {\n            this.edgeState.style.entryX = constraint.point.x;\n            this.edgeState.style.entryY = constraint.point.y;\n        }\n        else {\n            this.edgeState.style.entryX = 0;\n            this.edgeState.style.entryY = 0;\n        }\n        this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];\n        if (this.sourceConstraint) {\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n        }\n        if (this.currentState != null) {\n            if (constraint == null) {\n                constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n            }\n            this.edgeState.setAbsoluteTerminalPoint(null, false);\n            this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n        }\n        // Scales and translates the waypoints to the model\n        const realPoints = [];\n        for (let i = 0; i < this.waypoints.length; i += 1) {\n            const pt = this.waypoints[i].clone();\n            this.convertWaypoint(pt);\n            realPoints[i] = pt;\n        }\n        this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n        this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n    }\n    /**\n     * Returns the perimeter point for the given target state.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param _me {@link MouseEvent} that represents the mouse move.\n     */\n    getTargetPerimeterPoint(state, _me) {\n        let result = null;\n        const { view } = state;\n        const targetPerimeter = view.getPerimeterFunction(state);\n        if (targetPerimeter && this.previous && this.edgeState) {\n            const next = this.waypoints.length > 0\n                ? this.waypoints[this.waypoints.length - 1]\n                : new Point(this.previous.getCenterX(), this.previous.getCenterY());\n            const tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);\n            if (tmp) {\n                result = tmp;\n            }\n        }\n        else {\n            result = new Point(state.getCenterX(), state.getCenterY());\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> that represents the target cell state.\n     * @param next {@link Point} that represents the next point along the previewed edge.\n     * @param me {@link MouseEvent} that represents the mouse move.\n     */\n    getSourcePerimeterPoint(state, next, me) {\n        let result = null;\n        const { view } = state;\n        const sourcePerimeter = view.getPerimeterFunction(state);\n        const c = new Point(state.getCenterX(), state.getCenterY());\n        if (sourcePerimeter) {\n            const theta = state.style.rotation ?? 0;\n            const rad = -theta * (Math.PI / 180);\n            if (theta !== 0) {\n                next = getRotatedPoint(new Point(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n            }\n            let tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n            if (tmp) {\n                if (theta !== 0) {\n                    tmp = getRotatedPoint(new Point(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n                }\n                result = tmp;\n            }\n        }\n        else {\n            result = c;\n        }\n        return result;\n    }\n    /**\n     * Hook to update the icon position(s) based on a mouseOver event. This is\n     * an empty implementation.\n     *\n     * @param state <CellState> under the mouse.\n     * @param icons Array of currently displayed icons.\n     * @param me {@link MouseEvent} that contains the mouse event.\n     */\n    updateIcons(state, icons, me) {\n        // empty\n    }\n    /**\n     * Returns true if the given mouse up event should stop this handler. The\n     * connection will be created if <error> is null. Note that this is only\n     * called if <waypointsEnabled> is true. This implemtation returns true\n     * if there is a cell state in the given event.\n     */\n    isStopEvent(me) {\n        return !!me.getState();\n    }\n    /**\n     * Adds the waypoint for the given event to <waypoints>.\n     */\n    addWaypointForEvent(me) {\n        if (!this.first)\n            return;\n        let point = convertPoint(this.graph.container, me.getX(), me.getY());\n        const dx = Math.abs(point.x - this.first.x);\n        const dy = Math.abs(point.y - this.first.y);\n        const addPoint = this.waypoints.length > 0 ||\n            (this.mouseDownCounter > 1 &&\n                (dx > this.graph.getEventTolerance() || dy > this.graph.getEventTolerance()));\n        if (addPoint) {\n            const { scale } = this.graph.view;\n            point = new Point(this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);\n            this.waypoints.push(point);\n        }\n    }\n    /**\n     * Returns true if the connection for the given constraints is valid. This\n     * implementation returns true if the constraints are not pointing to the\n     * same fixed connection point.\n     */\n    checkConstraints(c1, c2) {\n        return (!c1 ||\n            !c2 ||\n            !c1.point ||\n            !c2.point ||\n            !c1.point.equals(c2.point) ||\n            c1.dx !== c2.dx ||\n            c1.dy !== c2.dy ||\n            c1.perimeter !== c2.perimeter);\n    }\n    /**\n     * Handles the event by inserting the new connection.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed() && this.isConnecting()) {\n            if (this.waypointsEnabled && !this.isStopEvent(me)) {\n                this.addWaypointForEvent(me);\n                me.consume();\n                return;\n            }\n            const c1 = this.sourceConstraint;\n            const c2 = this.constraintHandler.currentConstraint;\n            const source = this.previous ? this.previous.cell : null;\n            let target = null;\n            if (this.constraintHandler.currentConstraint &&\n                this.constraintHandler.currentFocus) {\n                target = this.constraintHandler.currentFocus.cell;\n            }\n            if (!target && this.currentState) {\n                target = this.currentState.cell;\n            }\n            // Inserts the edge if no validation error exists and if constraints differ\n            if (!this.error &&\n                (!source || !target || source !== target || this.checkConstraints(c1, c2))) {\n                this.connect(source, target, me.getEvent(), me.getCell());\n            }\n            else {\n                // Selects the source terminal for self-references\n                if (this.previous != null &&\n                    this.marker.validState != null &&\n                    this.previous.cell === this.marker.validState.cell) {\n                    this.graph.selectCellForEvent(this.marker.validState.cell, me.getEvent());\n                }\n                // Displays the error message if it is not an empty string,\n                // for empty error messages, the event is silently dropped\n                if (this.error != null && this.error.length > 0) {\n                    this.graph.validationAlert(this.error);\n                }\n            }\n            // Redraws the connect icons and resets the handler state\n            this.destroyIcons();\n            me.consume();\n        }\n        if (this.first != null) {\n            this.reset();\n        }\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.shape != null) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        // Resets the cursor on the container\n        if (this.cursor != null && this.graph.container != null) {\n            this.graph.container.style.cursor = '';\n        }\n        this.destroyIcons();\n        this.marker.reset();\n        this.constraintHandler.reset();\n        this.originalPoint = null;\n        this.currentPoint = null;\n        this.edgeState = null;\n        this.previous = null;\n        this.error = null;\n        this.sourceConstraint = null;\n        this.mouseDownCounter = 0;\n        this.first = null;\n        this.fireEvent(new EventObject(InternalEvent.RESET));\n    }\n    /**\n     * Redraws the preview edge using the color and width returned by\n     * <getEdgeColor> and <getEdgeWidth>.\n     */\n    drawPreview() {\n        this.updatePreview(this.error === null);\n        if (this.shape)\n            this.shape.redraw();\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    updatePreview(valid) {\n        if (this.shape) {\n            this.shape.strokeWidth = this.getEdgeWidth(valid);\n            this.shape.stroke = this.getEdgeColor(valid);\n        }\n    }\n    /**\n     * Returns the color used to draw the preview edge. This returns green if\n     * there is no edge validation error and red otherwise.\n     *\n     * @param valid Boolean indicating if the color for a valid edge should be\n     * returned.\n     */\n    getEdgeColor(valid) {\n        return valid ? VALID_COLOR : INVALID_COLOR;\n    }\n    /**\n     * Returns the width used to draw the preview edge. This returns 3 if\n     * there is no edge validation error and 1 otherwise.\n     *\n     * @param valid Boolean indicating if the width for a valid edge should be\n     * returned.\n     */\n    getEdgeWidth(valid) {\n        return valid ? 3 : 1;\n    }\n    /**\n     * Connects the given source and target using a new edge. This\n     * implementation uses <createEdge> to create the edge.\n     *\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param evt Mousedown event of the connect gesture.\n     * @param dropTarget <Cell> that represents the cell under the mouse when it was\n     * released.\n     */\n    connect(source, target, evt, dropTarget = null) {\n        if (target || this.isCreateTarget(evt) || this.graph.isAllowDanglingEdges()) {\n            // Uses the common parent of source and target or\n            // the default parent to insert the edge\n            const model = this.graph.getDataModel();\n            let terminalInserted = false;\n            let edge = null;\n            model.beginUpdate();\n            try {\n                if (source &&\n                    !target &&\n                    !this.graph.isIgnoreTerminalEvent(evt) &&\n                    this.isCreateTarget(evt)) {\n                    target = this.createTargetVertex(evt, source);\n                    if (target) {\n                        dropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n                        terminalInserted = true;\n                        // Disables edges as drop targets if the target cell was created\n                        // FIXME: Should not shift if vertex was aligned (same in Java)\n                        if (dropTarget == null || !dropTarget.isEdge()) {\n                            const pstate = dropTarget\n                                ? this.graph.getView().getState(dropTarget)\n                                : null;\n                            if (pstate) {\n                                const tmp = target.getGeometry();\n                                if (tmp) {\n                                    tmp.x -= pstate.origin.x;\n                                    tmp.y -= pstate.origin.y;\n                                }\n                            }\n                        }\n                        else {\n                            dropTarget = this.graph.getDefaultParent();\n                        }\n                        this.graph.addCell(target, dropTarget);\n                    }\n                }\n                let parent = this.graph.getDefaultParent();\n                if (source &&\n                    target &&\n                    source.getParent() === target.getParent() &&\n                    source.getParent()?.getParent() !== model.getRoot()) {\n                    parent = source.getParent();\n                    if (source.geometry &&\n                        source.geometry.relative &&\n                        target.geometry &&\n                        target.geometry.relative) {\n                        parent = parent.getParent();\n                    }\n                }\n                // Uses the value of the preview edge state for inserting\n                // the new edge into the graph\n                let value = null;\n                let style = {};\n                if (this.edgeState?.cell) {\n                    value = this.edgeState.cell.value;\n                    style = this.edgeState.cell.style ?? {};\n                }\n                edge = this.insertEdge(parent, '', value, source, target, style);\n                if (edge && source) {\n                    // Updates the connection constraints\n                    this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n                    this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n                    // Uses geometry of the preview edge state\n                    if (this.edgeState?.cell?.geometry) {\n                        model.setGeometry(edge, this.edgeState.cell.geometry);\n                    }\n                    parent = source.getParent();\n                    // Inserts edge before source\n                    if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {\n                        const index = null;\n                        let tmp = source;\n                        while (tmp &&\n                            tmp.parent != null &&\n                            tmp.geometry != null &&\n                            tmp.geometry.relative &&\n                            tmp.parent !== edge.parent) {\n                            tmp = tmp.getParent();\n                        }\n                        if (tmp != null && tmp.parent != null && tmp.parent === edge.parent) {\n                            model.add(parent, edge, tmp.parent.getIndex(tmp));\n                        }\n                    }\n                    // Makes sure the edge has a non-null, relative geometry\n                    let geo = edge.getGeometry();\n                    if (geo == null) {\n                        geo = new Geometry();\n                        geo.relative = true;\n                        model.setGeometry(edge, geo);\n                    }\n                    // Uses scaled waypoints in geometry\n                    if (this.waypoints.length > 0) {\n                        const s = this.graph.view.scale;\n                        const tr = this.graph.view.translate;\n                        geo.points = [];\n                        for (let i = 0; i < this.waypoints.length; i += 1) {\n                            const pt = this.waypoints[i];\n                            geo.points.push(new Point(pt.x / s - tr.x, pt.y / s - tr.y));\n                        }\n                    }\n                    if (!target && this.currentPoint) {\n                        const t = this.graph.view.translate;\n                        const s = this.graph.view.scale;\n                        const pt = this.originalPoint != null\n                            ? new Point(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y)\n                            : new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n                        pt.x -= this.graph.getPanDx() / this.graph.view.scale;\n                        pt.y -= this.graph.getPanDy() / this.graph.view.scale;\n                        geo.setTerminalPoint(pt, false);\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n                }\n            }\n            catch (e) {\n                GlobalConfig.logger.show();\n                const errorMessage = `Error in ConnectionHandler: ${e instanceof Error ? e.message + '\\n' + e.stack : 'unknown cause'}`;\n                GlobalConfig.logger.debug(errorMessage);\n            }\n            finally {\n                model.endUpdate();\n            }\n            if (this.select) {\n                this.selectCells(edge, terminalInserted ? target : null);\n            }\n        }\n    }\n    /**\n     * Selects the given edge after adding a new connection. The target argument\n     * contains the target vertex if one has been inserted.\n     */\n    selectCells(edge, target) {\n        this.graph.setSelectionCell(edge);\n    }\n    /**\n     * Creates, inserts and returns the new edge for the given parameters. This\n     * implementation does only use <createEdge> if <factoryMethod> is defined,\n     * otherwise {@link Graph#insertEdge} will be used.\n     */\n    insertEdge(parent, id, value, source, target, style) {\n        if (!this.factoryMethod) {\n            return this.graph.insertEdge(parent, id, value, source, target, style);\n        }\n        let edge = this.createEdge(value, source, target, style);\n        edge = this.graph.addEdge(edge, parent, source, target);\n        return edge;\n    }\n    /**\n     * Hook method for creating new vertices on the fly if no target was\n     * under the mouse. This is only called if <createTarget> is true and\n     * returns null.\n     *\n     * @param evt Mousedown event of the connect gesture.\n     * @param source <Cell> that represents the source terminal.\n     */\n    createTargetVertex(evt, source) {\n        // Uses the first non-relative source\n        let geo = source.getGeometry();\n        while (geo && geo.relative) {\n            source = source.getParent();\n            geo = source.getGeometry();\n        }\n        const clone = this.graph.cloneCell(source);\n        geo = clone.getGeometry();\n        if (geo && this.currentPoint) {\n            const t = this.graph.view.translate;\n            const s = this.graph.view.scale;\n            const point = new Point(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n            geo.x = Math.round(point.x - geo.width / 2 - this.graph.getPanDx() / s);\n            geo.y = Math.round(point.y - geo.height / 2 - this.graph.getPanDy() / s);\n            // Aligns with source if within certain tolerance\n            const tol = this.getAlignmentTolerance();\n            if (tol > 0) {\n                const sourceState = this.graph.view.getState(source);\n                if (sourceState != null) {\n                    const x = sourceState.x / s - t.x;\n                    const y = sourceState.y / s - t.y;\n                    if (Math.abs(x - geo.x) <= tol) {\n                        geo.x = Math.round(x);\n                    }\n                    if (Math.abs(y - geo.y) <= tol) {\n                        geo.y = Math.round(y);\n                    }\n                }\n            }\n        }\n        return clone;\n    }\n    /**\n     * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n     */\n    getAlignmentTolerance(evt) {\n        return this.graph.isGridEnabled()\n            ? this.graph.getGridSize() / 2\n            : this.graph.getSnapTolerance();\n    }\n    /**\n     * Creates and returns a new edge using <factoryMethod> if one exists. If\n     * no factory method is defined, then a new default edge is returned. The\n     * source and target arguments are informal, the actual connection is\n     * setup later by the caller of this function.\n     *\n     * @param value Value to be used for creating the edge.\n     * @param source <Cell> that represents the source terminal.\n     * @param target <Cell> that represents the target terminal.\n     * @param style Optional style from the preview edge.\n     */\n    createEdge(value, source, target, style = {}) {\n        let edge = null;\n        // Creates a new edge using the factoryMethod\n        if (this.factoryMethod != null) {\n            edge = this.factoryMethod(source, target, style);\n        }\n        if (edge == null) {\n            edge = new Cell(value || '');\n            edge.setEdge(true);\n            edge.setStyle(style);\n            const geo = new Geometry();\n            geo.relative = true;\n            edge.setGeometry(geo);\n        }\n        return edge;\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This should be\n     * called on all instances. It is called automatically for the built-in\n     * instance created for each {@link Graph}.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.marker) {\n            this.marker.destroy();\n            // @ts-expect-error this.marker is null when it is destroyed.\n            this.marker = null;\n        }\n        if (this.constraintHandler) {\n            this.constraintHandler.onDestroy();\n        }\n        if (this.changeHandler) {\n            this.graph.getDataModel().removeListener(this.changeHandler);\n            this.graph.getView().removeListener(this.changeHandler);\n        }\n        if (this.drillHandler) {\n            this.graph.removeListener(this.drillHandler);\n            this.graph.getView().removeListener(this.drillHandler);\n        }\n        if (this.escapeHandler) {\n            this.graph.removeListener(this.escapeHandler);\n        }\n    }\n}\nConnectionHandler.pluginId = 'ConnectionHandler';\nclass ConnectionHandlerCellMarker extends CellMarker {\n    constructor(graph, connectionHandler, validColor = DEFAULT_VALID_COLOR, invalidColor = DEFAULT_INVALID_COLOR, hotspot = DEFAULT_HOTSPOT) {\n        super(graph, validColor, invalidColor, hotspot);\n        this.hotspotEnabled = true;\n        this.connectionHandler = connectionHandler;\n    }\n    // Overrides to return cell at location only if valid (so that\n    // there is no highlight for invalid cells)\n    getCell(me) {\n        let cell = super.getCell(me);\n        this.connectionHandler.error = null;\n        // Checks for cell at preview point (with grid)\n        if (!cell && this.connectionHandler.currentPoint) {\n            cell = this.connectionHandler.graph.getCellAt(this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y);\n        }\n        // Uses connectable parent vertex if one exists\n        if (cell && !cell.isConnectable() && this.connectionHandler.cell) {\n            const parent = this.connectionHandler.cell.getParent();\n            if (parent && parent.isVertex() && parent.isConnectable()) {\n                cell = parent;\n            }\n        }\n        if (cell) {\n            if ((this.connectionHandler.graph.isSwimlane(cell) &&\n                this.connectionHandler.currentPoint != null &&\n                this.connectionHandler.graph.hitsSwimlaneContent(cell, this.connectionHandler.currentPoint.x, this.connectionHandler.currentPoint.y)) ||\n                !this.connectionHandler.isConnectableCell(cell)) {\n                cell = null;\n            }\n        }\n        if (cell) {\n            if (this.connectionHandler.isConnecting()) {\n                if (this.connectionHandler.previous) {\n                    this.connectionHandler.error = this.connectionHandler.validateConnection(this.connectionHandler.previous.cell, cell);\n                    if (this.connectionHandler.error !== null &&\n                        this.connectionHandler.error.length === 0) {\n                        cell = null;\n                        // Enables create target inside groups\n                        if (this.connectionHandler.isCreateTarget(me.getEvent())) {\n                            this.connectionHandler.error = null;\n                        }\n                    }\n                }\n            }\n            else if (!this.connectionHandler.isValidSource(cell, me)) {\n                cell = null;\n            }\n        }\n        else if (this.connectionHandler.isConnecting() &&\n            !this.connectionHandler.isCreateTarget(me.getEvent()) &&\n            !this.connectionHandler.graph.isAllowDanglingEdges()) {\n            this.connectionHandler.error = '';\n        }\n        return cell;\n    }\n    // Sets the highlight color according to validateConnection\n    isValidState(state) {\n        if (this.connectionHandler.isConnecting()) {\n            return !this.connectionHandler.error;\n        }\n        return super.isValidState(state);\n    }\n    // Overrides to use marker color only in highlight mode or for\n    // target selection\n    getMarkerColor(evt, state, isValid) {\n        return !this.connectionHandler.connectImage || this.connectionHandler.isConnecting()\n            ? super.getMarkerColor(evt, state, isValid)\n            : NONE;\n    }\n    // Overrides to use hotspot only for source selection otherwise\n    // intersects always returns true when over a cell\n    intersects(state, evt) {\n        if (this.connectionHandler.connectImage || this.connectionHandler.isConnecting()) {\n            return true;\n        }\n        return super.intersects(state, evt);\n    }\n}\nexport default ConnectionHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { DIALECT, GUIDE_COLOR, GUIDE_STROKEWIDTH } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport PolylineShape from '../geometry/edge/PolylineShape';\n/**\n * Implements the alignment of selection cells to other cells in the graph.\n *\n * Constructor: mxGuide\n *\n * Constructs a new guide object.\n */\nclass Guide {\n    constructor(graph, states) {\n        /**\n         * Contains the {@link CellStates} that are used for alignment.\n         */\n        this.states = [];\n        /**\n         * Specifies if horizontal guides are enabled. Default is true.\n         */\n        this.horizontal = true;\n        /**\n         * Specifies if vertical guides are enabled. Default is true.\n         */\n        this.vertical = true;\n        /**\n         * Holds the {@link Shape} for the horizontal guide.\n         */\n        this.guideX = null;\n        /**\n         * Holds the {@link Shape} for the vertical guide.\n         */\n        this.guideY = null;\n        /**\n         * Specifies if rounded coordinates should be used. Default is false.\n         */\n        this.rounded = false;\n        /**\n         * Default tolerance in px if grid is disabled. Default is 2.\n         */\n        this.tolerance = 2;\n        this.graph = graph;\n        this.setStates(states);\n    }\n    /**\n     * Sets the {@link CellState}s that should be used for alignment.\n     */\n    setStates(states) {\n        this.states = states;\n    }\n    /**\n     * Returns true if the guide should be enabled for the given native event. This\n     * implementation always returns true.\n     */\n    isEnabledForEvent(evt) {\n        return true;\n    }\n    /**\n     * Returns the tolerance for the guides. Default value is gridSize / 2.\n     */\n    getGuideTolerance(gridEnabled = false) {\n        return gridEnabled && this.graph.isGridEnabled()\n            ? this.graph.getGridSize() / 2\n            : this.tolerance;\n    }\n    /**\n     * Returns the mxShape to be used for painting the respective guide. This\n     * implementation returns a new, dashed and crisp {@link PolylineShape} using\n     * {@link GUIDE_COLOR} and {@link GUIDE_STROKEWIDTH} as the format.\n     *\n     * @param horizontal Boolean that specifies which guide should be created.\n     */\n    createGuideShape(horizontal = false) {\n        // TODO: Should vertical guides be supported here?? ============================\n        const guide = new PolylineShape([], GUIDE_COLOR, GUIDE_STROKEWIDTH);\n        guide.isDashed = true;\n        return guide;\n    }\n    /**\n     * Returns true if the given state should be ignored.\n     * @param state\n     */\n    isStateIgnored(state) {\n        return false;\n    }\n    /**\n     * Moves the <bounds> by the given {@link Point} and returnt the snapped point.\n     */\n    move(bounds = null, delta, gridEnabled = false, clone = false) {\n        if ((this.horizontal || this.vertical) && bounds) {\n            const { scale } = this.graph.getView();\n            const tt = this.getGuideTolerance(gridEnabled) * scale;\n            const b = bounds.clone();\n            b.x += delta.x;\n            b.y += delta.y;\n            let overrideX = false;\n            let stateX = null;\n            let valueX = null;\n            let overrideY = false;\n            let stateY = null;\n            let valueY = null;\n            let ttX = tt;\n            let ttY = tt;\n            const left = b.x;\n            const right = b.x + b.width;\n            const center = b.getCenterX();\n            const top = b.y;\n            const bottom = b.y + b.height;\n            const middle = b.getCenterY();\n            // Snaps the left, center and right to the given x-coordinate\n            const snapX = (x, state, centerAlign) => {\n                let override = false;\n                if (centerAlign && Math.abs(x - center) < ttX) {\n                    delta.x = x - bounds.getCenterX();\n                    ttX = Math.abs(x - center);\n                    override = true;\n                }\n                else if (!centerAlign) {\n                    if (Math.abs(x - left) < ttX) {\n                        delta.x = x - bounds.x;\n                        ttX = Math.abs(x - left);\n                        override = true;\n                    }\n                    else if (Math.abs(x - right) < ttX) {\n                        delta.x = x - bounds.x - bounds.width;\n                        ttX = Math.abs(x - right);\n                        override = true;\n                    }\n                }\n                if (override) {\n                    stateX = state;\n                    valueX = x;\n                    if (!this.guideX) {\n                        this.guideX = this.createGuideShape(true);\n                        // Makes sure to use SVG shapes in order to implement\n                        // event-transparency on the background area of the rectangle since\n                        // HTML shapes do not let mouseevents through even when transparent\n                        this.guideX.dialect = DIALECT.SVG;\n                        this.guideX.pointerEvents = false;\n                        this.guideX.init(this.graph.getView().getOverlayPane());\n                    }\n                }\n                overrideX = overrideX || override;\n            };\n            // Snaps the top, middle or bottom to the given y-coordinate\n            const snapY = (y, state, centerAlign) => {\n                let override = false;\n                if (centerAlign && Math.abs(y - middle) < ttY) {\n                    delta.y = y - bounds.getCenterY();\n                    ttY = Math.abs(y - middle);\n                    override = true;\n                }\n                else if (!centerAlign) {\n                    if (Math.abs(y - top) < ttY) {\n                        delta.y = y - bounds.y;\n                        ttY = Math.abs(y - top);\n                        override = true;\n                    }\n                    else if (Math.abs(y - bottom) < ttY) {\n                        delta.y = y - bounds.y - bounds.height;\n                        ttY = Math.abs(y - bottom);\n                        override = true;\n                    }\n                }\n                if (override) {\n                    stateY = state;\n                    valueY = y;\n                    if (!this.guideY) {\n                        this.guideY = this.createGuideShape(false);\n                        // Makes sure to use SVG shapes in order to implement\n                        // event-transparency on the background area of the rectangle since\n                        // HTML shapes do not let mouseevents through even when transparent\n                        this.guideY.dialect = DIALECT.SVG;\n                        this.guideY.pointerEvents = false;\n                        this.guideY.init(this.graph.getView().getOverlayPane());\n                    }\n                }\n                overrideY = overrideY || override;\n            };\n            for (let i = 0; i < this.states.length; i += 1) {\n                const state = this.states[i];\n                if (state && !this.isStateIgnored(state)) {\n                    // Align x\n                    if (this.horizontal) {\n                        snapX(state.getCenterX(), state, true);\n                        snapX(state.x, state, false);\n                        snapX(state.x + state.width, state, false);\n                        // Aligns left and right of shape to center of page\n                        if (!state.cell) {\n                            snapX(state.getCenterX(), state, false);\n                        }\n                    }\n                    // Align y\n                    if (this.vertical) {\n                        snapY(state.getCenterY(), state, true);\n                        snapY(state.y, state, false);\n                        snapY(state.y + state.height, state, false);\n                        // Aligns left and right of shape to center of page\n                        if (!state.cell) {\n                            snapY(state.getCenterY(), state, false);\n                        }\n                    }\n                }\n            }\n            // Moves cells to the raster if not aligned\n            this.graph.snapDelta(delta, bounds, !gridEnabled, overrideX, overrideY);\n            delta = this.getDelta(bounds, stateX, delta.x, stateY, delta.y);\n            // Redraws the guides\n            const c = this.graph.container;\n            if (!overrideX && this.guideX) {\n                this.guideX.node.style.visibility = 'hidden';\n            }\n            else if (this.guideX) {\n                let minY = null;\n                let maxY = null;\n                if (stateX) {\n                    minY = Math.min(bounds.y + delta.y - this.graph.getPanDy(), stateX.y);\n                    maxY = Math.max(bounds.y + bounds.height + delta.y - this.graph.getPanDy(), \n                    // @ts-ignore stateX! doesn't work for some reason...\n                    stateX.y + stateX.height);\n                }\n                if (minY !== null && maxY !== null) {\n                    this.guideX.points = [new Point(valueX, minY), new Point(valueX, maxY)];\n                }\n                else {\n                    this.guideX.points = [\n                        new Point(valueX, -this.graph.getPanDy()),\n                        new Point(valueX, c.scrollHeight - 3 - this.graph.getPanDy()),\n                    ];\n                }\n                this.guideX.stroke = this.getGuideColor(stateX, true);\n                this.guideX.node.style.visibility = 'visible';\n                this.guideX.redraw();\n            }\n            if (!overrideY && this.guideY != null) {\n                this.guideY.node.style.visibility = 'hidden';\n            }\n            else if (this.guideY != null) {\n                let minX = null;\n                let maxX = null;\n                if (stateY != null && bounds != null) {\n                    minX = Math.min(bounds.x + delta.x - this.graph.getPanDx(), stateY.x);\n                    maxX = Math.max(bounds.x + bounds.width + delta.x - this.graph.getPanDx(), \n                    // @ts-ignore\n                    stateY.x + stateY.width);\n                }\n                if (minX != null && maxX != null && valueY !== null) {\n                    this.guideY.points = [new Point(minX, valueY), new Point(maxX, valueY)];\n                }\n                else if (valueY !== null) {\n                    this.guideY.points = [\n                        new Point(-this.graph.getPanDx(), valueY),\n                        new Point(c.scrollWidth - 3 - this.graph.getPanDx(), valueY),\n                    ];\n                }\n                this.guideY.stroke = this.getGuideColor(stateY, false);\n                this.guideY.node.style.visibility = 'visible';\n                this.guideY.redraw();\n            }\n        }\n        return delta;\n    }\n    /**\n     * Rounds to pixels for virtual states (eg. page guides)\n     */\n    getDelta(bounds, stateX = null, dx, stateY = null, dy) {\n        const s = this.graph.view.scale;\n        if (this.rounded || (stateX != null && stateX.cell == null)) {\n            dx = Math.round((bounds.x + dx) / s) * s - bounds.x;\n        }\n        if (this.rounded || (stateY != null && stateY.cell == null)) {\n            dy = Math.round((bounds.y + dy) / s) * s - bounds.y;\n        }\n        return new Point(dx, dy);\n    }\n    /**\n     * Hides all current guides.\n     */\n    getGuideColor(state, horizontal) {\n        return GUIDE_COLOR;\n    }\n    /**\n     * Hides all current guides.\n     */\n    hide() {\n        this.setVisible(false);\n    }\n    /**\n     * Shows or hides the current guides.\n     */\n    setVisible(visible) {\n        if (this.guideX) {\n            this.guideX.node.style.visibility = visible ? 'visible' : 'hidden';\n        }\n        if (this.guideY) {\n            this.guideY.node.style.visibility = visible ? 'visible' : 'hidden';\n        }\n    }\n    /**\n     * Destroys all resources that this object uses.\n     */\n    destroy() {\n        if (this.guideX) {\n            this.guideX.destroy();\n            this.guideX = null;\n        }\n        if (this.guideY) {\n            this.guideY.destroy();\n            this.guideY = null;\n        }\n    }\n}\nexport default Guide;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../../Client';\nimport InternalEvent from '../event/InternalEvent';\nimport { contains, getRotatedPoint, isNumeric, toRadians } from '../../util/mathUtils';\nimport { convertPoint } from '../../util/styleUtils';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport mxGuide from '../other/Guide';\nimport Point from '../geometry/Point';\nimport { CURSOR, DIALECT, DROP_TARGET_COLOR, INVALID_CONNECT_TARGET_COLOR, NONE, VALID_COLOR, } from '../../util/Constants';\nimport Dictionary from '../../util/Dictionary';\nimport CellHighlight from '../cell/CellHighlight';\nimport Rectangle from '../geometry/Rectangle';\nimport { getClientX, getClientY, isAltDown, isMultiTouchEvent, } from '../../util/EventUtils';\n/**\n * Graph event handler that handles selection. Individual cells are handled\n * separately using {@link VertexHandler} or one of the edge handlers. These\n * handlers are created using {@link Graph#createHandler} in\n * {@link GraphSelectionModel#cellAdded}.\n *\n * To avoid the container to scroll a moved cell into view, set {@link scrollOnMove} to `false`.\n *\n * @category Plugin\n */\nclass SelectionHandler {\n    /**\n     * Constructs an event handler that creates handles for the selection cells.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     */\n    constructor(graph) {\n        this.refreshThread = null;\n        /**\n         * Defines the maximum number of cells to paint subhandles\n         * for. Default is 50 for Firefox and 20 for IE. Set this\n         * to 0 if you want an unlimited number of handles to be\n         * displayed. This is only recommended if the number of\n         * cells in the graph is limited to a small number, eg.\n         * 500.\n         */\n        this.maxCells = 50;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies if drop targets under the mouse should be enabled. Default is\n         * true.\n         */\n        this.highlightEnabled = true;\n        /**\n         * Specifies if cloning by control-drag is enabled. Default is true.\n         */\n        this.cloneEnabled = true;\n        /**\n         * Specifies if moving is enabled. Default is true.\n         */\n        this.moveEnabled = true;\n        /**\n         * Specifies if other cells should be used for snapping the right, center or\n         * left side of the current selection. Default is false.\n         */\n        this.guidesEnabled = false;\n        /**\n         * Whether the handles of the selection are currently visible.\n         */\n        this.handlesVisible = true;\n        /**\n         * Holds the {@link Guide} instance that is used for alignment.\n         */\n        this.guide = null;\n        /**\n         * Stores the x-coordinate of the current mouse move.\n         */\n        this.currentDx = 0;\n        /**\n         * Stores the y-coordinate of the current mouse move.\n         */\n        this.currentDy = 0;\n        /**\n         * Specifies if a move cursor should be shown if the mouse is over a movable\n         * cell. Default is true.\n         */\n        this.updateCursor = true;\n        /**\n         * Specifies if selecting is enabled. Default is true.\n         */\n        this.selectEnabled = true;\n        /**\n         * Specifies if cells may be moved out of their parents. Default is true.\n         */\n        this.removeCellsFromParent = true;\n        /**\n         * If empty parents should be removed from the model after all child cells\n         * have been moved out. Default is true.\n         */\n        this.removeEmptyParents = false;\n        /**\n         * Specifies if drop events are interpreted as new connections if no other\n         * drop action is defined. Default is false.\n         */\n        this.connectOnDrop = false;\n        /**\n         * Specifies if the view should be scrolled so that a moved cell is visible.\n         * @default true\n         */\n        this.scrollOnMove = true;\n        /**\n         * Specifies the minimum number of pixels for the width and height of a\n         * selection border. Default is 6.\n         */\n        this.minimumSize = 6;\n        /**\n         * Specifies the color of the preview shape. Default is black.\n         */\n        this.previewColor = 'black';\n        /**\n         * Specifies if the graph container should be used for preview. If this is used\n         * then drop target detection relies entirely on {@link Graph#getCellAt} because\n         * the HTML preview does not \"let events through\". Default is false.\n         */\n        this.htmlPreview = false;\n        /**\n         * Reference to the {@link Shape} that represents the preview.\n         */\n        this.shape = null;\n        /**\n         * Specifies if the grid should be scaled. Default is false.\n         */\n        this.scaleGrid = false;\n        /**\n         * Specifies if the bounding box should allow for rotation. Default is true.\n         */\n        this.rotationEnabled = true;\n        /**\n         * Maximum number of cells for which live preview should be used.  Default is 0 which means no live preview.\n         */\n        this.maxLivePreview = 0;\n        /**\n         * Variable allowLivePreview\n         *\n         * If live preview is allowed on this system.  Default is true for systems with SVG support.\n         */\n        this.allowLivePreview = Client.IS_SVG;\n        this.cell = null;\n        this.delayedSelection = false;\n        this.first = null;\n        this.cells = null;\n        this.bounds = null;\n        this.pBounds = null;\n        this.allCells = new Dictionary();\n        this.cellWasClicked = false;\n        this.cloning = false;\n        this.cellCount = 0;\n        this.target = null;\n        this.suspended = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.highlight = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Repaints the handler after autoscroll\n        this.panHandler = () => {\n            if (!this.suspended) {\n                this.updatePreview();\n                this.updateHint();\n            }\n        };\n        this.graph.addListener(InternalEvent.PAN, this.panHandler);\n        // Handles escape keystrokes\n        this.escapeHandler = (sender, evt) => {\n            this.reset();\n        };\n        this.graph.addListener(InternalEvent.ESCAPE, this.escapeHandler);\n        // Updates the preview box for remote changes\n        this.refreshHandler = (sender, evt) => {\n            // Merges multiple pending calls\n            if (this.refreshThread) {\n                window.clearTimeout(this.refreshThread);\n            }\n            // Waits for the states and handlers to be updated\n            this.refreshThread = window.setTimeout(() => {\n                this.refreshThread = null;\n                if (this.first && !this.suspended && this.cells) {\n                    // Updates preview with no translate to compute bounding box\n                    const dx = this.currentDx;\n                    const dy = this.currentDy;\n                    this.currentDx = 0;\n                    this.currentDy = 0;\n                    this.updatePreview();\n                    this.bounds = this.graph.getView().getBounds(this.cells);\n                    this.pBounds = this.getPreviewBounds(this.cells);\n                    if (this.pBounds == null && !this.livePreviewUsed) {\n                        this.reset();\n                    }\n                    else {\n                        // Restores translate and updates preview\n                        this.currentDx = dx;\n                        this.currentDy = dy;\n                        this.updatePreview();\n                        this.updateHint();\n                        if (this.livePreviewUsed) {\n                            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                            // Forces update to ignore last visible state\n                            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false, true);\n                            this.updatePreview();\n                        }\n                    }\n                }\n            }, 0);\n        };\n        this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.refreshHandler);\n        this.graph.addListener(InternalEvent.REFRESH, this.refreshHandler);\n        this.keyHandler = (e) => {\n            if (this.graph.container != null &&\n                this.graph.container.style.visibility !== 'hidden' &&\n                this.first != null &&\n                !this.suspended) {\n                const clone = this.graph.isCloneEvent(e) &&\n                    this.graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                if (clone !== this.cloning) {\n                    this.cloning = clone;\n                    this.checkPreview();\n                    this.updatePreview();\n                }\n            }\n        };\n        if (typeof document !== 'undefined') {\n            InternalEvent.addListener(document, 'keydown', this.keyHandler);\n            InternalEvent.addListener(document, 'keyup', this.keyHandler);\n        }\n    }\n    /**\n     * Returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets <enabled>.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns <cloneEnabled>.\n     */\n    isCloneEnabled() {\n        return this.cloneEnabled;\n    }\n    /**\n     * Sets <cloneEnabled>.\n     *\n     * @param value Boolean that specifies the new clone enabled state.\n     */\n    setCloneEnabled(value) {\n        this.cloneEnabled = value;\n    }\n    /**\n     * Returns {@link oveEnabled}.\n     */\n    isMoveEnabled() {\n        return this.moveEnabled;\n    }\n    /**\n     * Sets {@link oveEnabled}.\n     */\n    setMoveEnabled(value) {\n        this.moveEnabled = value;\n    }\n    /**\n     * Returns <selectEnabled>.\n     */\n    isSelectEnabled() {\n        return this.selectEnabled;\n    }\n    /**\n     * Sets <selectEnabled>.\n     */\n    setSelectEnabled(value) {\n        this.selectEnabled = value;\n    }\n    /**\n     * Returns <removeCellsFromParent>.\n     */\n    isRemoveCellsFromParent() {\n        return this.removeCellsFromParent;\n    }\n    /**\n     * Sets <removeCellsFromParent>.\n     */\n    setRemoveCellsFromParent(value) {\n        this.removeCellsFromParent = value;\n    }\n    /**\n     * Returns true if the given cell and parent should propagate\n     * selection state to the parent.\n     */\n    isPropagateSelectionCell(cell, immediate, me) {\n        const parent = cell.getParent();\n        if (immediate) {\n            const geo = cell.isEdge() ? null : cell.getGeometry();\n            return ((!this.graph.isSiblingSelected(cell) && geo && geo.relative) ||\n                !this.graph.isSwimlane(parent));\n        }\n        return ((!this.graph.isToggleEvent(me.getEvent()) ||\n            (!this.graph.isSiblingSelected(cell) &&\n                !this.graph.isCellSelected(cell) &&\n                !this.graph.isSwimlane(parent)) ||\n            this.graph.isCellSelected(parent)) &&\n            (this.graph.isToggleEvent(me.getEvent()) || !this.graph.isCellSelected(parent)));\n    }\n    /**\n     * Hook to return initial cell for the given event.\n     */\n    getInitialCellForEvent(me) {\n        let state = me.getState();\n        if ((!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) &&\n            state &&\n            !this.graph.isCellSelected(state.cell)) {\n            let parent = state.cell.getParent();\n            let next = parent ? this.graph.view.getState(parent) : null;\n            while (next &&\n                !this.graph.isCellSelected(next.cell) &&\n                (next.cell.isVertex() || next.cell.isEdge()) &&\n                this.isPropagateSelectionCell(state.cell, true, me)) {\n                state = next;\n                parent = state.cell.getParent();\n                next = parent ? this.graph.view.getState(parent) : null;\n            }\n        }\n        return state ? state.cell : null;\n    }\n    /**\n     * Hook to return true for delayed selections.\n     */\n    isDelayedSelection(cell, me) {\n        let c = cell;\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n            while (c) {\n                if (selectionCellsHandler?.isHandled(c)) {\n                    const cellEditorHandler = this.graph.getPlugin('CellEditorHandler');\n                    return cellEditorHandler?.getEditingCell() !== c;\n                }\n                c = c.getParent();\n            }\n        }\n        return this.graph.isToggleEvent(me.getEvent()) && !isAltDown(me.getEvent());\n    }\n    /**\n     * Implements the delayed selection for the given mouse event.\n     */\n    selectDelayed(me) {\n        const popupMenuHandler = this.graph.getPlugin('PopupMenuHandler');\n        if (!popupMenuHandler || !popupMenuHandler.isPopupTrigger(me)) {\n            let cell = me.getCell();\n            if (cell === null) {\n                cell = this.cell;\n            }\n            if (cell)\n                this.selectCellForEvent(cell, me);\n        }\n    }\n    /**\n     * Selects the given cell for the given {@link MouseEvent}.\n     */\n    selectCellForEvent(cell, me) {\n        const state = this.graph.view.getState(cell);\n        if (state) {\n            if (me.isSource(state.control)) {\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n            else {\n                if (!this.graph.isToggleEvent(me.getEvent()) || !isAltDown(me.getEvent())) {\n                    let parent = cell.getParent();\n                    while (parent &&\n                        this.graph.view.getState(parent) &&\n                        (parent.isVertex() || parent.isEdge()) &&\n                        this.isPropagateSelectionCell(cell, false, me)) {\n                        cell = parent;\n                        parent = cell.getParent();\n                    }\n                }\n                this.graph.selectCellForEvent(cell, me.getEvent());\n            }\n        }\n        return cell;\n    }\n    /**\n     * Consumes the given mouse event. NOTE: This may be used to enable click\n     * events for links in labels on iOS as follows as consuming the initial\n     * touchStart disables firing the subsequent click evnent on the link.\n     *\n     * <code>\n     * consumeMouseEvent(evtName, me)\n     * {\n     *   var source = mxEvent.getSource(me.getEvent());\n     *\n     *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n     *   {\n     *     me.consume();\n     *   }\n     * }\n     * </code>\n     */\n    consumeMouseEvent(evtName, me) {\n        me.consume();\n    }\n    /**\n     * Handles the event by selecing the given cell and creating a handle for\n     * it. By consuming the event all subsequent events of the gesture are\n     * redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() &&\n            this.isEnabled() &&\n            this.graph.isEnabled() &&\n            me.getState() &&\n            !isMultiTouchEvent(me.getEvent())) {\n            const cell = this.getInitialCellForEvent(me);\n            if (cell) {\n                this.delayedSelection = this.isDelayedSelection(cell, me);\n                this.cell = null;\n                if (this.isSelectEnabled() && !this.delayedSelection) {\n                    this.graph.selectCellForEvent(cell, me.getEvent());\n                }\n                if (this.isMoveEnabled()) {\n                    const geo = cell.getGeometry();\n                    if (geo &&\n                        this.graph.isCellMovable(cell) &&\n                        (!cell.isEdge() ||\n                            this.graph.getSelectionCount() > 1 ||\n                            (geo.points && geo.points.length > 0) ||\n                            !cell.getTerminal(true) ||\n                            !cell.getTerminal(false) ||\n                            this.graph.isAllowDanglingEdges() ||\n                            (this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable()))) {\n                        this.start(cell, me.getX(), me.getY());\n                    }\n                    else if (this.delayedSelection) {\n                        this.cell = cell;\n                    }\n                    this.cellWasClicked = true;\n                    this.consumeMouseEvent(InternalEvent.MOUSE_DOWN, me);\n                }\n            }\n        }\n    }\n    /**\n     * Creates an array of cell states which should be used as guides.\n     */\n    getGuideStates() {\n        const parent = this.graph.getDefaultParent();\n        const filter = (cell) => {\n            const geo = cell.getGeometry();\n            return (!!this.graph.view.getState(cell) && cell.isVertex() && !!geo && !geo.relative);\n        };\n        return this.graph.view.getCellStates(parent.filterDescendants(filter));\n    }\n    /**\n     * Returns the cells to be modified by this handler. This implementation\n     * returns all selection cells that are movable, or the given initial cell if\n     * the given cell is not selected and movable. This handles the case of moving\n     * unselectable or unselected cells.\n     *\n     * @param initialCell <Cell> that triggered this handler.\n     */\n    getCells(initialCell) {\n        if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {\n            return [initialCell];\n        }\n        return this.graph.getMovableCells(this.graph.getSelectionCells());\n    }\n    /**\n     * Returns the {@link Rectangle} used as the preview bounds for\n     * moving the given cells.\n     */\n    getPreviewBounds(cells) {\n        const bounds = this.getBoundingBox(cells);\n        if (bounds) {\n            // Corrects width and height\n            bounds.width = Math.max(0, bounds.width - 1);\n            bounds.height = Math.max(0, bounds.height - 1);\n            if (bounds.width < this.minimumSize) {\n                const dx = this.minimumSize - bounds.width;\n                bounds.x -= dx / 2;\n                bounds.width = this.minimumSize;\n            }\n            else {\n                bounds.x = Math.round(bounds.x);\n                bounds.width = Math.ceil(bounds.width);\n            }\n            if (bounds.height < this.minimumSize) {\n                const dy = this.minimumSize - bounds.height;\n                bounds.y -= dy / 2;\n                bounds.height = this.minimumSize;\n            }\n            else {\n                bounds.y = Math.round(bounds.y);\n                bounds.height = Math.ceil(bounds.height);\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Returns the union of the {@link CellStates} for the given array of {@link Cells}.\n     * For vertices, this method uses the bounding box of the corresponding shape\n     * if one exists. The bounding box of the corresponding text label and all\n     * controls and overlays are ignored. See also: {@link GraphView#getBounds} and\n     * {@link Graph#getBoundingBox}.\n     *\n     * @param cells Array of {@link Cells} whose bounding box should be returned.\n     */\n    getBoundingBox(cells) {\n        let result = null;\n        if (cells.length > 0) {\n            for (let i = 0; i < cells.length; i += 1) {\n                if (cells[i].isVertex() || cells[i].isEdge()) {\n                    const state = this.graph.view.getState(cells[i]);\n                    if (state) {\n                        let bbox = null;\n                        if (cells[i].isVertex() && state.shape && state.shape.boundingBox) {\n                            bbox = state.shape.boundingBox;\n                        }\n                        if (bbox) {\n                            if (!result) {\n                                result = Rectangle.fromRectangle(bbox);\n                            }\n                            else {\n                                result.add(bbox);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Creates the shape used to draw the preview for the given bounds.\n     */\n    createPreviewShape(bounds) {\n        const shape = new RectangleShape(bounds, NONE, this.previewColor);\n        shape.isDashed = true;\n        if (this.htmlPreview) {\n            shape.dialect = DIALECT.STRICTHTML;\n            shape.init(this.graph.container);\n        }\n        else {\n            // Makes sure to use either VML or SVG shapes in order to implement\n            // event-transparency on the background area of the rectangle since\n            // HTML shapes do not let mouseevents through even when transparent\n            shape.dialect = DIALECT.SVG;\n            shape.init(this.graph.getView().getOverlayPane());\n            shape.pointerEvents = false;\n            // Workaround for artifacts on iOS\n            if (Client.IS_IOS) {\n                shape.getSvgScreenOffset = () => {\n                    return 0;\n                };\n            }\n        }\n        return shape;\n    }\n    createGuide() {\n        return new mxGuide(this.graph, this.getGuideStates());\n    }\n    /**\n     * Starts the handling of the mouse gesture.\n     */\n    start(cell, x, y, cells) {\n        this.cell = cell;\n        this.first = convertPoint(this.graph.container, x, y);\n        this.cells = cells ? cells : this.getCells(this.cell);\n        this.bounds = this.graph.getView().getBounds(this.cells);\n        this.pBounds = this.getPreviewBounds(this.cells);\n        this.cloning = false;\n        this.cellCount = 0;\n        for (let i = 0; i < this.cells.length; i += 1) {\n            this.cellCount += this.addStates(this.cells[i], this.allCells);\n        }\n        if (this.guidesEnabled) {\n            this.guide = this.createGuide();\n            const parent = cell.getParent();\n            const ignore = parent.getChildCount() < 2;\n            // Uses connected states as guides\n            const connected = new Dictionary();\n            const opps = this.graph.getOpposites(this.graph.getEdges(this.cell), this.cell);\n            for (let i = 0; i < opps.length; i += 1) {\n                const state = this.graph.view.getState(opps[i]);\n                if (state && !connected.get(state)) {\n                    connected.put(state, true);\n                }\n            }\n            this.guide.isStateIgnored = (state) => {\n                const p = state.cell.getParent();\n                return (!!state.cell &&\n                    ((!this.cloning && !!this.isCellMoving(state.cell)) ||\n                        (state.cell !== (this.target || parent) &&\n                            !ignore &&\n                            !connected.get(state) &&\n                            (!this.target || this.target.getChildCount() >= 2) &&\n                            p !== (this.target || parent))));\n            };\n        }\n    }\n    /**\n     * Adds the states for the given cell recursively to the given dictionary.\n     * @param cell\n     * @param dict\n     */\n    addStates(cell, dict) {\n        const state = this.graph.view.getState(cell);\n        let count = 0;\n        if (state && !dict.get(cell)) {\n            dict.put(cell, state);\n            count++;\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                count += this.addStates(cell.getChildAt(i), dict);\n            }\n        }\n        return count;\n    }\n    /**\n     * Returns true if the given cell is currently being moved.\n     */\n    isCellMoving(cell) {\n        return this.allCells.get(cell);\n    }\n    /**\n     * Returns true if the guides should be used for the given {@link MouseEvent}.\n     * This implementation returns {@link Guide#isEnabledForEvent}.\n     */\n    useGuidesForEvent(me) {\n        return this.guide\n            ? this.guide.isEnabledForEvent(me.getEvent()) &&\n                !this.graph.isConstrainedEvent(me.getEvent())\n            : true;\n    }\n    /**\n     * Snaps the given vector to the grid and returns the given mxPoint instance.\n     */\n    snap(vector) {\n        const scale = this.scaleGrid ? this.graph.view.scale : 1;\n        vector.x = this.graph.snap(vector.x / scale) * scale;\n        vector.y = this.graph.snap(vector.y / scale) * scale;\n        return vector;\n    }\n    /**\n     * Returns an {@link Point} that represents the vector for moving the cells\n     * for the given {@link MouseEvent}.\n     */\n    getDelta(me) {\n        const point = convertPoint(this.graph.container, me.getX(), me.getY());\n        if (!this.first)\n            return new Point();\n        return new Point(point.x - this.first.x - this.graph.getPanDx(), point.y - this.first.y - this.graph.getPanDy());\n    }\n    /**\n     * Hook for subclassers do show details while the handler is active.\n     */\n    updateHint(me) {\n        return;\n    }\n    /**\n     * Hooks for subclassers to hide details when the handler gets inactive.\n     */\n    removeHint() {\n        return;\n    }\n    /**\n     * Hook for rounding the unscaled vector. This uses Math.round.\n     */\n    roundLength(length) {\n        return Math.round(length * 100) / 100;\n    }\n    /**\n     * Returns true if the given cell is a valid drop target.\n     */\n    isValidDropTarget(target, me) {\n        return this.cell ? this.cell.getParent() !== target : false;\n    }\n    /**\n     * Updates the preview if cloning state has changed.\n     */\n    checkPreview() {\n        if (this.livePreviewActive && this.cloning) {\n            this.resetLivePreview();\n            this.livePreviewActive = false;\n        }\n        else if (this.maxLivePreview >= this.cellCount &&\n            !this.livePreviewActive &&\n            this.allowLivePreview) {\n            if (!this.cloning || !this.livePreviewActive) {\n                this.livePreviewActive = true;\n                this.livePreviewUsed = true;\n            }\n        }\n        else if (!this.livePreviewUsed && !this.shape && this.bounds) {\n            this.shape = this.createPreviewShape(this.bounds);\n        }\n    }\n    /**\n     * Handles the event by highlighting possible drop targets and updating the\n     * preview.\n     */\n    mouseMove(sender, me) {\n        const { graph } = this;\n        if (!me.isConsumed() &&\n            graph.isMouseDown &&\n            this.cell &&\n            this.first &&\n            this.bounds &&\n            !this.suspended) {\n            // Stops moving if a multi touch event is received\n            if (isMultiTouchEvent(me.getEvent())) {\n                this.reset();\n                return;\n            }\n            let delta = this.getDelta(me);\n            const tol = graph.getEventTolerance();\n            if (this.shape ||\n                this.livePreviewActive ||\n                Math.abs(delta.x) > tol ||\n                Math.abs(delta.y) > tol) {\n                // Highlight is used for highlighting drop targets\n                if (!this.highlight) {\n                    this.highlight = new CellHighlight(this.graph, DROP_TARGET_COLOR, 3);\n                }\n                const clone = graph.isCloneEvent(me.getEvent()) &&\n                    graph.isCellsCloneable() &&\n                    this.isCloneEnabled();\n                const gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n                const cell = me.getCell();\n                let hideGuide = true;\n                let target = null;\n                this.cloning = clone;\n                if (graph.isDropEnabled() && this.highlightEnabled && this.cells) {\n                    // Contains a call to getCellAt to find the cell under the mouse\n                    target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n                }\n                let state = target ? graph.getView().getState(target) : null;\n                let highlight = false;\n                if (state && (clone || (target && this.isValidDropTarget(target, me)))) {\n                    if (this.target !== target) {\n                        this.target = target;\n                        this.setHighlightColor(DROP_TARGET_COLOR);\n                    }\n                    highlight = true;\n                }\n                else {\n                    this.target = null;\n                    if (this.connectOnDrop &&\n                        cell &&\n                        this.cells &&\n                        this.cells.length === 1 &&\n                        cell.isVertex() &&\n                        cell.isConnectable()) {\n                        state = graph.getView().getState(cell);\n                        if (state) {\n                            const error = graph.getEdgeValidationError(null, this.cell, cell);\n                            const color = error === null ? VALID_COLOR : INVALID_CONNECT_TARGET_COLOR;\n                            this.setHighlightColor(color);\n                            highlight = true;\n                        }\n                    }\n                }\n                if (state && highlight) {\n                    this.highlight.highlight(state);\n                }\n                else {\n                    this.highlight.hide();\n                }\n                if (this.guide && this.useGuidesForEvent(me)) {\n                    delta = this.guide.move(this.bounds, delta, gridEnabled, clone);\n                    hideGuide = false;\n                }\n                else {\n                    delta = this.graph.snapDelta(delta, this.bounds, !gridEnabled, false, false);\n                }\n                if (this.guide && hideGuide) {\n                    this.guide.hide();\n                }\n                // Constrained movement if shift key is pressed\n                if (graph.isConstrainedEvent(me.getEvent())) {\n                    if (Math.abs(delta.x) > Math.abs(delta.y)) {\n                        delta.y = 0;\n                    }\n                    else {\n                        delta.x = 0;\n                    }\n                }\n                this.checkPreview();\n                if (this.currentDx !== delta.x || this.currentDy !== delta.y) {\n                    this.currentDx = delta.x;\n                    this.currentDy = delta.y;\n                    this.updatePreview();\n                }\n            }\n            this.updateHint(me);\n            this.consumeMouseEvent(InternalEvent.MOUSE_MOVE, me);\n            // Cancels the bubbling of events to the container so\n            // that the droptarget is not reset due to an mouseMove\n            // fired on the container with no associated state.\n            InternalEvent.consume(me.getEvent());\n        }\n        else if ((this.isMoveEnabled() || this.isCloneEnabled()) &&\n            this.updateCursor &&\n            !me.isConsumed() &&\n            (me.getState() || me.sourceState) &&\n            !graph.isMouseDown) {\n            let cursor = graph.getCursorForMouseEvent(me);\n            const cell = me.getCell();\n            if (!cursor && cell && graph.isEnabled() && graph.isCellMovable(cell)) {\n                if (cell.isEdge()) {\n                    cursor = CURSOR.MOVABLE_EDGE;\n                }\n                else {\n                    cursor = CURSOR.MOVABLE_VERTEX;\n                }\n            }\n            // Sets the cursor on the original source state under the mouse\n            // instead of the event source state which can be the parent\n            if (cursor && me.sourceState) {\n                me.sourceState.setCursor(cursor);\n            }\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreview(remote = false) {\n        if (this.livePreviewUsed && !remote) {\n            if (this.cells) {\n                const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n                this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], false);\n                this.updateLivePreview(this.currentDx, this.currentDy);\n            }\n        }\n        else {\n            this.updatePreviewShape();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updatePreviewShape() {\n        if (this.shape && this.pBounds) {\n            this.shape.bounds = new Rectangle(Math.round(this.pBounds.x + this.currentDx), Math.round(this.pBounds.y + this.currentDy), this.pBounds.width, this.pBounds.height);\n            this.shape.redraw();\n        }\n    }\n    /**\n     * Updates the bounds of the preview shape.\n     */\n    updateLivePreview(dx, dy) {\n        if (!this.suspended) {\n            const states = [];\n            if (this.allCells) {\n                this.allCells.visit((key, state) => {\n                    const realState = state ? this.graph.view.getState(state.cell) : null;\n                    // Checks if cell was removed or replaced\n                    if (realState !== state && state) {\n                        state.destroy();\n                        if (realState) {\n                            this.allCells.put(state.cell, realState);\n                        }\n                        else {\n                            this.allCells.remove(state.cell);\n                        }\n                        state = realState;\n                    }\n                    if (state) {\n                        // Saves current state\n                        const tempState = state.clone();\n                        states.push([state, tempState]);\n                        // Makes transparent for events to detect drop targets\n                        if (state.shape) {\n                            if (state.shape.originalPointerEvents === null) {\n                                state.shape.originalPointerEvents = state.shape.pointerEvents;\n                            }\n                            state.shape.pointerEvents = false;\n                            if (state.text) {\n                                if (state.text.originalPointerEvents === null) {\n                                    state.text.originalPointerEvents = state.text.pointerEvents;\n                                }\n                                state.text.pointerEvents = false;\n                            }\n                        }\n                        // Temporarily changes position\n                        if (state.cell.isVertex()) {\n                            state.x += dx;\n                            state.y += dy;\n                            // Draws the live preview\n                            if (!this.cloning) {\n                                state.view.graph.cellRenderer.redraw(state, true);\n                                // Forces redraw of connected edges after all states\n                                // have been updated but avoids update of state\n                                state.view.invalidate(state.cell);\n                                state.invalid = false;\n                                // Hides folding icon\n                                if (state.control && state.control.node) {\n                                    state.control.node.style.visibility = 'hidden';\n                                }\n                            }\n                            // Clone live preview may use text bounds\n                            else if (state.text) {\n                                state.text.updateBoundingBox();\n                                // Fixes preview box for edge labels\n                                if (state.text.boundingBox) {\n                                    state.text.boundingBox.x += dx;\n                                    state.text.boundingBox.y += dy;\n                                }\n                                if (state.text.unrotatedBoundingBox) {\n                                    state.text.unrotatedBoundingBox.x += dx;\n                                    state.text.unrotatedBoundingBox.y += dy;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            // Resets the handler if everything was removed\n            if (states.length === 0) {\n                this.reset();\n            }\n            else {\n                // Redraws connected edges\n                const s = this.graph.view.scale;\n                for (let i = 0; i < states.length; i += 1) {\n                    const state = states[i][0];\n                    if (state.cell.isEdge()) {\n                        const geometry = state.cell.getGeometry();\n                        const points = [];\n                        if (geometry && geometry.points) {\n                            for (let j = 0; j < geometry.points.length; j++) {\n                                if (geometry.points[j]) {\n                                    points.push(new Point(geometry.points[j].x + dx / s, geometry.points[j].y + dy / s));\n                                }\n                            }\n                        }\n                        let source = state.visibleSourceState;\n                        let target = state.visibleTargetState;\n                        const pts = states[i][1].absolutePoints;\n                        if (source == null || !this.isCellMoving(source.cell)) {\n                            const pt0 = pts[0];\n                            if (pt0) {\n                                state.setAbsoluteTerminalPoint(new Point(pt0.x + dx, pt0.y + dy), true);\n                                source = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, source, true, this.graph.getConnectionConstraint(state, source, true));\n                        }\n                        if (target == null || !this.isCellMoving(target.cell)) {\n                            const ptn = pts[pts.length - 1];\n                            if (ptn) {\n                                state.setAbsoluteTerminalPoint(new Point(ptn.x + dx, ptn.y + dy), false);\n                                target = null;\n                            }\n                        }\n                        else {\n                            state.view.updateFixedTerminalPoint(state, target, false, this.graph.getConnectionConstraint(state, target, false));\n                        }\n                        state.view.updatePoints(state, points, source, target);\n                        state.view.updateFloatingTerminalPoints(state, source, target);\n                        state.view.updateEdgeLabelOffset(state);\n                        state.invalid = false;\n                        // Draws the live preview but avoids update of state\n                        if (!this.cloning) {\n                            state.view.graph.cellRenderer.redraw(state, true);\n                        }\n                    }\n                }\n                this.graph.view.validate();\n                this.redrawHandles(states);\n                this.resetPreviewStates(states);\n            }\n        }\n    }\n    /**\n     * Redraws the preview shape for the given states array.\n     */\n    redrawHandles(states) {\n        const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n        for (let i = 0; i < states.length; i += 1) {\n            const handler = selectionCellsHandler?.getHandler(states[i][0].cell);\n            handler?.redraw(true);\n        }\n    }\n    /**\n     * Resets the given preview states array.\n     */\n    resetPreviewStates(states) {\n        for (let i = 0; i < states.length; i += 1) {\n            states[i][0].setState(states[i][1]);\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    suspend() {\n        if (!this.suspended) {\n            if (this.livePreviewUsed) {\n                this.updateLivePreview(0, 0);\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'hidden';\n            }\n            if (this.guide) {\n                this.guide.setVisible(false);\n            }\n            this.suspended = true;\n        }\n    }\n    /**\n     * Suspends the livew preview.\n     */\n    resume() {\n        if (this.suspended) {\n            this.suspended = false;\n            if (this.livePreviewUsed) {\n                this.livePreviewActive = true;\n            }\n            if (this.shape) {\n                this.shape.node.style.visibility = 'visible';\n            }\n            if (this.guide) {\n                this.guide.setVisible(true);\n            }\n        }\n    }\n    /**\n     * Resets the livew preview.\n     */\n    resetLivePreview() {\n        this.allCells.visit((key, state) => {\n            // Restores event handling\n            if (state.shape && state.shape.originalPointerEvents !== null) {\n                state.shape.pointerEvents = state.shape.originalPointerEvents;\n                state.shape.originalPointerEvents = null;\n                // Forces repaint even if not moved to update pointer events\n                state.shape.bounds = null;\n                if (state.text && state.text.originalPointerEvents !== null) {\n                    state.text.pointerEvents = state.text.originalPointerEvents;\n                    state.text.originalPointerEvents = null;\n                }\n            }\n            // Shows folding icon\n            if (state.control &&\n                state.control.node &&\n                state.control.node.style.visibility === 'hidden') {\n                state.control.node.style.visibility = '';\n            }\n            // Fixes preview box for edge labels\n            if (!this.cloning) {\n                if (state.text) {\n                    state.text.updateBoundingBox();\n                }\n            }\n            // Forces repaint of connected edges\n            state.view.invalidate(state.cell);\n        });\n        // Repaints all invalid states\n        this.graph.view.validate();\n    }\n    /**\n     * Sets wether the handles attached to the given cells are visible.\n     *\n     * @param cells Array of {@link Cells}.\n     * @param visible Boolean that specifies if the handles should be visible.\n     * @param force Forces an update of the handler regardless of the last used value.\n     */\n    setHandlesVisibleForCells(cells, visible, force = false) {\n        if (force || this.handlesVisible !== visible) {\n            this.handlesVisible = visible;\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            for (let i = 0; i < cells.length; i += 1) {\n                const handler = selectionCellsHandler?.getHandler(cells[i]);\n                if (handler) {\n                    handler.setHandlesVisible(visible);\n                    if (visible) {\n                        handler.redraw();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Sets the color of the rectangle used to highlight drop targets.\n     *\n     * @param color String that represents the new highlight color.\n     */\n    setHighlightColor(color) {\n        if (this.highlight) {\n            this.highlight.setHighlightColor(color);\n        }\n    }\n    /**\n     * Handles the event by applying the changes to the selection cells.\n     */\n    mouseUp(sender, me) {\n        if (!me.isConsumed()) {\n            if (this.livePreviewUsed) {\n                this.resetLivePreview();\n            }\n            if (this.cell &&\n                this.first &&\n                (this.shape || this.livePreviewUsed) &&\n                isNumeric(this.currentDx) &&\n                isNumeric(this.currentDy)) {\n                const { graph } = this;\n                const cell = me.getCell();\n                if (this.connectOnDrop &&\n                    !this.target &&\n                    cell &&\n                    cell.isVertex() &&\n                    cell.isConnectable() &&\n                    graph.isEdgeValid(null, this.cell, cell)) {\n                    const connectionHandler = graph.getPlugin('ConnectionHandler');\n                    connectionHandler?.connect(this.cell, cell, me.getEvent());\n                }\n                else {\n                    const clone = graph.isCloneEvent(me.getEvent()) &&\n                        graph.isCellsCloneable() &&\n                        this.isCloneEnabled();\n                    const { scale } = graph.getView();\n                    const dx = this.roundLength(this.currentDx / scale);\n                    const dy = this.roundLength(this.currentDy / scale);\n                    const target = this.target;\n                    if (target &&\n                        graph.isSplitEnabled() &&\n                        this.cells &&\n                        graph.isSplitTarget(target, this.cells, me.getEvent())) {\n                        graph.splitEdge(target, this.cells, null, dx, dy, me.getGraphX(), me.getGraphY());\n                    }\n                    else if (this.cells) {\n                        this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n                    }\n                }\n            }\n            else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {\n                this.selectDelayed(me);\n            }\n        }\n        // Consumes the event if a cell was initially clicked\n        if (this.cellWasClicked) {\n            this.consumeMouseEvent(InternalEvent.MOUSE_UP, me);\n        }\n        this.reset();\n    }\n    /**\n     * Resets the state of this handler.\n     */\n    reset() {\n        if (this.livePreviewUsed) {\n            this.resetLivePreview();\n            const selectionCellsHandler = this.graph.getPlugin('SelectionCellsHandler');\n            this.setHandlesVisibleForCells(selectionCellsHandler?.getHandledSelectionCells() ?? [], true);\n        }\n        this.destroyShapes();\n        this.removeHint();\n        this.delayedSelection = false;\n        this.livePreviewActive = false;\n        this.livePreviewUsed = false;\n        this.cellWasClicked = false;\n        this.suspended = false;\n        this.currentDx = 0;\n        this.currentDy = 0;\n        this.cellCount = 0;\n        this.cloning = false;\n        this.allCells.clear();\n        this.pBounds = null;\n        this.target = null;\n        this.first = null;\n        this.cells = null;\n        this.cell = null;\n    }\n    /**\n     * Returns true if the given cells should be removed from the parent for the specified\n     * mousereleased event.\n     */\n    shouldRemoveCellsFromParent(parent, cells, evt) {\n        if (parent.isVertex()) {\n            const pState = this.graph.getView().getState(parent);\n            if (pState) {\n                let pt = convertPoint(this.graph.container, getClientX(evt), getClientY(evt));\n                const alpha = toRadians(pState.style.rotation ?? 0);\n                if (alpha !== 0) {\n                    const cos = Math.cos(-alpha);\n                    const sin = Math.sin(-alpha);\n                    const cx = new Point(pState.getCenterX(), pState.getCenterY());\n                    pt = getRotatedPoint(pt, cos, sin, cx);\n                }\n                return !contains(pState, pt.x, pt.y);\n            }\n        }\n        return false;\n    }\n    /**\n     * Moves the given cells by the specified amount.\n     */\n    moveCells(cells, dx, dy, clone, target, evt) {\n        if (!this.cell)\n            return;\n        if (clone) {\n            cells = this.graph.getCloneableCells(cells);\n        }\n        // Removes cells from parent\n        const parent = this.cell.getParent();\n        if (!target &&\n            parent &&\n            this.isRemoveCellsFromParent() &&\n            this.shouldRemoveCellsFromParent(parent, cells, evt)) {\n            target = this.graph.getDefaultParent();\n        }\n        // Cloning into locked cells is not allowed\n        clone = !!clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n        this.graph.batchUpdate(() => {\n            const parents = [];\n            // Removes parent if all child cells are removed\n            if (!clone && target && this.removeEmptyParents) {\n                // Collects all non-selected parents\n                const dict = new Dictionary();\n                for (let i = 0; i < cells.length; i += 1) {\n                    dict.put(cells[i], true);\n                }\n                // LATER: Recurse up the cell hierarchy\n                for (let i = 0; i < cells.length; i += 1) {\n                    const par = cells[i].getParent();\n                    if (par && !dict.get(par)) {\n                        dict.put(par, true);\n                        parents.push(par);\n                    }\n                }\n            }\n            // Passes all selected cells in order to correctly clone or move into\n            // the target cell. The method checks for each cell if its movable.\n            cells = this.graph.moveCells(cells, dx, dy, clone, target, evt);\n            // Removes parent if all child cells are removed\n            const temp = [];\n            for (let i = 0; i < parents.length; i += 1) {\n                if (this.shouldRemoveParent(parents[i])) {\n                    temp.push(parents[i]);\n                }\n            }\n            this.graph.removeCells(temp, false);\n        });\n        // Selects the new cells if cells have been cloned\n        if (clone) {\n            this.graph.setSelectionCells(cells);\n        }\n        if (this.isSelectEnabled() && this.scrollOnMove) {\n            this.graph.scrollCellToVisible(cells[0]);\n        }\n    }\n    /**\n     * Returns true if the given parent should be removed after removal of child cells.\n     */\n    shouldRemoveParent(parent) {\n        const state = this.graph.view.getState(parent);\n        return (state != null &&\n            (state.cell.isEdge() || state.cell.isVertex()) &&\n            this.graph.isCellDeletable(state.cell) &&\n            state.cell.getChildCount() === 0 &&\n            state.isTransparentState());\n    }\n    /**\n     * Destroy the preview and highlight shapes.\n     */\n    destroyShapes() {\n        // Destroys the preview dashed rectangle\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n        if (this.guide) {\n            this.guide.destroy();\n            this.guide = null;\n        }\n        // Destroys the drop target highlight\n        if (this.highlight) {\n            this.highlight.destroy();\n            this.highlight = null;\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.panHandler);\n        this.graph.removeListener(this.escapeHandler);\n        this.graph.getDataModel().removeListener(this.refreshHandler);\n        this.graph.removeListener(this.refreshHandler);\n        InternalEvent.removeListener(document, 'keydown', this.keyHandler);\n        InternalEvent.removeListener(document, 'keyup', this.keyHandler);\n        this.destroyShapes();\n        this.removeHint();\n    }\n}\nSelectionHandler.pluginId = 'SelectionHandler';\nexport default SelectionHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Implements a handler for panning.\n */\nclass PanningManager {\n    constructor(graph) {\n        /**\n         * Damper value for the panning. Default is 1/6.\n         */\n        this.damper = 1 / 6;\n        /**\n         * Delay in milliseconds for the panning. Default is 10.\n         */\n        this.delay = 10;\n        /**\n         * Specifies if mouse events outside of the component should be handled. Default is true.\n         */\n        this.handleMouseOut = true;\n        /**\n         * Border to handle automatic panning inside the component. Default is 0 (disabled).\n         */\n        this.border = 0;\n        this.thread = null;\n        this.active = false;\n        this.tdx = 0;\n        this.tdy = 0;\n        this.t0x = 0;\n        this.t0y = 0;\n        this.dx = 0;\n        this.dy = 0;\n        this.scrollbars = false;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n        this.thread = null;\n        this.active = false;\n        this.tdx = 0;\n        this.tdy = 0;\n        this.t0x = 0;\n        this.t0y = 0;\n        this.dx = 0;\n        this.dy = 0;\n        this.scrollbars = false;\n        this.scrollLeft = 0;\n        this.scrollTop = 0;\n        this.mouseListener = {\n            mouseDown: (sender, me) => {\n                return;\n            },\n            mouseMove: (sender, me) => {\n                return;\n            },\n            mouseUp: (sender, me) => {\n                if (this.active) {\n                    this.stop();\n                }\n            },\n        };\n        graph.addMouseListener(this.mouseListener);\n        this.mouseUpListener = () => {\n            if (this.active) {\n                this.stop();\n            }\n        };\n        // Stops scrolling on every mouseup anywhere in the document\n        InternalEvent.addListener(document, 'mouseup', this.mouseUpListener);\n        const createThread = () => {\n            this.scrollbars = hasScrollbars(graph.container);\n            this.scrollLeft = graph.container.scrollLeft;\n            this.scrollTop = graph.container.scrollTop;\n            return window.setInterval(() => {\n                this.tdx -= this.dx;\n                this.tdy -= this.dy;\n                if (this.scrollbars) {\n                    const left = -graph.container.scrollLeft - Math.ceil(this.dx);\n                    const top = -graph.container.scrollTop - Math.ceil(this.dy);\n                    graph.panGraph(left, top);\n                    graph.setPanDx(this.scrollLeft - graph.container.scrollLeft);\n                    graph.setPanDy(this.scrollTop - graph.container.scrollTop);\n                    graph.fireEvent(new EventObject(InternalEvent.PAN));\n                    // TODO: Implement graph.autoExtend\n                }\n                else {\n                    graph.panGraph(this.getDx(), this.getDy());\n                }\n            }, this.delay);\n        };\n        this.isActive = () => {\n            return this.active;\n        };\n        this.getDx = () => {\n            return Math.round(this.tdx);\n        };\n        this.getDy = () => {\n            return Math.round(this.tdy);\n        };\n        this.start = () => {\n            this.t0x = graph.view.translate.x;\n            this.t0y = graph.view.translate.y;\n            this.active = true;\n        };\n        this.panTo = (x, y, w = 0, h = 0) => {\n            if (!this.active) {\n                this.start();\n            }\n            this.scrollLeft = graph.container.scrollLeft;\n            this.scrollTop = graph.container.scrollTop;\n            const c = graph.container;\n            this.dx = x + w - c.scrollLeft - c.clientWidth;\n            if (this.dx < 0 && Math.abs(this.dx) < this.border) {\n                this.dx = this.border + this.dx;\n            }\n            else if (this.handleMouseOut) {\n                this.dx = Math.max(this.dx, 0);\n            }\n            else {\n                this.dx = 0;\n            }\n            if (this.dx == 0) {\n                this.dx = x - c.scrollLeft;\n                if (this.dx > 0 && this.dx < this.border) {\n                    this.dx -= this.border;\n                }\n                else if (this.handleMouseOut) {\n                    this.dx = Math.min(0, this.dx);\n                }\n                else {\n                    this.dx = 0;\n                }\n            }\n            this.dy = y + h - c.scrollTop - c.clientHeight;\n            if (this.dy < 0 && Math.abs(this.dy) < this.border) {\n                this.dy = this.border + this.dy;\n            }\n            else if (this.handleMouseOut) {\n                this.dy = Math.max(this.dy, 0);\n            }\n            else {\n                this.dy = 0;\n            }\n            if (this.dy == 0) {\n                this.dy = y - c.scrollTop;\n                if (this.dy > 0 && this.dy < this.border) {\n                    this.dy -= this.border;\n                }\n                else if (this.handleMouseOut) {\n                    this.dy = Math.min(0, this.dy);\n                }\n                else {\n                    this.dy = 0;\n                }\n            }\n            if (this.dx != 0 || this.dy != 0) {\n                this.dx *= this.damper;\n                this.dy *= this.damper;\n                if (this.thread == null) {\n                    this.thread = createThread();\n                }\n            }\n            else if (this.thread != null) {\n                window.clearInterval(this.thread);\n                this.thread = null;\n            }\n        };\n        this.stop = () => {\n            if (this.active) {\n                this.active = false;\n                if (this.thread != null) {\n                    window.clearInterval(this.thread);\n                    this.thread = null;\n                }\n                this.tdx = 0;\n                this.tdy = 0;\n                if (!this.scrollbars) {\n                    const px = graph.getPanDx();\n                    const py = graph.getPanDy();\n                    if (px != 0 || py != 0) {\n                        graph.panGraph(0, 0);\n                        graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);\n                    }\n                }\n                else {\n                    graph.setPanDx(0);\n                    graph.setPanDy(0);\n                    graph.fireEvent(new EventObject(InternalEvent.PAN));\n                }\n            }\n        };\n        this.destroy = () => {\n            graph.removeMouseListener(this.mouseListener);\n            InternalEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n        };\n    }\n}\nexport default PanningManager;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport { hasScrollbars } from '../../util/styleUtils';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\nimport { isConsumed, isControlDown, isLeftMouseButton, isMultiTouchEvent, isPopupTrigger, isShiftDown, } from '../../util/EventUtils';\nimport PanningManager from '../other/PanningManager';\n/**\n * Event handler that pans and creates popupmenus. To use the left\n * mouse button for panning without interfering with cell moving and\n * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\n * steps while panning, use <useGrid>.\n *\n * When registered in the {@link Graph.constructor} plugins list, it can be enabled using {@link Graph.setPanning}.\n *\n * Event: mxEvent.PAN_START\n *\n * Fires when the panning handler changes its <active> state to true. The\n * <code>event</code> property contains the corresponding {@link MouseEvent}.\n *\n * Event: mxEvent.PAN\n *\n * Fires while handle is processing events. The <code>event</code> property contains\n * the corresponding {@link MouseEvent}.\n *\n * Event: mxEvent.PAN_END\n *\n * Fires when the panning handler changes its <active> state to false. The\n * <code>event</code> property contains the corresponding {@link MouseEvent}.\n *\n * @category Plugin\n */\nclass PanningHandler extends EventSource {\n    constructor(graph) {\n        super();\n        this.getPanningManager = () => this.panningManager;\n        /**\n         * Specifies if panning should be active for the left mouse button.\n         * Setting this to true may conflict with {@link Rubberband}. Default is false.\n         */\n        this.useLeftButtonForPanning = false;\n        /**\n         * Specifies if {@link Event#isPopupTrigger} should also be used for panning.\n         */\n        this.usePopupTrigger = true;\n        /**\n         * Specifies if panning should be active even if there is a cell under the\n         * mousepointer. Default is false.\n         */\n        this.ignoreCell = false;\n        /**\n         * Specifies if the panning should be previewed. Default is true.\n         */\n        this.previewEnabled = true;\n        /**\n         * Specifies if the panning steps should be aligned to the grid size.\n         * Default is false.\n         */\n        this.useGrid = false;\n        /**\n         * Specifies if panning should be enabled. Default is false.\n         */\n        this.panningEnabled = false;\n        /**\n         * Specifies if pinch gestures should be handled as zoom. Default is true.\n         */\n        this.pinchEnabled = true;\n        this.initialScale = 0;\n        /**\n         * Specifies the maximum scale. Default is 8.\n         */\n        this.maxScale = 8;\n        /**\n         * Specifies the minimum scale. Default is 0.01.\n         */\n        this.minScale = 0.01;\n        /**\n         * Holds the current horizontal offset.\n         */\n        this.dx = 0;\n        /**\n         * Holds the current vertical offset.\n         */\n        this.dy = 0;\n        /**\n         * Holds the x-coordinate of the start point.\n         */\n        this.startX = 0;\n        /**\n         * Holds the y-coordinate of the start point.\n         */\n        this.startY = 0;\n        this.dx0 = 0;\n        this.dy0 = 0;\n        this.panningTrigger = false;\n        this.active = false;\n        this.mouseDownEvent = null;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Handles force panning event\n        this.forcePanningHandler = (sender, eo) => {\n            const evtName = eo.getProperty('eventName');\n            const me = eo.getProperty('event');\n            if (evtName === InternalEvent.MOUSE_DOWN && this.isForcePanningEvent(me)) {\n                this.start(me);\n                this.active = true;\n                this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));\n                me.consume();\n            }\n        };\n        this.graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);\n        // Handles pinch gestures\n        this.gestureHandler = (sender, eo) => {\n            if (this.isPinchEnabled()) {\n                const evt = eo.getProperty('event');\n                if (!isConsumed(evt) && evt.type === 'gesturestart') {\n                    this.initialScale = this.graph.view.scale;\n                    // Forces start of panning when pinch gesture starts\n                    if (!this.active && this.mouseDownEvent) {\n                        this.start(this.mouseDownEvent);\n                        this.mouseDownEvent = null;\n                    }\n                }\n                else if (evt.type === 'gestureend' && this.initialScale !== 0) {\n                    this.initialScale = 0;\n                }\n                if (this.initialScale !== 0) {\n                    this.zoomGraph(evt);\n                }\n            }\n        };\n        this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);\n        this.mouseUpListener = () => {\n            if (this.active) {\n                this.reset();\n            }\n        };\n        // Stops scrolling on every mouseup anywhere in the document\n        InternalEvent.addListener(document, 'mouseup', this.mouseUpListener);\n        this.panningManager = new PanningManager(graph);\n    }\n    /**\n     * Returns true if the handler is currently active.\n     */\n    isActive() {\n        return this.active || this.initialScale !== null;\n    }\n    /**\n     * Returns <panningEnabled>.\n     */\n    isPanningEnabled() {\n        return this.panningEnabled;\n    }\n    /**\n     * Sets <panningEnabled>.\n     */\n    setPanningEnabled(value) {\n        this.panningEnabled = value;\n    }\n    /**\n     * Returns <pinchEnabled>.\n     */\n    isPinchEnabled() {\n        return this.pinchEnabled;\n    }\n    /**\n     * Sets <pinchEnabled>.\n     */\n    setPinchEnabled(value) {\n        this.pinchEnabled = value;\n    }\n    /**\n     * Returns true if the given event is a panning trigger for the optional\n     * given cell. This returns true if control-shift is pressed or if\n     * <usePopupTrigger> is true and the event is a popup trigger.\n     */\n    isPanningTrigger(me) {\n        const evt = me.getEvent();\n        return ((this.useLeftButtonForPanning && !me.getState() && isLeftMouseButton(evt)) ||\n            (isControlDown(evt) && isShiftDown(evt)) ||\n            (this.usePopupTrigger && isPopupTrigger(evt)));\n    }\n    /**\n     * Returns true if the given {@link MouseEvent} should start panning. This\n     * implementation always returns true if <ignoreCell> is true or for\n     * multi touch events.\n     */\n    isForcePanningEvent(me) {\n        return this.ignoreCell || isMultiTouchEvent(me.getEvent());\n    }\n    /**\n     * Handles the event by initiating the panning. By consuming the event all\n     * subsequent events of the gesture are redirected to this handler.\n     */\n    mouseDown(sender, me) {\n        this.mouseDownEvent = me;\n        if (!me.isConsumed() &&\n            this.isPanningEnabled() &&\n            !this.active &&\n            this.isPanningTrigger(me)) {\n            this.start(me);\n            this.consumePanningTrigger(me);\n        }\n    }\n    /**\n     * Starts panning at the given event.\n     */\n    start(me) {\n        this.dx0 = -this.graph.container.scrollLeft;\n        this.dy0 = -this.graph.container.scrollTop;\n        // Stores the location of the trigger event\n        this.startX = me.getX();\n        this.startY = me.getY();\n        this.dx = 0;\n        this.dy = 0;\n        this.panningTrigger = true;\n    }\n    /**\n     * Consumes the given {@link MouseEvent} if it was a panning trigger in\n     * {@link ouseDown}. The default is to invoke {@link MouseEvent#consume}. Note that this\n     * will block any further event processing. If you haven't disabled built-in\n     * context menus and require immediate selection of the cell on mouseDown in\n     * Safari and/or on the Mac, then use the following code:\n     *\n     * ```javascript\n     * consumePanningTrigger(me)\n     * {\n     *   if (me.evt.preventDefault)\n     *   {\n     *     me.evt.preventDefault();\n     *   }\n     *\n     *   // Stops event processing in IE\n     *   me.evt.returnValue = false;\n     *\n     *   // Sets local consumed state\n     *   if (!Client.IS_SF && !Client.IS_MAC)\n     *   {\n     *     me.consumed = true;\n     *   }\n     * };\n     * ```\n     */\n    consumePanningTrigger(me) {\n        me.consume();\n    }\n    /**\n     * Handles the event by updating the panning on the graph.\n     */\n    mouseMove(sender, me) {\n        this.dx = me.getX() - this.startX;\n        this.dy = me.getY() - this.startY;\n        if (this.active) {\n            if (this.previewEnabled) {\n                // Applies the grid to the panning steps\n                if (this.useGrid) {\n                    this.dx = this.graph.snap(this.dx);\n                    this.dy = this.graph.snap(this.dy);\n                }\n                this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);\n            }\n            this.fireEvent(new EventObject(InternalEvent.PAN, { event: me }));\n        }\n        else if (this.panningTrigger) {\n            const tmp = this.active;\n            // Panning is activated only if the mouse is moved\n            // beyond the graph tolerance\n            this.active =\n                Math.abs(this.dx) > this.graph.getSnapTolerance() ||\n                    Math.abs(this.dy) > this.graph.getSnapTolerance();\n            if (!tmp && this.active) {\n                this.fireEvent(new EventObject(InternalEvent.PAN_START, { event: me }));\n            }\n        }\n        if (this.active || this.panningTrigger) {\n            me.consume();\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    mouseUp(sender, me) {\n        if (this.active) {\n            if (this.dx !== 0 && this.dy !== 0) {\n                // Ignores if scrollbars have been used for panning\n                if (!this.graph.isUseScrollbarsForPanning() ||\n                    !hasScrollbars(this.graph.container)) {\n                    const { scale } = this.graph.getView();\n                    const t = this.graph.getView().translate;\n                    this.graph.panGraph(0, 0);\n                    this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);\n                }\n                me.consume();\n            }\n            this.fireEvent(new EventObject(InternalEvent.PAN_END, { event: me }));\n        }\n        this.reset();\n    }\n    /**\n     * Zooms the graph to the given value and consumed the event if needed.\n     */\n    zoomGraph(evt) {\n        // @ts-ignore evt may have scale property\n        let value = Math.round(this.initialScale * evt.scale * 100) / 100;\n        value = Math.max(this.minScale, value);\n        value = Math.min(this.maxScale, value);\n        if (this.graph.view.scale !== value) {\n            this.graph.zoomTo(value);\n            InternalEvent.consume(evt);\n        }\n    }\n    /**\n     * Handles the event by setting the translation on the view or showing the\n     * popupmenu.\n     */\n    reset() {\n        this.panningTrigger = false;\n        this.mouseDownEvent = null;\n        this.active = false;\n        this.dx = 0;\n        this.dy = 0;\n    }\n    /**\n     * Pans <graph> by the given amount.\n     */\n    panGraph(dx, dy) {\n        this.graph.getView().setTranslate(dx, dy);\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes.\n     */\n    onDestroy() {\n        this.graph.removeMouseListener(this);\n        this.graph.removeListener(this.forcePanningHandler);\n        this.graph.removeListener(this.gestureHandler);\n        InternalEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n    }\n}\nPanningHandler.pluginId = 'PanningHandler';\nexport default PanningHandler;\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellEditorHandler from '../handler/CellEditorHandler';\nimport TooltipHandler from '../handler/TooltipHandler';\nimport SelectionCellsHandler from '../handler/SelectionCellsHandler';\nimport PopupMenuHandler from '../handler/PopupMenuHandler';\nimport ConnectionHandler from '../handler/ConnectionHandler';\nimport SelectionHandler from '../handler/SelectionHandler';\nimport PanningHandler from '../handler/PanningHandler';\n/**\n * Returns the list of plugins used by default in `maxGraph`.\n *\n * The function returns a new array each time it is called.\n *\n * @category Plugin\n * @since 0.13.0\n */\nexport const getDefaultPlugins = () => [\n    CellEditorHandler,\n    TooltipHandler,\n    SelectionCellsHandler,\n    PopupMenuHandler,\n    ConnectionHandler,\n    SelectionHandler,\n    PanningHandler,\n];\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Image from './image/ImageBox';\nimport EventObject from './event/EventObject';\nimport EventSource from './event/EventSource';\nimport InternalEvent from './event/InternalEvent';\nimport Rectangle from './geometry/Rectangle';\nimport Client from '../Client';\nimport GraphView from './GraphView';\nimport CellRenderer from './cell/CellRenderer';\nimport { getCurrentStyle, hasScrollbars, parseCssNumber } from '../util/styleUtils';\nimport Cell from './cell/Cell';\nimport GraphDataModel from './GraphDataModel';\nimport { Stylesheet } from './style/Stylesheet';\nimport { PAGE_FORMAT_A4_PORTRAIT } from '../util/Constants';\nimport ChildChange from './undoable_changes/ChildChange';\nimport GeometryChange from './undoable_changes/GeometryChange';\nimport RootChange from './undoable_changes/RootChange';\nimport StyleChange from './undoable_changes/StyleChange';\nimport TerminalChange from './undoable_changes/TerminalChange';\nimport ValueChange from './undoable_changes/ValueChange';\nimport { isNode } from '../util/domUtils';\nimport EdgeStyle from './style/EdgeStyle';\nimport EdgeHandler from './handler/EdgeHandler';\nimport VertexHandler from './handler/VertexHandler';\nimport EdgeSegmentHandler from './handler/EdgeSegmentHandler';\nimport ElbowEdgeHandler from './handler/ElbowEdgeHandler';\nimport GraphSelectionModel from './GraphSelectionModel';\nimport { registerDefaultShapes } from './cell/register-shapes';\nimport { registerDefaultEdgeMarkers } from './geometry/edge/MarkerShape';\nimport { registerDefaultStyleElements } from './style/register';\nimport { applyGraphMixins } from './mixins/_graph-mixins-apply';\nimport { getDefaultPlugins } from './plugins';\n/**\n * Extends {@link EventSource} to implement a graph component for the browser. This is the main class of the package.\n *\n * To activate panning and connections use {@link setPanning} and {@link setConnectable}.\n * For rubberband selection you must create a new instance of {@link rubberband}.\n *\n * The following listeners are added to {@link mouseListeners} by default:\n *\n * - tooltipHandler: {@link TooltipHandler} that displays tooltips\n * - panningHandler: {@link PanningHandler} for panning and popup menus\n * - connectionHandler: {@link ConnectionHandler} for creating connections\n * - selectionHandler: {@link SelectionHandler} for moving and cloning cells\n *\n * These listeners will be called in the above order if they are enabled.\n */\nclass Graph extends EventSource {\n    // ===================================================================================================================\n    // Group: \"Create Class Instance\" factory functions.\n    // These can be overridden in subclasses of Graph to allow the Graph to instantiate user-defined implementations with\n    // custom behavior.\n    // ===================================================================================================================\n    /**\n     * Creates a new {@link CellRenderer} to be used in this graph.\n     */\n    createCellRenderer() {\n        return new CellRenderer();\n    }\n    /**\n     * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.\n     *\n     * @param state {@link CellState} to create the handler for.\n     */\n    createEdgeHandlerInstance(state) {\n        // Note this method not being called createEdgeHandler to keep compatibility\n        // with older code which overrides/calls createEdgeHandler\n        return new EdgeHandler(state);\n    }\n    /**\n     * Hooks to create a new {@link EdgeSegmentHandler} for the given {@link CellState}.\n     *\n     * @param state {@link CellState} to create the handler for.\n     */\n    createEdgeSegmentHandler(state) {\n        return new EdgeSegmentHandler(state);\n    }\n    /**\n     * Hooks to create a new {@link ElbowEdgeHandler} for the given {@link CellState}.\n     *\n     * @param state {@link CellState} to create the handler for.\n     */\n    createElbowEdgeHandler(state) {\n        return new ElbowEdgeHandler(state);\n    }\n    /**\n     * Creates a new {@link GraphDataModel} to be used in this graph.\n     */\n    createGraphDataModel() {\n        return new GraphDataModel();\n    }\n    /**\n     * Creates a new {@link GraphView} to be used in this graph.\n     */\n    createGraphView() {\n        return new GraphView(this);\n    }\n    /**\n     * Creates a new {@link GraphSelectionModel} to be used in this graph.\n     */\n    createSelectionModel() {\n        return new GraphSelectionModel(this);\n    }\n    /**\n     * Creates a new {@link Stylesheet} to be used in this graph.\n     */\n    createStylesheet() {\n        return new Stylesheet();\n    }\n    /**\n     * Hooks to create a new {@link VertexHandler} for the given {@link CellState}.\n     *\n     * @param state {@link CellState} to create the handler for.\n     */\n    createVertexHandler(state) {\n        return new VertexHandler(state);\n    }\n    // ===================================================================================================================\n    // Group: Main graph constructor and functions\n    // ===================================================================================================================\n    registerDefaults() {\n        registerDefaultShapes();\n        registerDefaultStyleElements();\n        registerDefaultEdgeMarkers();\n    }\n    constructor(container, model, plugins = getDefaultPlugins(), stylesheet = null) {\n        super();\n        this.destroyed = false;\n        this.graphModelChangeListener = null;\n        this.paintBackground = null;\n        this.isConstrainedMoving = false;\n        // ===================================================================================================================\n        // Group: Variables (that maybe should be in the mixins, but need to be created for each new class instance)\n        // ===================================================================================================================\n        this.cells = [];\n        this.imageBundles = [];\n        /**\n         * Holds the mouse event listeners. See {@link fireMouseEvent}.\n         */\n        this.mouseListeners = [];\n        /**\n         * An array of {@link Multiplicity} describing the allowed connections in a graph.\n         */\n        this.multiplicities = [];\n        this.plugins = {};\n        /**\n         * RenderHint as it was passed to the constructor.\n         */\n        this.renderHint = null;\n        /**\n         * Dialect to be used for drawing the graph. Possible values are all constants in {@link DIALECT}.\n         */\n        this.dialect = 'svg';\n        /**\n         * Value returned by {@link getOverlap} if {@link isAllowOverlapParent} returns\n         * `true` for the given cell. {@link getOverlap} is used in {@link constrainChild} if\n         * {@link isConstrainChild} returns `true`. The value specifies the\n         * portion of the child which is allowed to overlap the parent.\n         */\n        this.defaultOverlap = 0.5;\n        /**\n         * Specifies the default parent to be used to insert new cells.\n         * This is used in {@link getDefaultParent}.\n         * @default null\n         */\n        this.defaultParent = null;\n        /**\n         * Specifies the {@link Image} to be returned by {@link getBackgroundImage}.\n         * @default null\n         *\n         * @example\n         * ```javascript\n         * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\n         * graph.setBackgroundImage(img);\n         * graph.view.validate();\n         * ```\n         */\n        this.backgroundImage = null;\n        /**\n         * Specifies if the background page should be visible.\n         * Not yet implemented.\n         * @default false\n         */\n        this.pageVisible = false;\n        /**\n         * Specifies if a dashed line should be drawn between multiple pages.\n         * If you change this value while a graph is being displayed then you\n         * should call {@link sizeDidChange} to force an update of the display.\n         * @default false\n         */\n        this.pageBreaksVisible = false;\n        /**\n         * Specifies the color for page breaks.\n         * @default gray\n         */\n        this.pageBreakColor = 'gray';\n        /**\n         * Specifies the page breaks should be dashed.\n         * @default true\n         */\n        this.pageBreakDashed = true;\n        /**\n         * Specifies the minimum distance in pixels for page breaks to be visible.\n         * @default 20\n         */\n        this.minPageBreakDist = 20;\n        /**\n         * Specifies if the graph size should be rounded to the next page number in\n         * {@link sizeDidChange}. This is only used if the graph container has scrollbars.\n         * @default false\n         */\n        this.preferPageSize = false;\n        /**\n         * Specifies the page format for the background page.\n         * This is used as the default in {@link PrintPreview} and for painting the background page\n         * if {@link pageVisible} is `true` and the page breaks if {@link pageBreaksVisible} is `true`.\n         * @default {@link mxConstants.PAGE_FORMAT_A4_PORTRAIT}\n         */\n        this.pageFormat = new Rectangle(...PAGE_FORMAT_A4_PORTRAIT);\n        /**\n         * Specifies the scale of the background page.\n         * Not yet implemented.\n         * @default 1.5\n         */\n        this.pageScale = 1.5;\n        /**\n         * Specifies the return value for {@link isEnabled}.\n         * @default true\n         */\n        this.enabled = true;\n        /**\n         * Specifies the return value for {@link canExportCell}.\n         * @default true\n         */\n        this.exportEnabled = true;\n        /**\n         * Specifies the return value for {@link canImportCell}.\n         * @default true\n         */\n        this.importEnabled = true;\n        /**\n         * Specifies if the graph should automatically scroll regardless of the\n         * scrollbars. This will scroll the container using positive values for\n         * scroll positions (ie usually only rightwards and downwards). To avoid\n         * possible conflicts with panning, set {@link translateToScrollPosition} to `true`.\n         */\n        this.ignoreScrollbars = false;\n        /**\n         * Specifies if the graph should automatically convert the current scroll\n         * position to a translate in the graph view when a mouseUp event is received.\n         * This can be used to avoid conflicts when using {@link autoScroll} and\n         * {@link ignoreScrollbars} with no scrollbars in the container.\n         */\n        this.translateToScrollPosition = false;\n        /**\n         * {@link Rectangle} that specifies the area in which all cells in the diagram\n         * should be placed. Uses in {@link getMaximumGraphBounds}. Use a width or height of\n         * `0` if you only want to give a upper, left corner.\n         */\n        this.maximumGraphBounds = null;\n        /**\n         * {@link Rectangle} that specifies the minimum size of the graph. This is ignored\n         * if the graph container has no scrollbars.\n         * @default null\n         */\n        this.minimumGraphSize = null;\n        /**\n         * {@link Rectangle} that specifies the minimum size of the {@link container} if\n         * {@link resizeContainer} is `true`.\n         */\n        this.minimumContainerSize = null;\n        /**\n         * {@link Rectangle} that specifies the maximum size of the container if\n         * {@link resizeContainer} is `true`.\n         */\n        this.maximumContainerSize = null;\n        /**\n         * Specifies if the container should be resized to the graph size when\n         * the graph size has changed.\n         * @default false\n         */\n        this.resizeContainer = false;\n        /**\n         * Border to be added to the bottom and right side when the container is\n         * being resized after the graph has been changed.\n         * @default 0\n         */\n        this.border = 0;\n        /**\n         * Specifies if edges should appear in the foreground regardless of their order\n         * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are\n         * both `true` then the normal order is applied.\n         * @default false\n         */\n        this.keepEdgesInForeground = false;\n        /**\n         * Specifies if edges should appear in the background regardless of their order\n         * in the model. If {@link keepEdgesInForeground} and {@link keepEdgesInBackground} are\n         * both `true` then the normal order is applied.\n         * @default false\n         */\n        this.keepEdgesInBackground = false;\n        /**\n         * Specifies the return value for {@link isRecursiveResize}.\n         * @default false (for backwards compatibility)\n         */\n        this.recursiveResize = false;\n        /**\n         * Specifies if the scale and translate should be reset if the root changes in\n         * the model.\n         * @default true\n         */\n        this.resetViewOnRootChange = true;\n        /**\n         * Specifies if loops (aka self-references) are allowed.\n         * @default false\n         */\n        this.allowLoops = false;\n        /**\n         * {@link EdgeStyle} to be used for loops. This is a fallback for loops if the\n         * {@link CellStateStyle.loopStyle} is `undefined`.\n         * @default {@link EdgeStyle.Loop}\n         */\n        this.defaultLoopStyle = EdgeStyle.Loop;\n        /**\n         * Specifies if multiple edges in the same direction between the same pair of\n         * vertices are allowed.\n         * @default true\n         */\n        this.multigraph = true;\n        /**\n         * Specifies the minimum scale to be applied in {@link fit}. Set this to `null` to allow any value.\n         * @default 0.1\n         */\n        this.minFitScale = 0.1;\n        /**\n         * Specifies the maximum scale to be applied in {@link fit}. Set this to `null` to allow any value.\n         * @default 8\n         */\n        this.maxFitScale = 8;\n        /**\n         * Specifies the {@link Image} for the image to be used to display a warning\n         * overlay. See {@link setCellWarning}. Default value is Client.imageBasePath +\n         * '/warning'.  The extension for the image depends on the platform. It is\n         * '.png' on the Mac and '.gif' on all other platforms.\n         */\n        this.warningImage = new Image(`${Client.imageBasePath}/warning${Client.IS_MAC ? '.png' : '.gif'}`, 16, 16);\n        /**\n         * Specifies the resource key for the error message to be displayed in\n         * non-multigraphs when two vertices are already connected. If the resource\n         * for this key does not exist then the value is used as the error message.\n         * @default 'alreadyConnected'\n         */\n        this.alreadyConnectedResource = Client.language != 'none' ? 'alreadyConnected' : '';\n        /**\n         * Specifies the resource key for the warning message to be displayed when\n         * a collapsed cell contains validation errors. If the resource for this\n         * key does not exist then the value is used as the warning message.\n         * @default 'containsValidationErrors'\n         */\n        this.containsValidationErrorsResource = Client.language != 'none' ? 'containsValidationErrors' : '';\n        this.getContainer = () => this.container;\n        this.getPlugin = (id) => this.plugins[id];\n        this.getCellRenderer = () => this.cellRenderer;\n        this.getDialect = () => this.dialect;\n        this.isPageVisible = () => this.pageVisible;\n        this.isPageBreaksVisible = () => this.pageBreaksVisible;\n        this.getPageBreakColor = () => this.pageBreakColor;\n        this.isPageBreakDashed = () => this.pageBreakDashed;\n        this.getMinPageBreakDist = () => this.minPageBreakDist;\n        this.isPreferPageSize = () => this.preferPageSize;\n        this.getPageFormat = () => this.pageFormat;\n        this.getPageScale = () => this.pageScale;\n        this.isExportEnabled = () => this.exportEnabled;\n        this.isImportEnabled = () => this.importEnabled;\n        this.isIgnoreScrollbars = () => this.ignoreScrollbars;\n        this.isTranslateToScrollPosition = () => this.translateToScrollPosition;\n        this.getMinimumGraphSize = () => this.minimumGraphSize;\n        this.setMinimumGraphSize = (size) => (this.minimumGraphSize = size);\n        this.getMinimumContainerSize = () => this.minimumContainerSize;\n        this.setMinimumContainerSize = (size) => (this.minimumContainerSize = size);\n        this.getAlreadyConnectedResource = () => this.alreadyConnectedResource;\n        this.getContainsValidationErrorsResource = () => this.containsValidationErrorsResource;\n        this.registerDefaults();\n        this.container = container ?? document.createElement('div');\n        this.model = model ?? this.createGraphDataModel();\n        this.cellRenderer = this.createCellRenderer();\n        this.setStylesheet(stylesheet ?? this.createStylesheet());\n        this.view = this.createGraphView();\n        // Adds a graph model listener to update the view\n        this.graphModelChangeListener = (sender, evt) => {\n            this.graphModelChanged(evt.getProperty('edit').changes);\n        };\n        this.getDataModel().addListener(InternalEvent.CHANGE, this.graphModelChangeListener);\n        // Initializes the container using the view\n        this.view.init();\n        // Updates the size of the container for the current graph\n        this.sizeDidChange();\n        // Set the selection model\n        this.setSelectionModel(this.createSelectionModel());\n        // Initializes plugins\n        plugins.forEach((p) => (this.plugins[p.pluginId] = new p(this)));\n        this.view.revalidate();\n    }\n    getWarningImage() {\n        return this.warningImage;\n    }\n    /**\n     * Updates the model in a transaction.\n     *\n     * @param fn the update to be performed in the transaction.\n     *\n     * @see {@link GraphDataModel.batchUpdate}\n     */\n    batchUpdate(fn) {\n        this.getDataModel().batchUpdate(fn);\n    }\n    /**\n     * Returns the {@link GraphDataModel} that contains the cells.\n     */\n    getDataModel() {\n        return this.model;\n    }\n    /**\n     * Returns the {@link GraphView} that contains the {@link mxCellStates}.\n     */\n    getView() {\n        return this.view;\n    }\n    /**\n     * Returns the {@link Stylesheet} that defines the style.\n     */\n    getStylesheet() {\n        return this.stylesheet;\n    }\n    /**\n     * Sets the {@link Stylesheet} that defines the style.\n     */\n    setStylesheet(stylesheet) {\n        this.stylesheet = stylesheet;\n    }\n    /**\n     * Called when the graph model changes. Invokes {@link processChange} on each\n     * item of the given array to update the view accordingly.\n     *\n     * @param changes Array that contains the individual changes.\n     */\n    graphModelChanged(changes) {\n        for (const change of changes) {\n            this.processChange(change);\n        }\n        this.updateSelection();\n        this.view.validate();\n        this.sizeDidChange();\n    }\n    /**\n     * Processes the given change and invalidates the respective cached data\n     * in {@link GraphView}. This fires a {@link root} event if the root has changed in the\n     * model.\n     *\n     * @param {(RootChange|ChildChange|TerminalChange|GeometryChange|ValueChange|StyleChange)} change - Object that represents the change on the model.\n     */\n    processChange(change) {\n        // Resets the view settings, removes all cells and clears\n        // the selection if the root changes.\n        if (change instanceof RootChange) {\n            this.clearSelection();\n            this.setDefaultParent(null);\n            if (change.previous)\n                this.removeStateForCell(change.previous);\n            if (this.resetViewOnRootChange) {\n                this.view.scale = 1;\n                this.view.translate.x = 0;\n                this.view.translate.y = 0;\n            }\n            this.fireEvent(new EventObject(InternalEvent.ROOT));\n        }\n        // Adds or removes a child to the view by online invaliding\n        // the minimal required portions of the cache, namely, the\n        // old and new parent and the child.\n        else if (change instanceof ChildChange) {\n            const newParent = change.child.getParent();\n            this.view.invalidate(change.child, true, true);\n            if (!newParent ||\n                !this.getDataModel().contains(newParent) ||\n                newParent.isCollapsed()) {\n                this.view.invalidate(change.child, true, true);\n                this.removeStateForCell(change.child);\n                // Handles special case of current root of view being removed\n                if (this.view.currentRoot == change.child) {\n                    this.home();\n                }\n            }\n            if (newParent != change.previous) {\n                // Refreshes the collapse/expand icons on the parents\n                if (newParent != null) {\n                    this.view.invalidate(newParent, false, false);\n                }\n                if (change.previous != null) {\n                    this.view.invalidate(change.previous, false, false);\n                }\n            }\n        }\n        // Handles two special cases where the shape does not need to be\n        // recreated from scratch, it only needs to be invalidated.\n        else if (change instanceof TerminalChange || change instanceof GeometryChange) {\n            // Checks if the geometry has changed to avoid unnessecary revalidation\n            if (change instanceof TerminalChange ||\n                (change.previous == null && change.geometry != null) ||\n                (change.previous != null && !change.previous.equals(change.geometry))) {\n                this.view.invalidate(change.cell);\n            }\n        }\n        // Handles two special cases where only the shape, but no\n        // descendants need to be recreated\n        else if (change instanceof ValueChange) {\n            this.view.invalidate(change.cell, false, false);\n        }\n        // Requires a new mxShape in JavaScript\n        else if (change instanceof StyleChange) {\n            this.view.invalidate(change.cell, true, true);\n            const state = this.view.getState(change.cell);\n            if (state != null) {\n                state.invalidStyle = true;\n            }\n        }\n        // Removes the state from the cache by default\n        else if (change.cell != null && change.cell instanceof Cell) {\n            this.removeStateForCell(change.cell);\n        }\n    }\n    /**\n     * Scrolls the graph to the given point, extending the graph container if\n     * specified.\n     */\n    scrollPointToVisible(x, y, extend = false, border = 20) {\n        const panningHandler = this.getPlugin('PanningHandler');\n        if (!this.isTimerAutoScroll() &&\n            (this.ignoreScrollbars || hasScrollbars(this.container))) {\n            const c = this.container;\n            if (x >= c.scrollLeft &&\n                y >= c.scrollTop &&\n                x <= c.scrollLeft + c.clientWidth &&\n                y <= c.scrollTop + c.clientHeight) {\n                let dx = c.scrollLeft + c.clientWidth - x;\n                if (dx < border) {\n                    const old = c.scrollLeft;\n                    c.scrollLeft += border - dx;\n                    // Automatically extends the canvas size to the bottom, right\n                    // if the event is outside of the canvas and the edge of the\n                    // canvas has been reached. Notes: Needs fix for IE.\n                    if (extend && old === c.scrollLeft) {\n                        // @ts-ignore\n                        const root = this.view.getDrawPane().ownerSVGElement;\n                        const width = c.scrollWidth + border - dx;\n                        // Updates the clipping region. This is an expensive\n                        // operation that should not be executed too often.\n                        // @ts-ignore\n                        root.style.width = `${width}px`;\n                        c.scrollLeft += border - dx;\n                    }\n                }\n                else {\n                    dx = x - c.scrollLeft;\n                    if (dx < border) {\n                        c.scrollLeft -= border - dx;\n                    }\n                }\n                let dy = c.scrollTop + c.clientHeight - y;\n                if (dy < border) {\n                    const old = c.scrollTop;\n                    c.scrollTop += border - dy;\n                    if (old == c.scrollTop && extend) {\n                        // @ts-ignore\n                        const root = this.view.getDrawPane().ownerSVGElement;\n                        const height = c.scrollHeight + border - dy;\n                        // Updates the clipping region. This is an expensive\n                        // operation that should not be executed too often.\n                        // @ts-ignore\n                        root.style.height = `${height}px`;\n                        c.scrollTop += border - dy;\n                    }\n                }\n                else {\n                    dy = y - c.scrollTop;\n                    if (dy < border) {\n                        c.scrollTop -= border - dy;\n                    }\n                }\n            }\n        }\n        else if (this.isAllowAutoPanning() &&\n            panningHandler &&\n            !panningHandler.isActive()) {\n            panningHandler.getPanningManager().panTo(x + this.getPanDx(), y + this.getPanDy());\n        }\n    }\n    /**\n     * Returns the size of the border and padding on all four sides of the\n     * container. The left, top, right and bottom borders are stored in the x, y,\n     * width and height of the returned {@link Rectangle}, respectively.\n     */\n    getBorderSizes() {\n        const css = getCurrentStyle(this.container);\n        return new Rectangle(parseCssNumber(css.paddingLeft) +\n            (css.borderLeftStyle != 'none' ? parseCssNumber(css.borderLeftWidth) : 0), parseCssNumber(css.paddingTop) +\n            (css.borderTopStyle != 'none' ? parseCssNumber(css.borderTopWidth) : 0), parseCssNumber(css.paddingRight) +\n            (css.borderRightStyle != 'none' ? parseCssNumber(css.borderRightWidth) : 0), parseCssNumber(css.paddingBottom) +\n            (css.borderBottomStyle != 'none' ? parseCssNumber(css.borderBottomWidth) : 0));\n    }\n    /**\n     * Returns the preferred size of the background page if {@link preferPageSize} is true.\n     */\n    getPreferredPageSize(bounds, width, height) {\n        const tr = this.view.translate;\n        const fmt = this.pageFormat;\n        const ps = this.pageScale;\n        const page = new Rectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));\n        const hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;\n        const vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;\n        return new Rectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);\n    }\n    /**\n     * Scales the graph such that the complete diagram fits into <container> and\n     * returns the current scale in the view. To fit an initial graph prior to\n     * rendering, set {@link GraphView#rendering} to false prior to changing the model\n     * and execute the following after changing the model.\n     *\n     * ```javascript\n     * graph.fit();\n     * graph.view.rendering = true;\n     * graph.refresh();\n     * ```\n     *\n     * To fit and center the graph, the following code can be used.\n     *\n     * ```javascript\n     * let margin = 2;\n     * let max = 3;\n     *\n     * let bounds = graph.getGraphBounds();\n     * let cw = graph.container.clientWidth - margin;\n     * let ch = graph.container.clientHeight - margin;\n     * let w = bounds.width / graph.view.scale;\n     * let h = bounds.height / graph.view.scale;\n     * let s = Math.min(max, Math.min(cw / w, ch / h));\n     *\n     * graph.view.scaleAndTranslate(s,\n     *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\n     *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\n     * ```\n     *\n     * @param border Optional number that specifies the border. Default is <border>.\n     * @param keepOrigin Optional boolean that specifies if the translate should be\n     * changed. Default is false.\n     * @param margin Optional margin in pixels. Default is 0.\n     * @param enabled Optional boolean that specifies if the scale should be set or\n     * just returned. Default is true.\n     * @param ignoreWidth Optional boolean that specifies if the width should be\n     * ignored. Default is false.\n     * @param ignoreHeight Optional boolean that specifies if the height should be\n     * ignored. Default is false.\n     * @param maxHeight Optional maximum height.\n     */\n    fit(border = this.getBorder(), keepOrigin = false, margin = 0, enabled = true, ignoreWidth = false, ignoreHeight = false, maxHeight = null) {\n        if (this.container != null) {\n            // Adds spacing and border from css\n            const cssBorder = this.getBorderSizes();\n            let w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;\n            let h1 = maxHeight != null\n                ? maxHeight\n                : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;\n            let bounds = this.view.getGraphBounds();\n            if (bounds.width > 0 && bounds.height > 0) {\n                if (keepOrigin && bounds.x != null && bounds.y != null) {\n                    bounds = bounds.clone();\n                    bounds.width += bounds.x;\n                    bounds.height += bounds.y;\n                    bounds.x = 0;\n                    bounds.y = 0;\n                }\n                // LATER: Use unscaled bounding boxes to fix rounding errors\n                const s = this.view.scale;\n                let w2 = bounds.width / s;\n                let h2 = bounds.height / s;\n                // Fits to the size of the background image if required\n                if (this.backgroundImage != null) {\n                    w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);\n                    h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);\n                }\n                const b = (keepOrigin ? border : 2 * border) + margin + 1;\n                w1 -= b;\n                h1 -= b;\n                let s2 = ignoreWidth\n                    ? h1 / h2\n                    : ignoreHeight\n                        ? w1 / w2\n                        : Math.min(w1 / w2, h1 / h2);\n                if (this.minFitScale != null) {\n                    s2 = Math.max(s2, this.minFitScale);\n                }\n                if (this.maxFitScale != null) {\n                    s2 = Math.min(s2, this.maxFitScale);\n                }\n                if (enabled) {\n                    if (!keepOrigin) {\n                        if (!hasScrollbars(this.container)) {\n                            const x0 = bounds.x != null\n                                ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2)\n                                : border;\n                            const y0 = bounds.y != null\n                                ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2)\n                                : border;\n                            this.view.scaleAndTranslate(s2, x0, y0);\n                        }\n                        else {\n                            this.view.setScale(s2);\n                            const b2 = this.getGraphBounds();\n                            if (b2.x != null) {\n                                this.container.scrollLeft = b2.x;\n                            }\n                            if (b2.y != null) {\n                                this.container.scrollTop = b2.y;\n                            }\n                        }\n                    }\n                    else if (this.view.scale != s2) {\n                        this.view.setScale(s2);\n                    }\n                }\n                else {\n                    return s2;\n                }\n            }\n        }\n        return this.view.scale;\n    }\n    /**\n     * Resizes the container for the given graph width and height.\n     */\n    doResizeContainer(width, height) {\n        if (this.maximumContainerSize != null) {\n            width = Math.min(this.maximumContainerSize.width, width);\n            height = Math.min(this.maximumContainerSize.height, height);\n        }\n        const container = this.container;\n        container.style.width = `${Math.ceil(width)}px`;\n        container.style.height = `${Math.ceil(height)}px`;\n    }\n    /*****************************************************************************\n     * Group: UNCLASSIFIED\n     *****************************************************************************/\n    /**\n     * Creates a new handler for the given cell state. This implementation\n     * returns a new {@link EdgeHandler} of the corresponding cell is an edge,\n     * otherwise it returns an {@link VertexHandler}.\n     *\n     * @param state {@link CellState} whose handler should be created.\n     */\n    createHandler(state) {\n        let result = null;\n        if (state.cell.isEdge()) {\n            const source = state.getVisibleTerminalState(true);\n            const target = state.getVisibleTerminalState(false);\n            const geo = state.cell.getGeometry();\n            const edgeStyle = this.getView().getEdgeStyle(state, geo ? geo.points || undefined : undefined, source, target);\n            result = this.createEdgeHandler(state, edgeStyle);\n        }\n        else {\n            result = this.createVertexHandler(state);\n        }\n        return result;\n    }\n    /**\n     * Hooks to create a new {@link EdgeHandler} for the given {@link CellState}.\n     *\n     * @param state {@link CellState} to create the handler for.\n     * @param edgeStyle the {@link EdgeStyleFunction} that let choose the actual edge handler.\n     */\n    createEdgeHandler(state, edgeStyle) {\n        let result = null;\n        if (edgeStyle == EdgeStyle.Loop ||\n            edgeStyle == EdgeStyle.ElbowConnector ||\n            edgeStyle == EdgeStyle.SideToSide ||\n            edgeStyle == EdgeStyle.TopToBottom) {\n            result = this.createElbowEdgeHandler(state);\n        }\n        else if (edgeStyle == EdgeStyle.SegmentConnector ||\n            edgeStyle == EdgeStyle.OrthConnector) {\n            result = this.createEdgeSegmentHandler(state);\n        }\n        else {\n            result = this.createEdgeHandlerInstance(state);\n        }\n        return result;\n    }\n    /*****************************************************************************\n     * Group: Drilldown\n     *****************************************************************************/\n    /**\n     * Returns the current root of the displayed cell hierarchy. This is a\n     * shortcut to {@link GraphView.currentRoot} in {@link GraphView}.\n     */\n    getCurrentRoot() {\n        return this.view.currentRoot;\n    }\n    /**\n     * Returns the translation to be used if the given cell is the root cell as\n     * an {@link Point}. This implementation returns null.\n     *\n     * To keep the children at their absolute position while stepping into groups,\n     * this function can be overridden as follows.\n     *\n     * @example\n     * ```javascript\n     * var offset = new mxPoint(0, 0);\n     *\n     * while (cell != null)\n     * {\n     *   var geo = this.model.getGeometry(cell);\n     *\n     *   if (geo != null)\n     *   {\n     *     offset.x -= geo.x;\n     *     offset.y -= geo.y;\n     *   }\n     *\n     *   cell = this.model.getParent(cell);\n     * }\n     *\n     * return offset;\n     * ```\n     *\n     * @param cell {@link mxCell} that represents the root.\n     */\n    getTranslateForRoot(cell) {\n        return null;\n    }\n    /**\n     * Returns the offset to be used for the cells inside the given cell. The\n     * root and layer cells may be identified using {@link GraphDataModel.isRoot} and\n     * {@link GraphDataModel.isLayer}. For all other current roots, the\n     * {@link GraphView.currentRoot} field points to the respective cell, so that\n     * the following holds: cell == this.view.currentRoot. This implementation\n     * returns null.\n     *\n     * @param cell {@link mxCell} whose offset should be returned.\n     */\n    getChildOffsetForCell(cell) {\n        return null;\n    }\n    /**\n     * Uses the root of the model as the root of the displayed cell hierarchy\n     * and selects the previous root.\n     */\n    home() {\n        const current = this.getCurrentRoot();\n        if (current != null) {\n            this.view.setCurrentRoot(null);\n            const state = this.view.getState(current);\n            if (state != null) {\n                this.setSelectionCell(current);\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell is a valid root for the cell display\n     * hierarchy. This implementation returns true for all non-null values.\n     *\n     * @param cell {@link mxCell} which should be checked as a possible root.\n     */\n    isValidRoot(cell) {\n        return !!cell;\n    }\n    /*****************************************************************************\n     * Group: Graph display\n     *****************************************************************************/\n    /**\n     * Returns the bounds of the visible graph. Shortcut to\n     * {@link GraphView.getGraphBounds}. See also: {@link getBoundingBoxFromGeometry}.\n     */\n    getGraphBounds() {\n        return this.view.getGraphBounds();\n    }\n    /**\n     * Returns the bounds inside which the diagram should be kept as an\n     * {@link Rectangle}.\n     */\n    getMaximumGraphBounds() {\n        return this.maximumGraphBounds;\n    }\n    /**\n     * Clears all cell states or the states for the hierarchy starting at the\n     * given cell and validates the graph. This fires a refresh event as the\n     * last step.\n     *\n     * @param cell Optional {@link Cell} for which the cell states should be cleared.\n     */\n    refresh(cell = null) {\n        if (cell) {\n            this.view.clear(cell, false);\n        }\n        else {\n            this.view.clear(undefined, true);\n        }\n        this.view.validate();\n        this.sizeDidChange();\n        this.fireEvent(new EventObject(InternalEvent.REFRESH));\n    }\n    /**\n     * Centers the graph in the container.\n     *\n     * @param horizontal Optional boolean that specifies if the graph should be centered\n     * horizontally. Default is `true`.\n     * @param vertical Optional boolean that specifies if the graph should be centered\n     * vertically. Default is `true`.\n     * @param cx Optional float that specifies the horizontal center. Default is `0.5`.\n     * @param cy Optional float that specifies the vertical center. Default is `0.5`.\n     */\n    center(horizontal = true, vertical = true, cx = 0.5, cy = 0.5) {\n        const container = this.container;\n        const _hasScrollbars = hasScrollbars(this.container);\n        const padding = 2 * this.getBorder();\n        const cw = container.clientWidth - padding;\n        const ch = container.clientHeight - padding;\n        const bounds = this.getGraphBounds();\n        const t = this.view.translate;\n        const s = this.view.scale;\n        let dx = horizontal ? cw - bounds.width : 0;\n        let dy = vertical ? ch - bounds.height : 0;\n        if (!_hasScrollbars) {\n            this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x / s + (dx * cx) / s) : t.x, vertical ? Math.floor(t.y - bounds.y / s + (dy * cy) / s) : t.y);\n        }\n        else {\n            bounds.x -= t.x;\n            bounds.y -= t.y;\n            const sw = container.scrollWidth;\n            const sh = container.scrollHeight;\n            if (sw > cw) {\n                dx = 0;\n            }\n            if (sh > ch) {\n                dy = 0;\n            }\n            this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));\n            container.scrollLeft = (sw - cw) / 2;\n            container.scrollTop = (sh - ch) / 2;\n        }\n    }\n    /**\n     * Returns true if perimeter points should be computed such that the\n     * resulting edge has only horizontal or vertical segments.\n     *\n     * @param edge {@link CellState} that represents the edge.\n     */\n    isOrthogonal(edge) {\n        /*\n        'orthogonal' defines if the connection points on either end of the edge should\n        be computed so that the edge is vertical or horizontal if possible\n        and if the point is not at a fixed location. Default is false.\n        This also returns true if the edgeStyle of the edge is an elbow or\n        entity.\n         */\n        const orthogonal = edge.style.orthogonal;\n        if (orthogonal != null) {\n            return orthogonal;\n        }\n        const tmp = this.view.getEdgeStyle(edge);\n        return (tmp === EdgeStyle.SegmentConnector ||\n            tmp === EdgeStyle.ElbowConnector ||\n            tmp === EdgeStyle.SideToSide ||\n            tmp === EdgeStyle.TopToBottom ||\n            tmp === EdgeStyle.EntityRelation ||\n            tmp === EdgeStyle.OrthConnector);\n    }\n    /*****************************************************************************\n     * Group: Graph appearance\n     *****************************************************************************/\n    /**\n     * Returns the {@link backgroundImage} as an {@link Image}.\n     */\n    getBackgroundImage() {\n        return this.backgroundImage;\n    }\n    /**\n     * Sets the new {@link backgroundImage}.\n     *\n     * @param image New {@link Image} to be used for the background.\n     */\n    setBackgroundImage(image) {\n        this.backgroundImage = image;\n    }\n    /**\n     * Returns the textual representation for the given cell.\n     *\n     * This implementation returns the node name or string-representation of the user object.\n     *\n     *\n     * The following returns the label attribute from the cells user object if it is an XML node.\n     *\n     * @example\n     * ```javascript\n     * graph.convertValueToString = function(cell)\n     * {\n     * \treturn cell.getAttribute('label');\n     * }\n     * ```\n     *\n     * See also: {@link cellLabelChanged}.\n     *\n     * @param cell {@link Cell} whose textual representation should be returned.\n     */\n    convertValueToString(cell) {\n        const value = cell.getValue();\n        if (value != null) {\n            if (isNode(value)) {\n                return value.nodeName;\n            }\n            if (typeof value.toString === 'function') {\n                return value.toString();\n            }\n        }\n        return '';\n    }\n    /**\n     * Returns the string to be used as the link for the given cell.\n     *\n     * This implementation returns null.\n     *\n     * @param cell {@link Cell} whose link should be returned.\n     */\n    getLinkForCell(cell) {\n        return null;\n    }\n    /**\n     * Returns the value of {@link border}.\n     */\n    getBorder() {\n        return this.border;\n    }\n    /**\n     * Sets the value of {@link border}.\n     *\n     * @param value Positive integer that represents the border to be used.\n     */\n    setBorder(value) {\n        this.border = value;\n    }\n    /*****************************************************************************\n     * Group: Graph behaviour\n     *****************************************************************************/\n    /**\n     * Returns {@link resizeContainer}.\n     */\n    isResizeContainer() {\n        return this.resizeContainer;\n    }\n    /**\n     * Sets {@link resizeContainer}.\n     *\n     * @param value Boolean indicating if the container should be resized.\n     */\n    setResizeContainer(value) {\n        this.resizeContainer = value;\n    }\n    /**\n     * Returns true if the graph is {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Specifies if the graph should allow any interactions. This\n     * implementation updates {@link enabled}.\n     *\n     * @param value Boolean indicating if the graph should be enabled.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns {@link multigraph} as a boolean.\n     */\n    isMultigraph() {\n        return this.multigraph;\n    }\n    /**\n     * Specifies if the graph should allow multiple connections between the\n     * same pair of vertices.\n     *\n     * @param value Boolean indicating if the graph allows multiple connections\n     * between the same pair of vertices.\n     */\n    setMultigraph(value) {\n        this.multigraph = value;\n    }\n    /**\n     * Returns {@link allowLoops} as a boolean.\n     */\n    isAllowLoops() {\n        return this.allowLoops;\n    }\n    /**\n     * Specifies if loops are allowed.\n     *\n     * @param value Boolean indicating if loops are allowed.\n     */\n    setAllowLoops(value) {\n        this.allowLoops = value;\n    }\n    /**\n     * Returns {@link recursiveResize}.\n     *\n     * @param state {@link CellState} that is being resized.\n     */\n    isRecursiveResize(state = null) {\n        return this.recursiveResize;\n    }\n    /**\n     * Sets {@link recursiveResize}.\n     *\n     * @param value New boolean value for {@link recursiveResize}.\n     */\n    setRecursiveResize(value) {\n        this.recursiveResize = value;\n    }\n    /**\n     * Returns a decimal number representing the amount of the width and height\n     * of the given cell that is allowed to overlap its parent. A value of 0\n     * means all children must stay inside the parent, 1 means the child is\n     * allowed to be placed outside of the parent such that it touches one of\n     * the parents sides. If {@link isAllowOverlapParent} returns false for the given\n     * cell, then this method returns 0.\n     *\n     * @param cell {@link mxCell} for which the overlap ratio should be returned.\n     */\n    getOverlap(cell) {\n        return this.isAllowOverlapParent(cell) ? this.defaultOverlap : 0;\n    }\n    /**\n     * Returns true if the given cell is allowed to be placed outside of the\n     * parents area.\n     *\n     * @param cell {@link mxCell} that represents the child to be checked.\n     */\n    isAllowOverlapParent(cell) {\n        return false;\n    }\n    /*****************************************************************************\n     * Group: Cell retrieval\n     *****************************************************************************/\n    /**\n     * Returns {@link defaultParent} or {@link GraphView.currentRoot} or the first child\n     * child of {@link GraphDataModel.root} if both are null. The value returned by\n     * this function should be used as the parent for new cells (aka default\n     * layer).\n     */\n    getDefaultParent() {\n        let parent = this.getCurrentRoot();\n        if (!parent) {\n            parent = this.defaultParent;\n            if (!parent) {\n                const root = this.getDataModel().getRoot();\n                parent = root.getChildAt(0);\n            }\n        }\n        return parent;\n    }\n    /**\n     * Sets the {@link defaultParent} to the given cell. Set this to null to return\n     * the first child of the root in getDefaultParent.\n     */\n    setDefaultParent(cell) {\n        this.defaultParent = cell;\n    }\n    /**\n     * Destroys the graph and all its resources.\n     */\n    destroy() {\n        if (!this.destroyed) {\n            this.destroyed = true;\n            Object.values(this.plugins).forEach((p) => p.onDestroy());\n            this.view.destroy();\n            if (this.model && this.graphModelChangeListener) {\n                this.getDataModel().removeListener(this.graphModelChangeListener);\n                this.graphModelChangeListener = null;\n            }\n        }\n    }\n}\n// This introduces a side effect, but it is necessary to ensure the Graph is enriched with all properties and methods defined in mixins.\n// It is only called when Graph is imported, so the Graph definition is always consistent.\n// And this doesn't impact the tree-shaking.\napplyGraphMixins();\nexport { Graph };\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport { convertPoint, sortCells } from '../../util/styleUtils';\nimport RootChange from '../undoable_changes/RootChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport TerminalChange from '../undoable_changes/TerminalChange';\nimport GeometryChange from '../undoable_changes/GeometryChange';\nimport VisibleChange from '../undoable_changes/VisibleChange';\nimport StyleChange from '../undoable_changes/StyleChange';\nimport EventObject from '../event/EventObject';\nimport { getClientX, getClientY } from '../../util/EventUtils';\n/**\n * Implements a layout manager that runs a given layout after any changes to the graph:\n *\n * ### Example\n *\n * ```javascript\n * const layoutManager = new LayoutManager(graph);\n * layoutManager.getLayout = (cell, eventName) => {\n *   return layout;\n * };\n * ```\n *\n * See {@link getLayout} for a description of the possible eventNames.\n *\n * #### Event: mxEvent.LAYOUT_CELLS\n *\n * Fires between begin- and endUpdate after all cells have been layouted in\n * {@link layoutCells}. The `cells` property contains all cells that have\n * been passed to {@link layoutCells}.\n *\n * @category Layout\n */\nclass LayoutManager extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Specifies if the layout should bubble along\n         * the cell hierarchy.\n         * @default true\n         */\n        this.bubbling = true;\n        /**\n         * Specifies if event handling is enabled.\n         * @default true\n         */\n        this.enabled = true;\n        // Executes the layout before the changes are dispatched\n        this.undoHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.beforeUndo(evt.getProperty('edit'));\n            }\n        };\n        // Notifies the layout of a move operation inside a parent\n        this.moveHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n            }\n        };\n        // Notifies the layout of a move operation inside a parent\n        this.resizeHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.cellsResized(evt.getProperty('cells'), evt.getProperty('bounds'), evt.getProperty('previous'));\n            }\n        };\n        this.setGraph(graph);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns true if a layout should bubble, that is, if the parent layout\n     * should be executed whenever a cell layout (layout of the children of\n     * a cell) has been executed. This implementation returns {@link bubbling}.\n     */\n    isBubbling() {\n        return this.bubbling;\n    }\n    /**\n     * Sets {@link bubbling}.\n     */\n    setBubbling(value) {\n        this.bubbling = value;\n    }\n    /**\n     * Returns the graph that this layout operates on.\n     */\n    getGraph() {\n        return this.graph;\n    }\n    /**\n     * Sets the graph that the layouts operate on.\n     */\n    setGraph(graph) {\n        if (this.graph) {\n            const model = this.graph.getDataModel();\n            model.removeListener(this.undoHandler);\n            this.graph.removeListener(this.moveHandler);\n            this.graph.removeListener(this.resizeHandler);\n        }\n        this.graph = graph;\n        if (this.graph) {\n            const model = this.graph.getDataModel();\n            model.addListener(InternalEvent.BEFORE_UNDO, this.undoHandler);\n            this.graph.addListener(InternalEvent.MOVE_CELLS, this.moveHandler);\n            this.graph.addListener(InternalEvent.RESIZE_CELLS, this.resizeHandler);\n        }\n    }\n    /**\n     * Returns true if the given cell has a layout. This implementation invokes\n     * <getLayout> with {@link Event#LAYOUT_CELLS} as the eventName. Override this\n     * if creating layouts in <getLayout> is expensive and return true if\n     * <getLayout> will return a layout for the given cell for\n     * {@link Event#BEGIN_UPDATE} or {@link Event#END_UPDATE}.\n     */\n    hasLayout(cell) {\n        return !!this.getLayout(cell, InternalEvent.LAYOUT_CELLS);\n    }\n    /**\n     * Returns the layout for the given cell and eventName. Possible\n     * event names are {@link InternalEvent.MOVE_CELLS} and {@link InternalEvent.RESIZE_CELLS}\n     * for callbacks on when cells are moved or resized and\n     * {@link InternalEvent.BEGIN_UPDATE} and {@link InternalEvent.END_UPDATE} for the capture\n     * and bubble phase of the layout after any changes of the model.\n     */\n    getLayout(cell, eventName) {\n        return null;\n    }\n    /**\n     * Called from {@link undoHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been moved.\n     * @param evt Mouse event that represents the mousedown.\n     *\n     * TODO: what is undoableEdit type?\n     */\n    beforeUndo(undoableEdit) {\n        this.executeLayoutForCells(this.getCellsForChanges(undoableEdit.changes));\n    }\n    /**\n     * Called from {@link moveHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been moved.\n     * @param evt Mouse event that represents the mousedown.\n     */\n    cellsMoved(cells, evt) {\n        if (cells.length > 0 && evt) {\n            const point = convertPoint(this.getGraph().container, getClientX(evt), getClientY(evt));\n            for (let i = 0; i < cells.length; i += 1) {\n                const layout = this.getLayout(cells[i].getParent(), InternalEvent.MOVE_CELLS);\n                if (layout) {\n                    layout.moveCell(cells[i], point.x, point.y);\n                }\n            }\n        }\n    }\n    /**\n     * Called from {@link resizeHandler}.\n     *\n     * @param cell Array of {@link Cell} that have been resized.\n     * @param bounds {@link mxRectangle} taht represents the new bounds.\n     */\n    cellsResized(cells = null, bounds = null, prev = null) {\n        if (cells && bounds) {\n            for (let i = 0; i < cells.length; i += 1) {\n                const layout = this.getLayout(cells[i].getParent(), InternalEvent.RESIZE_CELLS);\n                if (layout) {\n                    layout.resizeCell(cells[i], bounds[i], prev?.[i]);\n                }\n            }\n        }\n    }\n    /**\n     * Returns the cells for which a layout should be executed.\n     */\n    getCellsForChanges(changes) {\n        let result = [];\n        for (const change of changes) {\n            if (change instanceof RootChange) {\n                return [];\n            }\n            result = result.concat(this.getCellsForChange(change));\n        }\n        return result;\n    }\n    /**\n     * Executes all layouts which have been scheduled during the\n     * changes.\n     * @param change  mxChildChange|mxTerminalChange|mxVisibleChange|...\n     */\n    getCellsForChange(change) {\n        if (change instanceof ChildChange) {\n            return this.addCellsWithLayout(change.child, this.addCellsWithLayout(change.previous));\n        }\n        if (change instanceof TerminalChange || change instanceof GeometryChange) {\n            return this.addCellsWithLayout(change.cell);\n        }\n        if (change instanceof VisibleChange || change instanceof StyleChange) {\n            return this.addCellsWithLayout(change.cell);\n        }\n        return [];\n    }\n    /**\n     * Adds all ancestors of the given cell that have a layout.\n     */\n    addCellsWithLayout(cell, result = []) {\n        return this.addDescendantsWithLayout(cell, this.addAncestorsWithLayout(cell, result));\n    }\n    /**\n     * Adds all ancestors of the given cell that have a layout.\n     */\n    addAncestorsWithLayout(cell, result = []) {\n        if (cell) {\n            const layout = this.hasLayout(cell);\n            if (layout) {\n                result.push(cell);\n            }\n            if (this.isBubbling()) {\n                this.addAncestorsWithLayout(cell.getParent(), result);\n            }\n        }\n        return result;\n    }\n    /**\n     * Adds all descendants of the given cell that have a layout.\n     */\n    addDescendantsWithLayout(cell, result = []) {\n        if (cell && this.hasLayout(cell)) {\n            for (let i = 0; i < cell.getChildCount(); i += 1) {\n                const child = cell.getChildAt(i);\n                if (this.hasLayout(child)) {\n                    result.push(child);\n                    this.addDescendantsWithLayout(child, result);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Executes the given layout on the given parent.\n     */\n    executeLayoutForCells(cells) {\n        const sorted = sortCells(cells, false);\n        this.layoutCells(sorted, true);\n        this.layoutCells(sorted.reverse(), false);\n    }\n    /**\n     * Executes all layouts which have been scheduled during the changes.\n     */\n    layoutCells(cells, bubble = false) {\n        if (cells.length > 0) {\n            // Invokes the layouts while removing duplicates\n            const model = this.getGraph().getDataModel();\n            model.batchUpdate(() => {\n                let last = null;\n                for (const cell of cells) {\n                    if (cell !== model.getRoot() && cell !== last) {\n                        this.executeLayout(cell, bubble);\n                        last = cell;\n                    }\n                }\n                this.fireEvent(new EventObject(InternalEvent.LAYOUT_CELLS, { cells }));\n            });\n        }\n    }\n    /**\n     * Executes the given layout on the given parent.\n     */\n    executeLayout(cell, bubble = false) {\n        const layout = this.getLayout(cell, bubble ? InternalEvent.BEGIN_UPDATE : InternalEvent.END_UPDATE);\n        if (layout) {\n            layout.execute(cell);\n        }\n    }\n    /**\n     * Removes all handlers from the {@link graph} and deletes the reference to it.\n     */\n    destroy() {\n        this.setGraph(null);\n    }\n}\nexport default LayoutManager;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport { NONE, OUTLINE_COLOR, OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR, OUTLINE_STROKEWIDTH, } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { Graph } from '../Graph';\nimport ImageShape from '../geometry/node/ImageShape';\nimport InternalEvent from '../event/InternalEvent';\nimport { getSource, isMouseEvent } from '../../util/EventUtils';\nimport { hasScrollbars } from '../../util/styleUtils';\nimport { getDefaultPlugins } from '../plugins';\n/**\n * @class Outline\n *\n * Implements an outline (aka overview) for a graph. Set {@link updateOnPan} to true\n * to enable updates while the source graph is panning.\n *\n * ### Example\n *\n * ```javascript\n * var outline = new mxOutline(graph, div);\n * ```\n *\n * If an outline is used in an {@link MaxWindow} in IE8 standards mode, the following\n * code makes sure that the shadow filter is not inherited and that any\n * transparent elements in the graph do not show the page background, but the\n * background of the graph container.\n *\n * ```javascript\n * if (document.documentMode == 8)\n * {\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n * }\n * ```\n *\n * To move the graph to the top, left corner the following code can be used.\n *\n * ```javascript\n * var scale = graph.view.scale;\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\n * ```\n *\n * To toggle the suspended mode, the following can be used.\n *\n * ```javascript\n * outline.suspended = !outln.suspended;\n * if (!outline.suspended)\n * {\n *   outline.update(true);\n * }\n * ```\n */\nclass Outline {\n    constructor(source, container = null) {\n        // TODO: Document me!!\n        this.sizer = null;\n        this.selectionBorder = null;\n        this.updateHandler = null;\n        this.refreshHandler = null;\n        this.panHandler = null;\n        this.active = null;\n        this.bounds = null;\n        this.zoom = false;\n        this.startX = null;\n        this.startY = null;\n        this.dx0 = null;\n        this.dy0 = null;\n        this.index = null;\n        /**\n         * Reference to the {@link graph} that renders the outline.\n         */\n        this.outline = null;\n        /**\n         * Renderhint to be used for the outline graph.\n         * @default faster\n         */\n        this.graphRenderHint = 'exact';\n        /**\n         * Specifies if events are handled.\n         * @default true\n         */\n        this.enabled = true;\n        /**\n         * Specifies a viewport rectangle should be shown.\n         * @default true\n         */\n        this.showViewport = true;\n        /**\n         * Border to be added at the bottom and right.\n         * @default 10\n         */\n        this.border = 10;\n        /**\n         * Specifies the size of the sizer handler.\n         * @default 8\n         */\n        this.sizerSize = 8;\n        /**\n         * Specifies if labels should be visible in the outline.\n         * @default false\n         */\n        this.labelsVisible = false;\n        /**\n         * Specifies if {@link update} should be called for {@link InternalEvent.PAN} in the source\n         * graph.\n         * @default false\n         */\n        this.updateOnPan = false;\n        /**\n         * Optional {@link Image} to be used for the sizer.\n         * @default null\n         */\n        this.sizerImage = null;\n        /**\n         * Minimum scale to be used.\n         * @default 0.0001\n         */\n        this.minScale = 0.0001;\n        /**\n         * Optional boolean flag to suspend updates. This flag will\n         * also suspend repaints of the outline. To toggle this switch, use the\n         * following code.\n         *\n         * @default false\n         *\n         * @example\n         * ```javascript\n         * nav.suspended = !nav.suspended;\n         *\n         * if (!nav.suspended)\n         * {\n         *   nav.update(true);\n         * }\n         * ```\n         */\n        this.suspended = false;\n        this.source = source;\n        if (container != null) {\n            this.init(container);\n        }\n    }\n    /**\n     * Initializes the outline inside the given container.\n     */\n    init(container) {\n        this.outline = this.createGraph(container);\n        // Do not repaint when suspended\n        const outlineGraphModelChanged = this.outline.graphModelChanged;\n        this.outline.graphModelChanged = (changes) => {\n            if (!this.suspended && this.outline != null) {\n                outlineGraphModelChanged.apply(this.outline, [changes]);\n            }\n        };\n        // Enable faster painting in SVG\n        //const node = <SVGElement>this.outline.getView().getCanvas().parentNode;\n        //node.setAttribute('shape-rendering', 'optimizeSpeed');\n        //node.setAttribute('image-rendering', 'optimizeSpeed');\n        // Hides cursors and labels\n        this.outline.labelsVisible = this.labelsVisible;\n        this.outline.setEnabled(false);\n        this.updateHandler = (sender, evt) => {\n            if (!this.suspended && !this.active) {\n                this.update();\n            }\n        };\n        // Updates the scale of the outline after a change of the main graph\n        this.source.getDataModel().addListener(InternalEvent.CHANGE, this.updateHandler);\n        this.outline.addMouseListener(this);\n        // Adds listeners to keep the outline in sync with the source graph\n        const view = this.source.getView();\n        view.addListener(InternalEvent.SCALE, this.updateHandler);\n        view.addListener(InternalEvent.TRANSLATE, this.updateHandler);\n        view.addListener(InternalEvent.SCALE_AND_TRANSLATE, this.updateHandler);\n        view.addListener(InternalEvent.DOWN, this.updateHandler);\n        view.addListener(InternalEvent.UP, this.updateHandler);\n        // Updates blue rectangle on scroll\n        // @ts-ignore because sender and evt don't seem used\n        InternalEvent.addListener(this.source.container, 'scroll', this.updateHandler);\n        this.panHandler = (sender, evt) => {\n            if (this.updateOnPan) {\n                this.updateHandler(sender, evt);\n            }\n        };\n        this.source.addListener(InternalEvent.PAN, this.panHandler);\n        // Refreshes the graph in the outline after a refresh of the main graph\n        this.refreshHandler = (sender) => {\n            const outline = this.outline;\n            outline.setStylesheet(this.source.getStylesheet());\n            outline.refresh();\n        };\n        this.source.addListener(InternalEvent.REFRESH, this.refreshHandler);\n        // Creates the blue rectangle for the viewport\n        this.bounds = new Rectangle(0, 0, 0, 0);\n        this.selectionBorder = new RectangleShape(this.bounds, NONE, OUTLINE_COLOR, OUTLINE_STROKEWIDTH);\n        this.selectionBorder.dialect = this.outline.dialect;\n        this.selectionBorder.init(this.outline.getView().getOverlayPane());\n        const selectionBorderNode = this.selectionBorder.node;\n        // Handles event by catching the initial pointer start and then listening to the\n        // complete gesture on the event target. This is needed because all the events\n        // are routed via the initial element even if that element is removed from the\n        // DOM, which happens when we repaint the selection border and zoom handles.\n        const handler = (evt) => {\n            const t = getSource(evt);\n            const redirect = (evt) => {\n                const outline = this.outline;\n                outline.fireMouseEvent(InternalEvent.MOUSE_MOVE, new InternalMouseEvent(evt));\n            };\n            const redirect2 = (evt) => {\n                const outline = this.outline;\n                InternalEvent.removeGestureListeners(t, null, redirect, redirect2);\n                outline.fireMouseEvent(InternalEvent.MOUSE_UP, new InternalMouseEvent(evt));\n            };\n            const outline = this.outline;\n            InternalEvent.addGestureListeners(t, null, redirect, redirect2);\n            outline.fireMouseEvent(InternalEvent.MOUSE_DOWN, new InternalMouseEvent(evt));\n        };\n        InternalEvent.addGestureListeners(this.selectionBorder.node, handler);\n        // Creates a small blue rectangle for sizing (sizer handle)\n        const sizer = (this.sizer = this.createSizer());\n        const sizerNode = sizer.node;\n        sizer.init(this.outline.getView().getOverlayPane());\n        if (this.enabled) {\n            sizerNode.style.cursor = 'nwse-resize';\n        }\n        InternalEvent.addGestureListeners(this.sizer.node, handler);\n        selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n        sizerNode.style.display = selectionBorderNode.style.display;\n        selectionBorderNode.style.cursor = 'move';\n        this.update(false);\n    }\n    /**\n     * Creates the {@link graph} used in the outline.\n     */\n    createGraph(container) {\n        const graph = new Graph(container, this.source.getDataModel(), \n        // TODO review the list of plugins for the Graph of an Outline\n        // we could pass an empty array or a selection of plugins\n        // it may be necessary to make the plugins array configurable to allow custom plugins and improve tree-shaking\n        getDefaultPlugins(), this.source.getStylesheet());\n        graph.options.foldingEnabled = false;\n        graph.autoScroll = false;\n        return graph;\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param value Boolean that specifies the new enabled state.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Enables or disables the zoom handling by showing or hiding the respective\n     * handle.\n     *\n     * @param value Boolean that specifies the new enabled state.\n     */\n    setZoomEnabled(value) {\n        // @ts-ignore\n        this.sizer.node.style.visibility = value ? 'visible' : 'hidden';\n    }\n    /**\n     * Invokes {@link update} and revalidate the outline. This method is deprecated.\n     */\n    refresh() {\n        this.update(true);\n    }\n    /**\n     * Creates the shape used as the sizer.\n     */\n    // createSizer(): mxShape;\n    createSizer() {\n        const outline = this.outline;\n        if (this.sizerImage != null) {\n            const sizer = new ImageShape(new Rectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n            sizer.dialect = outline.dialect;\n            return sizer;\n        }\n        const sizer = new RectangleShape(new Rectangle(0, 0, this.sizerSize, this.sizerSize), OUTLINE_HANDLE_FILLCOLOR, OUTLINE_HANDLE_STROKECOLOR);\n        sizer.dialect = outline.dialect;\n        return sizer;\n    }\n    /**\n     * Returns the size of the source container.\n     */\n    getSourceContainerSize() {\n        return new Rectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n    }\n    /**\n     * Returns the offset for drawing the outline graph.\n     */\n    getOutlineOffset(scale) {\n        // TODO: Should number -> mxPoint?\n        return null;\n    }\n    /**\n     * Returns the offset for drawing the outline graph.\n     */\n    getSourceGraphBounds() {\n        return this.source.getGraphBounds();\n    }\n    /**\n     * Updates the outline.\n     */\n    update(revalidate = false) {\n        if (this.source != null &&\n            this.source.container != null &&\n            this.outline != null &&\n            this.outline.container != null) {\n            const sourceScale = this.source.view.scale;\n            const scaledGraphBounds = this.getSourceGraphBounds();\n            const unscaledGraphBounds = new Rectangle(scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);\n            const unscaledFinderBounds = new Rectangle(0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);\n            const union = unscaledGraphBounds.clone();\n            union.add(unscaledFinderBounds);\n            // Zooms to the scrollable area if that is bigger than the graph\n            const size = this.getSourceContainerSize();\n            const completeWidth = Math.max(size.width / sourceScale, union.width);\n            const completeHeight = Math.max(size.height / sourceScale, union.height);\n            const availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n            const availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n            const outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n            let scale = Number.isNaN(outlineScale)\n                ? this.minScale\n                : Math.max(this.minScale, outlineScale);\n            if (scale > 0) {\n                if (this.outline.getView().scale !== scale) {\n                    this.outline.getView().scale = scale;\n                    revalidate = true;\n                }\n                const navView = this.outline.getView();\n                if (navView.currentRoot !== this.source.getView().currentRoot) {\n                    navView.setCurrentRoot(this.source.getView().currentRoot);\n                }\n                const t = this.source.view.translate;\n                let tx = t.x + this.source.panDx;\n                let ty = t.y + this.source.panDy;\n                const off = this.getOutlineOffset(scale);\n                if (off != null) {\n                    tx += off.x;\n                    ty += off.y;\n                }\n                if (unscaledGraphBounds.x < 0) {\n                    tx -= unscaledGraphBounds.x;\n                }\n                if (unscaledGraphBounds.y < 0) {\n                    ty -= unscaledGraphBounds.y;\n                }\n                if (navView.translate.x !== tx || navView.translate.y !== ty) {\n                    navView.translate.x = tx;\n                    navView.translate.y = ty;\n                    revalidate = true;\n                }\n                // Prepares local variables for computations\n                const t2 = navView.translate;\n                scale = this.source.getView().scale;\n                const scale2 = scale / navView.scale;\n                const scale3 = 1.0 / navView.scale;\n                const { container } = this.source;\n                // Updates the bounds of the viewrect in the navigation\n                this.bounds = new Rectangle((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);\n                // Adds the scrollbar offset to the finder\n                this.bounds.x += (this.source.container.scrollLeft * navView.scale) / scale;\n                this.bounds.y += (this.source.container.scrollTop * navView.scale) / scale;\n                const selectionBorder = this.selectionBorder;\n                let b = selectionBorder.bounds;\n                if (b.x !== this.bounds.x ||\n                    b.y !== this.bounds.y ||\n                    b.width !== this.bounds.width ||\n                    b.height !== this.bounds.height) {\n                    selectionBorder.bounds = this.bounds;\n                    selectionBorder.redraw();\n                }\n                // Updates the bounds of the zoom handle at the bottom right\n                const sizer = this.sizer;\n                b = sizer.bounds;\n                const b2 = new Rectangle(this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n                if (b.x !== b2.x ||\n                    b.y !== b2.y ||\n                    b.width !== b2.width ||\n                    b.height !== b2.height) {\n                    sizer.bounds = b2;\n                    // Avoids update of visibility in redraw for VML\n                    if (sizer.node.style.visibility !== 'hidden') {\n                        sizer.redraw();\n                    }\n                }\n                if (revalidate) {\n                    this.outline.view.revalidate();\n                }\n            }\n        }\n    }\n    /**\n     * Handles the event by starting a translation or zoom.\n     */\n    mouseDown(sender, me) {\n        if (this.enabled && this.showViewport) {\n            const tol = !isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;\n            const hit = tol > 0\n                ? new Rectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol)\n                : null;\n            this.zoom =\n                me.isSource(this.sizer) ||\n                    // @ts-ignore\n                    (hit != null && intersects(this.sizer.bounds, hit));\n            this.startX = me.getX();\n            this.startY = me.getY();\n            this.active = true;\n            const sourceContainer = this.source.container;\n            if (this.source.useScrollbarsForPanning && hasScrollbars(this.source.container)) {\n                this.dx0 = sourceContainer.scrollLeft;\n                this.dy0 = sourceContainer.scrollTop;\n            }\n            else {\n                this.dx0 = 0;\n                this.dy0 = 0;\n            }\n        }\n        me.consume();\n    }\n    /**\n     * Handles the event by previewing the viewrect in {@link graph} and updating the\n     * rectangle that represents the viewrect in the outline.\n     */\n    mouseMove(sender, me) {\n        if (this.active) {\n            const myBounds = this.bounds;\n            const sizer = this.sizer;\n            const sizerNode = sizer.node;\n            const selectionBorder = this.selectionBorder;\n            const selectionBorderNode = selectionBorder.node;\n            const source = this.source;\n            const outline = this.outline;\n            selectionBorderNode.style.display = this.showViewport ? '' : 'none';\n            sizerNode.style.display = selectionBorderNode.style.display;\n            const delta = this.getTranslateForEvent(me);\n            let dx = delta.x;\n            let dy = delta.y;\n            let bounds = null;\n            if (!this.zoom) {\n                // Previews the panning on the source graph\n                const { scale } = outline.getView();\n                bounds = new Rectangle(myBounds.x + dx, myBounds.y + dy, myBounds.width, myBounds.height);\n                selectionBorder.bounds = bounds;\n                selectionBorder.redraw();\n                dx /= scale;\n                dx *= source.getView().scale;\n                dy /= scale;\n                dy *= source.getView().scale;\n                source.panGraph(-dx - this.dx0, -dy - this.dy0);\n            }\n            else {\n                // Does *not* preview zooming on the source graph\n                const { container } = this.source;\n                // @ts-ignore\n                const viewRatio = container.clientWidth / container.clientHeight;\n                dy = dx / viewRatio;\n                bounds = new Rectangle(myBounds.x, myBounds.y, Math.max(1, myBounds.width + dx), Math.max(1, myBounds.height + dy));\n                selectionBorder.bounds = bounds;\n                selectionBorder.redraw();\n            }\n            // Updates the zoom handle\n            const b = sizer.bounds;\n            sizer.bounds = new Rectangle(bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);\n            // Avoids update of visibility in redraw for VML\n            if (sizerNode.style.visibility !== 'hidden') {\n                sizer.redraw();\n            }\n            me.consume();\n        }\n    }\n    /**\n     * Gets the translate for the given mouse event. Here is an example to limit\n     * the outline to stay within positive coordinates:\n     *\n     * @example\n     * ```javascript\n     * outline.getTranslateForEvent(me)\n     * {\n     *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n     *\n     *   if (!this.zoom)\n     *   {\n     *     var tr = this.source.view.translate;\n     *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\n     *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\n     *   }\n     *\n     *   return pt;\n     * };\n     * ```\n     */\n    getTranslateForEvent(me) {\n        return new Point(me.getX() - this.startX, me.getY() - this.startY);\n    }\n    /**\n     * Handles the event by applying the translation or zoom to {@link graph}.\n     */\n    mouseUp(sender, me) {\n        if (this.active) {\n            const delta = this.getTranslateForEvent(me);\n            let dx = delta.x;\n            let dy = delta.y;\n            const source = this.source;\n            const outline = this.outline;\n            const selectionBorder = this.selectionBorder;\n            if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {\n                if (!this.zoom) {\n                    // Applies the new translation if the source\n                    // has no scrollbars\n                    if (!source.useScrollbarsForPanning || !hasScrollbars(source.container)) {\n                        source.panGraph(0, 0);\n                        dx /= outline.getView().scale;\n                        dy /= outline.getView().scale;\n                        const t = source.getView().translate;\n                        source.getView().setTranslate(t.x - dx, t.y - dy);\n                    }\n                }\n                else {\n                    // Applies the new zoom\n                    const w = selectionBorder.bounds.width;\n                    const { scale } = source.getView();\n                    source.zoomTo(Math.max(this.minScale, scale - (dx * scale) / w), false);\n                }\n                this.update();\n                me.consume();\n            }\n            // Resets the state of the handler\n            this.index = null;\n            this.active = false;\n        }\n    }\n    /**\n     * Destroy this outline and removes all listeners from {@link source}.\n     */\n    destroy() {\n        if (this.source != null) {\n            // @ts-ignore\n            this.source.removeListener(this.panHandler);\n            // @ts-ignore\n            this.source.removeListener(this.refreshHandler);\n            // @ts-ignore\n            this.source.getDataModel().removeListener(this.updateHandler);\n            // @ts-ignore\n            this.source.getView().removeListener(this.updateHandler);\n            // @ts-ignore\n            InternalEvent.removeListener(this.source.container, 'scroll', this.updateHandler);\n            // @ts-ignore\n            this.source = null;\n        }\n        if (this.outline != null) {\n            this.outline.removeMouseListener(this);\n            this.outline.destroy();\n            this.outline = null;\n        }\n        if (this.selectionBorder != null) {\n            this.selectionBorder.destroy();\n            this.selectionBorder = null;\n        }\n        if (this.sizer != null) {\n            this.sizer.destroy();\n            this.sizer = null;\n        }\n    }\n}\nexport default Outline;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2019, JGraph Ltd\nCopyright (c) 2006-2017, draw.io AG\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Rectangle from '../geometry/Rectangle';\nimport TemporaryCellStates from '../cell/TemporaryCellStates';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport { intersects } from '../../util/mathUtils';\nimport { DIALECT } from '../../util/Constants';\nimport { addLinkToHead, write } from '../../util/domUtils';\nimport { GlobalConfig } from '../../util/config';\n/**\n * Implements printing of a diagram across multiple pages.\n *\n * The following opens a print preview for an existing graph:\n *\n * ```javascript\n * const preview = new PrintPreview(graph);\n * preview.open();\n * ```\n *\n * Use {@link getScaleForPageCount} as follows in order to print the graph across a given number of pages:\n *\n * ```javascript\n * const pageCount = window.prompt('Enter page count', '1');\n * if (pageCount) {\n *   const scale = printUtils.getScaleForPageCount(pageCount, graph);\n *   const preview = new PrintPreview(graph, scale);\n *   preview.open();\n * }\n * ```\n *\n * ### Additional pages\n *\n * To add additional pages before and after the output, {@link getCoverPages} and {@link getAppendices} can be used, respectively.\n *\n * ```javascript\n * const preview = new PrintPreview(graph, 1);\n *\n * preview.getCoverPages = function(w, h) {\n *   return [this.renderPage(w, h, 0, 0, (div) => {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\n *   }];\n * };\n *\n * preview.getAppendices = function(w, h) {\n *   return [this.renderPage(w, h, 0, 0, (div) => {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\n *   }];\n * };\n * preview.open();\n * ```\n *\n * ### CSS\n *\n * The CSS from the original page is not carried over to the print preview.\n * To add CSS to the page, use the `css` argument in the {@link open} function or\n * override {@link writeHead} to add the respective link tags as follows:\n *\n * ```typescript\n * const writeHead = preview.writeHead;\n * preview.writeHead = function(doc: Document, css: string | null): void {\n *   writeHead.apply(this, [doc, css]);\n *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\n * };\n * ```\n *\n * ### Padding\n *\n * To add a padding to the page in the preview (but not the print output), use the following code:\n *\n * ```typescript\n * preview.writeHead = function(doc: Document, css: string | null): void {\n *   writeHead.apply(this, [doc, css]);\n *\n *   doc.writeln('<style type=\"text/css\">');\n *   doc.writeln('@media screen {');\n *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\n *   doc.writeln('}');\n *   doc.writeln('</style>');\n * };\n * ```\n *\n * ### Headers\n *\n * Apart from setting the title argument in the `PrintPreview` constructor you\n * can override {@link renderPage} as follows to add a header to any page:\n *\n * ```javascript\n * const renderPage = printPreview.renderPage;\n * printPreview.renderPage = function(w, h, x, y, content, pageNumber) {\n *   const div = renderPage.apply(this, [w, h, x, y, content, pageNumber]);\n *\n *   const header = document.createElement('div');\n *   header.style.position = 'absolute';\n *   header.style.top = '0px';\n *   header.style.width = '100%';\n *   header.style.textAlign = 'right';\n *   domUtils.write(header, 'Your header here');\n *   div.firstChild.appendChild(header);\n *\n *   return div;\n * };\n * ```\n *\n * The pageNumber argument contains the number of the current page, starting at\n * 1. To display a header on the first page only, check pageNumber and add a\n * vertical offset in the constructor call for the height of the header.\n *\n * ### Page Format\n *\n * For landscape printing, use {@link PAGE_FORMAT_A4_LANDSCAPE} as\n * the pageFormat in {@link getScaleForPageCount} and {@link PrintPreview}.\n * Keep in mind that one can not set the defaults for the print dialog\n * of the operating system from JavaScript so the user must manually choose\n * a page format that matches this setting.\n *\n * You can try passing the following CSS directive to {@link open} to set the\n * page format in the print dialog to landscape. However, this CSS\n * directive seems to be ignored in most major browsers, including IE.\n *\n * ```javascript\n * @page {\n *   size: landscape;\n * }\n * ```\n */\nclass PrintPreview {\n    constructor(graph, scale = null, pageFormat = null, border = null, x0 = 0, y0 = 0, borderColor = null, title = 'Printer-friendly version', pageSelector = null) {\n        /**\n         * The border inset around each side of every page in the preview. This is set\n         * to 0 if autoOrigin is false.\n         * @default 0\n         */\n        this.border = 0;\n        /**\n         * The margin at the top of the page (number).\n         * @default 0\n         */\n        this.marginTop = 0;\n        /**\n         * The margin at the bottom of the page (number).\n         * @default 0\n         */\n        this.marginBottom = 0;\n        /**\n         * Holds the horizontal offset of the output.\n         */\n        this.x0 = 0;\n        /**\n         * Holds the vertical offset of the output.\n         */\n        this.y0 = 0;\n        /**\n         * Specifies if the origin should be automatically computed based on the top,\n         * left corner of the actual diagram contents. The required offset will be added\n         * to {@link x0} and {@link y0} in {@link open}.\n         * @default true\n         */\n        this.autoOrigin = true;\n        /**\n         * Specifies if overlays should be printed.\n         * @default false\n         */\n        this.printOverlays = false;\n        /**\n         * Specifies if controls (such as folding icons) should be printed. Default is\n         * false.\n         */\n        this.printControls = false;\n        /**\n         * Specifies if the background image should be printed.\n         * @default false\n         */\n        this.printBackgroundImage = false;\n        /**\n         * Holds the color value for the page background color.\n         * @default '#ffffff'\n         */\n        this.backgroundColor = '#ffffff';\n        /**\n         * Reference to the preview window.\n         */\n        this.wnd = null;\n        /**\n         * Assign any window here to redirect the rendering in {@link open}.\n         */\n        this.targetWindow = null;\n        /**\n         * Holds the actual number of pages in the preview.\n         */\n        this.pageCount = 0;\n        /**\n         * Specifies is clipping should be used to avoid creating too many cell states\n         * in large diagrams. The bounding box of the cells in the original diagram is\n         * used if this is enabled.\n         * @default true\n         */\n        this.clipping = true;\n        this.graph = graph;\n        this.scale = scale != null ? scale : 1 / graph.pageScale;\n        this.border = border != null ? border : 0;\n        this.pageFormat = Rectangle.fromRectangle(pageFormat != null ? pageFormat : graph.pageFormat);\n        this.title = title;\n        this.x0 = x0;\n        this.y0 = y0;\n        this.borderColor = borderColor;\n        this.pageSelector = pageSelector != null ? pageSelector : true;\n    }\n    /**\n     * Returns {@link wnd}.\n     */\n    getWindow() {\n        return this.wnd;\n    }\n    /**\n     * Returns the string that should go before the HTML tag in the print preview\n     * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,\n     * IE8 in IE8 standards mode and edge in IE9 standards mode.\n     */\n    getDoctype() {\n        const dt = '';\n        return dt;\n    }\n    /**\n     * Adds the given graph to the existing print preview.\n     *\n     * @param css Optional CSS string to be used in the head section.\n     * @param targetWindow Optional window that should be used for rendering. If\n     * this is specified then no HEAD tag, CSS and BODY tag will be written.\n     */\n    appendGraph(graph, scale, x0, y0, forcePageBreaks, keepOpen) {\n        this.graph = graph;\n        this.scale = scale != null ? scale : 1 / graph.pageScale;\n        this.x0 = x0;\n        this.y0 = y0;\n        this.open(null, null, forcePageBreaks, keepOpen);\n    }\n    /**\n     * Shows the print preview window. The window is created here if it does\n     * not exist.\n     *\n     * @param css Optional CSS string to be used in the head section.\n     * @param targetWindow Optional window that should be used for rendering. If\n     * this is specified then no HEAD tag, CSS and BODY tag will be written.\n     */\n    open(css = null, targetWindow = null, forcePageBreaks = false, keepOpen = false) {\n        // Closing the window while the page is being rendered may cause an\n        // exception in IE. This and any other exceptions are simply ignored.\n        const previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;\n        let div = null;\n        try {\n            // Temporarily overrides the method to redirect rendering of overlays\n            // to the draw pane so that they are visible in the printout\n            if (this.printOverlays) {\n                this.graph.cellRenderer.initializeOverlay = (state, overlay) => {\n                    overlay.init(state.view.getDrawPane());\n                };\n            }\n            if (this.printControls) {\n                this.graph.cellRenderer.initControl = (state, control, handleEvents, clickHandler) => {\n                    control.dialect = state.view.graph.dialect;\n                    control.init(state.view.getDrawPane());\n                    return null;\n                };\n            }\n            this.wnd = targetWindow != null ? targetWindow : this.wnd;\n            let isNewWindow = false;\n            if (this.wnd == null) {\n                isNewWindow = true;\n                this.wnd = window.open();\n            }\n            if (!this.wnd) {\n                throw new Error('Create new window not allowed');\n            }\n            const doc = this.wnd.document;\n            if (isNewWindow) {\n                const dt = this.getDoctype();\n                if (dt != null && dt.length > 0) {\n                    doc.writeln(dt);\n                }\n                if (document.compatMode === 'CSS1Compat') {\n                    doc.writeln('<!DOCTYPE html>');\n                }\n                doc.writeln('<html>');\n                doc.writeln('<head>');\n                this.writeHead(doc, css);\n                doc.writeln('</head>');\n                doc.writeln('<body class=\"mxPage\">');\n            }\n            // Computes the horizontal and vertical page count\n            const bounds = this.graph.getGraphBounds().clone();\n            const currentScale = this.graph.getView().getScale();\n            const sc = currentScale / this.scale;\n            const tr = this.graph.getView().getTranslate();\n            // Uses the absolute origin with no offset for all printing\n            if (!this.autoOrigin) {\n                this.x0 -= tr.x * this.scale;\n                this.y0 -= tr.y * this.scale;\n                bounds.width += bounds.x;\n                bounds.height += bounds.y;\n                bounds.x = 0;\n                bounds.y = 0;\n                this.border = 0;\n            }\n            // Store the available page area\n            const availableWidth = this.pageFormat.width - this.border * 2;\n            const availableHeight = this.pageFormat.height - this.border * 2;\n            // Adds margins to page format\n            this.pageFormat.height += this.marginTop + this.marginBottom;\n            // Compute the unscaled, untranslated bounds to find\n            // the number of vertical and horizontal pages\n            bounds.width /= sc;\n            bounds.height /= sc;\n            const hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));\n            const vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));\n            this.pageCount = hpages * vpages;\n            const writePageSelector = () => {\n                if (this.pageSelector && (vpages > 1 || hpages > 1)) {\n                    const table = this.createPageSelector(vpages, hpages);\n                    doc.body.appendChild(table);\n                }\n            };\n            const addPage = (div, addBreak) => {\n                // Border of the DIV (aka page) inside the document\n                if (this.borderColor != null) {\n                    div.style.borderColor = this.borderColor;\n                    div.style.borderStyle = 'solid';\n                    div.style.borderWidth = '1px';\n                }\n                // Needs to be assigned directly because IE doesn't support\n                // child selectors, eg. body > div { background: white; }\n                div.style.background = this.backgroundColor;\n                if (forcePageBreaks || addBreak) {\n                    div.style.pageBreakAfter = 'always';\n                }\n                // NOTE: We are dealing with cross-window DOM here, which\n                // is a problem in IE, so we copy the HTML markup instead.\n                // The underlying problem is that the graph display markup\n                // creation (in mxShape, mxGraphView) is hardwired to using\n                // document.createElement and hence we must use this document\n                // to create the complete page and then copy it over to the\n                // new window.document. This can be fixed later by using the\n                // ownerDocument of the container in mxShape and mxGraphView.\n                if (isNewWindow && Client.IS_EDGE) {\n                    // For some obscure reason, removing the DIV from the\n                    // parent before fetching its outerHTML has missing\n                    // fillcolor properties and fill children, so the div\n                    // must be removed afterwards to keep the fillcolors.\n                    doc.writeln(div.outerHTML);\n                    div.parentNode.removeChild(div);\n                }\n                else if (Client.IS_EDGE) {\n                    let clone = doc.createElement('div');\n                    clone.innerHTML = div.outerHTML;\n                    clone = clone.getElementsByTagName('div')[0];\n                    doc.body.appendChild(clone);\n                    div.parentNode.removeChild(div);\n                }\n                else {\n                    div.parentNode.removeChild(div);\n                    doc.body.appendChild(div);\n                }\n                if (forcePageBreaks || addBreak) {\n                    this.addPageBreak(doc);\n                }\n            };\n            const cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);\n            if (cov) {\n                for (const page of cov) {\n                    addPage(page, true);\n                }\n            }\n            const apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);\n            // Appends each page to the page output for printing, making\n            // sure there will be a page break after each page (ie. div)\n            for (let i = 0; i < vpages; i += 1) {\n                const dy = (i * availableHeight) / this.scale -\n                    this.y0 / this.scale +\n                    (bounds.y - tr.y * currentScale) / currentScale;\n                for (let j = 0; j < hpages; j++) {\n                    if (this.wnd == null) {\n                        return null;\n                    }\n                    const dx = (j * availableWidth) / this.scale -\n                        this.x0 / this.scale +\n                        (bounds.x - tr.x * currentScale) / currentScale;\n                    const pageNum = i * hpages + j + 1;\n                    const clip = new Rectangle(dx, dy, availableWidth, availableHeight);\n                    div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, (div) => {\n                        this.addGraphFragment(-dx, -dy, this.scale, pageNum, div, clip);\n                        if (this.printBackgroundImage) {\n                            this.insertBackgroundImage(div, -dx, -dy);\n                        }\n                    }, pageNum);\n                    // Gives the page a unique ID for later accessing the page\n                    div.setAttribute('id', `mxPage-${pageNum}`);\n                    addPage(div, apx != null || i < vpages - 1 || j < hpages - 1);\n                }\n            }\n            if (apx) {\n                for (const [index, page] of apx.entries()) {\n                    addPage(page, index < apx.length - 1);\n                }\n            }\n            if (isNewWindow && !keepOpen) {\n                this.closeDocument();\n                writePageSelector();\n            }\n            this.wnd.focus();\n        }\n        catch (e) {\n            // Removes the DIV from the document in case of an error\n            if (div != null && div.parentNode != null) {\n                div.parentNode.removeChild(div);\n            }\n        }\n        finally {\n            this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;\n        }\n        return this.wnd;\n    }\n    /**\n     * Adds a page break to the given document.\n     */\n    addPageBreak(doc) {\n        const hr = doc.createElement('hr');\n        hr.className = 'mxPageBreak';\n        doc.body.appendChild(hr);\n    }\n    /**\n     * Writes the closing tags for body and page after calling {@link writePostfix}.\n     */\n    closeDocument() {\n        try {\n            if (this.wnd != null && this.wnd.document != null) {\n                const doc = this.wnd.document;\n                this.writePostfix(doc);\n                doc.writeln('</body>');\n                doc.writeln('</html>');\n                doc.close();\n                // Removes all event handlers in the print output\n                InternalEvent.release(doc.body);\n            }\n        }\n        catch (e) {\n            // ignore any errors resulting from wnd no longer being available\n        }\n    }\n    /**\n     * Writes the HEAD section into the given document, without the opening and closing HEAD tags.\n     */\n    writeHead(doc, css) {\n        if (this.title != null) {\n            doc.writeln(`<title>${this.title}</title>`);\n        }\n        // Adds all required stylesheets\n        addLinkToHead('stylesheet', `${Client.basePath}/css/common.css`, doc);\n        // Removes horizontal rules and page selector from print output\n        doc.writeln('<style type=\"text/css\">');\n        doc.writeln('@media print {');\n        doc.writeln('  * { -webkit-print-color-adjust: exact; }');\n        doc.writeln('  table.mxPageSelector { display: none; }');\n        doc.writeln('  hr.mxPageBreak { display: none; }');\n        doc.writeln('}');\n        doc.writeln('@media screen {');\n        // NOTE: position: fixed is not supported in IE, so the page selector\n        // position (absolute) needs to be updated in IE (see below)\n        doc.writeln('  table.mxPageSelector { position: fixed; right: 10px; top: 10px;' +\n            'font-family: Arial; font-size:10pt; border: solid 1px darkgray;' +\n            'background: white; border-collapse:collapse; }');\n        doc.writeln('  table.mxPageSelector td { border: solid 1px gray; padding:4px; }');\n        doc.writeln('  body.mxPage { background: gray; }');\n        doc.writeln('}');\n        if (css != null) {\n            doc.writeln(css);\n        }\n        doc.writeln('</style>');\n    }\n    /**\n     * Called before closing the body of the page. This implementation is empty.\n     */\n    writePostfix(doc) {\n        // empty\n    }\n    /**\n     * Creates the page selector table.\n     */\n    createPageSelector(vpages, hpages) {\n        if (!this.wnd) {\n            throw new Error('Popup window not created');\n        }\n        const doc = this.wnd.document;\n        const table = doc.createElement('table');\n        table.className = 'mxPageSelector';\n        table.setAttribute('border', '0');\n        const tbody = doc.createElement('tbody');\n        for (let i = 0; i < vpages; i += 1) {\n            const row = doc.createElement('tr');\n            for (let j = 0; j < hpages; j++) {\n                const pageNum = i * hpages + j + 1;\n                const cell = doc.createElement('td');\n                const a = doc.createElement('a');\n                a.setAttribute('href', `#mxPage-${pageNum}`);\n                // Workaround for FF where the anchor is appended to the URL of the original document\n                if (Client.IS_NS && !Client.IS_SF && !Client.IS_GC) {\n                    const js = `let page = document.getElementById('mxPage-${pageNum}');page.scrollIntoView(true);event.preventDefault();`;\n                    a.setAttribute('onclick', js);\n                }\n                write(a, String(pageNum));\n                cell.appendChild(a);\n                row.appendChild(cell);\n            }\n            tbody.appendChild(row);\n        }\n        table.appendChild(tbody);\n        return table;\n    }\n    /**\n     * Creates a DIV that prints a single page of the given\n     * graph using the given scale and returns the DIV that\n     * represents the page.\n     *\n     * @param w Width of the page in pixels.\n     * @param h Height of the page in pixels.\n     * @param dx Optional horizontal page offset in pixels (used internally).\n     * @param dy Optional vertical page offset in pixels (used internally).\n     * @param content Callback that adds the HTML content to the inner div of a page.\n     * Takes the inner div as the argument.\n     * @param pageNumber Integer representing the page number.\n     */\n    renderPage(w, h, dx, dy, content, pageNumber) {\n        let div = document.createElement('div');\n        let arg = null;\n        try {\n            // Workaround for ignored clipping in IE 9 standards\n            // when printing with page breaks and HTML labels.\n            if (dx !== 0 || dy !== 0) {\n                div.style.position = 'relative';\n                div.style.width = `${w}px`;\n                div.style.height = `${h}px`;\n                div.style.pageBreakInside = 'avoid';\n                const innerDiv = document.createElement('div');\n                innerDiv.style.position = 'relative';\n                innerDiv.style.top = `${this.border}px`;\n                innerDiv.style.left = `${this.border}px`;\n                innerDiv.style.width = `${w - 2 * this.border}px`;\n                innerDiv.style.height = `${h - 2 * this.border}px`;\n                innerDiv.style.overflow = 'hidden';\n                const viewport = document.createElement('div');\n                viewport.style.position = 'relative';\n                viewport.style.marginLeft = `${dx}px`;\n                viewport.style.marginTop = `${dy}px`;\n                innerDiv.appendChild(viewport);\n                div.appendChild(innerDiv);\n                document.body.appendChild(div);\n                arg = viewport;\n            }\n            // FIXME: IE10/11 too many pages\n            else {\n                div.style.width = `${w}px`;\n                div.style.height = `${h}px`;\n                div.style.overflow = 'hidden';\n                div.style.pageBreakInside = 'avoid';\n                const innerDiv = document.createElement('div');\n                innerDiv.style.width = `${w - 2 * this.border}px`;\n                innerDiv.style.height = `${h - 2 * this.border}px`;\n                innerDiv.style.overflow = 'hidden';\n                innerDiv.style.top = `${this.border}px`;\n                innerDiv.style.left = `${this.border}px`;\n                div.appendChild(innerDiv);\n                document.body.appendChild(div);\n                arg = innerDiv;\n            }\n        }\n        catch (e) {\n            if (div && div.parentNode) {\n                div.parentNode.removeChild(div);\n            }\n            div = null;\n            throw e;\n        }\n        content(arg);\n        return div;\n    }\n    /**\n     * Returns the root cell for painting the graph.\n     */\n    getRoot() {\n        let root = this.graph.view.currentRoot;\n        if (root == null) {\n            root = this.graph.getDataModel().getRoot();\n        }\n        return root;\n    }\n    /**\n     * Returns true if CSS transforms should be used for scaling content.\n     * This returns true if foreignObject is supported and we're not in Safari\n     * as it has clipping bugs for transformed CSS content with foreignObjects.\n     */\n    useCssTransforms() {\n        return !Client.NO_FO && !Client.IS_SF;\n    }\n    /**\n     * Adds a graph fragment to the given div.\n     *\n     * @param dx Horizontal translation for the diagram.\n     * @param dy Vertical translation for the diagram.\n     * @param scale Scale for the diagram.\n     * @param pageNumber Number of the page to be rendered.\n     * @param div Div that contains the output.\n     * @param clip Contains the clipping rectangle as an {@link Rectangle}.\n     */\n    addGraphFragment(dx, dy, scale, pageNumber, div, clip) {\n        const view = this.graph.getView();\n        const previousContainer = this.graph.container;\n        this.graph.container = div;\n        const canvas = view.getCanvas();\n        const backgroundPane = view.getBackgroundPane();\n        const drawPane = view.getDrawPane();\n        const overlayPane = view.getOverlayPane();\n        const realScale = scale;\n        if (this.graph.dialect === DIALECT.SVG) {\n            view.createSvg();\n            // Uses CSS transform for scaling\n            if (this.useCssTransforms()) {\n                const g = view.getDrawPane().parentNode;\n                const prev = g.getAttribute('transform');\n                g.setAttribute('transformOrigin', '0 0');\n                g.setAttribute('transform', `scale(${scale},${scale})` + `translate(${dx},${dy})`);\n                scale = 1;\n                dx = 0;\n                dy = 0;\n            }\n        }\n        else {\n            view.createHtml();\n        }\n        // Disables events on the view\n        const eventsEnabled = view.isEventsEnabled();\n        view.setEventsEnabled(false);\n        // Disables the graph to avoid cursors\n        const graphEnabled = this.graph.isEnabled();\n        this.graph.setEnabled(false);\n        // Resets the translation\n        const translate = view.getTranslate();\n        view.translate = new Point(dx, dy);\n        // Redraws only states that intersect the clip\n        const { redraw } = this.graph.cellRenderer;\n        const { states } = view;\n        const s = view.scale;\n        // Gets the transformed clip for intersection check below\n        if (this.clipping) {\n            const tempClip = new Rectangle((clip.x + translate.x) * s, (clip.y + translate.y) * s, (clip.width * s) / realScale, (clip.height * s) / realScale);\n            // Checks clipping rectangle for speedup\n            // Must create terminal states for edge clipping even if terminal outside of clip\n            this.graph.cellRenderer.redraw = (state, force, rendering) => {\n                if (state != null) {\n                    // Gets original state from graph to find bounding box\n                    const orig = states.get(state.cell);\n                    if (orig != null) {\n                        const bbox = view.getBoundingBox(orig, false);\n                        // Stops rendering if outside clip for speedup but ignores\n                        // edge labels where width and height is set to 0\n                        if (bbox != null &&\n                            bbox.width > 0 &&\n                            bbox.height > 0 &&\n                            !intersects(tempClip, bbox)) {\n                            return;\n                        }\n                    }\n                }\n                redraw.apply(this.graph.cellRenderer, [state, force, rendering]);\n            };\n        }\n        let temp = null;\n        try {\n            // Creates the temporary cell states in the view and\n            // draws them onto the temporary DOM nodes in the view\n            const cells = [this.getRoot()];\n            temp = new TemporaryCellStates(view, scale, cells, null, (state) => {\n                return this.getLinkForCellState(state);\n            });\n        }\n        catch (e) {\n            GlobalConfig.logger.error('PrintPreview unable to generate the preview', e);\n        }\n        finally {\n            // Removes everything but the SVG node\n            let tmp = div.firstChild;\n            while (tmp != null) {\n                const next = tmp.nextSibling;\n                const name = tmp.nodeName.toLowerCase();\n                // Note: Width and height are required in FF 11\n                if (name === 'svg') {\n                    tmp.style.overflow = 'hidden';\n                    tmp.style.position = 'relative';\n                    tmp.style.top = `${this.marginTop}px`;\n                    tmp.setAttribute('width', String(clip.width));\n                    tmp.setAttribute('height', String(clip.height));\n                    tmp.style.width = '';\n                    tmp.style.height = '';\n                }\n                // Tries to fetch all text labels and only text labels\n                else if (tmp.style.cursor !== 'default' && name !== 'div') {\n                    tmp.parentNode.removeChild(tmp);\n                }\n                tmp = next;\n            }\n            // Puts background image behind SVG output\n            if (this.printBackgroundImage) {\n                const svgs = div.getElementsByTagName('svg');\n                if (svgs.length > 0) {\n                    svgs[0].style.position = 'absolute';\n                }\n            }\n            // Completely removes the overlay pane to remove more handles\n            view.overlayPane.parentNode.removeChild(view.overlayPane);\n            // Restores the state of the view\n            this.graph.setEnabled(graphEnabled);\n            this.graph.container = previousContainer;\n            this.graph.cellRenderer.redraw = redraw;\n            view.canvas = canvas;\n            view.backgroundPane = backgroundPane;\n            view.drawPane = drawPane;\n            view.overlayPane = overlayPane;\n            view.translate = translate;\n            if (temp) {\n                temp.destroy();\n            }\n            view.setEventsEnabled(eventsEnabled);\n        }\n    }\n    /**\n     * Returns the link for the given cell state. This returns null.\n     */\n    getLinkForCellState(state) {\n        return this.graph.getLinkForCell(state.cell);\n    }\n    /**\n     * Inserts the background image into the given div.\n     */\n    insertBackgroundImage(div, dx, dy) {\n        const bg = this.graph.backgroundImage;\n        if (bg != null) {\n            const img = document.createElement('img');\n            img.style.position = 'absolute';\n            img.style.marginLeft = `${Math.round(dx * this.scale)}px`;\n            img.style.marginTop = `${Math.round(dy * this.scale)}px`;\n            img.setAttribute('width', String(Math.round(this.scale * bg.width)));\n            img.setAttribute('height', String(Math.round(this.scale * bg.height)));\n            img.src = bg.src;\n            div.insertBefore(img, div.firstChild);\n        }\n    }\n    /**\n     * Returns the pages to be added before the print output. This returns `null`.\n     */\n    getCoverPages(_width, _height) {\n        return null;\n    }\n    /**\n     * Returns the pages to be added after the print output. This returns `null`.\n     */\n    getAppendices(_width, _height) {\n        return null;\n    }\n    /**\n     * Opens the print preview and shows the print dialog.\n     *\n     * @param css Optional CSS string to be used in the head section.\n     */\n    print(css) {\n        const wnd = this.open(css);\n        if (wnd != null) {\n            wnd.print();\n        }\n    }\n    /**\n     * Closes the print preview window.\n     */\n    close() {\n        if (this.wnd != null) {\n            this.wnd.close();\n            this.wnd = null;\n        }\n    }\n}\nexport default PrintPreview;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\nimport Rectangle from '../geometry/Rectangle';\n/**\n * Manager for swimlanes and nested swimlanes that sets the size of newly added\n * swimlanes to that of their siblings, and propagates changes to the size of a\n * swimlane to its siblings, if {@link siblings} is true, and its ancestors, if\n * {@link bubbling} is true.\n *\n * @category Layout\n */\nclass SwimlaneManager extends EventSource {\n    constructor(graph, horizontal = true, addEnabled = true, resizeEnabled = true) {\n        super();\n        /**\n         * Specifies if event handling is enabled.\n         * @default true\n         */\n        this.enabled = true;\n        /**\n         * Specifies the orientation of the swimlanes.\n         * @default true\n         */\n        this.horizontal = true;\n        /**\n         * Specifies if newly added cells should be resized to match the size of their\n         * existing siblings.\n         * @default true\n         */\n        this.addEnabled = true;\n        /**\n         * Specifies if resizing of swimlanes should be handled.\n         * @default true\n         */\n        this.resizeEnabled = true;\n        this.horizontal = horizontal;\n        this.addEnabled = addEnabled;\n        this.resizeEnabled = resizeEnabled;\n        this.addHandler = (sender, evt) => {\n            if (this.isEnabled() && this.isAddEnabled()) {\n                this.cellsAdded(evt.getProperty('cells'));\n            }\n        };\n        this.resizeHandler = (sender, evt) => {\n            if (this.isEnabled() && this.isResizeEnabled()) {\n                this.cellsResized(evt.getProperty('cells'));\n            }\n        };\n        this.setGraph(graph);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates {@link enabled}.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns {@link horizontal}.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Sets {@link horizontal}.\n     */\n    setHorizontal(value) {\n        this.horizontal = value;\n    }\n    /**\n     * Returns {@link addEnabled}.\n     */\n    isAddEnabled() {\n        return this.addEnabled;\n    }\n    /**\n     * Sets {@link addEnabled}.\n     */\n    setAddEnabled(value) {\n        this.addEnabled = value;\n    }\n    /**\n     * Returns {@link resizeEnabled}.\n     */\n    isResizeEnabled() {\n        return this.resizeEnabled;\n    }\n    /**\n     * Sets {@link resizeEnabled}.\n     */\n    setResizeEnabled(value) {\n        this.resizeEnabled = value;\n    }\n    /**\n     * Returns the graph that this manager operates on.\n     */\n    getGraph() {\n        return this.graph;\n    }\n    /**\n     * Sets the graph that the manager operates on.\n     */\n    setGraph(graph) {\n        if (this.graph) {\n            this.graph.removeListener(this.addHandler);\n            this.graph.removeListener(this.resizeHandler);\n        }\n        // @ts-expect-error this.graph can be null only when it is being destroyed.\n        this.graph = graph;\n        if (this.graph) {\n            this.graph.addListener(InternalEvent.ADD_CELLS, this.addHandler);\n            this.graph.addListener(InternalEvent.CELLS_RESIZED, this.resizeHandler);\n        }\n    }\n    /**\n     * Returns true if the given swimlane should be ignored.\n     */\n    isSwimlaneIgnored(swimlane) {\n        return !this.getGraph().isSwimlane(swimlane);\n    }\n    /**\n     * Returns true if the given cell is horizontal. If the given cell is not a\n     * swimlane, then the global orientation is returned.\n     */\n    isCellHorizontal(cell) {\n        if (this.graph.isSwimlane(cell)) {\n            const style = this.graph.getCellStyle(cell);\n            return style.horizontal ?? true;\n        }\n        return !this.isHorizontal();\n    }\n    /**\n     * Called if any cells have been added.\n     *\n     * @param cell Array of {@link Cell} that have been added.\n     */\n    cellsAdded(cells) {\n        if (cells.length > 0) {\n            this.graph.batchUpdate(() => {\n                for (const cell of cells) {\n                    if (!this.isSwimlaneIgnored(cell)) {\n                        this.swimlaneAdded(cell);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Updates the size of the given swimlane to match that of any existing\n     * siblings swimlanes.\n     *\n     * @param swimlane {@link mxCell} that represents the new swimlane.\n     */\n    swimlaneAdded(swimlane) {\n        const parent = swimlane.getParent();\n        const childCount = parent.getChildCount();\n        let geo = null;\n        // Finds the first valid sibling swimlane as reference\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (child !== swimlane && !this.isSwimlaneIgnored(child)) {\n                geo = child.getGeometry();\n                if (geo) {\n                    break;\n                }\n            }\n        }\n        // Applies the size of the refernece to the newly added swimlane\n        if (geo) {\n            const parentHorizontal = parent ? this.isCellHorizontal(parent) : this.horizontal;\n            this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n        }\n    }\n    /**\n     * Called if any cells have been resizes. Calls {@link swimlaneResized} for all\n     * swimlanes where {@link isSwimlaneIgnored} returns false.\n     *\n     * @param cells Array of {@link Cell} whose size was changed.\n     */\n    cellsResized(cells) {\n        if (cells.length > 0) {\n            this.graph.batchUpdate(() => {\n                // Finds the top-level swimlanes and adds offsets\n                for (const cell of cells) {\n                    if (!this.isSwimlaneIgnored(cell)) {\n                        const geo = cell.getGeometry();\n                        if (geo) {\n                            const size = new Rectangle(0, 0, geo.width, geo.height);\n                            let top = cell;\n                            let current = top;\n                            while (current) {\n                                top = current;\n                                current = current.getParent();\n                                const tmp = this.graph.isSwimlane(current)\n                                    ? this.graph.getStartSize(current)\n                                    : new Rectangle();\n                                size.width += tmp.width;\n                                size.height += tmp.height;\n                            }\n                            const parentHorizontal = current\n                                ? this.isCellHorizontal(current)\n                                : this.horizontal;\n                            this.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Called from {@link cellsResized} for all swimlanes that are not ignored to update\n     * the size of the siblings and the size of the parent swimlanes, recursively,\n     * if {@link bubbling} is true.\n     *\n     * @param swimlane {@link mxCell} whose size has changed.\n     */\n    resizeSwimlane(swimlane, w, h, parentHorizontal) {\n        const model = this.graph.getDataModel();\n        model.batchUpdate(() => {\n            const horizontal = this.isCellHorizontal(swimlane);\n            if (!this.isSwimlaneIgnored(swimlane)) {\n                let geo = swimlane.getGeometry();\n                if (geo) {\n                    if ((parentHorizontal && geo.height !== h) ||\n                        (!parentHorizontal && geo.width !== w)) {\n                        geo = geo.clone();\n                        if (parentHorizontal) {\n                            geo.height = h;\n                        }\n                        else {\n                            geo.width = w;\n                        }\n                        model.setGeometry(swimlane, geo);\n                    }\n                }\n            }\n            const tmp = this.graph.isSwimlane(swimlane)\n                ? this.graph.getStartSize(swimlane)\n                : new Rectangle();\n            w -= tmp.width;\n            h -= tmp.height;\n            const childCount = swimlane.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = swimlane.getChildAt(i);\n                this.resizeSwimlane(child, w, h, horizontal);\n            }\n        });\n    }\n    /**\n     * Removes all handlers from the {@link graph} and deletes the reference to it.\n     */\n    destroy() {\n        this.setGraph(null);\n    }\n}\nexport default SwimlaneManager;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isNullish } from '../../util/Utils';\n/**\n * Action to change the attribute of a cell's user object.\n * There is no method on the graph model that uses this\n * action. To use the action, you can use the code shown\n * in the example below.\n *\n * Example:\n *\n * To change the attributeName in the cell's user object\n * to attributeValue, use the following code:\n *\n * ```javascript\n * model.beginUpdate();\n * try\n * {\n *   var edit = new mxCellAttributeChange(\n *     cell, attributeName, attributeValue);\n *   model.execute(edit);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * ```\n *\n * Constructor: mxCellAttributeChange\n *\n * Constructs a change of a attribute of the DOM node\n * stored as the value of the given {@link Cell}`.\n */\nclass CellAttributeChange {\n    constructor(cell, attribute, value) {\n        this.cell = cell;\n        this.attribute = attribute;\n        this.value = value;\n        this.previous = value;\n    }\n    /**\n     * Changes the attribute of the cell's user object by\n     * using {@link Cell#setAttribute}.\n     */\n    execute() {\n        const tmp = this.cell.getAttribute(this.attribute);\n        if (isNullish(this.previous)) {\n            this.cell.value.removeAttribute(this.attribute);\n        }\n        else {\n            this.cell.setAttribute(this.attribute, this.previous);\n        }\n        this.previous = tmp;\n    }\n}\nexport default CellAttributeChange;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport { isAncestorNode } from '../../util/domUtils';\nimport { getSource, isAltDown, isConsumed, isControlDown as _isControlDown, isShiftDown, } from '../../util/EventUtils';\n/**\n * Event handler that listens to keystroke events. This is not a singleton,\n * however, it is normally only required once if the target is the document\n * element (default).\n *\n * This handler installs a key event listener in the topmost DOM node and\n * processes all events that originate from descandants of {@link Graph#container}\n * or from the topmost DOM node. The latter means that all unhandled keystrokes\n * are handled by this object regardless of the focused state of the <graph>.\n *\n * Example:\n *\n * The following example creates a key handler that listens to the delete key\n * (46) and deletes the selection cells if the graph is enabled.\n *\n * ```javascript\n * let keyHandler = new KeyHandler(graph);\n * keyHandler.bindKey(46, (evt)=>\n * {\n *   if (graph.isEnabled())\n *   {\n *     graph.removeCells();\n *   }\n * });\n * ```\n *\n * Keycodes:\n *\n * See http://tinyurl.com/yp8jgl or http://tinyurl.com/229yqw for a list of\n * keycodes or install a key event listener into the document element and print\n * the key codes of the respective events to the console.\n *\n * To support the Command key and the Control key on the Mac, the following\n * code can be used.\n *\n * ```javascript\n * keyHandler.getFunction = (evt)=>\n * {\n *   if (evt != null)\n *   {\n *     return (mxEvent.isControlDown(evt) || (Client.IS_MAC && evt.metaKey)) ? this.controlKeys[evt.keyCode] : this.normalKeys[evt.keyCode];\n *   }\n *\n *   return null;\n * };\n * ```\n *\n * Constructor: KeyHandler\n *\n * Constructs an event handler that executes functions bound to specific\n * keystrokes.\n *\n * @param graph Reference to the associated {@link Graph}.\n * @param target Optional reference to the event target. If null, the document\n * element is used as the event target, that is, the object where the key\n * event listener is installed.\n */\nclass KeyHandler {\n    constructor(graph, target = null) {\n        this.keydownHandler = null;\n        /**\n         * Reference to the {@link Graph} associated with this handler.\n         */\n        this.graph = null;\n        /**\n         * Reference to the target DOM, that is, the DOM node where the key event\n         * listeners are installed.\n         */\n        this.target = null;\n        /**\n         * Maps from keycodes to functions for non-pressed control keys.\n         */\n        this.normalKeys = {};\n        /**\n         * Maps from keycodes to functions for pressed shift keys.\n         */\n        this.shiftKeys = {};\n        /**\n         * Maps from keycodes to functions for pressed control keys.\n         */\n        this.controlKeys = {};\n        /**\n         * Maps from keycodes to functions for pressed control and shift keys.\n         */\n        this.controlShiftKeys = {};\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        if (graph != null) {\n            this.graph = graph;\n            this.target = target || document.documentElement;\n            this.keydownHandler = (evt) => {\n                this.keyDown(evt);\n            };\n            // Installs the keystroke listener in the target\n            InternalEvent.addListener(this.target, 'keydown', this.keydownHandler);\n        }\n    }\n    /**\n     * Returns true if events are handled. This implementation returns\n     * <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling by updating <enabled>.\n     *\n     * @param enabled Boolean that specifies the new enabled state.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Binds the specified keycode to the given function. This binding is used\n     * if the control key is not pressed.\n     *\n     * @param code Integer that specifies the keycode.\n     * @param funct JavaScript function that takes the key event as an argument.\n     */\n    bindKey(code, funct) {\n        this.normalKeys[code] = funct;\n    }\n    /**\n     * Binds the specified keycode to the given function. This binding is used\n     * if the shift key is pressed.\n     *\n     * @param code Integer that specifies the keycode.\n     * @param funct JavaScript function that takes the key event as an argument.\n     */\n    bindShiftKey(code, funct) {\n        this.shiftKeys[code] = funct;\n    }\n    /**\n     * Binds the specified keycode to the given function. This binding is used\n     * if the control key is pressed.\n     *\n     * @param code Integer that specifies the keycode.\n     * @param funct JavaScript function that takes the key event as an argument.\n     */\n    bindControlKey(code, funct) {\n        this.controlKeys[code] = funct;\n    }\n    /**\n     * Binds the specified keycode to the given function. This binding is used\n     * if the control and shift key are pressed.\n     *\n     * @param code Integer that specifies the keycode.\n     * @param funct JavaScript function that takes the key event as an argument.\n     */\n    bindControlShiftKey(code, funct) {\n        this.controlShiftKeys[code] = funct;\n    }\n    /**\n     * Returns true if the control key is pressed. This uses {@link Event#isControlDown}.\n     *\n     * @param evt Key event whose control key pressed state should be returned.\n     */\n    isControlDown(evt) {\n        return _isControlDown(evt);\n    }\n    /**\n     * Returns the function associated with the given key event or null if no\n     * function is associated with the given event.\n     *\n     * @param evt Key event whose associated function should be returned.\n     */\n    getFunction(evt) {\n        if (evt != null && !isAltDown(evt)) {\n            if (this.isControlDown(evt)) {\n                if (isShiftDown(evt)) {\n                    return this.controlShiftKeys[evt.keyCode];\n                }\n                return this.controlKeys[evt.keyCode];\n            }\n            if (isShiftDown(evt)) {\n                return this.shiftKeys[evt.keyCode];\n            }\n            return this.normalKeys[evt.keyCode];\n        }\n        return null;\n    }\n    /**\n     * Returns true if the event should be processed by this handler, that is,\n     * if the event source is either the target, one of its direct children, a\n     * descendant of the {@link Graph#container}, or the {@link Graph#cellEditor} of the\n     * <graph>.\n     *\n     * @param evt Key event that represents the keystroke.\n     */\n    isGraphEvent(evt) {\n        const source = getSource(evt);\n        // Accepts events from the target object or in-place editing inside graph\n        const cellEditorHandler = this.graph?.getPlugin('CellEditorHandler');\n        if (source === this.target ||\n            source.parentNode === this.target ||\n            (cellEditorHandler && cellEditorHandler.isEventSource(evt))) {\n            return true;\n        }\n        // Accepts events from inside the container\n        return isAncestorNode(this.graph.container, source);\n    }\n    /**\n     * Handles the event by invoking the function bound to the respective keystroke\n     * if <isEnabledForEvent> returns true for the given event and if\n     * <isEventIgnored> returns false, except for escape for which\n     * <isEventIgnored> is not invoked.\n     *\n     * @param evt Key event that represents the keystroke.\n     */\n    keyDown(evt) {\n        if (this.isEnabledForEvent(evt)) {\n            // Cancels the editing if escape is pressed\n            if (evt.keyCode === 27 /* Escape */) {\n                this.escape(evt);\n            }\n            // Invokes the function for the keystroke\n            else if (!this.isEventIgnored(evt)) {\n                const boundFunction = this.getFunction(evt);\n                if (boundFunction != null) {\n                    boundFunction(evt);\n                    InternalEvent.consume(evt);\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given event should be handled. <isEventIgnored> is\n     * called later if the event is not an escape key stroke, in which case\n     * <escape> is called. This implementation returns true if <isEnabled>\n     * returns true for both, this handler and <graph>, if the event is not\n     * consumed and if <isGraphEvent> returns true.\n     *\n     * @param evt Key event that represents the keystroke.\n     */\n    isEnabledForEvent(evt) {\n        return (this.graph.isEnabled() &&\n            !isConsumed(evt) &&\n            this.isGraphEvent(evt) &&\n            this.isEnabled());\n    }\n    /**\n     * Returns true if the given keystroke should be ignored. This returns\n     * graph.isEditing().\n     *\n     * @param evt Key event that represents the keystroke.\n     */\n    isEventIgnored(evt) {\n        return this.graph.isEditing();\n    }\n    /**\n     * Hook to process ESCAPE keystrokes. This implementation invokes\n     * {@link Graph#stopEditing} to cancel the current editing, connecting\n     * and/or other ongoing modifications.\n     *\n     * @param evt Key event that represents the keystroke. Possible keycode in this\n     * case is 27 (ESCAPE).\n     */\n    escape(evt) {\n        if (this.graph.isEscapeEnabled()) {\n            this.graph.escape(evt);\n        }\n    }\n    /**\n     * Destroys the handler and all its references into the DOM. This does\n     * normally not need to be called, it is called automatically when the\n     * window unloads (in IE).\n     */\n    onDestroy() {\n        if (this.target != null && this.keydownHandler != null) {\n            InternalEvent.removeListener(this.target, 'keydown', this.keydownHandler);\n            this.keydownHandler = null;\n        }\n        this.target = null;\n    }\n}\nexport default KeyHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../view/event/InternalEvent';\nimport EventObject from '../view/event/EventObject';\nimport KeyHandler from '../view/handler/KeyHandler';\n/**\n * Binds keycodes to action names in an editor.  This aggregates an internal {@link handler} and extends the implementation of {@link KeyHandler.escape} to not only cancel the editing, but also hide the properties dialog and fire an <Editor.escape> event via {@link editor}.  An instance of this class is created by {@link Editor} and stored in {@link Editor.keyHandler}.\n *\n * @Example\n * Bind the delete key to the delete action in an existing editor.\n * ```javascript\n * var keyHandler = new EditorKeyHandler(editor);\n * keyHandler.bindAction(46, 'delete');\n * ```\n *\n * @Codec\n * This class uses the {@link DefaultKeyHandlerCodec} to read configuration data into an existing instance.  See {@link DefaultKeyHandlerCodec} for a description of the configuration format.\n *\n * @Keycodes\n * See {@link KeyHandler}.\n * An {@link InternalEvent.ESCAPE} event is fired via the editor if the escape key is pressed.\n */\nexport class EditorKeyHandler {\n    constructor(editor = null) {\n        /**\n         * Reference to the enclosing {@link Editor}.\n         */\n        this.editor = null;\n        /**\n         * Holds the {@link KeyHandler} for key event handling.\n         */\n        this.handler = null;\n        if (editor != null) {\n            this.editor = editor;\n            const handler = (this.handler = new KeyHandler(editor.graph));\n            // Extends the escape function of the internal key\n            // handle to hide the properties dialog and fire\n            // the escape event via the editor instance\n            const old = this.handler.escape;\n            this.handler.escape = (evt) => {\n                old.apply(handler, [evt]);\n                editor.hideProperties();\n                editor.fireEvent(new EventObject(InternalEvent.ESCAPE, { event: evt }));\n            };\n        }\n    }\n    /**\n     * Binds the specified keycode to the given action in {@link editor}.  The optional control flag specifies if the control key must be pressed to trigger the action.\n     *\n     * @param code      Integer that specifies the keycode.\n     * @param action    Name of the action to execute in {@link editor}.\n     * @param control   Optional boolean that specifies if control must be pressed.  Default is false.\n     */\n    bindAction(code, action, control) {\n        const keyHandler = () => {\n            this.editor.execute(action);\n        };\n        if (control) {\n            // Binds the function to control-down keycode\n            this.handler.bindControlKey(code, keyHandler);\n        }\n        else {\n            // Binds the function to the normal keycode\n            this.handler.bindKey(code, keyHandler);\n        }\n    }\n    /**\n     * Destroys the {@link handler} associated with this object.  This does normally not need to be called, the {@link handler} is destroyed automatically when the window unloads (in IE) by {@link Editor}.\n     */\n    destroy() {\n        this.handler.onDestroy();\n        this.handler = null;\n    }\n}\nexport default EditorKeyHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getTextContent } from '../util/domUtils';\nimport Translations from '../util/Translations';\n/**\n * Creates popupmenus for mouse events.  This object holds an XML node which is a description of the popup menu to be created.  In {@link createMenu}, the configuration is applied to the context and the resulting menu items are added to the menu dynamically.  See {@link createMenu} for a description of the configuration format.\n * This class does not create the DOM nodes required for the popup menu, it only parses an XML description to invoke the respective methods on an {@link mxPopupMenu} each time the menu is displayed.\n *\n * @Codec\n * This class uses the {@link DefaultPopupMenuCodec} to read configuration data into an existing instance, however, the actual parsing is done by this class during program execution, so the format is described below.\n */\nexport class EditorPopupMenu {\n    constructor(config = null) {\n        /**\n         * Base path for all icon attributes in the config.  Default is null.\n         *\n         * @default null\n         */\n        this.imageBasePath = null;\n        this.config = config;\n    }\n    /**\n     * This function is called from {@link Editor} to add items to the\n     * given menu based on {@link config}. The config is a sequence of\n     * the following nodes and attributes.\n     *\n     * @ChildNodes:\n     *\n     * add - Adds a new menu item. See below for attributes.\n     * separator - Adds a separator. No attributes.\n     * condition - Adds a custom condition. Name attribute.\n     *\n     * The add-node may have a child node that defines a function to be invoked\n     * before the action is executed (or instead of an action to be executed).\n     *\n     * @Attributes:\n     *\n     * as - Resource key for the label (needs entry in property file).\n     * action - Name of the action to execute in enclosing editor.\n     * icon - Optional icon (relative/absolute URL).\n     * iconCls - Optional CSS class for the icon.\n     * if - Optional name of condition that must be true (see below).\n     * enabled-if - Optional name of condition that specifies if the menu item\n     * should be enabled.\n     * name - Name of custom condition. Only for condition nodes.\n     *\n     * @Conditions:\n     *\n     * nocell - No cell under the mouse.\n     * ncells - More than one cell selected.\n     * notRoot - Drilling position is other than home.\n     * cell - Cell under the mouse.\n     * notEmpty - Exactly one cell with children under mouse.\n     * expandable - Exactly one expandable cell under mouse.\n     * collapsable - Exactly one collapsable cell under mouse.\n     * validRoot - Exactly one cell which is a possible root under mouse.\n     * swimlane - Exactly one cell which is a swimlane under mouse.\n     *\n     * @Example:\n     *\n     * To add a new item for a given action to the popupmenu:\n     *\n     * ```\n     * <EditorPopupMenu as=\"popupHandler\">\n     *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>\n     * </EditorPopupMenu>\n     * ```\n     *\n     * To add a new item for a custom function:\n     *\n     * ```\n     * <EditorPopupMenu as=\"popupHandler\">\n     *   <add as=\"action1\"><![CDATA[\n     *\t\tfunction (editor, cell, evt)\n     *\t\t{\n     *\t\t\teditor.execute('action1', cell, 'myArg');\n     *\t\t}\n     *   ]]></add>\n     * </EditorPopupMenu>\n     * ```\n     *\n     * The above example invokes action1 with an additional third argument via\n     * the editor instance. The third argument is passed to the function that\n     * defines action1. If the add-node has no action-attribute, then only the\n     * function defined in the text content is executed, otherwise first the\n     * function and then the action defined in the action-attribute is\n     * executed. The function in the text content has 3 arguments, namely the\n     * {@link Editor} instance, the {@link mxCell} instance under the mouse, and the\n     * native mouse event.\n     *\n     * Custom Conditions:\n     *\n     * To add a new condition for popupmenu items:\n     *\n     * ```\n     * <condition name=\"condition1\"><![CDATA[\n     *   function (editor, cell, evt)\n     *   {\n     *     return cell != null;\n     *   }\n     * ]]></condition>\n     * ```\n     *\n     * The new condition can then be used in any item as follows:\n     *\n     * ```\n     * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>\n     * ```\n     *\n     * The order in which the items and conditions appear is not significant as\n     * all conditions are evaluated before any items are created.\n     *\n     * @param editor - Enclosing {@link Editor} instance.\n     * @param menu - {@link mxPopupMenu} that is used for adding items and separators.\n     * @param cell - Optional {@link mxCell} which is under the mousepointer.\n     * @param evt - Optional mouse event which triggered the menu.\n     */\n    createMenu(editor, menu, cell = null, evt = null) {\n        if (this.config != null) {\n            const conditions = this.createConditions(editor, cell, evt);\n            const item = this.config.firstChild;\n            this.addItems(editor, menu, cell, evt, conditions, item, null);\n        }\n    }\n    /**\n     * Recursively adds the given items and all of its children into the given menu.\n     *\n     * @param editor Enclosing <Editor> instance.\n     * @param menu {@link PopupMenu} that is used for adding items and separators.\n     * @param cell Optional <Cell> which is under the mousepointer.\n     * @param evt Optional mouse event which triggered the menu.\n     * @param conditions Array of names boolean conditions.\n     * @param item XML node that represents the current menu item.\n     * @param parent DOM node that represents the parent menu item.\n     */\n    addItems(editor, menu, cell = null, evt = null, conditions, item, parent = null) {\n        let addSeparator = false;\n        while (item != null) {\n            if (item.nodeName === 'add') {\n                const condition = item.getAttribute('if');\n                if (condition == null || conditions[condition]) {\n                    let as = item.getAttribute('as');\n                    as = Translations.get(as) || as;\n                    const funct = eval(getTextContent(item));\n                    const action = item.getAttribute('action');\n                    let icon = item.getAttribute('icon');\n                    const iconCls = item.getAttribute('iconCls');\n                    const enabledCond = item.getAttribute('enabled-if');\n                    const enabled = enabledCond == null || conditions[enabledCond];\n                    if (addSeparator) {\n                        menu.addSeparator(parent);\n                        addSeparator = false;\n                    }\n                    if (icon != null && this.imageBasePath) {\n                        icon = this.imageBasePath + icon;\n                    }\n                    const row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);\n                    this.addItems(editor, menu, cell, evt, conditions, \n                    // @ts-ignore\n                    item.firstChild, row);\n                }\n            }\n            else if (item.nodeName === 'separator') {\n                addSeparator = true;\n            }\n            // @ts-ignore\n            item = item.nextSibling;\n        }\n    }\n    /**\n     * Helper method to bind an action to a new menu item.\n     *\n     * @param menu {@link PopupMenu} that is used for adding items and separators.\n     * @param editor Enclosing <Editor> instance.\n     * @param lab String that represents the label of the menu item.\n     * @param icon Optional URL that represents the icon of the menu item.\n     * @param action Optional name of the action to execute in the given editor.\n     * @param funct Optional function to execute before the optional action. The\n     * function takes an <Editor>, the <Cell> under the mouse and the\n     * mouse event that triggered the call.\n     * @param cell Optional <Cell> to use as an argument for the action.\n     * @param parent DOM node that represents the parent menu item.\n     * @param iconCls Optional CSS class for the menu icon.\n     * @param enabled Optional boolean that specifies if the menu item is enabled.\n     * Default is true.\n     */\n    addAction(menu, editor, lab, icon = null, funct = null, action = null, cell = null, parent = null, iconCls = null, enabled = true) {\n        const clickHandler = (evt) => {\n            if (typeof funct === 'function') {\n                funct.call(editor, editor, cell, evt);\n            }\n            if (action != null) {\n                editor.execute(action, cell, evt);\n            }\n        };\n        return menu.addItem(lab, icon || null, clickHandler, parent, iconCls, enabled);\n    }\n    /**\n     * Evaluates the default conditions for the given context.\n     *\n     * @param editor\n     * @param cell\n     * @param evt\n     */\n    createConditions(editor, cell = null, evt = null) {\n        // Creates array with conditions\n        const model = editor.graph.getDataModel();\n        const childCount = cell ? cell.getChildCount() : 0;\n        // Adds some frequently used conditions\n        const conditions = {};\n        conditions.nocell = cell == null;\n        conditions.ncells = editor.graph.getSelectionCount() > 1;\n        conditions.notRoot = model.getRoot() !== editor.graph.getDefaultParent().getParent();\n        conditions.cell = cell != null;\n        const isCell = cell != null && editor.graph.getSelectionCount() === 1;\n        conditions.nonEmpty = isCell && childCount > 0;\n        conditions.expandable = isCell && editor.graph.isCellFoldable(cell, false);\n        conditions.collapsable = isCell && editor.graph.isCellFoldable(cell, true);\n        conditions.validRoot = isCell && editor.graph.isValidRoot(cell);\n        conditions.emptyValidRoot = conditions.validRoot && childCount === 0;\n        conditions.swimlane = isCell && editor.graph.isSwimlane(cell);\n        // Evaluates dynamic conditions from config file\n        const condNodes = this.config.getElementsByTagName('condition');\n        for (let i = 0; i < condNodes.length; i += 1) {\n            const funct = eval(getTextContent(condNodes[i]));\n            const name = condNodes[i].getAttribute('name');\n            if (name != null && typeof funct === 'function') {\n                conditions[name] = funct(editor, cell, evt);\n            }\n        }\n        return conditions;\n    }\n}\nexport default EditorPopupMenu;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../view/event/InternalEvent';\nimport Point from '../view/geometry/Point';\nimport MaxPopupMenu from './MaxPopupMenu';\nimport EventSource from '../view/event/EventSource';\nimport EventObject from '../view/event/EventObject';\nimport Client from '../Client';\nimport { br, write, writeln } from '../util/domUtils';\n/**\n * Creates a toolbar inside a given DOM node. The toolbar may contain icons, buttons and combo boxes.\n *\n * ### `InternalEvent.SELECT`\n *\n * Fires when an item was selected in the toolbar. The EventObject {@link InternalEvent.function}\n * property contains the function that was selected in {@link selectMode}.\n *\n */\nclass MaxToolbar extends EventSource {\n    constructor(container) {\n        super();\n        this.menu = null;\n        this.currentImg = null;\n        this.selectedMode = null;\n        this.defaultMode = null;\n        this.defaultFunction = null;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Specifies if <resetMode> requires a forced flag of true for resetting\n         * the current mode in the toolbar. Default is false. This is set to true\n         * if the toolbar item is double clicked to avoid a reset after a single\n         * use of the item.\n         */\n        this.noReset = false;\n        /**\n         * Boolean indicating if the default mode should be the last selected\n         * switch mode or the first inserted switch mode. Default is true, that\n         * is the last selected switch mode is the default mode. The default mode\n         * is the mode to be selected after a reset of the toolbar. If this is\n         * false, then the default mode is the first inserted mode item regardless\n         * of what was last selected. Otherwise, the selected item after a reset is\n         * the previously selected item.\n         */\n        this.updateDefaultMode = true;\n        this.container = container;\n    }\n    /**\n     * Adds the given function as an image with the specified title and icon\n     * and returns the new image node.\n     *\n     * @param title Optional string that is used as the tooltip.\n     * @param icon Optional URL of the image to be used. If no URL is given, then a\n     * button is created.\n     * @param funct Function to execute on a mouse click.\n     * @param pressedIcon Optional URL of the pressed image. Default is a gray\n     * background.\n     * @param style Optional style classname. Default is mxToolbarItem.\n     * @param factoryMethod Optional factory method for popup menu, eg.\n     * (menu, evt, cell)=> { menu.addItem('Hello, World!'); }\n     */\n    addItem(title = null, icon = null, funct = null, pressedIcon = null, style = null, factoryMethod = null) {\n        const img = document.createElement(icon != null ? 'img' : 'button');\n        const initialClassName = style || (factoryMethod ? 'mxToolbarMode' : 'mxToolbarItem');\n        img.className = initialClassName;\n        if (icon) {\n            img.setAttribute('src', icon);\n        }\n        if (title != null) {\n            if (icon != null) {\n                img.setAttribute('title', title);\n            }\n            else {\n                write(img, title);\n            }\n        }\n        this.container.appendChild(img);\n        // Invokes the function on a click on the toolbar item\n        if (funct != null) {\n            InternalEvent.addListener(img, 'click', funct);\n            if (Client.IS_TOUCH) {\n                InternalEvent.addListener(img, 'touchend', funct);\n            }\n        }\n        const mouseHandler = (evt) => {\n            if (pressedIcon != null) {\n                img.setAttribute('src', icon);\n            }\n            else {\n                img.style.backgroundColor = '';\n            }\n        };\n        // Highlights the toolbar item with a gray background\n        // while it is being clicked with the mouse\n        InternalEvent.addGestureListeners(img, (evt) => {\n            if (pressedIcon != null) {\n                img.setAttribute('src', pressedIcon);\n            }\n            else {\n                img.style.backgroundColor = 'gray';\n            }\n            // Popup Menu\n            if (factoryMethod) {\n                if (this.menu == null) {\n                    this.menu = new MaxPopupMenu();\n                    // TODO the removal of the init method in the MaxPopupMenu class changed the behavior here\n                    //this.menu.init();\n                }\n                const last = this.currentImg;\n                if (this.menu.isMenuShowing()) {\n                    this.menu.hideMenu();\n                }\n                if (last != img) {\n                    // Redirects factory method to local factory method\n                    this.currentImg = img;\n                    this.menu.factoryMethod = factoryMethod;\n                    const point = new Point(img.offsetLeft, img.offsetTop + img.offsetHeight);\n                    this.menu.popup(point.x, point.y, null, evt);\n                    // Sets and overrides to restore classname\n                    if (this.menu.isMenuShowing()) {\n                        img.className = `${initialClassName}Selected`;\n                        const hideMenu = this.menu.hideMenu;\n                        this.menu.hideMenu = () => {\n                            hideMenu.apply(this);\n                            img.className = initialClassName;\n                            this.currentImg = null;\n                        };\n                    }\n                }\n            }\n        }, null, mouseHandler);\n        InternalEvent.addListener(img, 'mouseout', mouseHandler);\n        return img;\n    }\n    /**\n     * Adds and returns a new SELECT element using the given style. The element\n     * is placed inside a DIV with the mxToolbarComboContainer style classname.\n     *\n     * @param style - Optional style classname. Default is mxToolbarCombo.\n     */\n    addCombo(style) {\n        const div = document.createElement('div');\n        div.style.display = 'inline';\n        div.className = 'mxToolbarComboContainer';\n        const select = document.createElement('select');\n        select.className = style || 'mxToolbarCombo';\n        div.appendChild(select);\n        this.container.appendChild(div);\n        return select;\n    }\n    /**\n     * Adds and returns a new SELECT element using the given title as the\n     * default element. The selection is reset to this element after each\n     * change.\n     *\n     * @param title - String that specifies the title of the default element.\n     * @param style - Optional style classname. Default is mxToolbarCombo.\n     */\n    addActionCombo(title, style) {\n        const select = document.createElement('select');\n        select.className = style || 'mxToolbarCombo';\n        this.addOption(select, title, null);\n        InternalEvent.addListener(select, 'change', (evt) => {\n            const value = select.options[select.selectedIndex];\n            select.selectedIndex = 0;\n            if (value.funct != null) {\n                value.funct(evt);\n            }\n        });\n        this.container.appendChild(select);\n        return select;\n    }\n    /**\n     * Adds and returns a new OPTION element inside the given SELECT element.\n     * If the given value is a function then it is stored in the option's funct\n     * field.\n     *\n     * @param combo - SELECT element that will contain the new entry.\n     * @param title - String that specifies the title of the option.\n     * @param value - Specifies the value associated with this option.\n     */\n    addOption(combo, title, value = null) {\n        const option = document.createElement('option');\n        writeln(option, title);\n        if (typeof value === 'function') {\n            option.funct = value;\n        }\n        else {\n            option.setAttribute('value', value);\n        }\n        combo.appendChild(option);\n        return option;\n    }\n    /**\n     * Adds a new selectable item to the toolbar. Only one switch mode item may\n     * be selected at a time. The currently selected item is the default item\n     * after a reset of the toolbar.\n     */\n    addSwitchMode(title, icon, funct, pressedIcon = null, style = 'mxToolbarMode') {\n        const img = document.createElement('img');\n        img.initialClassName = style;\n        img.className = img.initialClassName;\n        img.setAttribute('src', icon);\n        img.altIcon = pressedIcon;\n        if (title != null) {\n            img.setAttribute('title', title);\n        }\n        InternalEvent.addListener(img, 'click', (evt) => {\n            const selectedModeImg = this.selectedMode;\n            let tmp = selectedModeImg.altIcon;\n            if (tmp != null) {\n                selectedModeImg.altIcon = selectedModeImg.getAttribute('src');\n                selectedModeImg.setAttribute('src', tmp);\n            }\n            else {\n                selectedModeImg.className = selectedModeImg.initialClassName;\n            }\n            if (this.updateDefaultMode) {\n                this.defaultMode = img;\n            }\n            this.selectedMode = img;\n            tmp = img.altIcon;\n            if (tmp != null) {\n                img.altIcon = img.getAttribute('src');\n                img.setAttribute('src', tmp);\n            }\n            else {\n                img.className = `${img.initialClassName}Selected`;\n            }\n            this.fireEvent(new EventObject(InternalEvent.SELECT));\n            funct();\n        });\n        this.container.appendChild(img);\n        if (this.defaultMode == null) {\n            this.defaultMode = img;\n            // Function should fire only once so\n            // do not pass it with the select event\n            this.selectMode(img);\n            funct();\n        }\n        return img;\n    }\n    /**\n     * Adds a new item to the toolbar. The selection is typically reset after\n     * the item has been consumed, for example by adding a new vertex to the\n     * graph. The reset is not carried out if the item is double clicked.\n     *\n     * The function argument uses the following signature: funct(evt, cell) where\n     * evt is the native mouse event and cell is the cell under the mouse.\n     */\n    addMode(title = null, icon = null, funct, pressedIcon, style = null, toggle = false) {\n        toggle = toggle != null ? toggle : true;\n        const img = (document.createElement(icon != null ? 'img' : 'button'));\n        img.initialClassName = style || 'mxToolbarMode';\n        img.className = img.initialClassName;\n        if (icon) {\n            img.setAttribute('src', icon);\n        }\n        img.altIcon = pressedIcon;\n        if (title != null) {\n            img.setAttribute('title', title);\n        }\n        if (this.enabled && toggle) {\n            InternalEvent.addListener(img, 'click', (evt) => {\n                this.selectMode(img, funct);\n                this.noReset = false;\n            });\n            InternalEvent.addListener(img, 'dblclick', (evt) => {\n                this.selectMode(img, funct);\n                this.noReset = true;\n            });\n            if (this.defaultMode == null) {\n                this.defaultMode = img;\n                this.defaultFunction = funct;\n                this.selectMode(img, funct);\n            }\n        }\n        this.container.appendChild(img);\n        return img;\n    }\n    /**\n     * Resets the state of the previously selected mode and displays the given\n     * DOM node as selected. This function fires a select event with the given\n     * function as a parameter.\n     */\n    selectMode(domNode, funct = null) {\n        if (this.selectedMode != domNode) {\n            if (this.selectedMode != null) {\n                const tmp = this.selectedMode.altIcon;\n                if (tmp != null) {\n                    this.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n                    this.selectedMode.setAttribute('src', tmp);\n                }\n                else {\n                    this.selectedMode.className = this.selectedMode.initialClassName;\n                }\n            }\n            this.selectedMode = domNode;\n            const tmp = this.selectedMode.altIcon;\n            if (tmp != null) {\n                this.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n                this.selectedMode.setAttribute('src', tmp);\n            }\n            else {\n                this.selectedMode.className = `${this.selectedMode.initialClassName}Selected`;\n            }\n            this.fireEvent(new EventObject(InternalEvent.SELECT, { function: funct }));\n        }\n    }\n    /**\n     * Selects the default mode and resets the state of the previously selected\n     * mode.\n     */\n    resetMode(forced = false) {\n        if ((forced || !this.noReset) && this.selectedMode != this.defaultMode) {\n            // The last selected switch mode will be activated\n            // so the function was already executed and is\n            // no longer required here\n            this.selectMode(this.defaultMode, this.defaultFunction);\n        }\n    }\n    /**\n     * Adds the specifies image as a separator.\n     *\n     * @param icon - URL of the separator icon.\n     */\n    addSeparator(icon) {\n        return this.addItem(null, icon, null);\n    }\n    /**\n     * Adds a break to the container.\n     */\n    addBreak() {\n        br(this.container);\n    }\n    /**\n     * Adds a horizontal line to the container.\n     */\n    addLine() {\n        const hr = document.createElement('hr');\n        hr.style.marginRight = '6px';\n        hr.setAttribute('size', '1');\n        this.container.appendChild(hr);\n    }\n    /**\n     * Removes the toolbar and all its associated resources.\n     */\n    destroy() {\n        InternalEvent.release(this.container);\n        // @ts-ignore\n        this.container = null;\n        this.defaultMode = null;\n        this.defaultFunction = null;\n        this.selectedMode = null;\n        if (this.menu != null) {\n            this.menu.destroy();\n        }\n    }\n}\nexport default MaxToolbar;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport DragSource from '../view/other/DragSource';\nimport Point from '../view/geometry/Point';\nimport { TOOLTIP_VERTICAL_OFFSET } from './Constants';\n/**\n * Configures the given DOM element to act as a drag source for the\n * specified graph. Returns a a new {@link DragSource}. If\n * {@link DragSource#guideEnabled} is enabled then the x and y arguments must\n * be used in funct to match the preview location.\n *\n * Example:\n *\n * ```javascript\n * let funct = (graph, evt, cell, x, y)=>\n * {\n *   if (graph.canImportCell(cell))\n *   {\n *     let parent = graph.getDefaultParent();\n *     let vertex = null;\n *\n *     graph.getDataModel().beginUpdate();\n *     try\n *     {\n *        vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);\n *     }\n *     finally\n *     {\n *       graph.getDataModel().endUpdate();\n *     }\n *\n *     graph.setSelectionCell(vertex);\n *   }\n * }\n *\n * let img = document.createElement('img');\n * img.setAttribute('src', 'editors/images/rectangle.gif');\n * img.style.position = 'absolute';\n * img.style.left = '0px';\n * img.style.top = '0px';\n * img.style.width = '16px';\n * img.style.height = '16px';\n *\n * let dragImage = img.cloneNode(true);\n * dragImage.style.width = '32px';\n * dragImage.style.height = '32px';\n * mxUtils.makeDraggable(img, graph, funct, dragImage);\n * document.body.appendChild(img);\n * ```\n *\n * @param element DOM element to make draggable.\n * @param graphF {@link Graph} that acts as the drop target or a function that takes a\n * mouse event and returns the current {@link Graph}.\n * @param funct Function to execute on a successful drop.\n * @param dragElement Optional DOM node to be used for the drag preview.\n * @param dx Optional horizontal offset between the cursor and the drag\n * preview.\n * @param dy Optional vertical offset between the cursor and the drag\n * preview.\n * @param autoscroll Optional boolean that specifies if autoscroll should be\n * used. Default is mxGraph.autoscroll.\n * @param scalePreview Optional boolean that specifies if the preview element\n * should be scaled according to the graph scale. If this is true, then\n * the offsets will also be scaled. Default is false.\n * @param highlightDropTargets Optional boolean that specifies if dropTargets\n * should be highlighted. Default is true.\n * @param getDropTarget Optional function to return the drop target for a given\n * location (x, y). Default is mxGraph.getCellAt.\n */\nexport const makeDraggable = (element, graphF, funct, dragElement = null, dx = null, dy = null, autoscroll = null, scalePreview = false, highlightDropTargets = true, getDropTarget = null) => {\n    const dragSource = new DragSource(element, funct);\n    dragSource.dragOffset = new Point(dx != null ? dx : 0, dy != null ? dy : TOOLTIP_VERTICAL_OFFSET);\n    if (autoscroll != null) {\n        dragSource.autoscroll = autoscroll;\n    }\n    // Cannot enable this by default. This needs to be enabled in the caller\n    // if the funct argument uses the new x- and y-arguments.\n    dragSource.setGuidesEnabled(false);\n    if (highlightDropTargets != null) {\n        dragSource.highlightDropTargets = highlightDropTargets;\n    }\n    // Overrides function to find drop target cell\n    if (getDropTarget != null) {\n        dragSource.getDropTarget = getDropTarget;\n    }\n    // Overrides function to get current graph\n    dragSource.getGraphForEvent = (evt) => {\n        return typeof graphF === 'function' ? graphF(evt) : graphF;\n    };\n    // Translates switches into dragSource customizations\n    if (dragElement != null) {\n        // @ts-ignore\n        dragSource.createDragElement = () => {\n            return dragElement.cloneNode(true);\n        };\n        if (scalePreview) {\n            dragSource.createPreviewElement = (graph) => {\n                const elt = dragElement.cloneNode(true);\n                const w = parseInt(elt.style.width);\n                const h = parseInt(elt.style.height);\n                elt.style.width = `${Math.round(w * graph.view.scale)}px`;\n                elt.style.height = `${Math.round(h * graph.view.scale)}px`;\n                return elt;\n            };\n        }\n    }\n    return dragSource;\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport CellHighlight from '../cell/CellHighlight';\nimport { getDocumentScrollOrigin, getOffset, getScrollOrigin, setOpacity, } from '../../util/styleUtils';\nimport InternalEvent from '../event/InternalEvent';\nimport Client from '../../Client';\nimport Guide from './Guide';\nimport { DROP_TARGET_COLOR } from '../../util/Constants';\nimport Point from '../geometry/Point';\nimport { getClientX, getClientY, getSource, isConsumed, isMouseEvent, isPenEvent, isTouchEvent, } from '../../util/EventUtils';\n/**\n * @class DragSource\n *\n * Wrapper to create a drag source from a DOM element so that the element can\n * be dragged over a graph and dropped into the graph as a new cell.\n *\n * Problem is that in the dropHandler the current preview location is not\n * available, so the preview and the dropHandler must match.\n *\n */\nclass DragSource {\n    constructor(element, dropHandler) {\n        /**\n         * {@link Point} that specifies the offset of the {@link dragElement}. Default is null.\n         */\n        this.dragOffset = null;\n        /**\n         * Holds the DOM node that is used to represent the drag preview. If this is\n         * null then the source element will be cloned and used for the drag preview.\n         */\n        this.dragElement = null;\n        /**\n         * TODO - wrong description\n         * Optional {@link Rectangle} that specifies the unscaled size of the preview.\n         */\n        this.previewElement = null;\n        /**\n         * Optional {@link Point} that specifies the offset of the preview in pixels.\n         */\n        this.previewOffset = null;\n        /**\n         * Specifies if this drag source is enabled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Reference to the {@link mxGraph} that is the current drop target.\n         */\n        this.currentGraph = null;\n        /**\n         * Holds the current drop target under the mouse.\n         */\n        this.currentDropTarget = null;\n        /**\n         * Holds the current drop location.\n         */\n        this.currentPoint = null;\n        /**\n         * Holds an {@link mxGuide} for the {@link currentGraph} if {@link dragPreview} is not null.\n         */\n        this.currentGuide = null;\n        /**\n         * Holds an {@link mxGuide} for the {@link currentGraph} if {@link dragPreview} is not null.\n         * @note wrong doc\n         */\n        this.currentHighlight = null;\n        /**\n         * Specifies if the graph should scroll automatically. Default is true.\n         */\n        this.autoscroll = true;\n        /**\n         * Specifies if {@link mxGuide} should be enabled. Default is true.\n         */\n        this.guidesEnabled = true;\n        /**\n         * Specifies if the grid should be allowed. Default is true.\n         */\n        this.gridEnabled = true;\n        /**\n         * Specifies if drop targets should be highlighted. Default is true.\n         */\n        this.highlightDropTargets = true;\n        /**\n         * ZIndex for the drag element. Default is 100.\n         */\n        this.dragElementZIndex = 100;\n        /**\n         * Opacity of the drag element in %. Default is 70.\n         */\n        this.dragElementOpacity = 70;\n        /**\n         * Whether the event source should be checked in {@link graphContainerEvent}. Default\n         * is true.\n         */\n        this.checkEventSource = true;\n        this.mouseMoveHandler = null;\n        this.mouseUpHandler = null;\n        this.eventSource = null;\n        this.element = element;\n        this.dropHandler = dropHandler;\n        // Handles a drag gesture on the element\n        InternalEvent.addGestureListeners(element, (evt) => {\n            this.mouseDown(evt);\n        });\n        // Prevents native drag and drop\n        InternalEvent.addListener(element, 'dragstart', (evt) => {\n            InternalEvent.consume(evt);\n        });\n        this.eventConsumer = (sender, evt) => {\n            const evtName = evt.getProperty('eventName');\n            const me = evt.getProperty('event');\n            if (evtName !== InternalEvent.MOUSE_DOWN) {\n                me.consume();\n            }\n        };\n    }\n    /**\n     * Returns {@link enabled}.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Sets {@link enabled}.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Returns {@link guidesEnabled}.\n     */\n    isGuidesEnabled() {\n        return this.guidesEnabled;\n    }\n    /**\n     * Sets {@link guidesEnabled}.\n     */\n    setGuidesEnabled(value) {\n        this.guidesEnabled = value;\n    }\n    /**\n     * Returns {@link gridEnabled}.\n     */\n    isGridEnabled() {\n        return this.gridEnabled;\n    }\n    /**\n     * Sets {@link gridEnabled}.\n     */\n    setGridEnabled(value) {\n        this.gridEnabled = value;\n    }\n    /**\n     * Returns the graph for the given mouse event. This implementation returns\n     * null.\n     */\n    getGraphForEvent(evt) {\n        return null;\n    }\n    /**\n     * Returns the drop target for the given graph and coordinates. This\n     * implementation uses {@link mxGraph.getCellAt}.\n     */\n    getDropTarget(graph, x, y, evt) {\n        return graph.getCellAt(x, y);\n    }\n    /**\n     * Creates and returns a clone of the {@link dragElementPrototype} or the {@link element}\n     * if the former is not defined.\n     */\n    createDragElement(evt) {\n        return this.element.cloneNode(true);\n    }\n    /**\n     * Creates and returns an element which can be used as a preview in the given\n     * graph.\n     */\n    createPreviewElement(graph) {\n        return null;\n    }\n    /**\n     * Returns true if this drag source is active.\n     */\n    isActive() {\n        return !!this.mouseMoveHandler;\n    }\n    /**\n     * Stops and removes everything and restores the state of the object.\n     */\n    reset() {\n        if (this.currentGraph) {\n            this.dragExit(this.currentGraph);\n            this.currentGraph = null;\n        }\n        this.removeDragElement();\n        this.removeListeners();\n        this.stopDrag();\n    }\n    /**\n     * Returns the drop target for the given graph and coordinates. This\n     * implementation uses {@link mxGraph.getCellAt}.\n     *\n     * To ignore popup menu events for a drag source, this function can be\n     * overridden as follows.\n     *\n     * @example\n     * ```javascript\n     * var mouseDown = dragSource.mouseDown;\n     *\n     * dragSource.mouseDown(evt)\n     * {\n     *   if (!mxEvent.isPopupTrigger(evt))\n     *   {\n     *     mouseDown.apply(this, arguments);\n     *   }\n     * };\n     * ```\n     */\n    mouseDown(evt) {\n        if (this.enabled && !isConsumed(evt) && this.mouseMoveHandler == null) {\n            this.startDrag(evt);\n            this.mouseMoveHandler = this.mouseMove.bind(this);\n            this.mouseUpHandler = this.mouseUp.bind(this);\n            InternalEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n            if (Client.IS_TOUCH && !isMouseEvent(evt)) {\n                this.eventSource = getSource(evt);\n                if (this.eventSource) {\n                    InternalEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n                }\n            }\n        }\n    }\n    /**\n     * Creates the {@link dragElement} using {@link createDragElement}.\n     */\n    startDrag(evt) {\n        this.dragElement = this.createDragElement(evt);\n        this.dragElement.style.position = 'absolute';\n        this.dragElement.style.zIndex = String(this.dragElementZIndex);\n        setOpacity(this.dragElement, this.dragElementOpacity);\n        if (this.checkEventSource && Client.IS_SVG) {\n            this.dragElement.style.pointerEvents = 'none';\n        }\n    }\n    /**\n     * Invokes {@link removeDragElement}.\n     */\n    stopDrag() {\n        // LATER: This used to have a mouse event. If that is still needed we need to add another\n        // final call to the DnD protocol to add a cleanup step in the case of escape press, which\n        // is not associated with a mouse event and which currently calles this method.\n        this.removeDragElement();\n    }\n    /**\n     * Removes and destroys the {@link dragElement}.\n     */\n    removeDragElement() {\n        if (this.dragElement) {\n            if (this.dragElement.parentNode) {\n                this.dragElement.parentNode.removeChild(this.dragElement);\n            }\n            this.dragElement = null;\n        }\n    }\n    /**\n     * Returns the topmost element under the given event.\n     */\n    getElementForEvent(evt) {\n        return isTouchEvent(evt) || isPenEvent(evt)\n            ? document.elementFromPoint(getClientX(evt), getClientY(evt))\n            : getSource(evt);\n    }\n    /**\n     * Returns true if the given graph contains the given event.\n     */\n    graphContainsEvent(graph, evt) {\n        const x = getClientX(evt);\n        const y = getClientY(evt);\n        const offset = getOffset(graph.container);\n        const origin = getScrollOrigin();\n        let elt = this.getElementForEvent(evt);\n        if (this.checkEventSource) {\n            while (elt && elt !== graph.container) {\n                // @ts-ignore parentNode may exist\n                elt = elt.parentNode;\n            }\n        }\n        // Checks if event is inside the bounds of the graph container\n        return (!!elt &&\n            x >= offset.x - origin.x &&\n            y >= offset.y - origin.y &&\n            x <= offset.x - origin.x + graph.container.offsetWidth &&\n            y <= offset.y - origin.y + graph.container.offsetHeight);\n    }\n    /**\n     * Gets the graph for the given event using {@link getGraphForEvent}, updates the\n     * {@link currentGraph}, calling {@link dragEnter} and {@link dragExit} on the new and old graph,\n     * respectively, and invokes {@link dragOver} if {@link currentGraph} is not null.\n     */\n    mouseMove(evt) {\n        let graph = this.getGraphForEvent(evt);\n        // Checks if event is inside the bounds of the graph container\n        if (graph && !this.graphContainsEvent(graph, evt)) {\n            graph = null;\n        }\n        if (graph !== this.currentGraph) {\n            if (this.currentGraph) {\n                this.dragExit(this.currentGraph, evt);\n            }\n            this.currentGraph = graph;\n            if (this.currentGraph) {\n                this.dragEnter(this.currentGraph, evt);\n            }\n        }\n        if (this.currentGraph) {\n            this.dragOver(this.currentGraph, evt);\n        }\n        if (this.dragElement &&\n            (!this.previewElement || this.previewElement.style.visibility !== 'visible')) {\n            let x = getClientX(evt);\n            let y = getClientY(evt);\n            if (this.dragElement.parentNode == null) {\n                document.body.appendChild(this.dragElement);\n            }\n            this.dragElement.style.visibility = 'visible';\n            if (this.dragOffset) {\n                x += this.dragOffset.x;\n                y += this.dragOffset.y;\n            }\n            const offset = getDocumentScrollOrigin(document);\n            this.dragElement.style.left = `${x + offset.x}px`;\n            this.dragElement.style.top = `${y + offset.y}px`;\n        }\n        else if (this.dragElement) {\n            this.dragElement.style.visibility = 'hidden';\n        }\n        InternalEvent.consume(evt);\n    }\n    /**\n     * Processes the mouse up event and invokes {@link drop}, {@link dragExit} and {@link stopDrag}\n     * as required.\n     */\n    mouseUp(evt) {\n        if (this.currentGraph) {\n            if (this.currentPoint &&\n                (!this.previewElement || this.previewElement.style.visibility !== 'hidden')) {\n                const { scale } = this.currentGraph.view;\n                const tr = this.currentGraph.view.translate;\n                const x = this.currentPoint.x / scale - tr.x;\n                const y = this.currentPoint.y / scale - tr.y;\n                this.drop(this.currentGraph, evt, this.currentDropTarget, x, y);\n            }\n            this.dragExit(this.currentGraph);\n            this.currentGraph = null;\n        }\n        this.stopDrag();\n        this.removeListeners();\n        InternalEvent.consume(evt);\n    }\n    /**\n     * Actives the given graph as a drop target.\n     */\n    // removeListeners(): void;\n    removeListeners() {\n        if (this.eventSource) {\n            InternalEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n            this.eventSource = null;\n        }\n        InternalEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n        this.mouseMoveHandler = null;\n        this.mouseUpHandler = null;\n    }\n    /**\n     * Actives the given graph as a drop target.\n     */\n    dragEnter(graph, evt) {\n        graph.isMouseDown = true;\n        graph.isMouseTrigger = isMouseEvent(evt);\n        this.previewElement = this.createPreviewElement(graph);\n        if (this.previewElement && this.checkEventSource && Client.IS_SVG) {\n            this.previewElement.style.pointerEvents = 'none';\n        }\n        // Guide is only needed if preview element is used\n        if (this.isGuidesEnabled() && this.previewElement) {\n            const selectionHandler = graph.getPlugin('SelectionHandler');\n            this.currentGuide = new Guide(graph, selectionHandler?.getGuideStates());\n        }\n        if (this.highlightDropTargets) {\n            this.currentHighlight = new CellHighlight(graph, DROP_TARGET_COLOR);\n        }\n        // Consumes all events in the current graph before they are fired\n        graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.eventConsumer);\n    }\n    /**\n     * Deactivates the given graph as a drop target.\n     */\n    dragExit(graph, evt) {\n        this.currentDropTarget = null;\n        this.currentPoint = null;\n        graph.isMouseDown = false;\n        // Consumes all events in the current graph before they are fired\n        graph.removeListener(this.eventConsumer);\n        if (this.previewElement) {\n            if (this.previewElement.parentNode) {\n                this.previewElement.parentNode.removeChild(this.previewElement);\n            }\n            this.previewElement = null;\n        }\n        if (this.currentGuide) {\n            this.currentGuide.destroy();\n            this.currentGuide = null;\n        }\n        if (this.currentHighlight) {\n            this.currentHighlight.destroy();\n            this.currentHighlight = null;\n        }\n    }\n    /**\n     * Implements autoscroll, updates the {@link currentPoint}, highlights any drop\n     * targets and updates the preview.\n     */\n    dragOver(graph, evt) {\n        const offset = getOffset(graph.container);\n        const origin = getScrollOrigin(graph.container);\n        let x = getClientX(evt) - offset.x + origin.x - graph.getPanDx();\n        let y = getClientY(evt) - offset.y + origin.y - graph.getPanDy();\n        if (graph.isAutoScroll() && (!this.autoscroll || this.autoscroll)) {\n            graph.scrollPointToVisible(x, y, graph.isAutoExtend());\n        }\n        // Highlights the drop target under the mouse\n        if (this.currentHighlight && graph.isDropEnabled()) {\n            this.currentDropTarget = this.getDropTarget(graph, x, y, evt);\n            if (this.currentDropTarget) {\n                const state = graph.getView().getState(this.currentDropTarget);\n                this.currentHighlight.highlight(state);\n            }\n        }\n        // Updates the location of the preview\n        if (this.previewElement) {\n            if (!this.previewElement.parentNode) {\n                graph.container.appendChild(this.previewElement);\n                this.previewElement.style.zIndex = '3';\n                this.previewElement.style.position = 'absolute';\n            }\n            const gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);\n            let hideGuide = true;\n            // Grid and guides\n            if (this.currentGuide && this.currentGuide.isEnabledForEvent(evt)) {\n                // LATER: HTML preview appears smaller than SVG preview\n                const w = parseInt(this.previewElement.style.width);\n                const h = parseInt(this.previewElement.style.height);\n                const bounds = new Rectangle(0, 0, w, h);\n                let delta = new Point(x, y);\n                delta = this.currentGuide.move(bounds, delta, gridEnabled, true);\n                hideGuide = false;\n                x = delta.x;\n                y = delta.y;\n            }\n            else if (gridEnabled) {\n                const { scale } = graph.view;\n                const tr = graph.view.translate;\n                const off = graph.getGridSize() / 2;\n                x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;\n                y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;\n            }\n            if (this.currentGuide && hideGuide) {\n                this.currentGuide.hide();\n            }\n            if (this.previewOffset) {\n                x += this.previewOffset.x;\n                y += this.previewOffset.y;\n            }\n            this.previewElement.style.left = `${Math.round(x)}px`;\n            this.previewElement.style.top = `${Math.round(y)}px`;\n            this.previewElement.style.visibility = 'visible';\n        }\n        this.currentPoint = new Point(x, y);\n    }\n    /**\n     * Returns the drop target for the given graph and coordinates. This\n     * implementation uses {@link mxGraph.getCellAt}.\n     */\n    drop(graph, evt, dropTarget = null, x, y) {\n        this.dropHandler(graph, evt, dropTarget, x, y);\n        // Had to move this to after the insert because it will\n        // affect the scrollbars of the window in IE to try and\n        // make the complete container visible.\n        // LATER: Should be made optional.\n        if (graph.container.style.visibility !== 'hidden') {\n            graph.container.focus();\n        }\n    }\n}\nexport default DragSource;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport MaxToolbar from '../gui/MaxToolbar';\nimport Geometry from '../view/geometry/Geometry';\nimport { convertPoint } from '../util/styleUtils';\nimport InternalEvent from '../view/event/InternalEvent';\nimport { getClientX, getClientY } from '../util/EventUtils';\nimport { makeDraggable } from '../util/gestureUtils';\n/**\n * Toolbar for the editor. This modifies the state of the graph\n * or inserts new cells upon mouse clicks.\n *\n * @Example:\n *\n * Create a toolbar with a button to copy the selection into the clipboard,\n * and a combo box with one action to paste the selection from the clipboard\n * into the graph.\n *\n * ```\n * var toolbar = new EditorToolbar(container, editor);\n * toolbar.addItem('Copy', null, 'copy');\n *\n * var combo = toolbar.addActionCombo('More actions...');\n * toolbar.addActionOption(combo, 'Paste', 'paste');\n * ```\n *\n * @Codec:\n *\n * This class uses the {@link DefaultToolbarCodec} to read configuration\n * data into an existing instance. See {@link DefaultToolbarCodec} for a\n * description of the configuration format.\n */\nexport class EditorToolbar {\n    constructor(container = null, editor = null) {\n        /**\n         * Holds the internal {@link MaxToolbar}.\n         */\n        this.toolbar = null;\n        /**\n         * Reference to the function used to reset the {@link toolbar}.\n         */\n        this.resetHandler = null;\n        /**\n         * Defines the spacing between existing and new vertices in gridSize units when a new vertex is dropped on an existing cell.  Default is 4 (40 pixels).\n         *\n         * @Default is 4\n         */\n        this.spacing = 4;\n        /**\n         * Specifies if elements should be connected if new cells are dropped onto connectable elements.\n         *\n         * @Default is false.\n         */\n        this.connectOnDrop = false;\n        this.editor = editor;\n        if (container != null && editor != null) {\n            this.init(container);\n        }\n    }\n    /**\n     * Constructs the {@link toolbar} for the given container and installs a listener that updates the {@link Editor.insertFunction} on {@link editor} if an item is selected in the toolbar.  This assumes that {@link editor} is not null.\n     */\n    init(container) {\n        if (container != null) {\n            this.toolbar = new MaxToolbar(container);\n            // Installs the insert function in the editor if an item is\n            // selected in the toolbar\n            this.toolbar.addListener(InternalEvent.SELECT, (sender, evt) => {\n                const funct = evt.getProperty('function');\n                if (funct != null) {\n                    this.editor.insertFunction = () => {\n                        funct.apply(this, [container]);\n                        this.toolbar.resetMode();\n                    };\n                }\n                else {\n                    this.editor.insertFunction = null;\n                }\n            });\n            // Resets the selected tool after a doubleclick or escape keystroke\n            this.resetHandler = () => {\n                if (this.toolbar != null) {\n                    this.toolbar.resetMode(true);\n                }\n            };\n            this.editor.graph.addListener(InternalEvent.DOUBLE_CLICK, this.resetHandler);\n            this.editor.addListener(InternalEvent.ESCAPE, this.resetHandler);\n        }\n    }\n    /**\n     * Adds a new item that executes the given action in {@link editor}. The title,\n     * icon and pressedIcon are used to display the toolbar item.\n     *\n     * @param title - String that represents the title (tooltip) for the item.\n     * @param icon - URL of the icon to be used for displaying the item.\n     * @param action - Name of the action to execute when the item is clicked.\n     * @param pressed - Optional URL of the icon for the pressed state.\n     */\n    addItem(title, icon, action, pressed) {\n        const clickHandler = () => {\n            if (action != null && action.length > 0) {\n                this.editor.execute(action);\n            }\n        };\n        return this.toolbar.addItem(title, icon, clickHandler, pressed);\n    }\n    /**\n     * Adds a vertical separator using the optional icon.\n     *\n     * @param icon - Optional URL of the icon that represents the vertical separator. Default is {@link Client.imageBasePath} + /separator.gif.\n     */\n    addSeparator(icon) {\n        icon = icon || `${Client.imageBasePath}/separator.gif`;\n        this.toolbar.addSeparator(icon);\n    }\n    /**\n     * Helper method to invoke {@link MaxToolbar.addCombo} on toolbar and return the resulting DOM node.\n     */\n    addCombo() {\n        return this.toolbar.addCombo();\n    }\n    /**\n     * Helper method to invoke <MaxToolbar.addActionCombo> on <toolbar> using\n     * the given title and return the resulting DOM node.\n     *\n     * @param title String that represents the title of the combo.\n     */\n    addActionCombo(title) {\n        return this.toolbar.addActionCombo(title);\n    }\n    /**\n     * Binds the given action to a option with the specified label in the given combo.  Combo is an object returned from an earlier call to {@link addCombo} or {@link addActionCombo}.\n     *\n     * @param combo - DOM node that represents the combo box.\n     * @param title - String that represents the title of the combo.\n     * @param action - Name of the action to execute in {@link editor}.\n     */\n    addActionOption(combo, title, action) {\n        const clickHandler = () => {\n            this.editor.execute(action);\n        };\n        this.addOption(combo, title, clickHandler);\n    }\n    /**\n     * Helper method to invoke {@link MaxToolbar.addOption} on {@link toolbar} and return the resulting DOM node that represents the option.\n     *\n     * @param combo - DOM node that represents the combo box.\n     * @param title - String that represents the title of the combo.\n     * @param value - Object that represents the value of the option.\n     */\n    addOption(combo, title, value) {\n        return this.toolbar.addOption(combo, title, value);\n    }\n    /**\n     * Creates an item for selecting the given mode in the {@link editor}'s graph.\n     * Supported modenames are select, connect and pan.\n     *\n     * @param title - String that represents the title of the item.\n     * @param icon - URL of the icon that represents the item.\n     * @param mode - String that represents the mode name to be used in {@link Editor.setMode}.\n     * @param pressed - Optional URL of the icon that represents the pressed state.\n     * @param funct - Optional JavaScript function that takes the {@link Editor} as the first and only argument that is executed after the mode has been selected.\n     */\n    addMode(title, icon, mode, pressed = null, funct = null) {\n        const clickHandler = () => {\n            this.editor.setMode(mode);\n            if (funct != null) {\n                funct(this.editor);\n            }\n        };\n        return this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);\n    }\n    /**\n     * Creates an item for inserting a clone of the specified prototype cell into\n     * the <editor>'s graph. The ptype may either be a cell or a function that\n     * returns a cell.\n     *\n     * @param title String that represents the title of the item.\n     * @param icon URL of the icon that represents the item.\n     * @param ptype Function or object that represents the prototype cell. If ptype\n     * is a function then it is invoked with no arguments to create new\n     * instances.\n     * @param pressed Optional URL of the icon that represents the pressed state.\n     * @param insert Optional JavaScript function that handles an insert of the new\n     * cell. This function takes the <Editor>, new cell to be inserted, mouse\n     * event and optional <Cell> under the mouse pointer as arguments.\n     * @param toggle Optional boolean that specifies if the item can be toggled.\n     * Default is true.\n     */\n    addPrototype(title, icon, ptype, pressed, insert, toggle = true) {\n        // Creates a wrapper function that is in charge of constructing\n        // the new cell instance to be inserted into the graph\n        const factory = () => {\n            if (typeof ptype === 'function') {\n                return ptype();\n            }\n            if (ptype != null) {\n                return this.editor.graph.cloneCell(ptype);\n            }\n            return null;\n        };\n        // Defines the function for a click event on the graph\n        // after this item has been selected in the toolbar\n        const clickHandler = (evt, cell) => {\n            if (typeof insert === 'function') {\n                insert(this.editor, factory(), evt, cell);\n            }\n            else {\n                this.drop(factory(), evt, cell);\n            }\n            this.toolbar.resetMode();\n            InternalEvent.consume(evt);\n        };\n        const img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);\n        // Creates a wrapper function that calls the click handler without\n        // the graph argument\n        const dropHandler = (graph, evt, cell) => {\n            clickHandler(evt, cell);\n        };\n        this.installDropHandler(img, dropHandler);\n        return img;\n    }\n    /**\n     * Handles a drop from a toolbar item to the graph. The given vertex\n     * represents the new cell to be inserted. This invokes {@link insert} or\n     * {@link connect} depending on the given target cell.\n     *\n     * @param vertex - {@link Cell} to be inserted.\n     * @param evt - Mouse event that represents the drop.\n     * @param target - Optional {@link Cell} that represents the drop target.\n     */\n    drop(vertex, evt, target = null) {\n        const { graph } = this.editor;\n        const model = graph.getDataModel();\n        if (target == null ||\n            target.isEdge() ||\n            !this.connectOnDrop ||\n            !target.isConnectable()) {\n            while (target != null && !graph.isValidDropTarget(target, [vertex], evt)) {\n                target = target.getParent();\n            }\n            this.insert(vertex, evt, target);\n        }\n        else {\n            this.connect(vertex, evt, target);\n        }\n    }\n    /**\n     * Handles a drop by inserting the given vertex into the given parent cell\n     * or the default parent if no parent is specified.\n     *\n     * @param vertex - {@link Cell} to be inserted.\n     * @param evt - Mouse event that represents the drop.\n     * @param target - Optional {@link Cell} that represents the parent.\n     */\n    insert(vertex, evt, target = null) {\n        const { graph } = this.editor;\n        if (graph.canImportCell(vertex)) {\n            const x = getClientX(evt);\n            const y = getClientY(evt);\n            const pt = convertPoint(graph.container, x, y);\n            // Splits the target edge or inserts into target group\n            if (target &&\n                graph.isSplitEnabled() &&\n                graph.isSplitTarget(target, [vertex], evt)) {\n                return graph.splitEdge(target, [vertex], null, pt.x, pt.y);\n            }\n            return this.editor.addVertex(target, vertex, pt.x, pt.y);\n        }\n        return null;\n    }\n    /**\n     * Handles a drop by connecting the given vertex to the given source cell.\n     *\n     * @param vertex - {@link Cell} to be inserted.\n     * @param evt - Mouse event that represents the drop.\n     * @param source - Optional {@link Cell} that represents the source terminal.\n     */\n    connect(vertex, evt, source = null) {\n        const { graph } = this.editor;\n        const model = graph.getDataModel();\n        if (source != null &&\n            vertex.isConnectable() &&\n            graph.isEdgeValid(null, source, vertex)) {\n            let edge = null;\n            model.beginUpdate();\n            try {\n                const geo = source.getGeometry();\n                const g = vertex.getGeometry().clone();\n                // Moves the vertex away from the drop target that will\n                // be used as the source for the new connection\n                g.x = geo.x + (geo.width - g.width) / 2;\n                g.y = geo.y + (geo.height - g.height) / 2;\n                const step = this.spacing * graph.gridSize;\n                const dist = source.getDirectedEdgeCount(true) * 20;\n                if (this.editor.horizontalFlow) {\n                    g.x += (g.width + geo.width) / 2 + step + dist;\n                }\n                else {\n                    g.y += (g.height + geo.height) / 2 + step + dist;\n                }\n                vertex.setGeometry(g);\n                // Fires two add-events with the code below - should be fixed\n                // to only fire one add event for both inserts\n                const parent = source.getParent();\n                graph.addCell(vertex, parent);\n                graph.constrainChild(vertex);\n                // Creates the edge using the editor instance and calls\n                // the second function that fires an add event\n                edge = this.editor.createEdge(source, vertex);\n                if (edge.getGeometry() == null) {\n                    const edgeGeometry = new Geometry();\n                    edgeGeometry.relative = true;\n                    model.setGeometry(edge, edgeGeometry);\n                }\n                graph.addEdge(edge, parent, source, vertex);\n            }\n            finally {\n                model.endUpdate();\n            }\n            graph.setSelectionCells([vertex, edge]);\n            graph.scrollCellToVisible(vertex);\n        }\n    }\n    /**\n     * Makes the given img draggable using the given function for handling a drop event.\n     *\n     * @param img - DOM node that represents the image.\n     * @param dropHandler - Function that handles a drop of the image.\n     */\n    installDropHandler(img, dropHandler) {\n        const sprite = document.createElement('img');\n        sprite.setAttribute('src', img.getAttribute('src'));\n        // Handles delayed loading of the images\n        const loader = (evt) => {\n            // Preview uses the image node with double size. Later this can be\n            // changed to use a separate preview and guides, but for this the\n            // dropHandler must use the additional x- and y-arguments and the\n            // dragsource which makeDraggable returns much be configured to\n            // use guides via mxDragSource.isGuidesEnabled.\n            sprite.style.width = `${2 * img.offsetWidth}px`;\n            sprite.style.height = `${2 * img.offsetHeight}px`;\n            makeDraggable(img, this.editor.graph, dropHandler, sprite);\n            InternalEvent.removeListener(sprite, 'load', loader);\n        };\n    }\n    /**\n     * Destroys the {@link toolbar} associated with this object and removes all installed listeners.\n     * This does normally not need to be called, the {@link toolbar} is destroyed automatically when the window unloads (in IE) by {@link Editor}.\n     */\n    destroy() {\n        if (this.resetHandler != null) {\n            this.editor.graph.removeListener(this.resetHandler);\n            this.editor.removeListener(this.resetHandler);\n            this.resetHandler = null;\n        }\n        if (this.toolbar != null) {\n            this.toolbar.destroy();\n            this.toolbar = null;\n        }\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../event/InternalEvent';\nimport EventObject from '../event/EventObject';\nimport EventSource from '../event/EventSource';\n/**\n * @class UndoManager\n *\n * Implements a command history. When changing the graph model, an\n * {@link mxUndoableChange} object is created at the start of the transaction (when\n * model.beginUpdate is called). All atomic changes are then added to this\n * object until the last model.endUpdate call, at which point the\n * {@link mxUndoableEdit} is dispatched in an event, and added to the history inside\n * {@link UndoManager}. This is done by an event listener in\n * {@link Editor.installUndoHandler}.\n *\n * Each atomic change of the model is represented by an object (eg.\n * {@link mxRootChange}, {@link mxChildChange}, {@link mxTerminalChange} etc) which contains the\n * complete undo information. The {@link UndoManager} also listens to the\n * {@link mxGraphView} and stores it's changes to the current root as insignificant\n * undoable changes, so that drilling (step into, step up) is undone.\n *\n * This means when you execute an atomic change on the model, then change the\n * current root on the view and click undo, the change of the root will be\n * undone together with the change of the model so that the display represents\n * the state at which the model was changed. However, these changes are not\n * transmitted for sharing as they do not represent a state change.\n *\n * ### Example\n *\n * When adding an undo manager to a graph, make sure to add it\n * to the model and the view as well to maintain a consistent\n * display across multiple undo/redo steps.\n *\n * ```javascript\n * var undoManager = new UndoManager();\n * var listener(sender, evt)\n * {\n *   undoManager.undoableEditHappened(evt.getProperty('edit'));\n * };\n * graph.getDataModel().addListener(mxEvent.UNDO, listener);\n * graph.getView().addListener(mxEvent.UNDO, listener);\n * ```\n *\n * The code creates a function that informs the undoManager\n * of an undoable edit and binds it to the undo event of\n * {@link mxGraphModel} and {@link mxGraphView} using\n * {@link EventSource.addListener}.\n *\n * ### Event: mxEvent.CLEAR\n *\n * Fires after {@link clear} was invoked. This event has no properties.\n *\n * ### Event: mxEvent.UNDO\n *\n * Fires afer a significant edit was undone in {@link undo}. The `edit`\n * property contains the {@link mxUndoableEdit} that was undone.\n *\n * ### Event: mxEvent.REDO\n *\n * Fires afer a significant edit was redone in {@link redo}. The `edit`\n * property contains the {@link mxUndoableEdit} that was redone.\n *\n * ### Event: mxEvent.ADD\n *\n * Fires after an undoable edit was added to the history. The `edit`\n * property contains the {@link mxUndoableEdit} that was added.\n */\nclass UndoManager extends EventSource {\n    constructor(size = 100) {\n        super();\n        /**\n         * Maximum command history size. 0 means unlimited history. Default is\n         * 100.\n         * @default 100\n         */\n        this.size = 100;\n        /**\n         * Array that contains the steps of the command history.\n         */\n        this.history = [];\n        /**\n         * Index of the element to be added next.\n         */\n        this.indexOfNextAdd = 0;\n        this.size = size;\n        this.clear();\n    }\n    /**\n     * Returns true if the history is empty.\n     */\n    isEmpty() {\n        return this.history.length == 0;\n    }\n    /**\n     * Clears the command history.\n     */\n    clear() {\n        this.history = [];\n        this.indexOfNextAdd = 0;\n        this.fireEvent(new EventObject(InternalEvent.CLEAR));\n    }\n    /**\n     * Returns true if an undo is possible.\n     */\n    canUndo() {\n        return this.indexOfNextAdd > 0;\n    }\n    /**\n     * Undoes the last change.\n     */\n    undo() {\n        while (this.indexOfNextAdd > 0) {\n            const edit = this.history[--this.indexOfNextAdd];\n            edit.undo();\n            if (edit.isSignificant()) {\n                this.fireEvent(new EventObject(InternalEvent.UNDO, { edit }));\n                break;\n            }\n        }\n    }\n    /**\n     * Returns true if a redo is possible.\n     */\n    canRedo() {\n        return this.indexOfNextAdd < this.history.length;\n    }\n    /**\n     * Redoes the last change.\n     */\n    redo() {\n        const n = this.history.length;\n        while (this.indexOfNextAdd < n) {\n            const edit = this.history[this.indexOfNextAdd++];\n            edit.redo();\n            if (edit.isSignificant()) {\n                this.fireEvent(new EventObject(InternalEvent.REDO, { edit }));\n                break;\n            }\n        }\n    }\n    /**\n     * Method to be called to add new undoable edits to the <history>.\n     */\n    undoableEditHappened(undoableEdit) {\n        this.trim();\n        if (this.size > 0 && this.size == this.history.length) {\n            this.history.shift();\n        }\n        this.history.push(undoableEdit);\n        this.indexOfNextAdd = this.history.length;\n        this.fireEvent(new EventObject(InternalEvent.ADD, { edit: undoableEdit }));\n    }\n    /**\n     * Removes all pending steps after <indexOfNextAdd> from the history,\n     * invoking die on each edit. This is called from <undoableEditHappened>.\n     */\n    trim() {\n        if (this.history.length > this.indexOfNextAdd) {\n            const edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);\n            for (let i = 0; i < edits.length; i += 1) {\n                edits[i].die();\n            }\n        }\n    }\n}\nexport default UndoManager;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport Rectangle from '../geometry/Rectangle';\nimport Geometry from '../geometry/Geometry';\nimport Point from '../geometry/Point';\n/**\n * Base class for all layout algorithms in maxGraph.\n *\n * Main public methods are {@link moveCell} for handling a moved cell within a layouted parent,\n * and {@link execute} for running the layout on a given parent cell.\n *\n * @category Layout\n */\nclass GraphLayout {\n    constructor(graph) {\n        /**\n         * Boolean indicating if the bounding box of the label should be used if it iss available.\n         * @default true.\n         */\n        this.useBoundingBox = true;\n        /**\n         * The parent cell of the layout, if any\n         * @default null\n         */\n        this.parent = null;\n        this.graph = graph;\n    }\n    /**\n     * Notified when a cell is being moved in a parent that has automatic\n     * layout to update the cell state (eg. index) so that the outcome of the\n     * layout will position the vertex as close to the point (x, y) as\n     * possible.\n     *\n     * Empty implementation.\n     *\n     * @param cell {@link Cell} which has been moved.\n     * @param x X-coordinate of the new cell location.\n     * @param y Y-coordinate of the new cell location.\n     */\n    moveCell(cell, x, y) {\n        return;\n    }\n    /**\n     * Notified when a cell is being resized in a parent that has automatic\n     * layout to update the other cells in the layout.\n     *\n     * Empty implementation.\n     *\n     * @param cell {@link Cell} which has been moved.\n     * @param bounds {@link Rectangle} that represents the new cell bounds.\n     * @param prev\n     */\n    resizeCell(cell, bounds, prev) {\n        return;\n    }\n    /**\n     * Executes the layout algorithm for the children of the given parent.\n     *\n     * @param parent {@link Cell} whose children should be layed out.\n     */\n    execute(parent) {\n        return;\n    }\n    /**\n     * Returns the graph that this layout operates on.\n     */\n    getGraph() {\n        return this.graph;\n    }\n    /**\n     * Returns the constraint for the given key and cell. The optional edge and\n     * source arguments are used to return inbound and outgoing routing-\n     * constraints for the given edge and vertex. This implementation always\n     * returns the value for the given key in the style of the given cell.\n     *\n     * @param key Key of the constraint to be returned.\n     * @param cell {@link Cell} whose constraint should be returned.\n     * @param edge Optional {@link Cell} that represents the connection whose constraint\n     * should be returned. Default is null.\n     * @param source Optional boolean that specifies if the connection is incoming\n     * or outgoing. Default is null.\n     */\n    getConstraint(key, cell, edge, source) {\n        // @ts-expect-error\n        return this.graph.getCurrentCellStyle(cell)[key];\n    }\n    /**\n     * Traverses the (directed) graph invoking the given function for each\n     * visited vertex and edge. The function is invoked with the current vertex\n     * and the incoming edge as a parameter. This implementation makes sure\n     * each vertex is only visited once. The function may return false if the\n     * traversal should stop at the given vertex.\n     *\n     * Example:\n     *\n     * ```javascript\n     * GlobalConfig.logger.show();\n     * const cell = graph.getSelectionCell();\n     * graph.traverse(cell, false, function(vertex, edge)\n     * {\n     *   GlobalConfig.logger.debug(graph.getLabel(vertex));\n     * });\n     * ```\n     *\n     * @param vertex {@link Cell} that represents the vertex where the traversal starts.\n     * @param directed Optional boolean indicating if edges should only be traversed\n     * from source to target. Default is true.\n     * @param func Visitor function that takes the current vertex and the incoming\n     * edge as arguments. The traversal stops if the function returns false.\n     * @param edge Optional {@link Cell} that represents the incoming edge. This is\n     * null for the first step of the traversal.\n     * @param visited Optional {@link Dictionary} of cell paths for the visited cells.\n     */\n    traverse({ vertex, directed, func, edge, visited }) {\n        if (func != null && vertex != null) {\n            directed = directed != null ? directed : true;\n            visited = visited || new Dictionary();\n            if (!visited.get(vertex)) {\n                visited.put(vertex, true);\n                const result = func(vertex, edge);\n                if (result == null || result) {\n                    const edgeCount = vertex.getEdgeCount();\n                    if (edgeCount > 0) {\n                        for (let i = 0; i < edgeCount; i += 1) {\n                            const e = vertex.getEdgeAt(i);\n                            const isSource = e.getTerminal(true) === vertex;\n                            if (!directed || isSource) {\n                                const next = this.graph.view.getVisibleTerminal(e, !isSource);\n                                this.traverse({\n                                    vertex: next,\n                                    directed,\n                                    func,\n                                    edge: e,\n                                    visited,\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given parent is an ancestor of the given child.\n     *\n     * @param parent {@link Cell} that specifies the parent.\n     * @param child {@link Cell} that specifies the child.\n     * @param traverseAncestors boolean whether to\n     */\n    isAncestor(parent, child, traverseAncestors) {\n        if (!traverseAncestors) {\n            return child.getParent() === parent;\n        }\n        if (child === parent) {\n            return false;\n        }\n        while (child != null && child !== parent) {\n            child = child.getParent();\n        }\n        return child === parent;\n    }\n    /**\n     * Returns a boolean indicating if the given {@link Cell} is movable or\n     * bendable by the algorithm. This implementation returns true if the given\n     * cell is movable in the graph.\n     *\n     * @param cell {@link Cell} whose movable state should be returned.\n     */\n    isVertexMovable(cell) {\n        return this.graph.isCellMovable(cell);\n    }\n    /**\n     * Returns a boolean indicating if the given {@link Cell} should be ignored by\n     * the algorithm. This implementation returns false for all vertices.\n     *\n     * @param vertex {@link Cell} whose ignored state should be returned.\n     */\n    isVertexIgnored(vertex) {\n        return !vertex.isVertex() || !vertex.isVisible();\n    }\n    /**\n     * Returns a boolean indicating if the given {@link Cell} should be ignored by\n     * the algorithm. This implementation returns false for all vertices.\n     *\n     * @param edge {@link Cell} whose ignored state should be returned.\n     */\n    isEdgeIgnored(edge) {\n        return (!edge.isEdge() ||\n            !edge.isVisible() ||\n            edge.getTerminal(true) == null ||\n            edge.getTerminal(false) == null);\n    }\n    /**\n     * Disables or enables the edge style of the given edge.\n     */\n    setEdgeStyleEnabled(edge, value) {\n        this.graph.setCellStyles('noEdgeStyle', value ? '0' : '1', [edge]);\n    }\n    /**\n     * Disables or enables orthogonal end segments of the given edge.\n     */\n    setOrthogonalEdge(edge, value) {\n        this.graph.setCellStyles('orthogonal', value ? '1' : '0', [edge]);\n    }\n    /**\n     * Determines the offset of the given parent to the parent\n     * of the layout\n     */\n    getParentOffset(parent) {\n        const result = new Point();\n        if (parent != null && parent !== this.parent) {\n            const model = this.graph.getDataModel();\n            if (this.parent && this.parent.isAncestor(parent)) {\n                let parentGeo = parent.getGeometry();\n                while (parent !== this.parent) {\n                    result.x += parentGeo.x;\n                    result.y += parentGeo.y;\n                    parent = parent.getParent();\n                    parentGeo = parent.getGeometry();\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Replaces the array of Point in the geometry of the given edge\n     * with the given array of Point.\n     */\n    setEdgePoints(edge, points) {\n        if (edge != null) {\n            const { model } = this.graph;\n            let geometry = edge.getGeometry();\n            if (geometry == null) {\n                geometry = new Geometry();\n                geometry.setRelative(true);\n            }\n            else {\n                geometry = geometry.clone();\n            }\n            if (this.parent != null && points != null) {\n                const parent = edge.getParent();\n                const parentOffset = this.getParentOffset(parent);\n                for (let i = 0; i < points.length; i += 1) {\n                    points[i].x = points[i].x - parentOffset.x;\n                    points[i].y = points[i].y - parentOffset.y;\n                }\n            }\n            geometry.points = points;\n            model.setGeometry(edge, geometry);\n        }\n    }\n    /**\n     * Sets the new position of the given cell taking into account the size of\n     * the bounding box if {@link useBoundingBox} is true. The change is only carried\n     * out if the new location is not equal to the existing location, otherwise\n     * the geometry is not replaced with an updated instance. The new or old\n     * bounds are returned (including overlapping labels).\n     *\n     * @param cell {@link Cell} whose geometry is to be set.\n     * @param x Integer that defines the x-coordinate of the new location.\n     * @param y Integer that defines the y-coordinate of the new location.\n     */\n    setVertexLocation(cell, x, y) {\n        const model = this.graph.getDataModel();\n        let geometry = cell.getGeometry();\n        let result = null;\n        if (geometry != null) {\n            result = new Rectangle(x, y, geometry.width, geometry.height);\n            // Checks for oversize labels and shifts the result\n            // TODO: Use mxUtils.getStringSize for label bounds\n            if (this.useBoundingBox) {\n                const state = this.graph.getView().getState(cell);\n                if (state != null && state.text != null && state.text.boundingBox != null) {\n                    const { scale } = this.graph.getView();\n                    const box = state.text.boundingBox;\n                    if (state.text.boundingBox.x < state.x) {\n                        x += (state.x - box.x) / scale;\n                        result.width = box.width;\n                    }\n                    if (state.text.boundingBox.y < state.y) {\n                        y += (state.y - box.y) / scale;\n                        result.height = box.height;\n                    }\n                }\n            }\n            if (this.parent != null) {\n                const parent = cell.getParent();\n                if (parent != null && parent !== this.parent) {\n                    const parentOffset = this.getParentOffset(parent);\n                    x -= parentOffset.x;\n                    y -= parentOffset.y;\n                }\n            }\n            if (geometry.x !== x || geometry.y !== y) {\n                geometry = geometry.clone();\n                geometry.x = x;\n                geometry.y = y;\n                model.setGeometry(cell, geometry);\n            }\n        }\n        return result;\n    }\n    /**\n     * Returns an {@link Rectangle} that defines the bounds of the given cell or\n     * the bounding box if {@link useBoundingBox} is true.\n     */\n    getVertexBounds(cell) {\n        let geo = cell.getGeometry();\n        // Checks for oversize label bounding box and corrects\n        // the return value accordingly\n        // TODO: Use mxUtils.getStringSize for label bounds\n        if (this.useBoundingBox) {\n            const state = this.graph.getView().getState(cell);\n            if (state != null && state.text != null && state.text.boundingBox != null) {\n                const { scale } = this.graph.getView();\n                const tmp = state.text.boundingBox;\n                const dx0 = Math.max(state.x - tmp.x, 0) / scale;\n                const dy0 = Math.max(state.y - tmp.y, 0) / scale;\n                const dx1 = Math.max(tmp.x + tmp.width - (state.x + state.width), 0) / scale;\n                const dy1 = Math.max(tmp.y + tmp.height - (state.y + state.height), 0) / scale;\n                geo = new Rectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);\n            }\n        }\n        if (this.parent != null) {\n            const parent = cell.getParent();\n            geo = geo.clone();\n            if (parent != null && parent !== this.parent) {\n                const parentOffset = this.getParentOffset(parent);\n                geo.x += parentOffset.x;\n                geo.y += parentOffset.y;\n            }\n        }\n        return new Rectangle(geo.x, geo.y, geo.width, geo.height);\n    }\n    /**\n     * Shortcut to {@link Graph#updateGroupBounds} with moveGroup set to true.\n     */\n    arrangeGroups(cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {\n        return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);\n    }\n}\nexport default GraphLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * A utility class used to track cells whilst sorting occurs on the weighted\n * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\n * (x.equals(y))\n *\n * @category Layout\n */\nclass WeightedCellSorter {\n    constructor(cell, weightedValue = 0) {\n        /**\n         * The weighted value of the cell stored.\n         */\n        this.weightedValue = 0;\n        /**\n         * Whether or not to flip equal weight values.\n         */\n        this.nudge = false;\n        /**\n         * Whether or not this cell has been visited in the current assignment.\n         */\n        this.visited = false;\n        /**\n         * The index this cell is in the model rank.\n         */\n        this.rankIndex = null;\n        this.cell = cell;\n        this.weightedValue = weightedValue;\n    }\n    /**\n     * Compares two WeightedCellSorters.\n     */\n    static compare(a, b) {\n        if (a != null && b != null) {\n            if (b.weightedValue > a.weightedValue) {\n                return -1;\n            }\n            if (b.weightedValue < a.weightedValue) {\n                return 1;\n            }\n            if (b.nudge) {\n                return -1;\n            }\n            return 1;\n        }\n        return 0;\n    }\n}\nexport default WeightedCellSorter;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from './Dictionary';\n/*****************************************************************************\n * Group: Tree and traversal-related\n *****************************************************************************/\n/**\n * Returns all children in the given parent which do not have incoming\n * edges. If the result is empty then the with the greatest difference\n * between incoming and outgoing edges is returned.\n *\n * @param parent {@link mxCell} whose children should be checked.\n * @param isolate Optional boolean that specifies if edges should be ignored if\n * the opposite end is not a child of the given parent cell. Default is\n * false.\n * @param invert Optional boolean that specifies if outgoing or incoming edges\n * should be counted for a tree root. If false then outgoing edges will be\n * counted. Default is `false`.\n */\nexport function findTreeRoots(graph, parent, isolate = false, invert = false) {\n    const roots = [];\n    if (parent != null) {\n        let best = null;\n        let maxDiff = 0;\n        for (const cell of parent.getChildren()) {\n            if (cell.isVertex() && cell.isVisible()) {\n                const conns = graph.getConnections(cell, isolate ? parent : null);\n                let fanOut = 0;\n                let fanIn = 0;\n                for (let j = 0; j < conns.length; j++) {\n                    const src = graph.view.getVisibleTerminal(conns[j], true);\n                    if (src == cell) {\n                        fanOut++;\n                    }\n                    else {\n                        fanIn++;\n                    }\n                }\n                if ((invert && fanOut == 0 && fanIn > 0) ||\n                    (!invert && fanIn == 0 && fanOut > 0)) {\n                    roots.push(cell);\n                }\n                const diff = invert ? fanIn - fanOut : fanOut - fanIn;\n                if (diff > maxDiff) {\n                    maxDiff = diff;\n                    best = cell;\n                }\n            }\n        }\n        if (roots.length == 0 && best != null) {\n            roots.push(best);\n        }\n    }\n    return roots;\n}\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n *\n * Example:\n *\n * ```javascript\n * GlobalConfig.logger.show();\n * let cell = graph.getSelectionCell();\n * graph.traverse(cell, false, (vertex, edge)=>\n * {\n *   GlobalConfig.logger.debug(graph.getLabel(vertex));\n * });\n * ```\n *\n * @param vertex <Cell> that represents the vertex where the traversal starts.\n * @param directed Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * @param func Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * @param edge Optional <Cell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * @param visited Optional {@link Dictionary} from cells to true for the visited cells.\n * @param inverse Optional boolean to traverse in inverse direction. Default is false.\n * This is ignored if directed is false.\n */\nexport function traverse(vertex = null, directed = true, func = null, edge = null, visited = null, inverse = false) {\n    if (func != null && vertex != null) {\n        directed = directed != null ? directed : true;\n        inverse = inverse != null ? inverse : false;\n        visited = visited || new Dictionary();\n        if (!visited.get(vertex)) {\n            visited.put(vertex, true);\n            const result = func(vertex, edge);\n            if (result == null || result) {\n                const edgeCount = vertex.getEdgeCount();\n                if (edgeCount > 0) {\n                    for (let i = 0; i < edgeCount; i += 1) {\n                        const e = vertex.getEdgeAt(i);\n                        const isSource = e.getTerminal(true) == vertex;\n                        if (!directed || !inverse == isSource) {\n                            const next = e.getTerminal(!isSource);\n                            traverse(next, directed, func, e, visited, inverse);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../util/Dictionary';\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport CellPath from '../cell/CellPath';\nimport Rectangle from '../geometry/Rectangle';\nimport { sortCells } from '../../util/styleUtils';\nimport WeightedCellSorter from './util/WeightedCellSorter';\nimport { findTreeRoots } from '../../util/treeTraversal';\n/**\n * Extends {@link GraphLayout} to implement a compact tree (Moen) algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * ### Example\n *\n * ```javascript\n * const layout = new CompactTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nexport class CompactTreeLayout extends GraphLayout {\n    constructor(graph, horizontal = true, invert = false) {\n        super(graph);\n        this.parentX = null;\n        this.parentY = null;\n        this.visited = {};\n        /**\n         * Specifies the orientation of the layout.\n         * @default true\n         */\n        this.horizontal = true;\n        /**\n         * Specifies if edge directions should be inverted.\n         * @default false.\n         */\n        this.invert = false;\n        /**\n         * If the parents should be resized to match the width/height of the\n         * children. Default is true.\n         * @default true\n         */\n        this.resizeParent = true;\n        /**\n         * Specifies if the parent location should be maintained, so that the\n         * top, left corner stays the same before and after execution of\n         * the layout. Default is false for backwards compatibility.\n         * @default false\n         */\n        this.maintainParentLocation = false;\n        /**\n         * Padding added to resized parents.\n         * @default 10\n         */\n        this.groupPadding = 10;\n        /**\n         * Top padding added to resized parents.\n         * @default 0\n         */\n        this.groupPaddingTop = 0;\n        /**\n         * Right padding added to resized parents.\n         * @default 0\n         */\n        this.groupPaddingRight = 0;\n        /**\n         * Bottom padding added to resized parents.\n         * @default 0\n         */\n        this.groupPaddingBottom = 0;\n        /**\n         * Left padding added to resized parents.\n         * @default 0\n         */\n        this.groupPaddingLeft = 0;\n        /**\n         * A set of the parents that need updating based on children\n         * process as part of the layout.\n         */\n        this.parentsChanged = null;\n        /**\n         * Specifies if the tree should be moved to the top, left corner\n         * if it is inside a top-level layer.\n         * @default false\n         */\n        this.moveTree = false;\n        /**\n         * Holds the levelDistance.\n         * @default 10\n         */\n        this.levelDistance = 10;\n        /**\n         * Holds the nodeDistance.\n         * @default 20\n         */\n        this.nodeDistance = 20;\n        /**\n         * Specifies if all edge points of traversed edges should be removed.\n         *\n         * @default true\n         */\n        this.resetEdges = true;\n        /**\n         * The preferred horizontal distance between edges exiting a vertex.\n         */\n        this.prefHozEdgeSep = 5;\n        /**\n         * The preferred vertical offset between edges exiting a vertex.\n         */\n        this.prefVertEdgeOff = 4;\n        /**\n         * The minimum distance for an edge jetty from a vertex.\n         */\n        this.minEdgeJetty = 8;\n        /**\n         * The size of the vertical buffer in the center of inter-rank channels\n         * where edge control points should not be placed.\n         */\n        this.channelBuffer = 4;\n        /**\n         * Whether or not to apply the internal tree edge routing.\n         */\n        this.edgeRouting = true;\n        /**\n         * Specifies if edges should be sorted according to the order of their\n         * opposite terminal cell in the model.\n         */\n        this.sortEdges = false;\n        /**\n         * Whether or not the tops of cells in each rank should be aligned\n         * across the rank\n         */\n        this.alignRanks = false;\n        /**\n         * An array of the maximum height of cells (relative to the layout direction)\n         * per rank\n         */\n        this.maxRankHeight = [];\n        /**\n         * The cell to use as the root of the tree\n         */\n        this.root = null;\n        /**\n         * The internal node representation of the root cell. Do not set directly\n         * , this value is only exposed to assist with post-processing functionality\n         */\n        this.node = null;\n        this.horizontal = horizontal;\n        this.invert = invert;\n    }\n    /**\n     * Returns a boolean indicating if the given {@link mxCell} should be ignored as a\n     * vertex. This returns true if the cell has no connections.\n     *\n     * @param vertex {@link mxCell} whose ignored state should be returned.\n     */\n    isVertexIgnored(vertex) {\n        return super.isVertexIgnored(vertex) || vertex.getConnections().length === 0;\n    }\n    /**\n     * Returns {@link horizontal}.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Implements {@link GraphLayout.execute}.\n     *\n     * If the parent has any connected edges, then it is used as the root of\n     * the tree. Else, {@link mxGraph.findTreeRoots} will be used to find a suitable\n     * root node within the set of children of the given parent.\n     *\n     * @param parent  {@link mxCell} whose children should be laid out.\n     * @param root    Optional {@link mxCell} that will be used as the root of the tree. Overrides {@link root} if specified.\n     */\n    execute(parent, root) {\n        this.parent = parent;\n        const model = this.graph.getDataModel();\n        if (root == null) {\n            // Takes the parent as the root if it has outgoing edges\n            if (this.graph.getEdges(parent, parent.getParent(), this.invert, !this.invert, false)\n                .length > 0) {\n                this.root = parent;\n            }\n            // Tries to find a suitable root in the parent's\n            // children\n            else {\n                const roots = findTreeRoots(this.graph, parent, true, this.invert);\n                if (roots.length > 0) {\n                    for (let i = 0; i < roots.length; i += 1) {\n                        if (!this.isVertexIgnored(roots[i]) &&\n                            this.graph.getEdges(roots[i], null, this.invert, !this.invert, false)\n                                .length > 0) {\n                            this.root = roots[i];\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            this.root = root;\n        }\n        if (this.root != null) {\n            if (this.resizeParent) {\n                this.parentsChanged = {};\n            }\n            else {\n                this.parentsChanged = null;\n            }\n            //  Maintaining parent location\n            this.parentX = null;\n            this.parentY = null;\n            if (parent !== this.root &&\n                parent.isVertex() != null &&\n                this.maintainParentLocation) {\n                const geo = parent.getGeometry();\n                if (geo != null) {\n                    this.parentX = geo.x;\n                    this.parentY = geo.y;\n                }\n            }\n            model.beginUpdate();\n            try {\n                this.visited = {};\n                this.node = this.dfs(this.root, parent);\n                if (this.alignRanks) {\n                    this.maxRankHeight = [];\n                    this.findRankHeights(this.node, 0);\n                    this.setCellHeights(this.node, 0);\n                }\n                if (this.node != null) {\n                    this.layout(this.node);\n                    let x0 = this.graph.gridSize;\n                    let y0 = x0;\n                    if (!this.moveTree) {\n                        const g = this.getVertexBounds(this.root);\n                        if (g != null) {\n                            x0 = g.x;\n                            y0 = g.y;\n                        }\n                    }\n                    let bounds = null;\n                    if (this.isHorizontal()) {\n                        bounds = this.horizontalLayout(this.node, x0, y0);\n                    }\n                    else {\n                        bounds = this.verticalLayout(this.node, null, x0, y0);\n                    }\n                    if (bounds != null) {\n                        let dx = 0;\n                        let dy = 0;\n                        if (bounds.x < 0) {\n                            dx = Math.abs(x0 - bounds.x);\n                        }\n                        if (bounds.y < 0) {\n                            dy = Math.abs(y0 - bounds.y);\n                        }\n                        if (dx !== 0 || dy !== 0) {\n                            this.moveNode(this.node, dx, dy);\n                        }\n                        if (this.resizeParent) {\n                            this.adjustParents();\n                        }\n                        if (this.edgeRouting) {\n                            // Iterate through all edges setting their positions\n                            this.localEdgeProcessing(this.node);\n                        }\n                    }\n                    // Maintaining parent location\n                    if (this.parentX != null && this.parentY != null) {\n                        let geo = parent.getGeometry();\n                        if (geo != null) {\n                            geo = geo.clone();\n                            geo.x = this.parentX;\n                            geo.y = this.parentY;\n                            model.setGeometry(parent, geo);\n                        }\n                    }\n                }\n            }\n            finally {\n                model.endUpdate();\n            }\n        }\n    }\n    /**\n     * Moves the specified node and all of its children by the given amount.\n     */\n    moveNode(node, dx, dy) {\n        node.x += dx;\n        node.y += dy;\n        this.apply(node);\n        let { child } = node;\n        while (child != null) {\n            this.moveNode(child, dx, dy);\n            child = child.next;\n        }\n    }\n    /**\n     * Called if {@link sortEdges} is true to sort the array of outgoing edges in place.\n     */\n    sortOutgoingEdges(source, edges) {\n        const lookup = new Dictionary();\n        edges.sort((e1, e2) => {\n            const end1 = e1.getTerminal(e1.getTerminal(false) == source);\n            let p1 = lookup.get(end1);\n            if (p1 == null) {\n                p1 = CellPath.create(end1).split(CellPath.PATH_SEPARATOR);\n                lookup.put(end1, p1);\n            }\n            const end2 = e2.getTerminal(e2.getTerminal(false) === source);\n            let p2 = lookup.get(end2);\n            if (p2 == null) {\n                p2 = CellPath.create(end2).split(CellPath.PATH_SEPARATOR);\n                lookup.put(end2, p2);\n            }\n            return CellPath.compare(p1, p2);\n        });\n    }\n    /**\n     * Stores the maximum height (relative to the layout\n     * direction) of cells in each rank\n     */\n    findRankHeights(node, rank) {\n        const maxRankHeight = this.maxRankHeight;\n        if (maxRankHeight[rank] == null || maxRankHeight[rank] < node.height) {\n            maxRankHeight[rank] = node.height;\n        }\n        let { child } = node;\n        while (child != null) {\n            this.findRankHeights(child, rank + 1);\n            child = child.next;\n        }\n    }\n    /**\n     * Set the cells heights (relative to the layout\n     * direction) when the tops of each rank are to be aligned\n     */\n    setCellHeights(node, rank) {\n        const maxRankHeight = this.maxRankHeight;\n        if (maxRankHeight[rank] != null && maxRankHeight[rank] > node.height) {\n            node.height = maxRankHeight[rank];\n        }\n        let { child } = node;\n        while (child != null) {\n            this.setCellHeights(child, rank + 1);\n            child = child.next;\n        }\n    }\n    /**\n     * Does a depth first search starting at the specified cell.\n     * Makes sure the specified parent is never left by the\n     * algorithm.\n     */\n    dfs(cell, parent) {\n        const id = CellPath.create(cell);\n        let node = null;\n        if (cell != null && this.visited[id] == null && !this.isVertexIgnored(cell)) {\n            this.visited[id] = cell;\n            node = this.createNode(cell);\n            const model = this.graph.getDataModel();\n            let prev = null;\n            const out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);\n            const view = this.graph.getView();\n            if (this.sortEdges) {\n                this.sortOutgoingEdges(cell, out);\n            }\n            for (let i = 0; i < out.length; i += 1) {\n                const edge = out[i];\n                if (!this.isEdgeIgnored(edge)) {\n                    // Resets the points on the traversed edge\n                    if (this.resetEdges) {\n                        this.setEdgePoints(edge, null);\n                    }\n                    if (this.edgeRouting) {\n                        this.setEdgeStyleEnabled(edge, false);\n                        this.setEdgePoints(edge, null);\n                    }\n                    // Checks if terminal in same swimlane\n                    const state = view.getState(edge);\n                    const target = state != null\n                        ? state.getVisibleTerminal(this.invert)\n                        : view.getVisibleTerminal(edge, this.invert);\n                    const tmp = this.dfs(target, parent);\n                    if (tmp != null && target.getGeometry() != null) {\n                        if (prev == null) {\n                            node.child = tmp;\n                        }\n                        else {\n                            prev.next = tmp;\n                        }\n                        prev = tmp;\n                    }\n                }\n            }\n        }\n        return node;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    layout(node) {\n        let { child } = node;\n        while (child != null) {\n            this.layout(child);\n            child = child.next;\n        }\n        if (node.child != null) {\n            this.attachParent(node, this.join(node));\n        }\n        else {\n            this.layoutLeaf(node);\n        }\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    horizontalLayout(node, x0, y0, bounds = null) {\n        node.x += x0 + node.offsetX;\n        node.y += y0 + node.offsetY;\n        bounds = this.apply(node, bounds);\n        const { child } = node;\n        if (child != null) {\n            bounds = this.horizontalLayout(child, node.x, node.y, bounds);\n            let siblingOffset = node.y + child.offsetY;\n            let s = child.next;\n            while (s != null) {\n                bounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);\n                siblingOffset += s.offsetY;\n                s = s.next;\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    verticalLayout(node, parent, x0, y0, bounds = null) {\n        node.x = node.x + x0 + node.offsetY;\n        node.y = node.y + y0 + node.offsetX;\n        bounds = this.apply(node, bounds);\n        const { child } = node;\n        if (child != null) {\n            bounds = this.verticalLayout(child, node, node.x, node.y, bounds);\n            let siblingOffset = node.x + child.offsetY;\n            let s = child.next;\n            while (s != null) {\n                bounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);\n                siblingOffset += s.offsetY;\n                s = s.next;\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    attachParent(node, height) {\n        const x = this.nodeDistance + this.levelDistance;\n        const y2 = (height - node.width) / 2 - this.nodeDistance;\n        const y1 = y2 + node.width + 2 * this.nodeDistance - height;\n        node.child.offsetX = x + node.height;\n        node.child.offsetY = y1;\n        node.contour.upperHead = this.createLine(node.height, 0, this.createLine(x, y1, node.contour.upperHead));\n        node.contour.lowerHead = this.createLine(node.height, 0, this.createLine(x, y2, node.contour.lowerHead));\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    // layoutLeaf(node: any): void;\n    layoutLeaf(node) {\n        const dist = 2 * this.nodeDistance;\n        node.contour.upperTail = this.createLine(node.height + dist, 0);\n        node.contour.upperHead = node.contour.upperTail;\n        node.contour.lowerTail = this.createLine(0, -node.width - dist);\n        node.contour.lowerHead = this.createLine(node.height + dist, 0, node.contour.lowerTail);\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    join(node) {\n        const dist = 2 * this.nodeDistance;\n        let { child } = node;\n        node.contour = child.contour;\n        let h = child.width + dist;\n        let sum = h;\n        child = child.next;\n        while (child != null) {\n            const d = this.merge(node.contour, child.contour);\n            child.offsetY = d + h;\n            child.offsetX = 0;\n            h = child.width + dist;\n            sum += d + h;\n            child = child.next;\n        }\n        return sum;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    merge(p1, p2) {\n        let x = 0;\n        let y = 0;\n        let total = 0;\n        let upper = p1.lowerHead;\n        let lower = p2.upperHead;\n        while (lower != null && upper != null) {\n            const d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);\n            y += d;\n            total += d;\n            if (x + lower.dx <= upper.dx) {\n                x += lower.dx;\n                y += lower.dy;\n                lower = lower.next;\n            }\n            else {\n                x -= upper.dx;\n                y -= upper.dy;\n                upper = upper.next;\n            }\n        }\n        if (lower != null) {\n            const b = this.bridge(p1.upperTail, 0, 0, lower, x, y);\n            p1.upperTail = b.next != null ? p2.upperTail : b;\n            p1.lowerTail = p2.lowerTail;\n        }\n        else {\n            const b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);\n            if (b.next == null) {\n                p1.lowerTail = b;\n            }\n        }\n        p1.lowerHead = p2.lowerHead;\n        return total;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    // offset(p1: number, p2: number, a1: number, a2: number, b1: number, b2: number): number;\n    offset(p1, p2, a1, a2, b1, b2) {\n        let d = 0;\n        if (b1 <= p1 || p1 + a1 <= 0) {\n            return 0;\n        }\n        const t = b1 * a2 - a1 * b2;\n        if (t > 0) {\n            if (p1 < 0) {\n                const s = p1 * a2;\n                d = s / a1 - p2;\n            }\n            else if (p1 > 0) {\n                const s = p1 * b2;\n                d = s / b1 - p2;\n            }\n            else {\n                d = -p2;\n            }\n        }\n        else if (b1 < p1 + a1) {\n            const s = (b1 - p1) * a2;\n            d = b2 - (p2 + s / a1);\n        }\n        else if (b1 > p1 + a1) {\n            const s = (a1 + p1) * b2;\n            d = s / b1 - (p2 + a2);\n        }\n        else {\n            d = b2 - (p2 + a2);\n        }\n        if (d > 0) {\n            return d;\n        }\n        return 0;\n    }\n    bridge(line1, x1, y1, line2, x2, y2) {\n        const dx = x2 + line2.dx - x1;\n        let dy = 0;\n        let s = 0;\n        if (line2.dx === 0) {\n            dy = line2.dy;\n        }\n        else {\n            s = dx * line2.dy;\n            dy = s / line2.dx;\n        }\n        const r = this.createLine(dx, dy, line2.next);\n        line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);\n        return r;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    createNode(cell) {\n        const node = {};\n        node.cell = cell;\n        node.x = 0;\n        node.y = 0;\n        node.width = 0;\n        node.height = 0;\n        const geo = this.getVertexBounds(cell);\n        if (geo != null) {\n            if (this.isHorizontal()) {\n                node.width = geo.height;\n                node.height = geo.width;\n            }\n            else {\n                node.width = geo.width;\n                node.height = geo.height;\n            }\n        }\n        node.offsetX = 0;\n        node.offsetY = 0;\n        node.contour = {};\n        return node;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    apply(node, bounds = null) {\n        const model = this.graph.getDataModel();\n        const cell = node.cell;\n        let g = cell.getGeometry();\n        if (cell != null && g != null) {\n            if (this.isVertexMovable(cell)) {\n                g = this.setVertexLocation(cell, node.x, node.y);\n                if (this.resizeParent) {\n                    const parent = cell.getParent();\n                    const id = CellPath.create(parent);\n                    // Implements set semantic\n                    const parentsChanged = this.parentsChanged;\n                    if (parentsChanged[id] == null) {\n                        parentsChanged[id] = parent;\n                    }\n                }\n            }\n            if (bounds == null) {\n                bounds = new Rectangle(g.x, g.y, g.width, g.height);\n            }\n            else {\n                bounds = new Rectangle(Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));\n            }\n        }\n        return bounds;\n    }\n    /**\n     * Starts the actual compact tree layout algorithm\n     * at the given node.\n     */\n    createLine(dx, dy, next = null) {\n        const line = {\n            dx,\n            dy,\n            next,\n        };\n        return line;\n    }\n    /**\n     * Adjust parent cells whose child geometries have changed. The default\n     * implementation adjusts the group to just fit around the children with\n     * a padding.\n     */\n    adjustParents() {\n        const tmp = [];\n        for (const id in this.parentsChanged) {\n            tmp.push(this.parentsChanged[id]);\n        }\n        this.arrangeGroups(sortCells(tmp, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);\n    }\n    /**\n     * Moves the specified node and all of its children by the given amount.\n     */\n    localEdgeProcessing(node) {\n        this.processNodeOutgoing(node);\n        let { child } = node;\n        while (child != null) {\n            this.localEdgeProcessing(child);\n            child = child.next;\n        }\n    }\n    /**\n     * Separates the x position of edges as they connect to vertices\n     */\n    processNodeOutgoing(node) {\n        let { child } = node;\n        const parentCell = node.cell;\n        let childCount = 0;\n        const sortedCells = [];\n        while (child != null) {\n            childCount++;\n            let sortingCriterion;\n            if (this.horizontal) {\n                sortingCriterion = child.y;\n            }\n            else {\n                sortingCriterion = child.x;\n            }\n            sortedCells.push(new WeightedCellSorter(child, sortingCriterion));\n            child = child.next;\n        }\n        sortedCells.sort(WeightedCellSorter.compare);\n        let availableWidth = node.width;\n        const requiredWidth = (childCount + 1) * this.prefHozEdgeSep;\n        // Add a buffer on the edges of the vertex if the edge count allows\n        if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {\n            availableWidth -= 2 * this.prefHozEdgeSep;\n        }\n        const edgeSpacing = availableWidth / childCount;\n        let currentXOffset = edgeSpacing / 2.0;\n        if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {\n            currentXOffset += this.prefHozEdgeSep;\n        }\n        let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n        let maxYOffset = 0;\n        const parentBounds = this.getVertexBounds(parentCell);\n        child = node.child;\n        for (let j = 0; j < sortedCells.length; j++) {\n            const childCell = sortedCells[j].cell.cell;\n            const childBounds = this.getVertexBounds(childCell);\n            const edges = this.graph.getEdgesBetween(parentCell, childCell, false);\n            const newPoints = [];\n            let x = 0;\n            let y = 0;\n            for (let i = 0; i < edges.length; i += 1) {\n                if (this.horizontal) {\n                    // Use opposite co-ords, calculation was done for\n                    //\n                    x = parentBounds.x + parentBounds.width;\n                    y = parentBounds.y + currentXOffset;\n                    newPoints.push(new Point(x, y));\n                    x = parentBounds.x + parentBounds.width + currentYOffset;\n                    newPoints.push(new Point(x, y));\n                    y = childBounds.y + childBounds.height / 2.0;\n                    newPoints.push(new Point(x, y));\n                    this.setEdgePoints(edges[i], newPoints);\n                }\n                else {\n                    x = parentBounds.x + currentXOffset;\n                    y = parentBounds.y + parentBounds.height;\n                    newPoints.push(new Point(x, y));\n                    y = parentBounds.y + parentBounds.height + currentYOffset;\n                    newPoints.push(new Point(x, y));\n                    x = childBounds.x + childBounds.width / 2.0;\n                    newPoints.push(new Point(x, y));\n                    this.setEdgePoints(edges[i], newPoints);\n                }\n            }\n            if (j < childCount / 2) {\n                currentYOffset += this.prefVertEdgeOff;\n            }\n            else if (j > childCount / 2) {\n                currentYOffset -= this.prefVertEdgeOff;\n            }\n            // Ignore the case if equals, this means the second of 2\n            // jettys with the same y (even number of edges)\n            //                pos[k * 2] = currentX;\n            currentXOffset += edgeSpacing;\n            //                pos[k * 2 + 1] = currentYOffset;\n            maxYOffset = Math.max(maxYOffset, currentYOffset);\n        }\n    }\n}\nexport default CompactTreeLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\nimport { getValue } from '../../util/Utils';\nimport { getNumber } from '../../util/StringUtils';\nimport { DEFAULT_STARTSIZE } from '../../util/Constants';\nimport Geometry from '../geometry/Geometry';\n/**\n * Extends {@link GraphLayout} to create a horizontal or vertical stack of the child vertices.\n * The children do not need to be connected for this layout to work.\n *\n * Example:\n *\n * ```javascript\n * const layout = new StackLayout(graph, true);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass StackLayout extends GraphLayout {\n    constructor(graph, horizontal = null, spacing = null, x0 = null, y0 = null, border = null) {\n        super(graph);\n        /**\n         * Border to be added if fill is true.\n         */\n        this.border = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginTop = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginLeft = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginRight = 0;\n        /**\n         * Top margin for the child area.\n         */\n        this.marginBottom = 0;\n        /**\n         * Boolean indicating if the location of the first cell should be kept, that is, it will not be moved to x0 or y0.\n         */\n        this.keepFirstLocation = false;\n        /**\n         * Boolean indicating if dimension should be changed to fill out the parent cell.\n         */\n        this.fill = false;\n        /**\n         * If the parent should be resized to match the width/height of the stack.\n         */\n        this.resizeParent = false;\n        /**\n         * Use maximum of existing value and new value for resize of parent.\n         */\n        this.resizeParentMax = false;\n        /**\n         * If the last element should be resized to fill out the parent.\n         */\n        this.resizeLast = false;\n        /**\n         * Value at which a new column or row should be created.\n         */\n        this.wrap = null;\n        /**\n         * If the strokeWidth should be ignored.\n         */\n        this.borderCollapse = true;\n        /**\n         * If gaps should be allowed in the stack.\n         */\n        this.allowGaps = false;\n        /**\n         * Grid size for alignment of position and size.\n         */\n        this.gridSize = 0;\n        this.horizontal = horizontal != null ? horizontal : true;\n        this.spacing = spacing != null ? spacing : 0;\n        this.x0 = x0 != null ? x0 : 0;\n        this.y0 = y0 != null ? y0 : 0;\n        this.border = border != null ? border : 0;\n    }\n    /**\n     * Returns horizontal.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Implements mxGraphLayout.moveCell.\n     */\n    moveCell(cell, x, y) {\n        const model = this.graph.getDataModel();\n        const parent = cell.getParent();\n        const horizontal = this.isHorizontal();\n        if (cell != null && parent != null) {\n            let i = 0;\n            let last = 0;\n            const childCount = parent.getChildCount();\n            let value = horizontal ? x : y;\n            const pstate = this.graph.getView().getState(parent);\n            if (pstate != null) {\n                value -= horizontal ? pstate.x : pstate.y;\n            }\n            value /= this.graph.view.scale;\n            for (i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (child !== cell) {\n                    const bounds = child.getGeometry();\n                    if (bounds != null) {\n                        const tmp = horizontal\n                            ? bounds.x + bounds.width / 2\n                            : bounds.y + bounds.height / 2;\n                        if (last <= value && tmp > value) {\n                            break;\n                        }\n                        last = tmp;\n                    }\n                }\n            }\n            // Changes child order in parent\n            let idx = parent.getIndex(cell);\n            idx = Math.max(0, i - (i > idx ? 1 : 0));\n            model.add(parent, cell, idx);\n        }\n    }\n    /**\n     * Returns the size for the parent container or the size of the graph container if the parent is a layer or the root of the model.\n     */\n    getParentSize(parent) {\n        const model = this.graph.getDataModel();\n        let pgeo = parent.getGeometry();\n        // Handles special case where the parent is either a layer with no\n        // geometry or the current root of the view in which case the size\n        // of the graph's container will be used.\n        if (this.graph.container != null &&\n            ((pgeo == null && model.isLayer(parent)) ||\n                parent === this.graph.getView().currentRoot)) {\n            const width = this.graph.container.offsetWidth - 1;\n            const height = this.graph.container.offsetHeight - 1;\n            pgeo = new Geometry(0, 0, width, height);\n        }\n        return pgeo;\n    }\n    /**\n     * Returns the cells to be layouted.\n     */\n    getLayoutCells(parent) {\n        const model = this.graph.getDataModel();\n        const childCount = parent.getChildCount();\n        const cells = [];\n        for (let i = 0; i < childCount; i += 1) {\n            const child = parent.getChildAt(i);\n            if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n                cells.push(child);\n            }\n        }\n        if (this.allowGaps) {\n            cells.sort((c1, c2) => {\n                const geo1 = c1.getGeometry();\n                const geo2 = c2.getGeometry();\n                return this.horizontal\n                    ? geo1.x === geo2.x\n                        ? 0\n                        : geo1.x > geo2.x && geo2.x > 0\n                            ? 1\n                            : -1\n                    : geo1.y === geo2.y\n                        ? 0\n                        : geo1.y > geo2.y && geo2.y > 0\n                            ? 1\n                            : -1;\n            });\n        }\n        return cells;\n    }\n    /**\n     * Snaps the given value to the grid size.\n     */\n    snap(value) {\n        if (this.gridSize != null && this.gridSize > 0) {\n            value = Math.max(value, this.gridSize);\n            if (value / this.gridSize > 1) {\n                const mod = value % this.gridSize;\n                value += mod > this.gridSize / 2 ? this.gridSize - mod : -mod;\n            }\n        }\n        return value;\n    }\n    /**\n     * Implements mxGraphLayout.execute.\n     */\n    execute(parent) {\n        if (parent != null) {\n            const pgeo = this.getParentSize(parent);\n            const horizontal = this.isHorizontal();\n            const model = this.graph.getDataModel();\n            let fillValue = null;\n            if (pgeo != null) {\n                fillValue = horizontal\n                    ? pgeo.height - this.marginTop - this.marginBottom\n                    : pgeo.width - this.marginLeft - this.marginRight;\n                fillValue -= 2 * this.border;\n            }\n            let x0 = this.x0 + this.border + this.marginLeft;\n            let y0 = this.y0 + this.border + this.marginTop;\n            // Handles swimlane start size\n            if (this.graph.isSwimlane(parent)) {\n                // Uses computed style to get latest\n                const style = this.graph.getCellStyle(parent);\n                let start = getNumber(style, 'startSize', DEFAULT_STARTSIZE);\n                const horz = getValue(style, 'horizontal', true) == 1;\n                if (pgeo != null) {\n                    if (horz) {\n                        start = Math.min(start, pgeo.height);\n                    }\n                    else {\n                        start = Math.min(start, pgeo.width);\n                    }\n                }\n                if (horizontal === horz && fillValue != null) {\n                    fillValue -= start;\n                }\n                if (horz) {\n                    y0 += start;\n                }\n                else {\n                    x0 += start;\n                }\n            }\n            model.beginUpdate();\n            try {\n                let tmp = 0;\n                let last = null;\n                let lastValue = 0;\n                let lastChild = null;\n                const cells = this.getLayoutCells(parent);\n                for (let i = 0; i < cells.length; i += 1) {\n                    const child = cells[i];\n                    let geo = child.getGeometry();\n                    if (geo != null) {\n                        geo = geo.clone();\n                        if (this.wrap != null && last != null) {\n                            if ((horizontal &&\n                                last.x + last.width + geo.width + 2 * this.spacing > this.wrap) ||\n                                (!horizontal &&\n                                    last.y + last.height + geo.height + 2 * this.spacing > this.wrap)) {\n                                last = null;\n                                if (horizontal) {\n                                    y0 += tmp + this.spacing;\n                                }\n                                else {\n                                    x0 += tmp + this.spacing;\n                                }\n                                tmp = 0;\n                            }\n                        }\n                        tmp = Math.max(tmp, horizontal ? geo.height : geo.width);\n                        let sw = 0;\n                        if (!this.borderCollapse) {\n                            const childStyle = this.graph.getCellStyle(child);\n                            sw = getNumber(childStyle, 'strokeWidth', 1);\n                        }\n                        if (last != null) {\n                            const temp = lastValue + this.spacing + Math.floor(sw / 2);\n                            if (horizontal) {\n                                geo.x =\n                                    this.snap((this.allowGaps ? Math.max(temp, geo.x) : temp) - this.marginLeft) + this.marginLeft;\n                            }\n                            else {\n                                geo.y =\n                                    this.snap((this.allowGaps ? Math.max(temp, geo.y) : temp) - this.marginTop) + this.marginTop;\n                            }\n                        }\n                        else if (!this.keepFirstLocation) {\n                            if (horizontal) {\n                                geo.x =\n                                    this.allowGaps && geo.x > x0\n                                        ? Math.max(this.snap(geo.x - this.marginLeft) + this.marginLeft, x0)\n                                        : x0;\n                            }\n                            else {\n                                geo.y =\n                                    this.allowGaps && geo.y > y0\n                                        ? Math.max(this.snap(geo.y - this.marginTop) + this.marginTop, y0)\n                                        : y0;\n                            }\n                        }\n                        if (horizontal) {\n                            geo.y = y0;\n                        }\n                        else {\n                            geo.x = x0;\n                        }\n                        if (this.fill && fillValue != null) {\n                            if (horizontal) {\n                                geo.height = fillValue;\n                            }\n                            else {\n                                geo.width = fillValue;\n                            }\n                        }\n                        if (horizontal) {\n                            geo.width = this.snap(geo.width);\n                        }\n                        else {\n                            geo.height = this.snap(geo.height);\n                        }\n                        this.setChildGeometry(child, geo);\n                        lastChild = child;\n                        last = geo;\n                        if (horizontal) {\n                            lastValue = last.x + last.width + Math.floor(sw / 2);\n                        }\n                        else {\n                            lastValue = last.y + last.height + Math.floor(sw / 2);\n                        }\n                    }\n                }\n                if (this.resizeParent && pgeo != null && last != null && !parent.isCollapsed()) {\n                    this.updateParentGeometry(parent, pgeo, last);\n                }\n                else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {\n                    if (horizontal) {\n                        last.width =\n                            pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n                    }\n                    else {\n                        last.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n                    }\n                    this.setChildGeometry(lastChild, last);\n                }\n            }\n            finally {\n                model.endUpdate();\n            }\n        }\n    }\n    /**\n     * Sets the specific geometry to the given child cell.\n     *\n     * @param child The given child of <Cell>.\n     * @param geo The specific geometry of {@link Geometry}.\n     */\n    setChildGeometry(child, geo) {\n        const geo2 = child.getGeometry();\n        if (geo2 == null ||\n            geo.x !== geo2.x ||\n            geo.y !== geo2.y ||\n            geo.width !== geo2.width ||\n            geo.height !== geo2.height) {\n            this.graph.getDataModel().setGeometry(child, geo);\n        }\n    }\n    /**\n     * Updates the geometry of the given parent cell.\n     *\n     * @param parent The given parent of <Cell>.\n     * @param pgeo The new {@link Geometry} for parent.\n     * @param last The last {@link Geometry}.\n     */\n    updateParentGeometry(parent, pgeo, last) {\n        const horizontal = this.isHorizontal();\n        const model = this.graph.getDataModel();\n        const pgeo2 = pgeo.clone();\n        if (horizontal) {\n            const tmp = last.x + last.width + this.marginRight + this.border;\n            if (this.resizeParentMax) {\n                pgeo2.width = Math.max(pgeo2.width, tmp);\n            }\n            else {\n                pgeo2.width = tmp;\n            }\n        }\n        else {\n            const tmp = last.y + last.height + this.marginBottom + this.border;\n            if (this.resizeParentMax) {\n                pgeo2.height = Math.max(pgeo2.height, tmp);\n            }\n            else {\n                pgeo2.height = tmp;\n            }\n        }\n        if (pgeo.x !== pgeo2.x ||\n            pgeo.y !== pgeo2.y ||\n            pgeo.width !== pgeo2.width ||\n            pgeo.height !== pgeo2.height) {\n            model.setGeometry(parent, pgeo2);\n        }\n    }\n}\nexport default StackLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../view/geometry/Rectangle';\nimport EventObject from '../view/event/EventObject';\nimport EventSource from '../view/event/EventSource';\nimport { fit, getCurrentStyle } from '../util/styleUtils';\nimport InternalEvent from '../view/event/InternalEvent';\nimport Client from '../Client';\nimport { NODETYPE } from '../util/Constants';\nimport { br, write } from '../util/domUtils';\nimport Translations from '../util/Translations';\nimport { getClientX, getClientY } from '../util/EventUtils';\nimport { htmlEntities } from '../util/StringUtils';\nimport { utils } from '../util/Utils';\nlet activeWindow = null;\n/**\n * Basic window inside a document.\n *\n * Creating a simple window.\n * @example\n *\n * ```javascript\n * var tb = document.createElement('div');\n * var wnd = new MaxWindow('Title', tb, 100, 100, 200, 200, true, true);\n * wnd.setVisible(true);\n * ```\n *\n * Creating a window that contains an iframe.\n * @example\n *\n * ```javascript\n * var frame = document.createElement('iframe');\n * frame.setAttribute('width', '192px');\n * frame.setAttribute('height', '172px');\n * frame.setAttribute('src', 'http://www.example.com/');\n * frame.style.backgroundColor = 'white';\n *\n * var w = document.body.clientWidth;\n * var h = (document.body.clientHeight || document.documentElement.clientHeight);\n * var wnd = new MaxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);\n * wnd.setVisible(true);\n * ```\n *\n * To limit the movement of a window, eg. to keep it from being moved beyond\n * the top, left corner the following method can be overridden (recommended):\n *\n * ```javascript\n * wnd.setLocation(x, y)\n * {\n *   x = Math.max(0, x);\n *   y = Math.max(0, y);\n *   setLocation.apply(this, arguments);\n * };\n * ```\n *\n * Or the following event handler can be used:\n *\n * ```javascript\n * wnd.addListener(mxEvent.MOVE, function(e)\n * {\n *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));\n * });\n * ```\n *\n * To keep a window inside the current window:\n *\n * ```javascript\n * mxEvent.addListener(window, 'resize', mxUtils.bind(this, function()\n * {\n *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n *\n *   var x = this.window.getX();\n *   var y = this.window.getY();\n *\n *   if (x + this.window.table.clientWidth > iw)\n *   {\n *     x = Math.max(0, iw - this.window.table.clientWidth);\n *   }\n *\n *   if (y + this.window.table.clientHeight > ih)\n *   {\n *     y = Math.max(0, ih - this.window.table.clientHeight);\n *   }\n *\n *   if (this.window.getX() != x || this.window.getY() != y)\n *   {\n *     this.window.setLocation(x, y);\n *   }\n * }));\n * ```\n *\n * ### Event: mxEvent.MOVE_START\n *\n * Fires before the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * ### Event: mxEvent.MOVE\n *\n * Fires while the window is being moved. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * ### Event: mxEvent.MOVE_END\n *\n * Fires after the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * ### Event: mxEvent.RESIZE_START\n *\n * Fires before the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * ### Event: mxEvent.RESIZE\n *\n * Fires while the window is being resized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * ### Event: mxEvent.RESIZE_END\n *\n * Fires after the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * ### Event: mxEvent.MAXIMIZE\n *\n * Fires after the window is maximized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * ### Event: mxEvent.MINIMIZE\n *\n * Fires after the window is minimized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * ### Event: mxEvent.NORMALIZE\n *\n * Fires after the window is normalized, that is, it returned from\n * maximized or minimized state. The <code>event</code> property contains the\n * corresponding mouse event.\n *\n * ### Event: mxEvent.ACTIVATE\n *\n * Fires after a window is activated. The <code>previousWindow</code> property\n * contains the previous window. The event sender is the active window.\n *\n * ### Event: mxEvent.SHOW\n *\n * Fires after the window is shown. This event has no properties.\n *\n * ### Event: mxEvent.HIDE\n *\n * Fires after the window is hidden. This event has no properties.\n *\n * ### Event: mxEvent.CLOSE\n *\n * Fires before the window is closed. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * ### Event: mxEvent.DESTROY\n *\n * Fires before the window is destroyed. This event has no properties.\n *\n * @class MaxWindow\n * @extends EventSource\n */\nclass MaxWindow extends EventSource {\n    constructor(title, content, x, y, width = null, height = null, minimizable = true, movable = true, replaceNode = null, style) {\n        super();\n        /**\n         * URL of the image to be used for the close icon in the titlebar.\n         */\n        this.closeImage = `${Client.imageBasePath}/close.gif`;\n        /**\n         * URL of the image to be used for the minimize icon in the titlebar.\n         */\n        this.minimizeImage = `${Client.imageBasePath}/minimize.gif`;\n        /**\n         * URL of the image to be used for the normalize icon in the titlebar.\n         */\n        this.normalizeImage = `${Client.imageBasePath}/normalize.gif`;\n        /**\n         * URL of the image to be used for the maximize icon in the titlebar.\n         */\n        this.maximizeImage = `${Client.imageBasePath}/maximize.gif`;\n        /**\n         * URL of the image to be used for the resize icon.\n         */\n        this.resizeImage = `${Client.imageBasePath}/resize.gif`;\n        /**\n         * Boolean flag that represents the visible state of the window.\n         */\n        this.visible = false;\n        /**\n         * {@link Rectangle} that specifies the minimum width and height of the window.\n         * Default is (50, 40).\n         */\n        this.minimumSize = new Rectangle(0, 0, 50, 40);\n        /**\n         * Specifies if the window should be destroyed when it is closed. If this\n         * is false then the window is hidden using <setVisible>. Default is true.\n         */\n        this.destroyOnClose = true;\n        if (content != null) {\n            this.content = content;\n            this.init(x, y, width, height, style);\n            this.installMaximizeHandler();\n            this.installMinimizeHandler();\n            this.installCloseHandler();\n            this.setMinimizable(minimizable);\n            this.setTitle(title);\n            if (movable) {\n                this.installMoveHandler();\n            }\n            if (replaceNode != null && replaceNode.parentNode != null) {\n                replaceNode.parentNode.replaceChild(this.div, replaceNode);\n            }\n            else {\n                document.body.appendChild(this.div);\n            }\n        }\n    }\n    /**\n     * Initializes the DOM tree that represents the window.\n     */\n    init(x, y, width = null, height = null, style = 'mxWindow') {\n        this.div = document.createElement('div');\n        this.div.className = style;\n        this.div.style.left = `${x}px`;\n        this.div.style.top = `${y}px`;\n        this.table = document.createElement('table');\n        this.table.className = style;\n        // Disables built-in pan and zoom in IE10 and later\n        if (Client.IS_POINTER) {\n            this.div.style.touchAction = 'none';\n        }\n        // Workaround for table size problems in FF\n        if (width != null) {\n            this.div.style.width = `${width}px`;\n            this.table.style.width = `${width}px`;\n        }\n        if (height != null) {\n            this.div.style.height = `${height}px`;\n            this.table.style.height = `${height}px`;\n        }\n        // Creates title row\n        const tbody = document.createElement('tbody');\n        let tr = document.createElement('tr');\n        this.title = document.createElement('td');\n        this.title.className = `${style}Title`;\n        this.buttons = document.createElement('div');\n        this.buttons.style.position = 'absolute';\n        this.buttons.style.display = 'inline-block';\n        this.buttons.style.right = '4px';\n        this.buttons.style.top = '5px';\n        this.title.appendChild(this.buttons);\n        tr.appendChild(this.title);\n        tbody.appendChild(tr);\n        // Creates content row and table cell\n        tr = document.createElement('tr');\n        this.td = document.createElement('td');\n        this.td.className = `${style}Pane`;\n        this.contentWrapper = document.createElement('div');\n        this.contentWrapper.className = `${style}Pane`;\n        this.contentWrapper.style.width = '100%';\n        this.contentWrapper.appendChild(this.content);\n        // Workaround for div around div restricts height\n        // of inner div if outerdiv has hidden overflow\n        if (this.content.nodeName.toUpperCase() !== 'DIV') {\n            this.contentWrapper.style.height = '100%';\n        }\n        // Puts all content into the DOM\n        this.td.appendChild(this.contentWrapper);\n        tr.appendChild(this.td);\n        tbody.appendChild(tr);\n        this.table.appendChild(tbody);\n        this.div.appendChild(this.table);\n        // Puts the window on top of other windows when clicked\n        const activator = (evt) => {\n            this.activate();\n        };\n        InternalEvent.addGestureListeners(this.title, activator);\n        InternalEvent.addGestureListeners(this.table, activator);\n        this.hide();\n    }\n    /**\n     * Sets the window title to the given string. HTML markup inside the title\n     * will be escaped.\n     */\n    setTitle(title) {\n        // Removes all text content nodes (normally just one)\n        let child = this.title.firstChild;\n        while (child != null) {\n            const next = child.nextSibling;\n            if (child.nodeType === NODETYPE.TEXT) {\n                child.parentNode.removeChild(child);\n            }\n            child = next;\n        }\n        write(this.title, title || '');\n        this.title.appendChild(this.buttons);\n    }\n    /**\n     * Sets if the window contents should be scrollable.\n     */\n    setScrollable(scrollable) {\n        // Workaround for hang in Presto 2.5.22 (Opera 10.5)\n        if (navigator.userAgent == null || navigator.userAgent.indexOf('Presto/2.5') < 0) {\n            if (scrollable) {\n                this.contentWrapper.style.overflow = 'auto';\n            }\n            else {\n                this.contentWrapper.style.overflow = 'hidden';\n            }\n        }\n    }\n    /**\n     * Puts the window on top of all other windows.\n     */\n    activate() {\n        if (activeWindow !== this) {\n            const style = getCurrentStyle(this.getElement());\n            const index = style != null ? parseInt(style.zIndex) : 3;\n            if (activeWindow) {\n                const elt = activeWindow.getElement();\n                if (elt?.style) {\n                    elt.style.zIndex = String(index);\n                }\n            }\n            const previousWindow = activeWindow;\n            this.getElement().style.zIndex = String(index + 1);\n            // eslint-disable-next-line @typescript-eslint/no-this-alias -- we need to maintain the reference to the current window\n            activeWindow = this;\n            this.fireEvent(new EventObject(InternalEvent.ACTIVATE, { previousWindow }));\n        }\n    }\n    /**\n     * Returuns the outermost DOM node that makes up the window.\n     */\n    getElement() {\n        return this.div;\n    }\n    /**\n     * Makes sure the window is inside the client area of the window.\n     */\n    fit() {\n        fit(this.div);\n    }\n    /**\n     * Returns true if the window is resizable.\n     */\n    isResizable() {\n        if (this.resize != null) {\n            return this.resize.style.display !== 'none';\n        }\n        return false;\n    }\n    /**\n     * Sets if the window should be resizable. To avoid interference with some\n     * built-in features of IE10 and later, the use of the following code is\n     * recommended if there are resizable <MaxWindow>s in the page:\n     *\n     * ```javascript\n     * if (Client.IS_POINTER)\n     * {\n     *   document.body.style.msTouchAction = 'none';\n     * }\n     * ```\n     */\n    setResizable(resizable) {\n        if (resizable) {\n            if (this.resize == null) {\n                this.resize = document.createElement('img');\n                this.resize.style.position = 'absolute';\n                this.resize.style.bottom = '2px';\n                this.resize.style.right = '2px';\n                this.resize.setAttribute('src', this.resizeImage);\n                this.resize.style.cursor = 'nw-resize';\n                let startX = null;\n                let startY = null;\n                let width = null;\n                let height = null;\n                const start = (evt) => {\n                    // LATER: pointerdown starting on border of resize does start\n                    // the drag operation but does not fire consecutive events via\n                    // one of the listeners below (does pan instead).\n                    // Workaround: document.body.style.msTouchAction = 'none'\n                    this.activate();\n                    startX = getClientX(evt);\n                    startY = getClientY(evt);\n                    width = this.div.offsetWidth;\n                    height = this.div.offsetHeight;\n                    InternalEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n                    this.fireEvent(new EventObject(InternalEvent.RESIZE_START, { event: evt }));\n                    InternalEvent.consume(evt);\n                };\n                // Adds a temporary pair of listeners to intercept\n                // the gesture event in the document\n                const dragHandler = (evt) => {\n                    if (startX != null && startY != null) {\n                        const dx = getClientX(evt) - startX;\n                        const dy = getClientY(evt) - startY;\n                        if (width != null && height != null) {\n                            this.setSize(width + dx, height + dy);\n                        }\n                        this.fireEvent(new EventObject(InternalEvent.RESIZE, { event: evt }));\n                        InternalEvent.consume(evt);\n                    }\n                };\n                const dropHandler = (evt) => {\n                    if (startX != null && startY != null) {\n                        startX = null;\n                        startY = null;\n                        InternalEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n                        this.fireEvent(new EventObject(InternalEvent.RESIZE_END, { event: evt }));\n                        InternalEvent.consume(evt);\n                    }\n                };\n                InternalEvent.addGestureListeners(this.resize, start, dragHandler, dropHandler);\n                this.div.appendChild(this.resize);\n            }\n            else {\n                this.resize.style.display = 'inline';\n            }\n        }\n        else if (this.resize != null) {\n            this.resize.style.display = 'none';\n        }\n    }\n    /**\n     * Sets the size of the window.\n     */\n    setSize(width, height) {\n        width = Math.max(this.minimumSize.width, width);\n        height = Math.max(this.minimumSize.height, height);\n        // Workaround for table size problems in FF\n        this.div.style.width = `${width}px`;\n        this.div.style.height = `${height}px`;\n        this.table.style.width = `${width}px`;\n        this.table.style.height = `${height}px`;\n        this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;\n    }\n    /**\n     * Sets if the window is minimizable.\n     */\n    setMinimizable(minimizable) {\n        this.minimize.style.display = minimizable ? '' : 'none';\n    }\n    /**\n     * Returns an {@link Rectangle} that specifies the size for the minimized window.\n     * A width or height of 0 means keep the existing width or height. This\n     * implementation returns the height of the window title and keeps the width.\n     */\n    getMinimumSize() {\n        return new Rectangle(0, 0, 0, this.title.offsetHeight);\n    }\n    /**\n     * Installs the event listeners required for minimizing the window.\n     */\n    installMinimizeHandler() {\n        this.minimize = document.createElement('img');\n        this.minimize.setAttribute('src', this.minimizeImage);\n        this.minimize.setAttribute('title', 'Minimize');\n        this.minimize.style.cursor = 'pointer';\n        this.minimize.style.marginLeft = '2px';\n        this.minimize.style.display = 'none';\n        this.buttons.appendChild(this.minimize);\n        let minimized = false;\n        let maxDisplay = null;\n        let height = null;\n        const funct = (evt) => {\n            this.activate();\n            if (!minimized) {\n                minimized = true;\n                this.minimize.setAttribute('src', this.normalizeImage);\n                this.minimize.setAttribute('title', 'Normalize');\n                this.contentWrapper.style.display = 'none';\n                maxDisplay = this.maximize.style.display;\n                this.maximize.style.display = 'none';\n                height = this.table.style.height;\n                const minSize = this.getMinimumSize();\n                if (minSize.height > 0) {\n                    this.div.style.height = `${minSize.height}px`;\n                    this.table.style.height = `${minSize.height}px`;\n                }\n                if (minSize.width > 0) {\n                    this.div.style.width = `${minSize.width}px`;\n                    this.table.style.width = `${minSize.width}px`;\n                }\n                if (this.resize != null) {\n                    this.resize.style.visibility = 'hidden';\n                }\n                this.fireEvent(new EventObject(InternalEvent.MINIMIZE, { event: evt }));\n            }\n            else {\n                minimized = false;\n                this.minimize.setAttribute('src', this.minimizeImage);\n                this.minimize.setAttribute('title', 'Minimize');\n                this.contentWrapper.style.display = ''; // default\n                if (maxDisplay != null && height != null) {\n                    this.maximize.style.display = maxDisplay;\n                    this.div.style.height = height;\n                    this.table.style.height = height;\n                }\n                if (this.resize != null) {\n                    this.resize.style.visibility = '';\n                }\n                this.fireEvent(new EventObject(InternalEvent.NORMALIZE, { event: evt }));\n            }\n            InternalEvent.consume(evt);\n        };\n        InternalEvent.addGestureListeners(this.minimize, funct);\n    }\n    /**\n     * Sets if the window is maximizable.\n     */\n    setMaximizable(maximizable) {\n        this.maximize.style.display = maximizable ? '' : 'none';\n    }\n    /**\n     * Installs the event listeners required for maximizing the window.\n     */\n    installMaximizeHandler() {\n        this.maximize = document.createElement('img');\n        this.maximize.setAttribute('src', this.maximizeImage);\n        this.maximize.setAttribute('title', 'Maximize');\n        this.maximize.style.cursor = 'default';\n        this.maximize.style.marginLeft = '2px';\n        this.maximize.style.cursor = 'pointer';\n        this.maximize.style.display = 'none';\n        this.buttons.appendChild(this.maximize);\n        let maximized = false;\n        let x = null;\n        let y = null;\n        let height = null;\n        let width = null;\n        let minDisplay = null;\n        const funct = (evt) => {\n            this.activate();\n            if (this.maximize.style.display !== 'none') {\n                if (!maximized) {\n                    maximized = true;\n                    this.maximize.setAttribute('src', this.normalizeImage);\n                    this.maximize.setAttribute('title', 'Normalize');\n                    this.contentWrapper.style.display = '';\n                    minDisplay = this.minimize.style.display;\n                    this.minimize.style.display = 'none';\n                    // Saves window state\n                    x = parseInt(this.div.style.left);\n                    y = parseInt(this.div.style.top);\n                    height = this.table.style.height;\n                    width = this.table.style.width;\n                    this.div.style.left = '0px';\n                    this.div.style.top = '0px';\n                    const docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);\n                    this.div.style.width = `${document.body.clientWidth - 2}px`;\n                    this.div.style.height = `${docHeight - 2}px`;\n                    this.table.style.width = `${document.body.clientWidth - 2}px`;\n                    this.table.style.height = `${docHeight - 2}px`;\n                    if (this.resize != null) {\n                        this.resize.style.visibility = 'hidden';\n                    }\n                    const style = getCurrentStyle(this.contentWrapper);\n                    if (style.overflow === 'auto' || this.resize != null) {\n                        this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.MAXIMIZE, { event: evt }));\n                }\n                else {\n                    maximized = false;\n                    this.maximize.setAttribute('src', this.maximizeImage);\n                    this.maximize.setAttribute('title', 'Maximize');\n                    this.contentWrapper.style.display = '';\n                    if (minDisplay != null) {\n                        this.minimize.style.display = minDisplay;\n                    }\n                    // Restores window state\n                    this.div.style.left = `${x}px`;\n                    this.div.style.top = `${y}px`;\n                    if (width != null && height != null) {\n                        this.div.style.height = height;\n                        this.div.style.width = width;\n                    }\n                    const style = getCurrentStyle(this.contentWrapper);\n                    if (style.overflow === 'auto' || this.resize != null) {\n                        this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;\n                    }\n                    if (width != null && height != null) {\n                        this.table.style.height = height;\n                        this.table.style.width = width;\n                    }\n                    if (this.resize != null) {\n                        this.resize.style.visibility = '';\n                    }\n                    this.fireEvent(new EventObject(InternalEvent.NORMALIZE, { event: evt }));\n                }\n                InternalEvent.consume(evt);\n            }\n        };\n        InternalEvent.addGestureListeners(this.maximize, funct);\n        InternalEvent.addListener(this.title, 'dblclick', funct);\n    }\n    /**\n     * Installs the event listeners required for moving the window.\n     */\n    installMoveHandler() {\n        this.title.style.cursor = 'move';\n        InternalEvent.addGestureListeners(this.title, (evt) => {\n            const startX = getClientX(evt);\n            const startY = getClientY(evt);\n            const x = this.getX();\n            const y = this.getY();\n            // Adds a temporary pair of listeners to intercept\n            // the gesture event in the document\n            const dragHandler = (evt) => {\n                const dx = getClientX(evt) - startX;\n                const dy = getClientY(evt) - startY;\n                this.setLocation(x + dx, y + dy);\n                this.fireEvent(new EventObject(InternalEvent.MOVE, { event: evt }));\n                InternalEvent.consume(evt);\n            };\n            const dropHandler = (evt) => {\n                InternalEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n                this.fireEvent(new EventObject(InternalEvent.MOVE_END, { event: evt }));\n                InternalEvent.consume(evt);\n            };\n            InternalEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n            this.fireEvent(new EventObject(InternalEvent.MOVE_START, { event: evt }));\n            InternalEvent.consume(evt);\n        });\n        // Disables built-in pan and zoom in IE10 and later\n        if (Client.IS_POINTER) {\n            this.title.style.touchAction = 'none';\n        }\n    }\n    /**\n     * Sets the upper, left corner of the window.\n     */\n    setLocation(x, y) {\n        this.div.style.left = `${x}px`;\n        this.div.style.top = `${y}px`;\n    }\n    /**\n     * Returns the current position on the x-axis.\n     */\n    getX() {\n        return parseInt(this.div.style.left);\n    }\n    /**\n     * Returns the current position on the y-axis.\n     */\n    getY() {\n        return parseInt(this.div.style.top);\n    }\n    /**\n     * Adds the <closeImage> as a new image node in <closeImg> and installs the\n     * <close> event.\n     */\n    installCloseHandler() {\n        this.closeImg = document.createElement('img');\n        this.closeImg.setAttribute('src', this.closeImage);\n        this.closeImg.setAttribute('title', 'Close');\n        this.closeImg.style.marginLeft = '2px';\n        this.closeImg.style.cursor = 'pointer';\n        this.closeImg.style.display = 'none';\n        this.buttons.appendChild(this.closeImg);\n        InternalEvent.addGestureListeners(this.closeImg, (evt) => {\n            this.fireEvent(new EventObject(InternalEvent.CLOSE, { event: evt }));\n            if (this.destroyOnClose) {\n                this.destroy();\n            }\n            else {\n                this.setVisible(false);\n            }\n            InternalEvent.consume(evt);\n        });\n    }\n    /**\n     * Sets the image associated with the window.\n     *\n     *\n     * @param image - URL of the image to be used.\n     */\n    setImage(image) {\n        this.image = document.createElement('img');\n        this.image.setAttribute('src', image);\n        this.image.setAttribute('align', 'left');\n        this.image.style.marginRight = '4px';\n        this.image.style.marginLeft = '0px';\n        this.image.style.marginTop = '-2px';\n        this.title.insertBefore(this.image, this.title.firstChild);\n    }\n    /**\n     * Sets the image associated with the window.\n     *\n     *\n     * @param closable - Boolean specifying if the window should be closable.\n     */\n    setClosable(closable) {\n        this.closeImg.style.display = closable ? '' : 'none';\n    }\n    /**\n     * Returns true if the window is visible.\n     */\n    isVisible() {\n        if (this.div != null) {\n            return this.div.style.display !== 'none';\n        }\n        return false;\n    }\n    /**\n     * Shows or hides the window depending on the given flag.\n     *\n     *\n     * @param visible - Boolean indicating if the window should be made visible.\n     */\n    setVisible(visible) {\n        if (this.div != null && this.isVisible() !== visible) {\n            if (visible) {\n                this.show();\n            }\n            else {\n                this.hide();\n            }\n        }\n    }\n    /**\n     * Shows the window.\n     */\n    show() {\n        this.div.style.display = '';\n        this.activate();\n        const style = getCurrentStyle(this.contentWrapper);\n        if ((style.overflow == 'auto' || this.resize != null) &&\n            this.contentWrapper.style.display != 'none') {\n            this.contentWrapper.style.height = `${this.div.offsetHeight - this.title.offsetHeight}px`;\n        }\n        this.fireEvent(new EventObject(InternalEvent.SHOW));\n    }\n    /**\n     * Hides the window.\n     */\n    hide() {\n        this.div.style.display = 'none';\n        this.fireEvent(new EventObject(InternalEvent.HIDE));\n    }\n    /**\n     * Destroys the window and removes all associated resources. Fires a\n     * <destroy> event prior to destroying the window.\n     */\n    destroy() {\n        this.fireEvent(new EventObject(InternalEvent.DESTROY));\n        if (this.div != null) {\n            InternalEvent.release(this.div);\n            // @ts-ignore\n            this.div.parentNode.removeChild(this.div);\n            // @ts-ignore\n            this.div = null;\n        }\n        // @ts-ignore\n        this.title = null;\n        // @ts-ignore\n        this.content = null;\n        // @ts-ignore\n        this.contentWrapper = null;\n    }\n}\n/**\n * Shows the specified text content in a new <MaxWindow> or a new browser\n * window if isInternalWindow is false.\n *\n * @param content String that specifies the text to be displayed.\n * @param isInternalWindow Optional boolean indicating if an MaxWindow should be\n * used instead of a new browser window. Default is false.\n */\nexport const popup = (content, isInternalWindow = false) => {\n    if (isInternalWindow) {\n        const div = document.createElement('div');\n        div.style.overflow = 'scroll';\n        div.style.width = '636px';\n        div.style.height = '460px';\n        const pre = document.createElement('pre');\n        pre.innerHTML = htmlEntities(content, false)\n            .replace(/\\n/g, '<br>')\n            .replace(/ /g, '&nbsp;');\n        div.appendChild(pre);\n        const w = document.body.clientWidth;\n        const h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);\n        const wnd = new MaxWindow('Popup Window', div, w / 2 - 320, h / 2 - 240, 640, 480, false, true);\n        wnd.setClosable(true);\n        wnd.setVisible(true);\n    }\n    else {\n        // Wraps up the XML content in a textarea\n        if (Client.IS_NS) {\n            const wnd = window.open();\n            if (!wnd) {\n                throw new Error('Permission not granted to open popup window');\n            }\n            wnd.document.writeln(`<pre>${htmlEntities(content)}</pre`);\n            wnd.document.close();\n        }\n        else {\n            const wnd = window.open();\n            if (!wnd) {\n                throw new Error('Permission not granted to open popup window');\n            }\n            const pre = wnd.document.createElement('pre');\n            pre.innerHTML = htmlEntities(content, false)\n                .replace(/\\n/g, '<br>')\n                .replace(/ /g, '&nbsp;');\n            wnd.document.body.appendChild(pre);\n        }\n    }\n};\n/**\n * Displays the given error message in a new <MaxWindow> of the given width.\n * If close is true then an additional close button is added to the window.\n * The optional icon specifies the icon to be used for the window. Default\n * is {@link Utils#errorImage}.\n *\n * @param message String specifying the message to be displayed.\n * @param width Integer specifying the width of the window.\n * @param close Optional boolean indicating whether to add a close button.\n * @param icon Optional icon for the window decoration.\n */\nexport const error = (message, width, close, icon = null) => {\n    const div = document.createElement('div');\n    div.style.padding = '20px';\n    const img = document.createElement('img');\n    img.setAttribute('src', icon || utils.errorImage);\n    img.setAttribute('valign', 'bottom');\n    img.style.verticalAlign = 'middle';\n    div.appendChild(img);\n    div.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n    div.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n    div.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n    write(div, message);\n    const w = document.body.clientWidth;\n    const h = document.body.clientHeight || document.documentElement.clientHeight;\n    const warn = new MaxWindow(Translations.get(utils.errorResource) || utils.errorResource, div, (w - width) / 2, h / 4, width, null, false, true);\n    if (close) {\n        br(div);\n        const tmp = document.createElement('p');\n        const button = document.createElement('button');\n        button.setAttribute('style', 'float:right');\n        InternalEvent.addListener(button, 'click', (evt) => {\n            warn.destroy();\n        });\n        write(button, Translations.get(utils.closeResource) || utils.closeResource);\n        tmp.appendChild(button);\n        div.appendChild(tmp);\n        br(div);\n        warn.setClosable(true);\n    }\n    warn.setVisible(true);\n    return warn;\n};\nexport default MaxWindow;\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec';\nimport Editor from '../../../editor/Editor';\nimport MaxWindow from '../../../gui/MaxWindow';\nimport Translations from '../../../util/Translations';\nimport { addLinkToHead, getChildNodes } from '../../../util/domUtils';\n/**\n * Codec for {@link Editor}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - modified\n * - lastSnapshot\n * - ignoredChanges\n * - undoManager\n * - graphContainer\n * - toolbarContainer\n *\n * @category Serialization with Codecs\n */\nexport class EditorCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new Editor(__dummy), [\n            'modified',\n            'lastSnapshot',\n            'ignoredChanges',\n            'undoManager',\n            'graphContainer',\n            'toolbarContainer',\n        ]);\n    }\n    /**\n     * Decodes the ui-part of the configuration node by reading\n     * a sequence of the following child nodes and attributes\n     * and passes the control to the default decoding mechanism:\n     *\n     * Child Nodes:\n     *\n     * stylesheet - Adds a CSS stylesheet to the document.\n     * resource - Adds the basename of a resource bundle.\n     * add - Creates or configures a known UI element.\n     *\n     * These elements may appear in any order given that the\n     * graph UI element is added before the toolbar element\n     * (see Known Keys).\n     *\n     * Attributes:\n     *\n     * as - Key for the UI element (see below).\n     * element - ID for the element in the document.\n     * style - CSS style to be used for the element or window.\n     * x - X coordinate for the new window.\n     * y - Y coordinate for the new window.\n     * width - Width for the new window.\n     * height - Optional height for the new window.\n     * name - Name of the stylesheet (absolute/relative URL).\n     * basename - Basename of the resource bundle (see {@link Resources}).\n     *\n     * The x, y, width and height attributes are used to create a new\n     * <MaxWindow> if the element attribute is not specified in an add\n     * node. The name and basename are only used in the stylesheet and\n     * resource nodes, respectively.\n     *\n     * Known Keys:\n     *\n     * graph - Main graph element (see <Editor.setGraphContainer>).\n     * title - Title element (see <Editor.setTitleContainer>).\n     * toolbar - Toolbar element (see <Editor.setToolbarContainer>).\n     * status - Status bar element (see <Editor.setStatusContainer>).\n     *\n     * Example:\n     *\n     * ```javascript\n     * <ui>\n     *   <stylesheet name=\"css/process.css\"/>\n     *   <resource basename=\"resources/app\"/>\n     *   <add as=\"graph\" element=\"graph\"\n     *     style=\"left:70px;right:20px;top:20px;bottom:40px\"/>\n     *   <add as=\"status\" element=\"status\"/>\n     *   <add as=\"toolbar\" x=\"10\" y=\"20\" width=\"54\"/>\n     * </ui>\n     * ```\n     */\n    afterDecode(dec, node, obj) {\n        // Assigns the specified templates for edges\n        const defaultEdge = node.getAttribute('defaultEdge');\n        if (defaultEdge != null) {\n            node.removeAttribute('defaultEdge');\n            obj.defaultEdge = obj.templates[defaultEdge];\n        }\n        // Assigns the specified templates for groups\n        const defaultGroup = node.getAttribute('defaultGroup');\n        if (defaultGroup != null) {\n            node.removeAttribute('defaultGroup');\n            obj.defaultGroup = obj.templates[defaultGroup];\n        }\n        return obj;\n    }\n    /**\n     * Overrides decode child to handle special child nodes.\n     */\n    decodeChild(dec, child, obj) {\n        if (child.nodeName === 'Array') {\n            const role = child.getAttribute('as');\n            if (role === 'templates') {\n                this.decodeTemplates(dec, child, obj);\n                return;\n            }\n        }\n        else if (child.nodeName === 'ui') {\n            this.decodeUi(dec, child, obj);\n            return;\n        }\n        super.decodeChild.apply(this, [dec, child, obj]);\n    }\n    /**\n     * Decodes the ui elements from the given node.\n     */\n    decodeUi(dec, node, editor) {\n        let tmp = node.firstChild;\n        while (tmp != null) {\n            if (tmp.nodeName === 'add') {\n                const as = tmp.getAttribute('as');\n                const elt = tmp.getAttribute('element');\n                const style = tmp.getAttribute('style');\n                let element = null;\n                if (elt != null) {\n                    element = document.getElementById(elt);\n                    if (element != null && style != null) {\n                        element.style.cssText += `;${style}`;\n                    }\n                }\n                else {\n                    const x = parseInt(tmp.getAttribute('x'));\n                    const y = parseInt(tmp.getAttribute('y'));\n                    const width = tmp.getAttribute('width') || null;\n                    const height = tmp.getAttribute('height') || null;\n                    // Creates a new window around the element\n                    element = document.createElement('div');\n                    if (style != null) {\n                        element.style.cssText = style;\n                    }\n                    const wnd = new MaxWindow(Translations.get(as) || as, element, x, y, width ? parseInt(width) : null, height ? parseInt(height) : null, false, true);\n                    wnd.setVisible(true);\n                }\n                // TODO: Make more generic\n                if (as === 'graph') {\n                    editor.setGraphContainer(element);\n                }\n                else if (as === 'toolbar') {\n                    editor.setToolbarContainer(element);\n                }\n                else if (as === 'title') {\n                    editor.setTitleContainer(element);\n                }\n                else if (as === 'status') {\n                    editor.setStatusContainer(element);\n                }\n                else if (as === 'map') {\n                    throw new Error('Unimplemented');\n                    //editor.setMapContainer(element);\n                }\n            }\n            else if (tmp.nodeName === 'resource') {\n                Translations.add(tmp.getAttribute('basename'));\n            }\n            else if (tmp.nodeName === 'stylesheet') {\n                addLinkToHead('stylesheet', tmp.getAttribute('name'));\n            }\n            tmp = tmp.nextSibling;\n        }\n    }\n    /**\n     * Decodes the cells from the given node as templates.\n     */\n    decodeTemplates(dec, node, editor) {\n        if (editor.templates == null) {\n            editor.templates = [];\n        }\n        const children = getChildNodes(node);\n        for (let j = 0; j < children.length; j++) {\n            const name = children[j].getAttribute('as');\n            let child = children[j].firstChild;\n            while (child != null && child.nodeType !== 1) {\n                child = child.nextSibling;\n            }\n            if (child != null) {\n                // LATER: Only single cells means you need\n                // to group multiple cells within another\n                // cell. This should be changed to support\n                // arrays of cells, or the wrapper must\n                // be automatically handled in this class.\n                editor.templates[name] = dec.decodeCell(child);\n            }\n        }\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec';\nimport EditorKeyHandler from '../../../editor/EditorKeyHandler';\n/**\n * Custom codec for configuring {@link EditorKeyHandler}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only reads configuration data for existing key handlers, it does not encode or create key handlers.\n *\n * @category Serialization with Codecs\n */\nexport class EditorKeyHandlerCodec extends ObjectCodec {\n    constructor() {\n        super(new EditorKeyHandler());\n    }\n    /**\n     * Returns `null`.\n     */\n    encode(enc, obj) {\n        return null;\n    }\n    /**\n     * Reads a sequence of the following child nodes and attributes:\n     *\n     * Child Nodes:\n     *\n     * add - Binds a keystroke to an action name.\n     *\n     * Attributes:\n     *\n     * as - Keycode.\n     * action - Action name to execute in editor.\n     * control - Optional boolean indicating if\n     *     the control key must be pressed.\n     *\n     * Example:\n     *\n     * ```javascript\n     * <EditorKeyHandler as=\"keyHandler\">\n     *   <add as=\"88\" control=\"true\" action=\"cut\"/>\n     *   <add as=\"67\" control=\"true\" action=\"copy\"/>\n     *   <add as=\"86\" control=\"true\" action=\"paste\"/>\n     * </EditorKeyHandler>\n     * ```\n     *\n     * The keycodes are for the x, c and v keys.\n     *\n     * See also: <EditorKeyHandler.bindAction>, http://www.js-examples.com/page/tutorials__key_codes.html\n     */\n    decode(dec, _node, into) {\n        if (into != null) {\n            const { editor } = into;\n            let node = _node.firstChild;\n            while (node != null) {\n                if (!this.processInclude(dec, node, into) && node.nodeName === 'add') {\n                    const as = node.getAttribute('as');\n                    const action = node.getAttribute('action');\n                    const control = node.getAttribute('control');\n                    into.bindAction(as, action, control);\n                }\n                node = node.nextSibling;\n            }\n        }\n        return into;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec';\nimport EditorPopupMenu from '../../../editor/EditorPopupMenu';\n/**\n * Custom codec for configuring {@link EditorPopupMenu}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only reads configuration data for existing popup menus, it does not encode or create menus.\n * Note that this codec only passes the configuration node to the popup menu, which uses the config to dynamically create menus.\n *\n * @see {@link EditorPopupMenu.createMenu}.\n * @category Serialization with Codecs\n */\nexport class EditorPopupMenuCodec extends ObjectCodec {\n    constructor() {\n        super(new EditorPopupMenu());\n    }\n    /**\n     * Returns null.\n     */\n    encode(_enc, _obj) {\n        return null;\n    }\n    /**\n     * Uses the given node as the config for <EditorPopupMenu>.\n     */\n    decode(dec, node, into) {\n        const inc = node.getElementsByTagName('include')[0];\n        if (inc != null) {\n            this.processInclude(dec, inc, into);\n        }\n        else if (into != null) {\n            into.config = node;\n        }\n        return into;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec';\nimport { EditorToolbar } from '../../../editor/EditorToolbar';\nimport { NODETYPE } from '../../../util/Constants';\nimport { GlobalConfig } from '../../../util/config';\nimport { convertPoint } from '../../../util/styleUtils';\nimport { getClientX, getClientY } from '../../../util/EventUtils';\nimport InternalEvent from '../../../view/event/InternalEvent';\nimport { getChildNodes, getTextContent } from '../../../util/domUtils';\nimport Translations from '../../../util/Translations';\n/**\n * Custom codec for configuring {@link EditorToolbar}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only reads configuration data for existing toolbars handlers, it does not encode or create toolbars.\n *\n * @category Serialization with Codecs\n */\nexport class EditorToolbarCodec extends ObjectCodec {\n    constructor() {\n        super(new EditorToolbar());\n    }\n    /**\n     * Returns `null`.\n     */\n    encode(_enc, _obj) {\n        return null;\n    }\n    /**\n     * Reads a sequence of the following child nodes and attributes:\n     *\n     * Child Nodes:\n     *\n     * add - Adds a new item to the toolbar. See below for attributes.\n     * separator - Adds a vertical separator. No attributes.\n     * hr - Adds a horizontal separator. No attributes.\n     * br - Adds a linefeed. No attributes.\n     *\n     * Attributes:\n     *\n     * as - Resource key for the label.\n     * action - Name of the action to execute in enclosing editor.\n     * mode - Mode name (see below).\n     * template - Template name for cell insertion.\n     * style - Optional style to override the template style.\n     * icon - Icon (relative/absolute URL).\n     * pressedIcon - Optional icon for pressed state (relative/absolute URL).\n     * id - Optional ID to be used for the created DOM element.\n     * toggle - Optional 0 or 1 to disable toggling of the element. Default is 1 (true).\n     *\n     * The action, mode and template attributes are mutually exclusive. The style can only be used with the template attribute.\n     * The add node may contain another sequence of add nodes with \"as\" and action attributes to create a combo box in the toolbar.\n     * If the icon is specified then a list of the child node is expected to have its template attribute set and the action is ignored instead.\n     *\n     * Nodes with a specified template may define a function to be used for inserting the cloned template into the graph.\n     * Here is an example of such a node:\n     *\n     * ```javascript\n     * <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"><![CDATA[\n     *   function (editor, cell, evt, targetCell)\n     *   {\n     *     let pt = mxUtils.convertPoint(\n     *       editor.graph.container, mxEvent.getClientX(evt),\n     *         mxEvent.getClientY(evt));\n     *     return editor.addVertex(targetCell, cell, pt.x, pt.y);\n     *   }\n     * ]]></add>\n     * ```\n     *\n     * In the above function, editor is the enclosing {@link Editor} instance, cell is the clone of the template, evt is the mouse event that represents the\n     * drop and targetCell is the cell under the mouse pointer where the drop occurred. The targetCell is retrieved using {@link Graph#getCellAt}.\n     *\n     * Furthermore, nodes with the mode attribute may define a function to be executed upon selection of the respective toolbar icon. In the\n     * example below, the default edge style is set when this specific\n     * connect-mode is activated:\n     *\n     * ```javascript\n     * <add as=\"connect\" mode=\"connect\"><![CDATA[\n     *   function (editor)\n     *   {\n     *     if (editor.defaultEdge != null)\n     *     {\n     *       editor.defaultEdge.style = 'straightEdge';\n     *     }\n     *   }\n     * ]]></add>\n     * ```\n     *\n     * Both functions require {@link allowEval} to be set to `true`.\n     *\n     * Modes:\n     *\n     * select - Left mouse button used for rubberband- & cell-selection.\n     * connect - Allows connecting vertices by inserting new edges.\n     * pan - Disables selection and switches to panning on the left button.\n     *\n     * Example:\n     *\n     * To add items to the toolbar:\n     *\n     * ```javascript\n     * <EditorToolbar as=\"toolbar\">\n     *   <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n     *   <br/><hr/>\n     *   <add as=\"select\" mode=\"select\" icon=\"images/select.gif\"/>\n     *   <add as=\"connect\" mode=\"connect\" icon=\"images/connect.gif\"/>\n     * </EditorToolbar>\n     * ```\n     */\n    decode(dec, _node, into) {\n        if (into != null) {\n            const editor = into.editor;\n            let node = _node.firstChild;\n            while (node != null) {\n                if (node.nodeType === NODETYPE.ELEMENT) {\n                    if (!this.processInclude(dec, node, into)) {\n                        if (node.nodeName === 'separator') {\n                            into.addSeparator();\n                        }\n                        else if (node.nodeName === 'br') {\n                            into.toolbar.addBreak();\n                        }\n                        else if (node.nodeName === 'hr') {\n                            into.toolbar.addLine();\n                        }\n                        else if (node.nodeName === 'add') {\n                            let as = node.getAttribute('as');\n                            as = Translations.get(as) || as;\n                            const icon = node.getAttribute('icon');\n                            const pressedIcon = node.getAttribute('pressedIcon');\n                            const action = node.getAttribute('action');\n                            const mode = node.getAttribute('mode');\n                            const template = node.getAttribute('template');\n                            const toggle = node.getAttribute('toggle') != '0';\n                            const text = getTextContent(node);\n                            let elt = null;\n                            let funct;\n                            if (action != null) {\n                                elt = into.addItem(as, icon, action, pressedIcon);\n                            }\n                            else if (mode != null) {\n                                funct = EditorToolbarCodec.allowEval ? eval(text) : null;\n                                elt = into.addMode(as, icon, mode, pressedIcon, funct);\n                            }\n                            else if (template != null || (text != null && text.length > 0)) {\n                                let cell = template ? editor.templates[template] : null;\n                                const style = node.getAttribute('style');\n                                if (cell != null && style != null) {\n                                    cell = editor.graph.cloneCell(cell);\n                                    cell.setStyle(style);\n                                }\n                                let insertFunction = null;\n                                if (text != null && text.length > 0 && EditorToolbarCodec.allowEval) {\n                                    insertFunction = eval(text);\n                                }\n                                elt = into.addPrototype(as, icon, cell, pressedIcon, insertFunction, toggle);\n                            }\n                            else {\n                                const children = getChildNodes(node);\n                                if (children.length > 0) {\n                                    if (icon == null) {\n                                        const combo = into.addActionCombo(as);\n                                        for (let i = 0; i < children.length; i += 1) {\n                                            const child = children[i];\n                                            if (child.nodeName === 'separator') {\n                                                into.addOption(combo, '---');\n                                            }\n                                            else if (child.nodeName === 'add') {\n                                                const lab = child.getAttribute('as');\n                                                const act = child.getAttribute('action');\n                                                into.addActionOption(combo, lab, act);\n                                            }\n                                        }\n                                    }\n                                    else {\n                                        const select = into.addCombo();\n                                        const create = () => {\n                                            const template = editor.templates[select.value];\n                                            if (template != null) {\n                                                const clone = template.clone();\n                                                // @ts-ignore\n                                                const style = select.options[select.selectedIndex].cellStyle;\n                                                if (style != null) {\n                                                    clone.setStyle(style);\n                                                }\n                                                return clone;\n                                            }\n                                            GlobalConfig.logger.warn(`Template ${template} not found`);\n                                            return null;\n                                        };\n                                        const img = into.addPrototype(as, icon, create, null, null, toggle);\n                                        // Selects the toolbar icon if a selection change\n                                        // is made in the corresponding combobox.\n                                        InternalEvent.addListener(select, 'change', () => {\n                                            into.toolbar.selectMode(img, (evt) => {\n                                                const pt = convertPoint(editor.graph.container, getClientX(evt), getClientY(evt));\n                                                return editor.addVertex(null, funct(), pt.x, pt.y);\n                                            });\n                                            into.toolbar.noReset = false;\n                                        });\n                                        // Adds the entries to the combobox\n                                        for (let i = 0; i < children.length; i += 1) {\n                                            const child = children[i];\n                                            if (child.nodeName === 'separator') {\n                                                into.addOption(select, '---');\n                                            }\n                                            else if (child.nodeName === 'add') {\n                                                const lab = child.getAttribute('as');\n                                                const tmp = child.getAttribute('template');\n                                                const option = into.addOption(select, lab, tmp || template);\n                                                option.cellStyle = child.getAttribute('style');\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            // Assigns an ID to the created element to access it later.\n                            if (elt != null) {\n                                const id = node.getAttribute('id');\n                                if (id != null && id.length > 0) {\n                                    elt.setAttribute('id', id);\n                                }\n                            }\n                        }\n                    }\n                }\n                node = node.nextSibling;\n            }\n        }\n        return into;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from '../CodecRegistry';\nimport ObjectCodec from '../ObjectCodec';\nimport Cell from '../../view/cell/Cell';\nimport { NODETYPE } from '../../util/Constants';\nimport { importNode } from '../../util/domUtils';\nimport { removeWhitespace } from '../../util/StringUtils';\n/**\n * Codec for {@link Cell}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - children\n * - edges\n * - overlays\n * - mxTransient\n *\n * Reference Fields:\n *\n * - parent\n * - source\n * - target\n *\n * Transient fields can be added using the following code: `CodecRegistry.getCodec(Cell).exclude.push('name_of_field');`\n *\n * To subclass {@link Cell}, replace the template and add an alias as follows:\n *\n * ```javascript\n * // Given 'CustomCell' extends 'Cell'\n * CodecRegistry.getCodec(Cell).template = new CustomCell();\n * CodecRegistry.addAlias('CustomCell', 'Cell');\n * ```\n *\n * @category Serialization with Codecs\n */\nexport class CellCodec extends ObjectCodec {\n    constructor() {\n        super(new Cell(), ['children', 'edges', 'overlays', 'mxTransient'], ['parent', 'source', 'target']);\n        this.setName('Cell');\n    }\n    /**\n     * Returns `true` since this is a cell codec.\n     */\n    isCellCodec() {\n        return true;\n    }\n    /**\n     * Overridden to disable conversion of value to number.\n     */\n    isNumericAttribute(dec, attr, obj) {\n        return attr.nodeName !== 'value' && super.isNumericAttribute(dec, attr, obj);\n    }\n    /**\n     * Excludes user objects that are XML nodes.\n     */\n    isExcluded(obj, attr, value, isWrite) {\n        return (super.isExcluded(obj, attr, value, isWrite) ||\n            (isWrite && attr === 'value' && value.nodeType === NODETYPE.ELEMENT));\n    }\n    /**\n     * Encodes a {@link Cell} and wraps the XML up inside the XML of the user object (inversion).\n     */\n    afterEncode(enc, obj, node) {\n        if (obj.value != null && obj.value.nodeType === NODETYPE.ELEMENT) {\n            // Wraps the graphical annotation up in the user object (inversion)\n            // by putting the result of the default encoding into a clone of the\n            // user object (node type 1) and returning this cloned user object.\n            const tmp = node;\n            node = importNode(enc.document, obj.value, true);\n            node.appendChild(tmp);\n            // Moves the id attribute to the outermost XML node, namely the\n            // node which denotes the object boundaries in the file.\n            const id = tmp.getAttribute('id');\n            node.setAttribute('id', String(id));\n            tmp.removeAttribute('id');\n        }\n        return node;\n    }\n    /**\n     * Decodes an {@link Cell} and uses the enclosing XML node as the user object for the cell (inversion).\n     */\n    beforeDecode(dec, node, obj) {\n        let inner = node.cloneNode(true);\n        const classname = this.getName();\n        if (node.nodeName !== classname) {\n            // Passes the inner graphical annotation node to the\n            // object codec for further processing of the cell.\n            const tmp = node.getElementsByTagName(classname)[0];\n            if (tmp != null && tmp.parentNode === node) {\n                removeWhitespace(tmp, true);\n                removeWhitespace(tmp, false);\n                tmp.parentNode.removeChild(tmp);\n                inner = tmp;\n            }\n            else {\n                inner = null;\n            }\n            // Creates the user object out of the XML node\n            obj.value = node.cloneNode(true);\n            const id = obj.value.getAttribute('id');\n            if (id != null) {\n                obj.setId(id);\n                obj.value.removeAttribute('id');\n            }\n        }\n        else {\n            // Uses ID from XML file as ID for cell in model\n            obj.setId(node.getAttribute('id'));\n        }\n        // Preprocesses and removes all Id-references in order to use the\n        // correct encoder (this) for the known references to cells (all).\n        if (inner != null) {\n            for (let i = 0; i < this.idrefs.length; i += 1) {\n                const attr = this.idrefs[i];\n                const ref = inner.getAttribute(attr);\n                if (ref != null) {\n                    inner.removeAttribute(attr);\n                    let object = dec.objects[ref] || dec.lookup(ref);\n                    if (object == null) {\n                        // Needs to decode forward reference\n                        const element = dec.getElementById(ref);\n                        if (element != null) {\n                            const decoder = CodecRegistry.codecs[element.nodeName] || this;\n                            object = decoder.decode(dec, element);\n                        }\n                    }\n                    // @ts-ignore dynamic assignment was in original implementation\n                    obj[attr] = object;\n                }\n            }\n        }\n        return inner;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport ChildChange from '../../view/undoable_changes/ChildChange';\nimport { NODETYPE } from '../../util/Constants';\n/**\n * Codec for {@link ChildChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n * - previousIndex\n * - child\n *\n * Reference Fields:\n *\n * - parent\n *\n * @category Serialization with Codecs\n */\nexport class ChildChangeCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new ChildChange(__dummy, __dummy, __dummy), ['model', 'child', 'previousIndex'], ['parent', 'previous']);\n    }\n    /**\n     * Returns `true` for the child attribute if the child cell had a previous parent or if we're reading the\n     * child as an attribute rather than a child node, in which case it's always a reference.\n     */\n    isReference(obj, attr, value, isWrite) {\n        if (attr === 'child' && (!isWrite || obj.model.contains(obj.previous))) {\n            return true;\n        }\n        return this.idrefs.indexOf(attr) >= 0;\n    }\n    /**\n     * Excludes references to parent or previous if not in the model.\n     */\n    isExcluded(obj, attr, value, write) {\n        return (super.isExcluded(obj, attr, value, write) ||\n            (write &&\n                value != null &&\n                (attr === 'previous' || attr === 'parent') &&\n                !obj.model.contains(value)));\n    }\n    /**\n     * Encodes the child recursively and adds the result to the given node.\n     */\n    afterEncode(enc, obj, node) {\n        if (this.isReference(obj, 'child', obj.child, true)) {\n            // Encodes as reference (id)\n            node.setAttribute('child', enc.getId(obj.child));\n        }\n        else {\n            // At this point, the encoder is no longer able to know which cells\n            // are new, so we have to encode the complete cell hierarchy and\n            // ignore the ones that are already there at decoding time. Note:\n            // This can only be resolved by moving the notify event into the\n            // execute of the edit.\n            enc.encodeCell(obj.child, node);\n        }\n        return node;\n    }\n    /**\n     * Decodes any child nodes as using the respective codec from the registry.\n     */\n    beforeDecode(dec, _node, obj) {\n        if (_node.firstChild != null && _node.firstChild.nodeType === NODETYPE.ELEMENT) {\n            // Makes sure the original node isn't modified\n            const node = _node.cloneNode(true);\n            let tmp = node.firstChild;\n            obj.child = dec.decodeCell(tmp, false);\n            let tmp2 = tmp.nextSibling;\n            tmp.parentNode.removeChild(tmp);\n            tmp = tmp2;\n            while (tmp != null) {\n                tmp2 = tmp.nextSibling;\n                if (tmp.nodeType === NODETYPE.ELEMENT) {\n                    // Ignores all existing cells because those do not need to\n                    // be re-inserted into the model. Since the encoded version\n                    // of these cells contains the new parent, this would leave\n                    // to an inconsistent state on the model (i.e. a parent\n                    // change without a call to parentForCellChanged).\n                    const id = tmp.getAttribute('id');\n                    if (dec.lookup(id) == null) {\n                        dec.decodeCell(tmp);\n                    }\n                }\n                tmp.parentNode.removeChild(tmp);\n                tmp = tmp2;\n            }\n            return node;\n        }\n        else {\n            const childRef = _node.getAttribute('child');\n            obj.child = dec.getObject(childRef);\n            return _node;\n        }\n    }\n    /**\n     * Restores object state in the child change.\n     */\n    afterDecode(dec, node, obj) {\n        // Cells are decoded here after a complete transaction so the previous\n        // parent must be restored on the cell for the case where the cell was\n        // added. This is needed for the local model to identify the cell as a\n        // new cell and register the ID.\n        if (obj.child != null) {\n            if (obj.child.parent != null &&\n                obj.previous != null &&\n                obj.child.parent !== obj.previous) {\n                obj.previous = obj.child.parent;\n            }\n            obj.child.parent = obj.previous;\n            obj.previous = obj.parent;\n            obj.previousIndex = obj.index;\n        }\n        return obj;\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport { isNode } from '../../util/domUtils';\n/**\n * Codec for {@link ValueChange}s, {@link StyleChange}s, {@link GeometryChange}s, {@link CollapseChange}s and {@link VisibleChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n *\n * Reference Fields:\n *\n * - cell\n *\n * @category Serialization with Codecs\n */\nexport class GenericChangeCodec extends ObjectCodec {\n    /**\n     *\n     * @param obj An instance of the change object.\n     * @param variable The field name for the change data.\n     */\n    constructor(obj, variable) {\n        super(obj, ['model', 'previous'], ['cell']);\n        this.variable = variable;\n    }\n    /**\n     * Restores the state by assigning the previous value.\n     */\n    afterDecode(dec, _node, obj) {\n        // Allows forward references in sessions. This is a workaround\n        // for the sequence of edits in mxGraph.moveCells and cellsAdded.\n        if (isNode(obj.cell)) {\n            obj.cell = dec.decodeCell(obj.cell, false);\n        }\n        obj.previous = obj[this.variable];\n        return obj;\n    }\n}\n", "/*\nCopyright 2024-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport { Graph } from '../../view/Graph';\n/**\n * Codec for {@link Graph}s.\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - graphListeners\n * - eventListeners\n * - view\n * - container\n * - cellRenderer\n * - editor\n * - selection\n *\n * @category Serialization with Codecs\n */\nexport class GraphCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        // TODO: Register every possible plugin (i.e. all not being excluded via tree-shaking(?))\n        super(new Graph(__dummy), [\n            'graphListeners',\n            'eventListeners',\n            'view',\n            'container',\n            'cellRenderer',\n            'editor',\n            'selection',\n        ]);\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport GraphView from '../../view/GraphView';\nimport StyleRegistry from '../../view/style/StyleRegistry';\n/**\n * Custom encoder for {@link GraphView}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * This codec only writes views into an XML format that can be used to create an image for the graph, that is,\n * it contains absolute coordinates with computed perimeters, edge styles and cell styles.\n *\n * @category Serialization with Codecs\n */\nexport class GraphViewCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new GraphView(__dummy));\n    }\n    /**\n     * Encodes the given {@link GraphView} using {@link encodeCell} starting at the model's root. This returns the\n     * top-level graph node of the recursive encoding.\n     */\n    encode(enc, view) {\n        return this.encodeCell(enc, view, view.graph.getDataModel().getRoot());\n    }\n    /**\n     * Recursively encodes the specified cell.\n     *\n     * Uses layer as the default node name. If the cell's parent is null, then graph is used for the node name.\n     * If {@link Cell.isEdge} returns `true` for the cell, then edge is used for the node name, else if {@link Cell.isVertex} returns `true` for the cell,\n     * then vertex is used for the node name.\n     *\n     * {@link Graph.getLabel} is used to create the label attribute for the cell.\n     * For graph nodes and vertices the bounds are encoded into x, y, width and height.\n     * For edges the points are encoded into a points attribute as a space-separated list of comma-separated coordinate pairs (e.g. x0,y0 x1,y1 ... xn,yn).\n     * All values from the cell style are added as attribute values to the node.\n     */\n    encodeCell(enc, view, cell) {\n        let node;\n        const model = view.graph.getDataModel();\n        const state = view.getState(cell);\n        const parent = cell.getParent();\n        if (parent == null || state != null) {\n            const childCount = cell.getChildCount();\n            const geo = cell.getGeometry();\n            let name = null;\n            if (parent === model.getRoot()) {\n                name = 'layer';\n            }\n            else if (parent == null) {\n                name = 'graph';\n            }\n            else if (cell.isEdge()) {\n                name = 'edge';\n            }\n            else if (childCount > 0 && geo != null) {\n                name = 'group';\n            }\n            else if (cell.isVertex()) {\n                name = 'vertex';\n            }\n            if (name != null) {\n                node = enc.document.createElement(name);\n                const lab = view.graph.getLabel(cell);\n                if (lab != null) {\n                    node.setAttribute('label', view.graph.getLabel(cell));\n                    if (view.graph.isHtmlLabel(cell)) {\n                        node.setAttribute('html', true);\n                    }\n                }\n                if (parent == null) {\n                    const bounds = view.getGraphBounds();\n                    if (bounds != null) {\n                        node.setAttribute('x', Math.round(bounds.x));\n                        node.setAttribute('y', Math.round(bounds.y));\n                        node.setAttribute('width', Math.round(bounds.width));\n                        node.setAttribute('height', Math.round(bounds.height));\n                    }\n                    node.setAttribute('scale', view.scale);\n                }\n                else if (state != null && geo != null) {\n                    // Writes each key, value in the style pair to an attribute\n                    for (const i in state.style) {\n                        // @ts-ignore\n                        let value = state.style[i];\n                        // Tries to turn objects and functions into strings\n                        if (typeof value === 'function' && typeof value === 'object') {\n                            value = StyleRegistry.getName(value);\n                        }\n                        if (value != null &&\n                            typeof value !== 'function' &&\n                            typeof value !== 'object') {\n                            node.setAttribute(i, value);\n                        }\n                    }\n                    const abs = state.absolutePoints;\n                    // Writes the list of points into one attribute\n                    if (abs != null && abs.length > 0) {\n                        let pts = `${Math.round(abs[0].x)},${Math.round(abs[0].y)}`;\n                        for (let i = 1; i < abs.length; i += 1) {\n                            pts += ` ${Math.round(abs[i].x)},${Math.round(abs[i].y)}`;\n                        }\n                        node.setAttribute('points', pts);\n                    }\n                    // Writes the bounds into 4 attributes\n                    else {\n                        node.setAttribute('x', Math.round(state.x));\n                        node.setAttribute('y', Math.round(state.y));\n                        node.setAttribute('width', Math.round(state.width));\n                        node.setAttribute('height', Math.round(state.height));\n                    }\n                    const offset = state.absoluteOffset;\n                    // Writes the offset into 2 attributes\n                    if (offset != null) {\n                        if (offset.x !== 0) {\n                            node.setAttribute('dx', Math.round(offset.x));\n                        }\n                        if (offset.y !== 0) {\n                            node.setAttribute('dy', Math.round(offset.y));\n                        }\n                    }\n                }\n                for (let i = 0; i < childCount; i += 1) {\n                    const childNode = this.encodeCell(enc, view, cell.getChildAt(i));\n                    if (childNode != null) {\n                        node.appendChild(childNode);\n                    }\n                }\n            }\n        }\n        return node;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport GraphDataModel from '../../view/GraphDataModel';\n/**\n * Codec for {@link GraphDataModel}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * @category Serialization with Codecs\n */\nexport class ModelCodec extends ObjectCodec {\n    constructor() {\n        super(new GraphDataModel());\n        this.setName('GraphDataModel');\n    }\n    /**\n     * Encodes the given {@link GraphDataModel} by writing a (flat) XML sequence of cell nodes as produced by the {@link CellCodec}.\n     * The sequence is wrapped-up in a node with the name `root`.\n     */\n    encodeObject(enc, obj, node) {\n        const rootNode = enc.document.createElement('root');\n        enc.encodeCell(obj.getRoot(), rootNode);\n        node.appendChild(rootNode);\n    }\n    /**\n     * Overrides decode child to handle special child nodes.\n     */\n    decodeChild(dec, child, obj) {\n        if (child.nodeName === 'root') {\n            this.decodeRoot(dec, child, obj);\n        }\n        else {\n            this.decodeChild.apply(this, [dec, child, obj]);\n        }\n    }\n    /**\n     * Reads the cells into the graph model. All cells are children of the root element in the node.\n     */\n    decodeRoot(dec, root, model) {\n        let rootCell = null;\n        let tmp = root.firstChild;\n        while (tmp != null) {\n            const cell = dec.decodeCell(tmp);\n            if (cell != null && cell.getParent() == null) {\n                rootCell = cell;\n            }\n            tmp = tmp.nextSibling;\n        }\n        // Sets the root on the model if one has been decoded\n        if (rootCell != null) {\n            model.setRoot(rootCell);\n        }\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport RootChange from '../../view/undoable_changes/RootChange';\nimport { NODETYPE } from '../../util/Constants';\n/**\n * Codec for {@link RootChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n * - root\n *\n * @category Serialization with Codecs\n */\nexport class RootChangeCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new RootChange(__dummy, __dummy), ['model', 'previous', 'root']);\n    }\n    /**\n     * Encodes the child recursively.\n     */\n    afterEncode(enc, obj, node) {\n        enc.encodeCell(obj.root, node);\n        return node;\n    }\n    /**\n     * Decodes the optional children as cells using the respective decoder.\n     */\n    beforeDecode(dec, node, obj) {\n        if (node.firstChild != null && node.firstChild.nodeType === NODETYPE.ELEMENT) {\n            // Makes sure the original node isn't modified\n            node = node.cloneNode(true);\n            let tmp = node.firstChild;\n            obj.root = dec.decodeCell(tmp, false);\n            let tmp2 = tmp.nextSibling;\n            tmp.parentNode.removeChild(tmp);\n            tmp = tmp2;\n            while (tmp != null) {\n                tmp2 = tmp.nextSibling;\n                dec.decodeCell(tmp);\n                tmp.parentNode.removeChild(tmp);\n                tmp = tmp2;\n            }\n        }\n        return node;\n    }\n    /**\n     * Restores the state by assigning the previous value.\n     */\n    afterDecode(_dec, _node, obj) {\n        obj.previous = obj.root;\n        return obj;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport { Stylesheet } from '../../view/style/Stylesheet';\nimport StyleRegistry from '../../view/style/StyleRegistry';\nimport { clone } from '../../util/cloneUtils';\nimport { GlobalConfig } from '../../util/config';\nimport { NODETYPE } from '../../util/Constants';\nimport { isNumeric } from '../../util/mathUtils';\nimport { getTextContent } from '../../util/domUtils';\n/**\n * Codec for {@link Stylesheet}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * @category Serialization with Codecs\n */\nexport class StylesheetCodec extends ObjectCodec {\n    constructor() {\n        super(new Stylesheet());\n    }\n    /**\n     * Encodes a stylesheet. See {@link decode} for a description of the format.\n     */\n    encode(enc, obj) {\n        const node = enc.document.createElement(this.getName());\n        for (const i in obj.styles) {\n            const style = obj.styles[i];\n            const styleNode = enc.document.createElement('add');\n            if (i != null) {\n                styleNode.setAttribute('as', i);\n                for (const j in style) {\n                    const value = this.getStringValue(j, style[j]);\n                    if (value != null) {\n                        const entry = enc.document.createElement('add');\n                        entry.setAttribute('value', value);\n                        entry.setAttribute('as', j);\n                        styleNode.appendChild(entry);\n                    }\n                }\n                if (styleNode.childNodes.length > 0) {\n                    node.appendChild(styleNode);\n                }\n            }\n        }\n        return node;\n    }\n    /**\n     * Returns the string for encoding the given value.\n     */\n    getStringValue(key, value) {\n        const type = typeof value;\n        if (type === 'function') {\n            value = StyleRegistry.getName(value);\n        }\n        else if (type === 'object') {\n            value = null;\n        }\n        return value;\n    }\n    /**\n     * Reads a sequence of the following child nodes and attributes:\n     *\n     * Child Nodes:\n     *\n     * add - Adds a new style.\n     *\n     * Attributes:\n     *\n     * as - Name of the style.\n     * extend - Name of the style to inherit from.\n     *\n     * Each node contains another sequence of add and remove nodes with the following attributes:\n     *\n     * as - Name of the style (see {@link Constants}).\n     * value - Value for the style.\n     *\n     * Instead of the value-attribute, one can put Javascript expressions into the node as follows if {@link allowEval} is `true`:\n     * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\n     *\n     * A remove node will remove the entry with the name given in the as-attribute from the style.\n     *\n     * Example:\n     *\n     * ```javascript\n     * <mxStylesheet as=\"stylesheet\">\n     *   <add as=\"text\">\n     *     <add as=\"fontSize\" value=\"12\"/>\n     *   </add>\n     *   <add as=\"defaultVertex\" extend=\"text\">\n     *     <add as=\"shape\" value=\"rectangle\"/>\n     *   </add>\n     * </mxStylesheet>\n     * ```\n     */\n    decode(dec, _node, into) {\n        const obj = into || new this.template.constructor();\n        const id = _node.getAttribute('id');\n        if (id != null) {\n            dec.objects[id] = obj;\n        }\n        let node = _node.firstChild;\n        while (node != null) {\n            if (!this.processInclude(dec, node, obj) && node.nodeName === 'add') {\n                const as = node.getAttribute('as');\n                if (as != null) {\n                    const extend = node.getAttribute('extend');\n                    let style = extend != null ? clone(obj.styles[extend]) : null;\n                    if (style == null) {\n                        if (extend != null) {\n                            GlobalConfig.logger.warn(`StylesheetCodec.decode: stylesheet ${extend} not found to extend`);\n                        }\n                        style = {};\n                    }\n                    let entry = node.firstChild;\n                    while (entry != null) {\n                        if (entry.nodeType === NODETYPE.ELEMENT) {\n                            const key = entry.getAttribute('as');\n                            if (entry.nodeName === 'add') {\n                                const text = getTextContent(entry);\n                                let value = null;\n                                if (text != null && text.length > 0 && StylesheetCodec.allowEval) {\n                                    value = eval(text);\n                                }\n                                else {\n                                    value = entry.getAttribute('value');\n                                    if (isNumeric(value)) {\n                                        value = parseFloat(value);\n                                    }\n                                }\n                                if (value != null) {\n                                    style[key] = value;\n                                }\n                            }\n                            else if (entry.nodeName === 'remove') {\n                                delete style[key];\n                            }\n                        }\n                        entry = entry.nextSibling;\n                    }\n                    obj.putCellStyle(as, style);\n                }\n            }\n            node = node.nextSibling;\n        }\n        return obj;\n    }\n}\n/**\n * Static global switch that specifies if the use of eval is allowed for evaluating text content. Default is true.\n * Set this to `false` if stylesheets may contain user input.\n */\nStylesheetCodec.allowEval = true;\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../ObjectCodec';\nimport TerminalChange from '../../view/undoable_changes/TerminalChange';\n/**\n * Codec for {@link TerminalChange}s.\n *\n * This class is created and registered dynamically at load time and used implicitly via {@link Codec} and the {@link CodecRegistry}.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n *\n * Reference Fields:\n *\n * - cell\n * - terminal\n *\n * @category Serialization with Codecs\n */\nexport class TerminalChangeCodec extends ObjectCodec {\n    constructor() {\n        const __dummy = undefined;\n        super(new TerminalChange(__dummy, __dummy, __dummy, __dummy), ['model', 'previous'], ['cell', 'terminal']);\n    }\n    /**\n     * Restores the state by assigning the previous value.\n     */\n    afterDecode(_dec, _node, obj) {\n        obj.previous = obj.terminal;\n        return obj;\n    }\n}\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { isNumeric } from '../../../util/mathUtils';\n// from mxGraph to maxGraph\nconst fieldMapping = new Map([['autosize', 'autoSize']]);\nexport function convertStyleFromString(input) {\n    const style = {};\n    input.startsWith(';') && (style.ignoreDefaultStyle = true);\n    const elements = input\n        .split(';')\n        // filter empty key\n        .filter(([k]) => k);\n    for (const element of elements) {\n        if (!element.includes('=')) {\n            !style.baseStyleNames && (style.baseStyleNames = []);\n            style.baseStyleNames.push(element);\n        }\n        else {\n            const [key, value] = element.split('=');\n            // @ts-ignore\n            style[fieldMapping.get(key) ?? key] = convertToNumericIfNeeded(value);\n        }\n    }\n    return style;\n}\nfunction convertToNumericIfNeeded(value) {\n    // Adapted from ObjectCodec.convertAttributeFromXml\n    if (!isNumeric(value)) {\n        return value;\n    }\n    let numericValue = parseFloat(value);\n    if (Number.isNaN(numericValue) || !Number.isFinite(numericValue)) {\n        numericValue = 0;\n    }\n    return numericValue;\n}\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { convertStyleFromString } from './utils';\nimport { CellCodec } from '../CellCodec';\n/**\n * Add support for the legacy `mxGraph` format of {@link Cell}.\n *\n * @category Serialization with Codecs\n */\nexport class mxCellCodec extends CellCodec {\n    getName() {\n        return 'mxCell';\n    }\n    decodeAttribute(dec, attr, obj) {\n        const attributeNodeName = attr.nodeName;\n        if (obj && attributeNodeName == 'style') {\n            obj['style'] = convertStyleFromString(attr.value);\n        }\n        else {\n            super.decodeAttribute(dec, attr, obj);\n        }\n    }\n}\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectCodec from '../../ObjectCodec';\nimport Geometry from '../../../view/geometry/Geometry';\nimport Point from '../../../view/geometry/Point';\n/**\n * Add support for the legacy `mxGraph` format of {@link Geometry}.\n *\n * @category Serialization with Codecs\n */\nexport class mxGeometryCodec extends ObjectCodec {\n    getName() {\n        return 'mxGeometry';\n    }\n    constructor() {\n        super(new Geometry());\n    }\n    afterDecode(dec, node, obj) {\n        // Convert points to the right form\n        // input: [ { x: 420, y: 60 }, ... ]\n        // output: [ Point { _x: 420, _y: 60 }, ... ]\n        //\n        // In mxGraph XML, the points are modeled as Object, so there is no way to create an alias to do the decoding with a custom Codec.\n        // Then, it is easier to convert the values to Point objects after the whole decoding of the geometry\n        // <Array as=\"points\">\n        //   <Object x=\"420\" y=\"60\"/>\n        // </Array>\n        const originalPoints = obj.points;\n        if (originalPoints) {\n            const points = [];\n            for (const pointInput of originalPoints) {\n                const rawPoint = pointInput;\n                points.push(new Point(rawPoint.x, rawPoint.y));\n            }\n            obj.points = points;\n        }\n        return obj;\n    }\n}\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CodecRegistry from './CodecRegistry';\nimport { CellCodec, ChildChangeCodec, EditorCodec, EditorKeyHandlerCodec, EditorPopupMenuCodec, EditorToolbarCodec, GenericChangeCodec, GraphCodec, GraphViewCodec, ModelCodec, mxCellCodec, mxGeometryCodec, RootChangeCodec, StylesheetCodec, TerminalChangeCodec, } from './codecs';\nimport ObjectCodec from './ObjectCodec';\nimport Geometry from '../view/geometry/Geometry';\nimport Point from '../view/geometry/Point';\nimport CellAttributeChange from '../view/undoable_changes/CellAttributeChange';\nimport CollapseChange from '../view/undoable_changes/CollapseChange';\nimport GeometryChange from '../view/undoable_changes/GeometryChange';\nimport StyleChange from '../view/undoable_changes/StyleChange';\nimport ValueChange from '../view/undoable_changes/ValueChange';\nimport VisibleChange from '../view/undoable_changes/VisibleChange';\nconst registerGenericChangeCodecs = () => {\n    const __dummy = undefined;\n    CodecRegistry.register(new GenericChangeCodec(new CellAttributeChange(__dummy, __dummy, __dummy), 'value'));\n    CodecRegistry.register(new GenericChangeCodec(new CollapseChange(__dummy, __dummy, __dummy), 'collapsed'));\n    CodecRegistry.register(new GenericChangeCodec(new GeometryChange(__dummy, __dummy, __dummy), 'geometry'));\n    CodecRegistry.register(new GenericChangeCodec(new StyleChange(__dummy, __dummy, __dummy), 'style'));\n    CodecRegistry.register(new GenericChangeCodec(new ValueChange(__dummy, __dummy, __dummy), 'value'));\n    CodecRegistry.register(new GenericChangeCodec(new VisibleChange(__dummy, __dummy, __dummy), 'visible'));\n};\nconst createObjectCodec = (template, name) => {\n    const objectCodec = new ObjectCodec(template);\n    objectCodec.setName(name);\n    return objectCodec;\n};\nlet isModelCodecsRegistered = false;\n/**\n * Register model codecs i.e. codecs used to import/export the Graph Model, see {@link GraphDataModel}.\n *\n * @param force if `true` register the codecs even if they were already registered. If false, only register them\n *              if they have never been registered before.\n * @since 0.10.0\n * @category Configuration\n */\nexport const registerModelCodecs = (force = false) => {\n    if (!isModelCodecsRegistered || force) {\n        CodecRegistry.register(new CellCodec());\n        CodecRegistry.register(new ModelCodec());\n        // To support decode/import executed before encode/export (see https://github.com/maxGraph/maxGraph/issues/178)\n        // Codecs are currently only registered automatically during encode/export\n        CodecRegistry.register(createObjectCodec(new Geometry(), 'Geometry'));\n        CodecRegistry.register(createObjectCodec(new Point(), 'Point'));\n        CodecRegistry.register(new ObjectCodec({})); // Object\n        CodecRegistry.register(new ObjectCodec([])); // Array\n        // mxGraph support\n        CodecRegistry.addAlias('mxGraphModel', 'GraphDataModel');\n        CodecRegistry.addAlias('mxPoint', 'Point');\n        CodecRegistry.register(new mxCellCodec(), false);\n        CodecRegistry.register(new mxGeometryCodec(), false);\n        isModelCodecsRegistered = true;\n    }\n};\nlet isCoreCodecsRegistered = false;\n/**\n * Register core codecs i.e. codecs that don't relate to editor. This includes model codecs that can be registered individually with {@link registerModelCodecs}.\n *\n * @param force if `true` register the codecs even if they were already registered. If false, only register them\n *              if they have never been registered before.\n * @since 0.6.0\n * @category Configuration\n */\nexport const registerCoreCodecs = (force = false) => {\n    if (!isCoreCodecsRegistered || force) {\n        CodecRegistry.register(new ChildChangeCodec());\n        CodecRegistry.register(new GraphCodec());\n        CodecRegistry.register(new GraphViewCodec());\n        CodecRegistry.register(new RootChangeCodec());\n        CodecRegistry.register(new StylesheetCodec());\n        CodecRegistry.register(new TerminalChangeCodec());\n        registerGenericChangeCodecs();\n        registerModelCodecs(force);\n        isCoreCodecsRegistered = true;\n    }\n};\nlet isEditorCodecsRegistered = false;\n/**\n * Register only editor codecs.\n * @param force if `true` register the codecs even if they were already registered. If false, only register them\n *              if they have never been registered before.\n * @since 0.6.0\n * @category Configuration\n */\nexport const registerEditorCodecs = (force = false) => {\n    if (!isEditorCodecsRegistered || force) {\n        CodecRegistry.register(new EditorCodec());\n        CodecRegistry.register(new EditorKeyHandlerCodec());\n        CodecRegistry.register(new EditorPopupMenuCodec());\n        CodecRegistry.register(new EditorToolbarCodec());\n        isEditorCodecsRegistered = true;\n    }\n};\n/**\n * Register all codecs i.e. core codecs (as done by {@link registerCoreCodecs}) and editor codecs (as done by {@link registerEditorCodecs}).\n *\n * @param force if `true` register the codecs even if they were already registered. If false, only register them\n *              if they have never been registered before.\n * @since 0.6.0\n * @category Configuration\n */\nexport const registerAllCodecs = (force = false) => {\n    registerCoreCodecs(force);\n    registerEditorCodecs(force);\n};\n", "/*\nCopyright 2023-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { registerModelCodecs } from './register';\nimport { getPrettyXml, getXml, parseXml } from '../util/xmlUtils';\nimport Codec from './Codec';\n/**\n * Convenient utility class using {@link Codec} to manage maxGraph model import and export.\n *\n * **WARN**: this is an experimental feature that is subject to change (class and method names).\n *\n * @alpha\n * @experimental\n * @since 0.6.0\n * @category Serialization with Codecs\n */\n// Include 'XML' in the class name as there were past discussions about supporting other format like JSON for example\n// See https://github.com/maxGraph/maxGraph/discussions/60 for more details.\nexport class ModelXmlSerializer {\n    constructor(dataModel) {\n        this.dataModel = dataModel;\n        this.registerCodecs();\n    }\n    import(input) {\n        const doc = typeof input === 'string' ? parseXml(input) : input.ownerDocument;\n        new Codec(doc).decode(doc.documentElement, this.dataModel);\n    }\n    export(options) {\n        const encodedNode = new Codec().encode(this.dataModel);\n        return (options?.pretty ?? true) ? getPrettyXml(encodedNode) : getXml(encodedNode);\n    }\n    /**\n     * Hook for replacing codecs registered by default (model codecs).\n     */\n    registerCodecs() {\n        registerModelCodecs();\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport InternalEvent from '../view/event/InternalEvent';\nimport { write, writeln } from '../util/domUtils';\nimport Translations from '../util/Translations';\n/**\n * A simple class for creating HTML forms.\n *\n * @class MaxForm\n */\nclass MaxForm {\n    constructor(className) {\n        this.table = document.createElement('table');\n        this.table.className = className;\n        this.body = document.createElement('tbody');\n        this.table.appendChild(this.body);\n    }\n    /**\n     * Returns the table that contains this form.\n     */\n    getTable() {\n        return this.table;\n    }\n    /**\n     * Helper method to add an OK and Cancel button using the respective\n     * functions.\n     */\n    addButtons(okFunct, cancelFunct) {\n        const tr = document.createElement('tr');\n        let td = document.createElement('td');\n        tr.appendChild(td);\n        td = document.createElement('td');\n        // Adds the ok button\n        let button = document.createElement('button');\n        write(button, Translations.get('ok') || 'OK');\n        td.appendChild(button);\n        InternalEvent.addListener(button, 'click', () => {\n            okFunct();\n        });\n        // Adds the cancel button\n        button = document.createElement('button');\n        write(button, Translations.get('cancel') || 'Cancel');\n        td.appendChild(button);\n        InternalEvent.addListener(button, 'click', () => {\n            cancelFunct();\n        });\n        tr.appendChild(td);\n        this.body.appendChild(tr);\n    }\n    /**\n     * Adds an input for the given name, type and value and returns it.\n     */\n    addText(name, value, type = 'text') {\n        const input = document.createElement('input');\n        input.setAttribute('type', type);\n        input.value = value;\n        return this.addField(name, input);\n    }\n    /**\n     * Adds a checkbox for the given name and value and returns the textfield.\n     */\n    addCheckbox(name, value) {\n        const input = document.createElement('input');\n        input.setAttribute('type', 'checkbox');\n        this.addField(name, input);\n        // IE can only change the checked value if the input is inside the DOM\n        if (value) {\n            input.checked = true;\n        }\n        return input;\n    }\n    /**\n     * Adds a textarea for the given name and value and returns the textarea.\n     */\n    addTextarea(name, value, rows) {\n        const input = document.createElement('textarea');\n        if (Client.IS_NS) {\n            rows--;\n        }\n        input.setAttribute('rows', String(rows || 2));\n        input.value = value;\n        return this.addField(name, input);\n    }\n    /**\n     * Adds a combo for the given name and returns the combo.\n     */\n    addCombo(name, isMultiSelect, size) {\n        const select = document.createElement('select');\n        if (size != null) {\n            select.setAttribute('size', String(size));\n        }\n        if (isMultiSelect) {\n            select.setAttribute('multiple', 'true');\n        }\n        return this.addField(name, select);\n    }\n    /**\n     * Adds an option for the given label to the specified combo.\n     */\n    addOption(combo, label, value, isSelected) {\n        const option = document.createElement('option');\n        writeln(option, label);\n        option.setAttribute('value', value);\n        if (isSelected) {\n            option.setAttribute('selected', String(isSelected));\n        }\n        combo.appendChild(option);\n    }\n    /**\n     * Adds a new row with the name and the input field in two columns and\n     * returns the given input.\n     */\n    addField(name, input) {\n        const tr = document.createElement('tr');\n        let td = document.createElement('td');\n        write(td, name);\n        tr.appendChild(td);\n        td = document.createElement('td');\n        td.appendChild(input);\n        tr.appendChild(td);\n        this.body.appendChild(tr);\n        return input;\n    }\n}\nexport default MaxForm;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getTopmostCells } from './cellArrayUtils';\n/**\n * @class\n *\n * Singleton that implements a clipboard for graph cells.\n *\n * ### Example:\n *\n * ```javascript\n * Clipboard.copy(graph);\n * Clipboard.paste(graph2);\n * ```\n *\n * This copies the selection cells from the graph to the clipboard and\n * pastes them into graph2.\n *\n * For fine-grained control of the clipboard data the {@link graph.canExportCell}\n * and {@link graph.canImportCell} functions can be overridden.\n *\n * To restore previous parents for pasted cells, the implementation for\n * {@link copy} and {@link paste} can be changed as follows.\n *\n * ```javascript\n * Clipboard.copy = function(graph, cells)\n * {\n *   cells = cells || graph.getSelectionCells();\n *   var result = graph.getExportableCells(cells);\n *\n *   Clipboard.parents = new Object();\n *\n *   for (var i = 0; i < result.length; i++)\n *   {\n *     Clipboard.parents[i] = graph.model.getParent(cells[i]);\n *   }\n *\n *   Clipboard.insertCount = 1;\n *   Clipboard.setCells(graph.cloneCells(result));\n *\n *   return result;\n * };\n *\n * Clipboard.paste = function(graph)\n * {\n *   if (!Clipboard.isEmpty())\n *   {\n *     var cells = graph.getImportableCells(Clipboard.getCells());\n *     var delta = Clipboard.insertCount * Clipboard.STEPSIZE;\n *     var parent = graph.getDefaultParent();\n *\n *     graph.model.beginUpdate();\n *     try\n *     {\n *       for (var i = 0; i < cells.length; i++)\n *       {\n *         var tmp = (Clipboard.parents != null && graph.model.contains(Clipboard.parents[i])) ?\n *              Clipboard.parents[i] : parent;\n *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];\n *       }\n *     }\n *     finally\n *     {\n *       graph.model.endUpdate();\n *     }\n *\n *     // Increments the counter and selects the inserted cells\n *     Clipboard.insertCount++;\n *     graph.setSelectionCells(cells);\n *   }\n * };\n * ```\n */\nclass Clipboard {\n    /**\n     * Sets the cells in the clipboard. Fires a {@link mxEvent.CHANGE} event.\n     */\n    static setCells(cells) {\n        Clipboard.cells = cells;\n    }\n    /**\n     * Returns  the cells in the clipboard.\n     */\n    static getCells() {\n        return Clipboard.cells;\n    }\n    /**\n     * Returns true if the clipboard currently has not data stored.\n     */\n    static isEmpty() {\n        return !Clipboard.getCells();\n    }\n    /**\n     * Cuts the given array of {@link mxCell} from the specified graph.\n     * If cells is null then the selection cells of the graph will\n     * be used. Returns the cells that have been cut from the graph.\n     *\n     * @param graph - {@link graph} that contains the cells to be cut.\n     * @param cells - Optional array of {@link mxCell} to be cut.\n     */\n    static cut(graph, cells = []) {\n        cells = Clipboard.copy(graph, cells);\n        Clipboard.insertCount = 0;\n        Clipboard.removeCells(graph, cells);\n        return cells;\n    }\n    /**\n     * Hook to remove the given cells from the given graph after\n     * a cut operation.\n     *\n     * @param graph - {@link graph} that contains the cells to be cut.\n     * @param cells - Array of {@link mxCell} to be cut.\n     */\n    static removeCells(graph, cells) {\n        graph.removeCells(cells);\n    }\n    /**\n     * Copies the given array of {@link mxCell} from the specified\n     * graph to {@link cells}. Returns the original array of cells that has\n     * been cloned. Descendants of cells in the array are ignored.\n     *\n     * @param graph - {@link graph} that contains the cells to be copied.\n     * @param cells - Optional array of {@link mxCell} to be copied.\n     */\n    static copy(graph, cells) {\n        cells = cells || graph.getSelectionCells();\n        const result = getTopmostCells(graph.getExportableCells(cells));\n        Clipboard.insertCount = 1;\n        Clipboard.setCells(graph.cloneCells(result));\n        return result;\n    }\n    /**\n     * Pastes the {@link cells} into the specified graph restoring\n     * the relation to {@link parents}, if possible. If the parents\n     * are no longer in the graph or invisible then the\n     * cells are added to the graph's default or into the\n     * swimlane under the cell's new location if one exists.\n     * The cells are added to the graph using {@link graph.importCells}\n     * and returned.\n     *\n     * @param graph - {@link graph} to paste the {@link cells} into.\n     */\n    static paste(graph) {\n        let cells = null;\n        if (!Clipboard.isEmpty() && Clipboard.getCells()) {\n            cells = graph.getImportableCells(Clipboard.getCells());\n            const delta = Clipboard.insertCount * Clipboard.STEPSIZE;\n            const parent = graph.getDefaultParent();\n            cells = graph.importCells(cells, delta, delta, parent);\n            // Increments the counter and selects the inserted cells\n            Clipboard.insertCount++;\n            graph.setSelectionCells(cells);\n        }\n        return cells;\n    }\n}\n/**\n * Defines the step size to offset the cells after each paste operation.\n * Default is 10.\n */\nClipboard.STEPSIZE = 10;\n/**\n * Counts the number of times the clipboard data has been inserted.\n */\nClipboard.insertCount = 1;\nexport default Clipboard;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport InternalEvent from '../view/event/InternalEvent';\nimport { getInnerHtml, write } from '../util/domUtils';\nimport { toString } from '../util/StringUtils';\nimport MaxWindow, { popup } from './MaxWindow';\nimport { copyTextToClipboard, getElapseMillisecondsMessage } from '../util/Utils';\n/**\n * A singleton class that implements a simple console.\n */\nclass MaxLog {\n    /**\n     * Initializes the DOM node for the console.\n     * This requires `document.body` to point to a non-null value.\n     * This is called from within setVisible if the log has not yet been initialized.\n     */\n    static init() {\n        if (MaxLog.window == null && document.body != null) {\n            const title = `${MaxLog.consoleName} - mxGraph ${Client.VERSION}`;\n            // Creates a table that maintains the layout\n            const table = document.createElement('table');\n            table.setAttribute('width', '100%');\n            table.setAttribute('height', '100%');\n            const tbody = document.createElement('tbody');\n            let tr = document.createElement('tr');\n            const td = document.createElement('td');\n            td.style.verticalAlign = 'top';\n            // Adds the actual console as a textarea\n            MaxLog.textarea = document.createElement('textarea');\n            MaxLog.textarea.setAttribute('wrap', 'off');\n            MaxLog.textarea.setAttribute('readOnly', 'true');\n            MaxLog.textarea.style.height = '100%';\n            MaxLog.textarea.style.resize = 'none';\n            MaxLog.textarea.value = MaxLog.buffer;\n            // Workaround for wrong width in standards mode\n            if (Client.IS_NS && document.compatMode !== 'BackCompat') {\n                MaxLog.textarea.style.width = '99%';\n            }\n            else {\n                MaxLog.textarea.style.width = '100%';\n            }\n            td.appendChild(MaxLog.textarea);\n            tr.appendChild(td);\n            tbody.appendChild(tr);\n            // Creates the container div\n            tr = document.createElement('tr');\n            MaxLog.td = document.createElement('td');\n            MaxLog.td.style.verticalAlign = 'top';\n            MaxLog.td.setAttribute('height', '30px');\n            tr.appendChild(MaxLog.td);\n            tbody.appendChild(tr);\n            table.appendChild(tbody);\n            // Adds various debugging buttons\n            MaxLog.addButton('Info', function (evt) {\n                MaxLog.info();\n            });\n            MaxLog.addButton('DOM', function (evt) {\n                const content = getInnerHtml(document.body);\n                MaxLog.debug(content);\n            });\n            MaxLog.addButton('Trace', function (evt) {\n                MaxLog.TRACE = !MaxLog.TRACE;\n                if (MaxLog.TRACE) {\n                    MaxLog.debug('Tracing enabled');\n                }\n                else {\n                    MaxLog.debug('Tracing disabled');\n                }\n            });\n            MaxLog.addButton('Copy', function (evt) {\n                try {\n                    copyTextToClipboard(MaxLog.textarea.value);\n                }\n                catch (err) {\n                    alert(err);\n                }\n            });\n            MaxLog.addButton('Show', function (evt) {\n                try {\n                    popup(MaxLog.textarea.value);\n                }\n                catch (err) {\n                    alert(err);\n                }\n            });\n            MaxLog.addButton('Clear', function (evt) {\n                MaxLog.textarea.value = '';\n            });\n            // Cross-browser code to get window size\n            let h = 0;\n            let w = 0;\n            if (typeof window.innerWidth === 'number') {\n                h = window.innerHeight;\n                w = window.innerWidth;\n            }\n            else {\n                h = document.documentElement.clientHeight || document.body.clientHeight;\n                w = document.body.clientWidth;\n            }\n            MaxLog.window = new MaxWindow(title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);\n            MaxLog.window.setMaximizable(true);\n            MaxLog.window.setScrollable(false);\n            MaxLog.window.setResizable(true);\n            MaxLog.window.setClosable(true);\n            MaxLog.window.destroyOnClose = false;\n            // Workaround for ignored textarea height in various setups\n            if (Client.IS_NS &&\n                !Client.IS_GC &&\n                !Client.IS_SF &&\n                document.compatMode !== 'BackCompat') {\n                const elt = MaxLog.window.getElement();\n                const resizeHandler = (sender, evt) => {\n                    MaxLog.textarea.style.height = `${Math.max(0, elt.offsetHeight - 70)}px`;\n                };\n                MaxLog.window.addListener(InternalEvent.RESIZE_END, resizeHandler);\n                MaxLog.window.addListener(InternalEvent.MAXIMIZE, resizeHandler);\n                MaxLog.window.addListener(InternalEvent.NORMALIZE, resizeHandler);\n                MaxLog.textarea.style.height = '92px';\n            }\n        }\n    }\n    /**\n     * Writes the current navigator information to the console.\n     */\n    static info() {\n        MaxLog.writeln(toString(navigator));\n    }\n    /**\n     * Adds a button to the console using the given label and function.\n     */\n    static addButton(lab, funct) {\n        const button = document.createElement('button');\n        write(button, lab);\n        InternalEvent.addListener(button, 'click', funct);\n        MaxLog.td.appendChild(button);\n    }\n    /**\n     * Returns `true` if the console is visible.\n     */\n    static isVisible() {\n        if (MaxLog.window != null) {\n            return MaxLog.window.isVisible();\n        }\n        return false;\n    }\n    /**\n     * Shows the console.\n     */\n    static show() {\n        MaxLog.setVisible(true);\n    }\n    /**\n     * Shows or hides the console.\n     */\n    static setVisible(visible) {\n        if (MaxLog.window == null) {\n            MaxLog.init();\n        }\n        if (MaxLog.window != null) {\n            MaxLog.window.setVisible(visible);\n        }\n    }\n    /**\n     * Writes the specified string to the console if {@link TRACE} is `true` and returns the current time in milliseconds.\n     */\n    static enter(string) {\n        if (MaxLog.TRACE) {\n            MaxLog.writeln(`Entering ${string}`);\n            return new Date().getTime();\n        }\n    }\n    /**\n     * Writes the specified string to the console if {@link TRACE} is `true` and computes the difference between the current\n     * time and t0 in milliseconds.\n     *\n     * @see {@link enter} for an example.\n     */\n    static leave(string, t0) {\n        if (MaxLog.TRACE) {\n            const dt = getElapseMillisecondsMessage(t0);\n            MaxLog.writeln(`Leaving ${string}${dt}`);\n        }\n    }\n    /**\n     * Adds all arguments to the console if {@link DEBUG} is enabled.\n     */\n    static debug(...args) {\n        if (MaxLog.DEBUG) {\n            MaxLog.writeln(...args);\n        }\n    }\n    /**\n     * Adds all arguments to the console if {@link TRACE} is enabled.\n     */\n    static trace(...args) {\n        if (MaxLog.TRACE) {\n            MaxLog.writeln(...args);\n        }\n    }\n    /**\n     * Adds all arguments to the console if {@link WARN} is enabled.\n     */\n    static warn(...args) {\n        if (MaxLog.WARN) {\n            MaxLog.writeln(...args);\n        }\n    }\n    /**\n     * Adds the specified strings to the console.\n     */\n    static write(...args) {\n        let string = '';\n        for (let i = 0; i < args.length; i += 1) {\n            string += args[i];\n            if (i < args.length - 1) {\n                string += ' ';\n            }\n        }\n        if (MaxLog.textarea != null) {\n            MaxLog.textarea.value = MaxLog.textarea.value + string;\n            // Workaround for no update in Presto 2.5.22 (Opera 10.5)\n            if (navigator.userAgent != null && navigator.userAgent.indexOf('Presto/2.5') >= 0) {\n                MaxLog.textarea.style.visibility = 'hidden';\n                MaxLog.textarea.style.visibility = 'visible';\n            }\n            MaxLog.textarea.scrollTop = MaxLog.textarea.scrollHeight;\n        }\n        else {\n            MaxLog.buffer += string;\n        }\n    }\n    /**\n     * Adds the specified strings to the console, appending a linefeed at the end of each string.\n     */\n    static writeln(...args) {\n        let string = '';\n        for (let i = 0; i < args.length; i += 1) {\n            string += args[i];\n            if (i < args.length - 1) {\n                string += ' ';\n            }\n        }\n        MaxLog.write(`${string}\\n`);\n    }\n}\nMaxLog.textarea = null;\n/**\n * Specifies the name of the console window.\n * @default 'Console'\n */\nMaxLog.consoleName = 'Console';\n/**\n * Specified if the output for {@link enter} and {@link leave} should be visible in the console.\n * @default false\n */\nMaxLog.TRACE = false;\n/**\n * Specifies if the output for {@link debug} should be visible in the console.\n * @default true\n */\nMaxLog.DEBUG = true;\n/**\n * Specifies if the output for {@link warn} should be visible in the console.\n * @default true\n */\nMaxLog.WARN = true;\n/**\n * Buffer for pre-initialized content.\n */\nMaxLog.buffer = '';\nexport default MaxLog;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2016, JGraph Ltd\nCopyright (c) 2006-2016, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { convertPoint, getOffset, getScrollOrigin, setOpacity, setPrefixedStyle, } from '../../util/styleUtils';\nimport InternalEvent from '../event/InternalEvent';\nimport Point from '../geometry/Point';\nimport InternalMouseEvent from '../event/InternalMouseEvent';\nimport Client from '../../Client';\nimport Rectangle from '../geometry/Rectangle';\nimport { isAltDown, isMultiTouchEvent } from '../../util/EventUtils';\nimport { clearSelection } from '../../util/domUtils';\n/**\n * Event handler that selects rectangular regions.\n *\n * **IMPORTANT**: This is not built-into `maxGraph` i.e. this plugin is not in the `maxGraph` default plugins, see {@link getDefaultPlugins}.\n *\n * To enable rubberband selection in a graph, use the following code.\n *\n * ```javascript\n * const plugins = [\n *   ...getDefaultPlugins(), // or any other plugins you want\n *   RubberBandHandler,\n * ];\n *\n * // Creates the graph with the custom plugins\n * const graph = new Graph(container, undefined, plugins);\n * ```\n *\n * **IMPORTANT**: the RubberBandHandler requires CSS styles in order to work properly.\n * See the CSS rules in the `css/common.css` file provided within the npm package. They relate to the `.mxRubberband` class.\n *\n * @category Plugin\n */\nclass RubberBandHandler {\n    constructor(graph) {\n        this.first = null;\n        this.destroyed = false;\n        this.dragHandler = null;\n        this.dropHandler = null;\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        /**\n         * Specifies the default opacity to be used for the rubberband div.  Default is 20.\n         */\n        this.defaultOpacity = 20;\n        /**\n         * Specifies if events are handled. Default is true.\n         */\n        this.enabled = true;\n        /**\n         * Holds the DIV element which is currently visible.\n         */\n        this.div = null;\n        /**\n         * Holds the DIV element which is used to display the rubberband.\n         */\n        this.sharedDiv = null;\n        /**\n         * Holds the value of the x argument in the last call to <update>.\n         */\n        this.currentX = 0;\n        /**\n         * Holds the value of the y argument in the last call to <update>.\n         */\n        this.currentY = 0;\n        /**\n         * Optional fade out effect.  Default is false.\n         */\n        this.fadeOut = false;\n        this.graph = graph;\n        this.graph.addMouseListener(this);\n        // Handles force rubberband event\n        this.forceRubberbandHandler = (sender, evt) => {\n            const evtName = evt.getProperty('eventName');\n            const me = evt.getProperty('event');\n            if (evtName === InternalEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me)) {\n                const offset = getOffset(this.graph.container);\n                const origin = getScrollOrigin(this.graph.container);\n                origin.x -= offset.x;\n                origin.y -= offset.y;\n                this.start(me.getX() + origin.x, me.getY() + origin.y);\n                me.consume(false);\n            }\n        };\n        this.graph.addListener(InternalEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);\n        // Repaints the marquee after autoscroll\n        this.panHandler = () => {\n            this.repaint();\n        };\n        this.graph.addListener(InternalEvent.PAN, this.panHandler);\n        // Does not show menu if any touch gestures take place after the trigger\n        this.gestureHandler = (sender, eo) => {\n            if (this.first) {\n                this.reset();\n            }\n        };\n        this.graph.addListener(InternalEvent.GESTURE, this.gestureHandler);\n    }\n    /**\n     * Creates the rubberband selection shape.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation updates\n     * <enabled>.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n    }\n    /**\n     * Returns true if the given {@link MouseEvent} should start rubberband selection.\n     * This implementation returns true if the alt key is pressed.\n     */\n    isForceRubberbandEvent(me) {\n        return isAltDown(me.getEvent());\n    }\n    /**\n     * Handles the event by initiating a rubberband selection. By consuming the\n     * event all subsequent events of the gesture are redirected to this\n     * handler.\n     */\n    mouseDown(sender, me) {\n        if (!me.isConsumed() &&\n            this.isEnabled() &&\n            this.graph.isEnabled() &&\n            !me.getState() &&\n            !isMultiTouchEvent(me.getEvent())) {\n            const offset = getOffset(this.graph.container);\n            const origin = getScrollOrigin(this.graph.container);\n            origin.x -= offset.x;\n            origin.y -= offset.y;\n            this.start(me.getX() + origin.x, me.getY() + origin.y);\n            // Does not prevent the default for this event so that the\n            // event processing chain is still executed even if we start\n            // rubberbanding. This is required eg. in ExtJs to hide the\n            // current context menu. In mouseMove we'll make sure we're\n            // not selecting anything while we're rubberbanding.\n            me.consume(false);\n        }\n    }\n    /**\n     * Creates the rubberband selection shape.\n     */\n    start(x, y) {\n        this.first = new Point(x, y);\n        const { container } = this.graph;\n        function createMouseEvent(evt) {\n            const me = new InternalMouseEvent(evt);\n            const pt = convertPoint(container, me.getX(), me.getY());\n            me.graphX = pt.x;\n            me.graphY = pt.y;\n            return me;\n        }\n        this.dragHandler = (evt) => {\n            this.mouseMove(this.graph, createMouseEvent(evt));\n        };\n        this.dropHandler = (evt) => {\n            this.mouseUp(this.graph, createMouseEvent(evt));\n        };\n        // Workaround for rubberband stopping if the mouse leaves the container in Firefox\n        if (Client.IS_FF) {\n            InternalEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);\n        }\n    }\n    /**\n     * Handles the event by updating therubberband selection.\n     */\n    mouseMove(sender, me) {\n        if (!me.isConsumed() && this.first) {\n            const origin = getScrollOrigin(this.graph.container);\n            const offset = getOffset(this.graph.container);\n            origin.x -= offset.x;\n            origin.y -= offset.y;\n            const x = me.getX() + origin.x;\n            const y = me.getY() + origin.y;\n            const dx = this.first.x - x;\n            const dy = this.first.y - y;\n            const tol = this.graph.getEventTolerance();\n            if (this.div || Math.abs(dx) > tol || Math.abs(dy) > tol) {\n                if (!this.div) {\n                    this.div = this.createShape();\n                }\n                // Clears selection while rubberbanding. This is required because\n                // the event is not consumed in mouseDown.\n                clearSelection();\n                this.update(x, y);\n                me.consume();\n            }\n        }\n    }\n    /**\n     * Creates the rubberband selection shape.\n     */\n    createShape() {\n        if (!this.sharedDiv) {\n            this.sharedDiv = document.createElement('div');\n            this.sharedDiv.className = 'mxRubberband';\n            setOpacity(this.sharedDiv, this.defaultOpacity);\n        }\n        this.graph.container.appendChild(this.sharedDiv);\n        const result = this.sharedDiv;\n        if (Client.IS_SVG && this.fadeOut) {\n            this.sharedDiv = null;\n        }\n        return result;\n    }\n    /**\n     * Returns true if this handler is active.\n     */\n    isActive(sender, me) {\n        return this.div && this.div.style.display !== 'none';\n    }\n    /**\n     * Handles the event by selecting the region of the rubberband using\n     * {@link Graph#selectRegion}.\n     */\n    mouseUp(sender, me) {\n        const active = this.isActive();\n        this.reset();\n        if (active) {\n            this.execute(me.getEvent());\n            me.consume();\n        }\n    }\n    /**\n     * Resets the state of this handler and selects the current region\n     * for the given event.\n     */\n    execute(evt) {\n        const rect = new Rectangle(this.x, this.y, this.width, this.height);\n        this.graph.selectRegion(rect, evt);\n    }\n    /**\n     * Resets the state of the rubberband selection.\n     */\n    reset() {\n        if (this.div) {\n            if (Client.IS_SVG && this.fadeOut) {\n                const temp = this.div;\n                setPrefixedStyle(temp.style, 'transition', 'all 0.2s linear');\n                temp.style.pointerEvents = 'none';\n                temp.style.opacity = String(0);\n                window.setTimeout(() => {\n                    if (temp.parentNode)\n                        temp.parentNode.removeChild(temp);\n                }, 200);\n            }\n            else {\n                if (this.div.parentNode)\n                    this.div.parentNode.removeChild(this.div);\n            }\n        }\n        InternalEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);\n        this.dragHandler = null;\n        this.dropHandler = null;\n        this.currentX = 0;\n        this.currentY = 0;\n        this.first = null;\n        this.div = null;\n    }\n    /**\n     * Sets <currentX> and <currentY> and calls <repaint>.\n     */\n    update(x, y) {\n        this.currentX = x;\n        this.currentY = y;\n        this.repaint();\n    }\n    /**\n     * Computes the bounding box and updates the style of the <div>.\n     */\n    repaint() {\n        if (this.div && this.first) {\n            const x = this.currentX - this.graph.getPanDx();\n            const y = this.currentY - this.graph.getPanDy();\n            this.x = Math.min(this.first.x, x);\n            this.y = Math.min(this.first.y, y);\n            this.width = Math.max(this.first.x, x) - this.x;\n            this.height = Math.max(this.first.y, y) - this.y;\n            const dx = 0;\n            const dy = 0;\n            this.div.style.left = `${this.x + dx}px`;\n            this.div.style.top = `${this.y + dy}px`;\n            this.div.style.width = `${Math.max(1, this.width)}px`;\n            this.div.style.height = `${Math.max(1, this.height)}px`;\n        }\n    }\n    /**\n     * Destroys the handler and all its resources and DOM nodes. This does\n     * normally not need to be called, it is called automatically when the\n     * window unloads.\n     */\n    onDestroy() {\n        if (!this.destroyed) {\n            this.destroyed = true;\n            this.graph.removeMouseListener(this);\n            this.graph.removeListener(this.forceRubberbandHandler);\n            this.graph.removeListener(this.panHandler);\n            this.reset();\n            if (this.sharedDiv) {\n                this.sharedDiv = null;\n            }\n        }\n    }\n}\nRubberBandHandler.pluginId = 'RubberBandHandler';\nexport default RubberBandHandler;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Client from '../Client';\nimport { PAGE_FORMAT_A4_PORTRAIT } from './Constants';\nimport Rectangle from '../view/geometry/Rectangle';\nimport { getOuterHtml } from './domUtils';\nimport { removeCursors } from './styleUtils';\n/**\n * Returns the scale to be used for printing the graph with the given\n * bounds across the specifies number of pages with the given format. The\n * scale is always computed such that it given the given amount or fewer\n * pages in the print output. See {@link PrintPreview} for an example.\n *\n * @param pageCount Specifies the number of pages in the print output.\n * @param graph {@link Graph} that should be printed.\n * @param pageFormat Optional {@link Rectangle} that specifies the page format.\n * Default is <mxConstants.PAGE_FORMAT_A4_PORTRAIT>.\n * @param border The border along each side of every page.\n */\nexport const getScaleForPageCount = (pageCount, graph, pageFormat, border = 0) => {\n    if (pageCount < 1) {\n        // We can't work with less than 1 page, return no scale\n        // change\n        return 1;\n    }\n    pageFormat =\n        pageFormat != null ? pageFormat : new Rectangle(...PAGE_FORMAT_A4_PORTRAIT);\n    const availablePageWidth = pageFormat.width - border * 2;\n    const availablePageHeight = pageFormat.height - border * 2;\n    // Work out the number of pages required if the\n    // graph is not scaled.\n    const graphBounds = graph.getGraphBounds().clone();\n    const sc = graph.getView().getScale();\n    graphBounds.width /= sc;\n    graphBounds.height /= sc;\n    const graphWidth = graphBounds.width;\n    const graphHeight = graphBounds.height;\n    let scale = 1;\n    // The ratio of the width/height for each printer page\n    const pageFormatAspectRatio = availablePageWidth / availablePageHeight;\n    // The ratio of the width/height for the graph to be printer\n    const graphAspectRatio = graphWidth / graphHeight;\n    // The ratio of horizontal pages / vertical pages for this\n    // graph to maintain its aspect ratio on this page format\n    const pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;\n    // Factor the square root of the page count up and down\n    // by the pages aspect ratio to obtain a horizontal and\n    // vertical page count that adds up to the page count\n    // and has the correct aspect ratio\n    const pageRoot = Math.sqrt(pageCount);\n    const pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);\n    let numRowPages = pageRoot * pagesAspectRatioSqrt;\n    let numColumnPages = pageRoot / pagesAspectRatioSqrt;\n    // These value are rarely more than 2 rounding downs away from\n    // a total that meets the page count. In cases of one being less\n    // than 1 page, the other value can be too high and take more iterations\n    // In this case, just change that value to be the page count, since\n    // we know the other value is 1\n    if (numRowPages < 1 && numColumnPages > pageCount) {\n        const scaleChange = numColumnPages / pageCount;\n        numColumnPages = pageCount;\n        numRowPages /= scaleChange;\n    }\n    if (numColumnPages < 1 && numRowPages > pageCount) {\n        const scaleChange = numRowPages / pageCount;\n        numRowPages = pageCount;\n        numColumnPages /= scaleChange;\n    }\n    let currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n    let numLoops = 0;\n    // Iterate through while the rounded up number of pages comes to\n    // a total greater than the required number\n    while (currentTotalPages > pageCount) {\n        // Round down the page count (rows or columns) that is\n        // closest to its next integer down in percentage terms.\n        // i.e. Reduce the page total by reducing the total\n        // page area by the least possible amount\n        let roundRowDownProportion = Math.floor(numRowPages) / numRowPages;\n        let roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;\n        // If the round down proportion is, work out the proportion to\n        // round down to 1 page less\n        if (roundRowDownProportion == 1) {\n            roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;\n        }\n        if (roundColumnDownProportion == 1) {\n            roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;\n        }\n        // Check which rounding down is smaller, but in the case of very small roundings\n        // try the other dimension instead\n        let scaleChange = 1;\n        // Use the higher of the two values\n        if (roundRowDownProportion > roundColumnDownProportion) {\n            scaleChange = roundRowDownProportion;\n        }\n        else {\n            scaleChange = roundColumnDownProportion;\n        }\n        numRowPages *= scaleChange;\n        numColumnPages *= scaleChange;\n        currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n        numLoops++;\n        if (numLoops > 10) {\n            break;\n        }\n    }\n    // Work out the scale from the number of row pages required\n    // The column pages will give the same value\n    const posterWidth = availablePageWidth * numRowPages;\n    scale = posterWidth / graphWidth;\n    // Allow for rounding errors\n    return scale * 0.99999;\n};\n/**\n * Copies the styles and the markup from the graph's container into the\n * given document and removes all cursor styles. The document is returned.\n *\n * This function should be called from within the document with the graph.\n * If you experience problems with missing stylesheets in IE then try adding\n * the domain to the trusted sites.\n *\n * @param graph {@link Graph} to be copied.\n * @param doc Document where the new graph is created.\n * @param x0 X-coordinate of the graph view origin. Default is 0.\n * @param y0 Y-coordinate of the graph view origin. Default is 0.\n * @param w Optional width of the graph view.\n * @param h Optional height of the graph view.\n */\nexport const show = (graph, doc = null, x0 = 0, y0 = 0, w = null, h = null) => {\n    x0 = x0 != null ? x0 : 0;\n    y0 = y0 != null ? y0 : 0;\n    if (doc == null) {\n        const wnd = window.open();\n        doc = wnd.document;\n    }\n    else {\n        doc.open();\n    }\n    const bounds = graph.getGraphBounds();\n    const dx = Math.ceil(x0 - bounds.x);\n    const dy = Math.ceil(y0 - bounds.y);\n    if (w == null) {\n        w = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);\n    }\n    if (h == null) {\n        h = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);\n    }\n    doc.writeln('<html><head>');\n    const base = document.getElementsByTagName('base');\n    for (let i = 0; i < base.length; i += 1) {\n        doc.writeln(getOuterHtml(base[i]));\n    }\n    const links = document.getElementsByTagName('link');\n    for (let i = 0; i < links.length; i += 1) {\n        doc.writeln(getOuterHtml(links[i]));\n    }\n    const styles = document.getElementsByTagName('style');\n    for (let i = 0; i < styles.length; i += 1) {\n        doc.writeln(getOuterHtml(styles[i]));\n    }\n    doc.writeln('</head><body style=\"margin:0px;\"></body></html>');\n    doc.close();\n    const outer = doc.createElement('div');\n    outer.style.position = 'absolute';\n    outer.style.overflow = 'hidden';\n    outer.style.width = `${w}px`;\n    outer.style.height = `${h}px`;\n    // Required for HTML labels if foreignObjects are disabled\n    const div = doc.createElement('div');\n    div.style.position = 'absolute';\n    div.style.left = `${dx}px`;\n    div.style.top = `${dy}px`;\n    if (graph.container && graph.view.drawPane) {\n        let node = graph.container.firstChild;\n        let svg = null;\n        while (node != null) {\n            const clone = node.cloneNode(true);\n            if (node == graph.view.drawPane.ownerSVGElement) {\n                outer.appendChild(clone);\n                svg = clone;\n            }\n            else {\n                div.appendChild(clone);\n            }\n            node = node.nextSibling;\n        }\n        doc.body.appendChild(outer);\n        if (div.firstChild != null) {\n            doc.body.appendChild(div);\n        }\n        if (svg != null) {\n            svg.style.minWidth = '';\n            svg.style.minHeight = '';\n            if (svg.firstChild)\n                svg.firstChild.setAttribute('transform', `translate(${dx},${dy})`);\n        }\n        removeCursors(doc.body);\n    }\n    return doc;\n};\n/**\n * Prints the specified graph using a new window and the built-in print\n * dialog.\n *\n * This function should be called from within the document with the graph.\n *\n * @param graph {@link Graph} to be printed.\n */\nexport const printScreen = (graph) => {\n    const wnd = window.open();\n    if (!wnd)\n        return;\n    const bounds = graph.getGraphBounds();\n    show(graph, wnd.document);\n    const print = () => {\n        wnd.focus();\n        wnd.print();\n        wnd.close();\n    };\n    // Workaround for Google Chrome which needs a bit of a\n    // delay in order to render the SVG contents\n    if (Client.IS_GC) {\n        wnd.setTimeout(print, 500);\n    }\n    else {\n        print();\n    }\n};\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2019, JGraph Ltd\nCopyright (c) 2006-2019, draw.io AG\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EditorPopupMenu from './EditorPopupMenu';\nimport UndoManager from '../view/undoable_changes/UndoManager';\nimport EditorKeyHandler from './EditorKeyHandler';\nimport EventSource from '../view/event/EventSource';\nimport Translations from '../util/Translations';\nimport Client from '../Client';\nimport CompactTreeLayout from '../view/layout/CompactTreeLayout';\nimport { EditorToolbar } from './EditorToolbar';\nimport StackLayout from '../view/layout/StackLayout';\nimport EventObject from '../view/event/EventObject';\nimport { getOffset } from '../util/styleUtils';\nimport Codec from '../serialization/Codec';\nimport { ModelXmlSerializer } from '../serialization/ModelXmlSerializer';\nimport MaxWindow, { error } from '../gui/MaxWindow';\nimport MaxForm from '../gui/MaxForm';\nimport Outline from '../view/other/Outline';\nimport Cell from '../view/cell/Cell';\nimport Geometry from '../view/geometry/Geometry';\nimport { ALIGN, FONT } from '../util/Constants';\nimport { Graph } from '../view/Graph';\nimport SwimlaneManager from '../view/layout/SwimlaneManager';\nimport LayoutManager from '../view/layout/LayoutManager';\nimport RootChange from '../view/undoable_changes/RootChange';\nimport ValueChange from '../view/undoable_changes/ValueChange';\nimport CellAttributeChange from '../view/undoable_changes/CellAttributeChange';\nimport PrintPreview from '../view/other/PrintPreview';\nimport mxClipboard from '../util/Clipboard';\nimport MaxLog from '../gui/MaxLog';\nimport { isNode } from '../util/domUtils';\nimport { getViewXml, getXml } from '../util/xmlUtils';\nimport { load, post, submit } from '../util/MaxXmlRequest';\nimport RubberBandHandler from '../view/handler/RubberBandHandler';\nimport InternalEvent from '../view/event/InternalEvent';\nimport { show } from '../util/printUtils';\nimport { cloneCell } from '../util/cellArrayUtils';\n// TODO disabled side effects, so editor resources are not loaded by default\n// This should be done in a different way\n/**\n * Installs the required language resources at class\n * loading time.\n */\n/*\nif (mxLoadResources) {\n  mxResources.add(`${Client.basePath}/resources/editor`);\n} else {\n  Client.defaultBundles.push(`${Client.basePath}/resources/editor`);\n}\n */\n/**\n * Extends {@link EventSource} to implement an application wrapper for a graph that\n * adds {@link actions}, I/O using {@link Codec}, auto-layout using {@link LayoutManager},\n * command history using {@link undoManager}, and standard dialogs and widgets, eg.\n * properties, help, outline, toolbar, and popupmenu. It also adds {@link templates}\n * to be used as cells in toolbars, auto-validation using the {@link validation}\n * flag, attribute cycling using {@link cycleAttributeValues}, higher-level events\n * such as {@link root}, and backend integration using <urlPost> and {@link urlImage}.\n *\n * ### Actions:\n *\n * Actions are functions stored in the <actions> array under their names. The\n * functions take the <Editor> as the first, and an optional <Cell> as the\n * second argument and are invoked using <execute>. Any additional arguments\n * passed to execute are passed on to the action as-is.\n *\n * A list of built-in actions is available in the <addActions> description.\n *\n * ### Read/write Diagrams:\n *\n * To read a diagram from an XML string, for example from a textfield within the\n * page, the following code is used:\n *\n * ```javascript\n * var doc = mxUtils.parseXML(xmlString);\n * var node = doc.documentElement;\n * editor.readGraphModel(node);\n * ```\n *\n * For reading a diagram from a remote location, use the {@link open} method.\n *\n * To save diagrams in XML on a server, you can set the {@link urlPost} variable.\n * This variable will be used in {@link getUrlPost} to construct a URL for the post\n * request that is issued in the {@link save} method. The post request contains the\n * XML representation of the diagram as returned by {@link writeGraphModel} in the\n * xml parameter.\n *\n * On the server side, the post request is processed using standard\n * technologies such as Java Servlets, CGI, .NET or ASP.\n *\n * Here are some examples of processing a post request in various languages.\n *\n * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\n\", \"&#xa;\")\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image, but not\n * if the XML is passed back to the client-side.\n *\n * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])\n * - PHP: urldecode($_POST[\"xml\"])\n *\n * ### Creating images:\n *\n * A backend (Java, PHP or C#) is required for creating images. The\n * distribution contains an example for each backend (ImageHandler.java,\n * ImageHandler.cs and graph.php). More information about using a backend\n * to create images can be found in the readme.html files. Note that the\n * preview is implemented using VML/SVG in the browser and does not require\n * a backend. The backend is only required to creates images (bitmaps).\n *\n * ### Special characters:\n *\n * Note There are five characters that should always appear in XML content as\n * escapes, so that they do not interact with the syntax of the markup. These\n * are part of the language for all documents based on XML and for HTML.\n *\n * - &lt; (<)\n * - &gt; (>)\n * - &amp; (&)\n * - &quot; (\")\n * - &apos; (')\n *\n * Although it is part of the XML language, &apos; is not defined in HTML.\n * For this reason the XHTML specification recommends instead the use of\n * &#39; if text may be passed to a HTML user agent.\n *\n * If you are having problems with special characters on the server-side then\n * you may want to try the {@link escapePostData} flag.\n *\n * For converting decimal escape sequences inside strings, a user has provided\n * us with the following function:\n *\n * ```javascript\n * function html2js(text)\n * {\n *   var entitySearch = /&#[0-9]+;/;\n *   var entity;\n *\n *   while (entity = entitySearch.exec(text))\n *   {\n *     var charCode = entity[0].substring(2, entity[0].length -1);\n *     text = text.substring(0, entity.index)\n *            + String.fromCharCode(charCode)\n *            + text.substring(entity.index + entity[0].length);\n *   }\n *\n *   return text;\n * }\n * ```\n *\n * Otherwise try using hex escape sequences and the built-in unescape function\n * for converting such strings.\n *\n * ### Local Files:\n *\n * For saving and opening local files, no standardized method exists that\n * works across all browsers. The recommended way of dealing with local files\n * is to create a backend that streams the XML data back to the browser (echo)\n * as an attachment so that a Save-dialog is displayed on the client-side and\n * the file can be saved to the local disk.\n *\n * For example, in PHP the code that does this looks as follows.\n *\n * ```javascript\n * $xml = stripslashes($_POST[\"xml\"]);\n * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");\n * echo($xml);\n * ```\n *\n * To open a local file, the file should be uploaded via a form in the browser\n * and then opened from the server in the editor.\n *\n * ### Cell Properties:\n *\n * The properties displayed in the properties dialog are the attributes and\n * values of the cell's user object, which is an XML node. The XML node is\n * defined in the templates section of the config file.\n *\n * The templates are stored in {@link Editor.templates} and contain cells which\n * are cloned at insertion time to create new vertices by use of drag and\n * drop from the toolbar. Each entry in the toolbar for adding a new vertex\n * must refer to an existing template.\n *\n * In the following example, the task node is a business object and only the\n * mxCell node and its mxGeometry child contain graph information:\n *\n * ```javascript\n * <Task label=\"Task\" description=\"\">\n *   <Cell vertex=\"true\">\n *     <Geometry as=\"geometry\" width=\"72\" height=\"32\"/>\n *   </Cell>\n * </Task>\n * ```\n *\n * The idea is that the XML representation is inverse from the in-memory\n * representation: The outer XML node is the user object and the inner node is\n * the cell. This means the user object of the cell is the Task node with no\n * children for the above example:\n *\n * ```javascript\n * <Task label=\"Task\" description=\"\"/>\n * ```\n *\n * The Task node can have any tag name, attributes and child nodes. The\n * {@link Codec} will use the XML hierarchy as the user object, while removing the\n * \"known annotations\", such as the mxCell node. At save-time the cell data\n * will be \"merged\" back into the user object. The user object is only modified\n * via the properties dialog during the lifecycle of the cell.\n *\n * In the default implementation of {@link createProperties}, the user object's\n * attributes are put into a form for editing. Attributes are changed using\n * the {@link CellAttributeChange} action in the model. The dialog can be replaced\n * by overriding the {@link createProperties} hook or by replacing the showProperties\n * action in {@link action}. Alternatively, the entry in the config file's popupmenu\n * section can be modified to invoke a different action.\n *\n * If you want to displey the properties dialog on a doubleclick, you can set\n * {@link Editor.dblClickAction} to showProperties as follows:\n *\n * ```javascript\n * editor.dblClickAction = 'showProperties';\n * ```\n *\n * ### Popupmenu and Toolbar:\n *\n * The toolbar and popupmenu are typically configured using the respective\n * sections in the config file, that is, the popupmenu is defined as follows:\n *\n * ```javascript\n * <Editor>\n *   <EditorPopupMenu as=\"popupHandler\">\n * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>\n *      ...\n * ```\n *\n * New entries can be added to the toolbar by inserting an add-node into the\n * above configuration. Existing entries may be removed and changed by\n * modifying or removing the respective entries in the configuration.\n * The configuration is read by the {@link EditorPopupMenuCodec}, the format of the\n * configuration is explained in {@link EditorPopupMenu.decode}.\n *\n * The toolbar is defined in the EditorToolbar section. Items can be added\n * and removed in this section.\n *\n * ```javascript\n * <Editor>\n *   <EditorToolbar>\n *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>\n *     ...\n * ```\n *\n * The format of the configuration is described in {@link EditorToolbarCodec.decode}.\n *\n * Ids:\n *\n * For the IDs, there is an implicit behaviour in {@link Codec}: It moves the Id\n * from the cell to the user object at encoding time and vice versa at decoding\n * time. For example, if the Task node from above has an id attribute, then\n * the {@link Cell.id} of the corresponding cell will have this value. If there\n * is no Id collision in the model, then the cell may be retrieved using this\n * Id with the {@link GraphDataModel.getCell} function. If there is a collision, a new\n * Id will be created for the cell using {@link GraphDataModel.createId}. At encoding\n * time, this new Id will replace the value previously stored under the id\n * attribute in the Task node.\n *\n * See {@link EditorCodec}, {@link EditorToolbarCodec} and {@link EditorPopupMenuCodec}\n * for information about configuring the editor and user interface.\n *\n * Programmatically inserting cells:\n *\n * For inserting a new cell, say, by clicking a button in the document,\n * the following code can be used. This requires an reference to the editor.\n *\n * ```javascript\n * var userObject = new Object();\n * var parent = editor.graph.getDefaultParent();\n * var model = editor.graph.model;\n * model.beginUpdate();\n * try\n * {\n *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * ```\n *\n * If a template cell from the config file should be inserted, then a clone\n * of the template can be created as follows. The clone is then inserted using\n * the add function instead of addVertex.\n *\n * ```javascript\n * var template = editor.templates['task'];\n * var clone = cloneCell(template);\n * ```\n *\n * #### Translations:\n *\n * resources/editor - Language resources for Editor\n *\n * #### Callback: onInit\n *\n * Called from within the constructor. In the callback,\n * \"this\" refers to the editor instance.\n *\n * #### Cookie: mxgraph=seen\n *\n * Set when the editor is started. Never expires. Use\n * {@link resetFirstTime} to reset this cookie. This cookie\n * only exists if {@link onInit} is implemented.\n *\n * #### Event: mxEvent.OPEN\n *\n * Fires after a file was opened in {@link open}. The <code>filename</code> property\n * contains the filename that was used. The same value is also available in\n * {@link filename}.\n *\n * #### Event: mxEvent.SAVE\n *\n * Fires after the current file was saved in {@link save}. The <code>url</code>\n * property contains the URL that was used for saving.\n *\n * #### Event: mxEvent.POST\n *\n * Fires if a successful response was received in {@link postDiagram}. The\n * <code>request</code> property contains the <MaxXmlRequest>, the\n * <code>url</code> and <code>data</code> properties contain the URL and the\n * data that were used in the post request.\n *\n * #### Event: mxEvent.ROOT\n *\n * Fires when the current root has changed, or when the title of the current\n * root has changed. This event has no properties.\n *\n * #### Event: mxEvent.BEFORE_ADD_VERTEX\n *\n * Fires before a vertex is added in {@link addVertex}. The <code>vertex</code>\n * property contains the new vertex and the <code>parent</code> property\n * contains its parent.\n *\n * #### Event: mxEvent.ADD_VERTEX\n *\n * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>\n * property contains the vertex that is being inserted.\n *\n * #### Event: mxEvent.AFTER_ADD_VERTEX\n *\n * Fires after a vertex was inserted and selected in <addVertex>. The\n * <code>vertex</code> property contains the new vertex.\n *\n * ### Example:\n *\n * For starting an in-place edit after a new vertex has been added to the\n * graph, the following code can be used.\n *\n * ```javascript\n * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)\n * {\n *   var vertex = evt.getProperty('vertex');\n *\n *   if (editor.graph.isCellEditable(vertex))\n *   {\n *   \teditor.graph.startEditingAtCell(vertex);\n *   }\n * });\n * ```\n *\n * ### Event: mxEvent.ESCAPE\n *\n * Fires when the escape key is pressed. The <code>event</code> property\n * contains the key event.\n *\n * ### Constructor: Editor\n *\n * Constructs a new editor. This function invokes the {@link onInit} callback\n * upon completion.\n *\n * ```javascript\n * var config = mxUtils.load('config/diagrameditor.xml').getDocumentElement();\n * var editor = new Editor(config);\n * ```\n *\n * @class Editor\n * @extends EventSource\n */\nexport class Editor extends EventSource {\n    constructor(config) {\n        super();\n        this.onInit = null;\n        this.lastSnapshot = null;\n        this.ignoredChanges = null;\n        this.rubberband = null;\n        this.isActive = null;\n        this.destroyed = false;\n        /**\n         * Specifies the resource key for the zoom dialog. If the resource for this\n         * key does not exist then the value is used as the error message. Default is 'askZoom'.\n         * @default 'askZoom'\n         */\n        // askZoomResource: 'askZoom' | '';\n        this.askZoomResource = Client.language !== 'none' ? 'askZoom' : '';\n        /**\n         * Group: Controls and Handlers\n         */\n        /**\n         * Specifies the resource key for the last saved info. If the resource for\n         * this key does not exist then the value is used as the error message. Default is 'lastSaved'.\n         * @default 'lastSaved'.\n         */\n        this.lastSavedResource = Client.language !== 'none' ? 'lastSaved' : '';\n        /**\n         * Specifies the resource key for the current file info. If the resource for\n         * this key does not exist then the value is used as the error message. Default is 'currentFile'.\n         * @default 'currentFile'\n         */\n        this.currentFileResource = Client.language !== 'none' ? 'currentFile' : '';\n        /**\n         * Specifies the resource key for the properties window title. If the\n         * resource for this key does not exist then the value is used as the\n         * error message. Default is 'properties'.\n         * @default 'properties'\n         */\n        this.propertiesResource = Client.language !== 'none' ? 'properties' : '';\n        /**\n         * Specifies the resource key for the tasks window title. If the\n         * resource for this key does not exist then the value is used as the\n         * error message. Default is 'tasks'.\n         * @default 'tasks'\n         */\n        this.tasksResource = Client.language !== 'none' ? 'tasks' : '';\n        /**\n         * Specifies the resource key for the help window title. If the\n         * resource for this key does not exist then the value is used as the\n         * error message. Default is 'help'.\n         * @default 'help'\n         */\n        this.helpResource = Client.language !== 'none' ? 'help' : '';\n        /**\n         * Specifies the resource key for the outline window title. If the\n         * resource for this key does not exist then the value is used as the\n         * error message. Default is 'outline'.\n         * @default 'outline'\n         */\n        this.outlineResource = Client.language !== 'none' ? 'outline' : '';\n        /**\n         * Reference to the {@link MaxWindow} that contains the outline. The {@link outline}\n         * is stored in outline.outline.\n         */\n        this.outline = null;\n        /**\n         * Holds the render hint used for creating the\n         * graph in {@link setGraphContainer}. See {@link graph}. Default is null.\n         * @default null\n         */\n        this.graphRenderHint = null;\n        /**\n         * Holds a {@link EditorToolbar} for displaying the toolbar. The\n         * toolbar is created in {@link setToolbarContainer}.\n         */\n        this.toolbar = null;\n        /**\n         * DOM container that holds the statusbar.\n         * Use {@link setStatusContainer} to set this value.\n         */\n        this.status = null;\n        /**\n         * Holds a {@link EditorPopupMenu} for displaying popupmenus.\n         */\n        this.popupHandler = null;\n        /**\n         * Holds an {@link UndoManager} for the command history.\n         */\n        this.undoManager = null;\n        /**\n         * Holds a {@link EditorKeyHandler} for handling keyboard events.\n         * The handler is created in {@link setGraphContainer}.\n         */\n        this.keyHandler = null;\n        /**\n         * Maps from actionnames to actions, which are functions taking\n         * the editor and the cell as arguments. Use {@link addAction}\n         * to add or replace an action and {@link execute} to execute an action\n         * by name, passing the cell to be operated upon as the second\n         * argument.\n         */\n        this.actions = {};\n        /**\n         * Group: Actions and Options\n         */\n        /**\n         * Specifies the name of the action to be executed\n         * when a cell is double clicked. Default is 'edit'.\n         *\n         * To handle a singleclick, use the following code.\n         *\n         * @example\n         * ```javascript\n         * editor.graph.addListener(mxEvent.CLICK, function(sender, evt)\n         * {\n         *   var e = evt.getProperty('event');\n         *   var cell = evt.getProperty('cell');\n         *\n         *   if (cell != null && !e.isConsumed())\n         *   {\n         *     // Do something useful with cell...\n         *     e.consume();\n         *   }\n         * });\n         * ```\n         * @default 'edit'\n         */\n        this.dblClickAction = 'edit';\n        /**\n         * Specifies if new cells must be inserted\n         * into an existing swimlane. Otherwise, cells\n         * that are not swimlanes can be inserted as\n         * top-level cells. Default is false.\n         * @default false\n         */\n        this.swimlaneRequired = false;\n        /**\n         * Specifies if the context menu should be disabled in the graph container.\n         * Default is true.\n         * @default true\n         */\n        this.disableContextMenu = true;\n        /**\n         * Specifies the function to be used for inserting new\n         * cells into the graph. This is assigned from the\n         * {@link EditorToolbar} if a vertex-tool is clicked.\n         */\n        this.insertFunction = null;\n        /**\n         * Group: Templates\n         */\n        /**\n         * Specifies if a new cell should be inserted on a single\n         * click even using {@link insertFunction} if there is a cell\n         * under the mousepointer, otherwise the cell under the\n         * mousepointer is selected. Default is false.\n         * @default false\n         */\n        this.forcedInserting = false;\n        /**\n         * Maps from names to protoype cells to be used\n         * in the toolbar for inserting new cells into\n         * the diagram.\n         */\n        this.templates = null;\n        /**\n         * Prototype edge cell that is used for creating new edges.\n         */\n        this.defaultEdge = null;\n        /**\n         * Specifies the edge style to be returned in {@link getEdgeStyle}. Default is null.\n         * @default null\n         */\n        this.defaultEdgeStyle = null;\n        /**\n         * Prototype group cell that is used for creating new groups.\n         */\n        this.defaultGroup = null;\n        /**\n         * Default size for the border of new groups. If null,\n         * then then {@link Graph#gridSize} is used. Default is null.\n         * @default null\n         */\n        this.groupBorderSize = null;\n        /**\n         * Contains the URL of the last opened file as a string. Default is null.\n         * @default null\n         */\n        this.filename = null;\n        /**\n         * Group: Backend Integration\n         */\n        /**\n         * Character to be used for encoding linefeeds in {@link save}. Default is '&#xa;'.\n         * @default '&#xa;'\n         */\n        this.linefeed = '&#xa;';\n        /**\n         * Specifies if the name of the post parameter that contains the diagram\n         * data in a post request to the server. Default is 'xml'.\n         * @default 'xml'\n         */\n        this.postParameterName = 'xml';\n        /**\n         * Specifies if the data in the post request for saving a diagram\n         * should be converted using encodeURIComponent. Default is true.\n         * @default true\n         */\n        this.escapePostData = true;\n        /**\n         * Specifies the URL to be used for posting the diagram\n         * to a backend in {@link save}.\n         * @default null\n         */\n        this.urlPost = null;\n        /**\n         * Specifies the URL to be used for creating a bitmap of\n         * the graph in the image action.\n         * @default null\n         */\n        this.urlImage = null;\n        /**\n         * Specifies the direction of the flow\n         * in the diagram. This is used in the\n         * layout algorithms. Default is false,\n         * ie. vertical flow.\n         * @default false\n         */\n        this.horizontalFlow = false;\n        /**\n         * Group: Autolayout\n         */\n        /**\n         * Specifies if the top-level elements in the\n         * diagram should be layed out using a vertical\n         * or horizontal stack depending on the setting\n         * of {@link horizontalFlow}. The spacing between the\n         * swimlanes is specified by {@link swimlaneSpacing}.\n         * Default is false.\n         *\n         * If the top-level elements are swimlanes, then\n         * the intra-swimlane layout is activated by\n         * the {@link layoutSwimlanes} switch.\n         * @default false\n         */\n        this.layoutDiagram = false;\n        /**\n         * Specifies the spacing between swimlanes if\n         * automatic layout is turned on in\n         * {@link layoutDiagram}. Default is 0.\n         * @default 0\n         */\n        this.swimlaneSpacing = 0;\n        /**\n         * Specifies if the swimlanes should be kept at the same\n         * width or height depending on the setting of\n         * {@link horizontalFlow}. Default is false.\n         *\n         * For horizontal flows, all swimlanes\n         * have the same height and for vertical flows, all swimlanes\n         * have the same width. Furthermore, the swimlanes are\n         * automatically \"stacked\" if {@link layoutDiagram} is true.\n         * @default false\n         */\n        this.maintainSwimlanes = false;\n        /**\n         * Specifies if the children of swimlanes should\n         * be layed out, either vertically or horizontally\n         * depending on {@link horizontalFlow}. Default is false.\n         * @default false\n         */\n        this.layoutSwimlanes = false;\n        /**\n         * Specifies the attribute values to be cycled when inserting new swimlanes.\n         * Default is an empty array.\n         * @default any[]\n         */\n        this.cycleAttributeValues = [];\n        /**\n         * Group: Attribute Cycling\n         */\n        /**\n         * Index of the last consumed attribute index. If a new\n         * swimlane is inserted, then the {@link cycleAttributeValues}\n         * at this index will be used as the value for\n         * {@link cycleAttributeName}. Default is 0.\n         * @default 0\n         */\n        this.cycleAttributeIndex = 0;\n        /**\n         * Name of the attribute to be assigned a {@link cycleAttributeValues}\n         * when inserting new swimlanes. Default is 'fillColor'.\n         * @default 'fillColor'\n         */\n        // cycleAttributeName: 'fillColor';\n        this.cycleAttributeName = 'fillColor';\n        /**\n         * Holds the [@link MaxWindow} created in {@link showTasks}.\n         */\n        this.tasks = null;\n        /**\n         * Group: Windows\n         */\n        /**\n         * Icon for the tasks window.\n         */\n        this.tasksWindowImage = null;\n        /**\n         * Specifies the top coordinate of the tasks window in pixels. Default is 20.\n         * @default 20\n         */\n        this.tasksTop = 20;\n        /**\n         * Holds the {@link MaxWindow} created in {@link showHelp}\n         */\n        this.help = null;\n        /**\n         * Icon for the help window.\n         */\n        this.helpWindowImage = null;\n        /**\n         * Specifies the URL to be used for the contents of the\n         * Online Help window. This is usually specified in the\n         * resources file under urlHelp for language-specific\n         * online help support.\n         */\n        this.urlHelp = null;\n        /**\n         * Specifies the width of the help window in pixels. Default is 300.\n         * @default 300\n         */\n        this.helpWidth = 300;\n        /**\n         * Specifies the height of the help window in pixels. Default is 260.\n         * @default 260\n         */\n        // helpHeight: number;\n        this.helpHeight = 260;\n        /**\n         * Specifies the width of the properties window in pixels. Default is 240.\n         * @default 240\n         */\n        this.propertiesWidth = 240;\n        /**\n         * Specifies the height of the properties window in pixels.\n         * If no height is specified then the window will be automatically\n         * sized to fit its contents. Default is null.\n         * @default null\n         */\n        this.propertiesHeight = null;\n        /**\n         * Specifies if the properties dialog should be automatically\n         * moved near the cell it is displayed for, otherwise the\n         * dialog is not moved. This value is only taken into\n         * account if the dialog is already visible. Default is false.\n         * @default false\n         */\n        this.movePropertiesDialog = false;\n        /**\n         * Specifies if {@link Graph.validateGraph} should automatically be invoked after\n         * each change. Default is false.\n         * @default false\n         */\n        this.validating = false;\n        /**\n         * True if the graph has been modified since it was last saved.\n         */\n        this.modified = false;\n        this.actions = {};\n        this.addActions();\n        // Executes the following only if a document has been instanciated.\n        // That is, don't execute when the editorcodec is setup.\n        if (document.body != null) {\n            // Defines instance fields\n            this.cycleAttributeValues = [];\n            this.popupHandler = new EditorPopupMenu();\n            this.undoManager = new UndoManager();\n            // Creates the graph and toolbar without the containers\n            this.graph = this.createGraph();\n            this.toolbar = this.createToolbar();\n            // Creates the global keyhandler (requires graph instance)\n            this.keyHandler = new EditorKeyHandler(this);\n            // Configures the editor using the URI\n            // which was passed to the ctor\n            this.configure(config);\n            // Assigns the swimlaneIndicatorColorAttribute on the graph\n            this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;\n            // Checks if the <onInit> hook has been set\n            if (this.onInit != null) {\n                // Invokes the <onInit> hook\n                this.onInit();\n            }\n        }\n    }\n    /**\n     * Returns {@link modified}.\n     */\n    isModified() {\n        return this.modified;\n    }\n    /**\n     * Sets {@link modified} to the specified boolean value.\n     * @param value\n     */\n    setModified(value) {\n        this.modified = value;\n    }\n    /**\n     * Adds the built-in actions to the editor instance.\n     * save - Saves the graph using <urlPost>.\n     * print - Shows the graph in a new print preview window.\n     * show - Shows the graph in a new window.\n     * exportImage - Shows the graph as a bitmap image using <getUrlImage>.\n     * refresh - Refreshes the graph's display.\n     * cut - Copies the current selection into the clipboard\n     * and removes it from the graph.\n     * copy - Copies the current selection into the clipboard.\n     * paste - Pastes the clipboard into the graph.\n     * delete - Removes the current selection from the graph.\n     * group - Puts the current selection into a new group.\n     * ungroup - Removes the selected groups and selects the children.\n     * undo - Undoes the last change on the graph model.\n     * redo - Redoes the last change on the graph model.\n     * zoom - Sets the zoom via a dialog.\n     * zoomIn - Zooms into the graph.\n     * zoomOut - Zooms out of the graph\n     * actualSize - Resets the scale and translation on the graph.\n     * fit - Changes the scale so that the graph fits into the window.\n     * showProperties - Shows the properties dialog.\n     * selectAll - Selects all cells.\n     * selectNone - Clears the selection.\n     * selectVertices - Selects all vertices.\n     * selectEdges = Selects all edges.\n     * edit - Starts editing the current selection cell.\n     * enterGroup - Drills down into the current selection cell.\n     * exitGroup - Moves up in the drilling hierachy\n     * home - Moves to the topmost parent in the drilling hierarchy\n     * selectPrevious - Selects the previous cell.\n     * selectNext - Selects the next cell.\n     * selectParent - Selects the parent of the selection cell.\n     * selectChild - Selects the first child of the selection cell.\n     * collapse - Collapses the currently selected cells.\n     * expand - Expands the currently selected cells.\n     * bold - Toggle bold text style.\n     * italic - Toggle italic text style.\n     * underline - Toggle underline text style.\n     * alignCellsLeft - Aligns the selection cells at the left.\n     * alignCellsCenter - Aligns the selection cells in the center.\n     * alignCellsRight - Aligns the selection cells at the right.\n     * alignCellsTop - Aligns the selection cells at the top.\n     * alignCellsMiddle - Aligns the selection cells in the middle.\n     * alignCellsBottom - Aligns the selection cells at the bottom.\n     * alignFontLeft - Sets the horizontal text alignment to left.\n     * alignFontCenter - Sets the horizontal text alignment to center.\n     * alignFontRight - Sets the horizontal text alignment to right.\n     * alignFontTop - Sets the vertical text alignment to top.\n     * alignFontMiddle - Sets the vertical text alignment to middle.\n     * alignFontBottom - Sets the vertical text alignment to bottom.\n     * toggleTasks - Shows or hides the tasks window.\n     * toggleHelp - Shows or hides the help window.\n     * toggleOutline - Shows or hides the outline window.\n     * toggleConsole - Shows or hides the console window.\n     */\n    addActions() {\n        this.addAction('save', (editor) => {\n            editor.save();\n        });\n        this.addAction('print', (editor) => {\n            const preview = new PrintPreview(editor.graph, 1);\n            preview.open();\n        });\n        this.addAction('show', (editor) => {\n            show(editor.graph, null, 10, 10);\n        });\n        this.addAction('exportImage', (editor) => {\n            const url = editor.getUrlImage();\n            if (url == null || Client.IS_LOCAL) {\n                editor.execute('show');\n            }\n            else {\n                const node = getViewXml(editor.graph, 1);\n                const xml = getXml(node, '\\n');\n                submit(url, `${editor.postParameterName}=${encodeURIComponent(xml)}`, document, '_blank');\n            }\n        });\n        this.addAction('refresh', (editor) => {\n            editor.graph.refresh();\n        });\n        this.addAction('cut', (editor) => {\n            if (editor.graph.isEnabled()) {\n                mxClipboard.cut(editor.graph);\n            }\n        });\n        this.addAction('copy', (editor) => {\n            if (editor.graph.isEnabled()) {\n                mxClipboard.copy(editor.graph);\n            }\n        });\n        this.addAction('paste', (editor) => {\n            if (editor.graph.isEnabled()) {\n                mxClipboard.paste(editor.graph);\n            }\n        });\n        this.addAction('delete', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.removeCells();\n            }\n        });\n        this.addAction('group', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setSelectionCell(editor.groupCells());\n            }\n        });\n        this.addAction('ungroup', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setSelectionCells(editor.graph.ungroupCells());\n            }\n        });\n        this.addAction('removeFromParent', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.removeCellsFromParent();\n            }\n        });\n        this.addAction('undo', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.undo();\n            }\n        });\n        this.addAction('redo', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.redo();\n            }\n        });\n        this.addAction('zoomIn', (editor) => {\n            editor.graph.zoomIn();\n        });\n        this.addAction('zoomOut', (editor) => {\n            editor.graph.zoomOut();\n        });\n        this.addAction('actualSize', (editor) => {\n            editor.graph.zoomActual();\n        });\n        this.addAction('fit', (editor) => {\n            editor.graph.fit();\n        });\n        this.addAction('showProperties', (editor, cell) => {\n            editor.showProperties(cell);\n        });\n        this.addAction('selectAll', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectAll();\n            }\n        });\n        this.addAction('selectNone', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.clearSelection();\n            }\n        });\n        this.addAction('selectVertices', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectVertices();\n            }\n        });\n        this.addAction('selectEdges', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectEdges();\n            }\n        });\n        this.addAction('edit', (editor, cell) => {\n            if (editor.graph.isEnabled() && editor.graph.isCellEditable(cell)) {\n                editor.graph.startEditingAtCell(cell);\n            }\n        });\n        this.addAction('toBack', (editor, cell) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.orderCells(true);\n            }\n        });\n        this.addAction('toFront', (editor, cell) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.orderCells(false);\n            }\n        });\n        this.addAction('enterGroup', (editor, cell) => {\n            editor.graph.enterGroup(cell);\n        });\n        this.addAction('exitGroup', (editor) => {\n            editor.graph.exitGroup();\n        });\n        this.addAction('home', (editor) => {\n            editor.graph.home();\n        });\n        this.addAction('selectPrevious', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectPreviousCell();\n            }\n        });\n        this.addAction('selectNext', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectNextCell();\n            }\n        });\n        this.addAction('selectParent', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectParentCell();\n            }\n        });\n        this.addAction('selectChild', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.selectChildCell();\n            }\n        });\n        this.addAction('collapse', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.foldCells(true);\n            }\n        });\n        this.addAction('collapseAll', (editor) => {\n            if (editor.graph.isEnabled()) {\n                const cells = editor.graph.getChildVertices();\n                editor.graph.foldCells(true, false, cells);\n            }\n        });\n        this.addAction('expand', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.foldCells(false);\n            }\n        });\n        this.addAction('expandAll', (editor) => {\n            if (editor.graph.isEnabled()) {\n                const cells = editor.graph.getChildVertices();\n                editor.graph.foldCells(false, false, cells);\n            }\n        });\n        this.addAction('bold', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.toggleCellStyleFlags('fontStyle', FONT.BOLD);\n            }\n        });\n        this.addAction('italic', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.toggleCellStyleFlags('fontStyle', FONT.ITALIC);\n            }\n        });\n        this.addAction('underline', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.toggleCellStyleFlags('fontStyle', FONT.UNDERLINE);\n            }\n        });\n        this.addAction('alignCellsLeft', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.LEFT);\n            }\n        });\n        this.addAction('alignCellsCenter', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.CENTER);\n            }\n        });\n        this.addAction('alignCellsRight', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.RIGHT);\n            }\n        });\n        this.addAction('alignCellsTop', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.TOP);\n            }\n        });\n        this.addAction('alignCellsMiddle', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.MIDDLE);\n            }\n        });\n        this.addAction('alignCellsBottom', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.alignCells(ALIGN.BOTTOM);\n            }\n        });\n        this.addAction('alignFontLeft', (editor) => {\n            editor.graph.setCellStyles('align', ALIGN.LEFT);\n        });\n        this.addAction('alignFontCenter', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setCellStyles('align', ALIGN.CENTER);\n            }\n        });\n        this.addAction('alignFontRight', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setCellStyles('align', ALIGN.RIGHT);\n            }\n        });\n        this.addAction('alignFontTop', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setCellStyles('verticalAlign', ALIGN.TOP);\n            }\n        });\n        this.addAction('alignFontMiddle', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setCellStyles('verticalAlign', ALIGN.MIDDLE);\n            }\n        });\n        this.addAction('alignFontBottom', (editor) => {\n            if (editor.graph.isEnabled()) {\n                editor.graph.setCellStyles('verticalAlign', ALIGN.BOTTOM);\n            }\n        });\n        this.addAction('zoom', (editor) => {\n            const current = editor.graph.getView().scale * 100;\n            const preInput = prompt(Translations.get(editor.askZoomResource) || editor.askZoomResource, String(current));\n            if (preInput) {\n                const scale = parseFloat(preInput) / 100;\n                if (!isNaN(scale)) {\n                    editor.graph.getView().setScale(scale);\n                }\n            }\n        });\n        this.addAction('toggleTasks', (editor) => {\n            if (editor.tasks != null) {\n                editor.tasks.setVisible(!editor.tasks.isVisible());\n            }\n            else {\n                editor.showTasks();\n            }\n        });\n        this.addAction('toggleHelp', (editor) => {\n            if (editor.help != null) {\n                editor.help.setVisible(!editor.help.isVisible());\n            }\n            else {\n                editor.showHelp();\n            }\n        });\n        this.addAction('toggleOutline', (editor) => {\n            if (editor.outline == null) {\n                editor.showOutline();\n            }\n            else {\n                editor.outline.setVisible(!editor.outline.isVisible());\n            }\n        });\n        this.addAction('toggleConsole', (editor) => {\n            MaxLog.setVisible(!MaxLog.isVisible());\n        });\n    }\n    /**\n     * Configures the editor using the specified node. To load the\n     * configuration from a given URL the following code can be used to obtain\n     * the XML node.\n     *\n     * @example\n     * ```javascript\n     * var node = mxUtils.load(url).getDocumentElement();\n     * ```\n     * @param node XML node that contains the configuration.\n     */\n    configure(node) {\n        if (node != null) {\n            // Creates a decoder for the XML data\n            // and uses it to configure the editor\n            const dec = new Codec(node.ownerDocument);\n            dec.decode(node, this);\n            // Resets the counters, modified state and\n            // command history\n            this.resetHistory();\n        }\n    }\n    /**\n     * Resets the cookie that is used to remember if the editor has already been used.\n     */\n    resetFirstTime() {\n        document.cookie = 'mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/';\n    }\n    /**\n     * Resets the command history, modified state and counters.\n     */\n    resetHistory() {\n        this.lastSnapshot = new Date().getTime();\n        this.undoManager.clear();\n        this.ignoredChanges = 0;\n        this.setModified(false);\n    }\n    /**\n     * Binds the specified actionname to the specified function.\n     *\n     * @example\n     * ```javascript\n     * editor.addAction('test', function(editor: Editor, cell: Cell)\n     * {\n     * \t\tmxUtils.alert(\"test \"+cell);\n     * });\n     * ```\n     * @param actionname String that specifies the name of the action to be added.\n     * @param funct Function that implements the new action. The first argument\n     * of the function is the editor it is used with,\n     * the second argument is the cell it operates upon.\n     */\n    addAction(actionname, funct) {\n        this.actions[actionname] = funct;\n    }\n    /**\n     * Executes the function with the given name in {@link actions} passing the\n     * editor instance and given cell as the first and second argument. All\n     * additional arguments are passed to the action as well. This method\n     * contains a try-catch block and displays an error message if an action\n     * causes an exception. The exception is re-thrown after the error\n     * message was displayed.\n     *\n     * @example\n     * ```javascript\n     * editor.execute(\"showProperties\", cell);\n     * ```\n     * @param actionname\n     * @param cell\n     * @param evt\n     */\n    execute(actionname, cell = null, evt = null) {\n        const action = this.actions[actionname];\n        if (action != null) {\n            try {\n                // Creates the array of arguments by replacing the actionname\n                // with the editor instance in the args of this function\n                const args = [this, cell, evt];\n                // Invokes the function on the editor using the args\n                action.apply(this, args);\n            }\n            catch (e) {\n                error(`Cannot execute ${actionname}: ${e.message}`, 280, true);\n                throw e;\n            }\n        }\n        else {\n            error(`Cannot find action ${actionname}`, 280, true);\n        }\n    }\n    /**\n     * Adds the specified template under the given name in {@link templates}.\n     * @param name\n     * @param template\n     */\n    addTemplate(name, template) {\n        this.templates[name] = template;\n    }\n    /**\n     * Returns the template for the given name.\n     * @param name\n     */\n    getTemplate(name) {\n        return this.templates[name];\n    }\n    /**\n     * Creates the {@link graph} for the editor. The graph is created with no\n     * container and is initialized from {@link setGraphContainer}.\n     * @returns graph instance\n     */\n    createGraph() {\n        const __dummy = undefined;\n        const graph = new Graph(__dummy);\n        // Enables rubberband, tooltips, panning\n        graph.setTooltips(true);\n        graph.setPanning(true);\n        // Overrides the dblclick method on the graph to\n        // invoke the dblClickAction for a cell and reset\n        // the selection tool in the toolbar\n        this.installDblClickHandler(graph);\n        // Installs the command history\n        this.installUndoHandler(graph);\n        // Installs the handlers for the root event\n        this.installDrillHandler(graph);\n        // Installs the handler for validation\n        this.installChangeHandler(graph);\n        // Installs the handler for calling the\n        // insert function and consume the\n        // event if an insert function is defined\n        this.installInsertHandler(graph);\n        // Redirects the function for creating the popupmenu items\n        const popupMenuHandler = graph.getPlugin('PopupMenuHandler');\n        if (popupMenuHandler) {\n            popupMenuHandler.factoryMethod = (menu, cell, evt) => {\n                return this.createPopupMenu(menu, cell, evt);\n            };\n        }\n        // Redirects the function for creating new connections in the diagram\n        const connectionHandler = graph.getPlugin('ConnectionHandler');\n        if (connectionHandler) {\n            connectionHandler.factoryMethod = (source, target) => {\n                return this.createEdge(source, target);\n            };\n        }\n        // Maintains swimlanes and installs autolayout\n        this.createSwimlaneManager(graph);\n        this.createLayoutManager(graph);\n        return graph;\n    }\n    /**\n     * Sets the graph's container using [@link mxGraph.init}.\n     * @param graph\n     * @returns SwimlaneManager instance\n     */\n    createSwimlaneManager(graph) {\n        const swimlaneMgr = new SwimlaneManager(graph, false);\n        swimlaneMgr.isHorizontal = () => {\n            return this.horizontalFlow;\n        };\n        swimlaneMgr.isEnabled = () => {\n            return this.maintainSwimlanes;\n        };\n        return swimlaneMgr;\n    }\n    /**\n     * Creates a layout manager for the swimlane and diagram layouts, that\n     * is, the locally defined inter and intraswimlane layouts.\n     * @param graph\n     * @returns LayoutManager instance\n     */\n    createLayoutManager(graph) {\n        const layoutMgr = new LayoutManager(graph);\n        layoutMgr.getLayout = (cell) => {\n            let layout = null;\n            const model = this.graph.getDataModel();\n            if (cell.getParent() != null) {\n                // Executes the swimlane layout if a child of\n                // a swimlane has been changed. The layout is\n                // lazy created in createSwimlaneLayout.\n                if (this.layoutSwimlanes && graph.isSwimlane(cell)) {\n                    if (this.swimlaneLayout == null) {\n                        this.swimlaneLayout = this.createSwimlaneLayout();\n                    }\n                    layout = this.swimlaneLayout;\n                }\n                // Executes the diagram layout if the modified\n                // cell is a top-level cell. The layout is\n                // lazy created in createDiagramLayout.\n                else if (this.layoutDiagram &&\n                    (graph.isValidRoot(cell) || cell.getParent().getParent() == null)) {\n                    if (this.diagramLayout == null) {\n                        this.diagramLayout = this.createDiagramLayout();\n                    }\n                    layout = this.diagramLayout;\n                }\n            }\n            return layout;\n        };\n        return layoutMgr;\n    }\n    /**\n     * Sets the graph's container using {@link graph.init}.\n     * @param container\n     */\n    setGraphContainer(container) {\n        if (this.graph.container == null) {\n            // Creates the graph instance inside the given container and render hint\n            // this.graph = new mxGraph(container, null, this.graphRenderHint);\n            // @ts-ignore  TODO: FIXME!! ==============================================================================================\n            this.graph.init(container);\n            // Install rubberband selection as the last\n            // action handler in the chain\n            this.rubberband = new RubberBandHandler(this.graph);\n            // Disables the context menu\n            if (this.disableContextMenu) {\n                InternalEvent.disableContextMenu(container);\n            }\n        }\n    }\n    /**\n     * Overrides {@link graph.dblClick} to invoke {@link dblClickAction}\n     * on a cell and reset the selection tool in the toolbar.\n     * @param graph\n     */\n    installDblClickHandler(graph) {\n        // Installs a listener for double click events\n        graph.addListener(InternalEvent.DOUBLE_CLICK, (sender, evt) => {\n            const cell = evt.getProperty('cell');\n            if (cell != null && graph.isEnabled() && this.dblClickAction != null) {\n                this.execute(this.dblClickAction, cell);\n                evt.consume();\n            }\n        });\n    }\n    /**\n     * Adds the {@link undoManager} to the graph model and the view.\n     * @param graph\n     */\n    installUndoHandler(graph) {\n        const listener = (sender, evt) => {\n            const edit = evt.getProperty('edit');\n            this.undoManager.undoableEditHappened(edit);\n        };\n        graph.getDataModel().addListener(InternalEvent.UNDO, listener);\n        graph.getView().addListener(InternalEvent.UNDO, listener);\n        // Keeps the selection state in sync\n        const undoHandler = (sender, evt) => {\n            const { changes } = evt.getProperty('edit');\n            graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n        };\n        this.undoManager.addListener(InternalEvent.UNDO, undoHandler);\n        this.undoManager.addListener(InternalEvent.REDO, undoHandler);\n    }\n    /**\n     * Installs listeners for dispatching the {@link root} event.\n     * @param graph\n     */\n    installDrillHandler(graph) {\n        const listener = (sender) => {\n            this.fireEvent(new EventObject(InternalEvent.ROOT));\n        };\n        graph.getView().addListener(InternalEvent.DOWN, listener);\n        graph.getView().addListener(InternalEvent.UP, listener);\n    }\n    /**\n     * Installs the listeners required to automatically validate\n     * the graph. On each change of the root, this implementation\n     * fires a {@link root} event.\n     * @param graph\n     */\n    installChangeHandler(graph) {\n        const listener = (sender, evt) => {\n            // Updates the modified state\n            this.setModified(true);\n            // Automatically validates the graph\n            // after each change\n            if (this.validating == true) {\n                graph.validateGraph();\n            }\n            // Checks if the root has been changed\n            const { changes } = evt.getProperty('edit');\n            for (let i = 0; i < changes.length; i += 1) {\n                const change = changes[i];\n                if (change instanceof RootChange ||\n                    (change instanceof ValueChange && change.cell === this.graph.model.root) ||\n                    (change instanceof CellAttributeChange && change.cell === this.graph.model.root)) {\n                    this.fireEvent(new EventObject(InternalEvent.ROOT));\n                    break;\n                }\n            }\n        };\n        graph.getDataModel().addListener(InternalEvent.CHANGE, listener);\n    }\n    /**\n     * Installs the handler for invoking {@link insertFunction} if one is defined.\n     * @param graph\n     */\n    installInsertHandler(graph) {\n        const insertHandler = {\n            mouseDown: (sender, me) => {\n                if (this.insertFunction != null &&\n                    !me.isPopupTrigger() &&\n                    (this.forcedInserting || me.getState() == null)) {\n                    this.graph.clearSelection();\n                    this.insertFunction(me.getEvent(), me.getCell());\n                    // Consumes the rest of the events\n                    // for this gesture (down, move, up)\n                    this.isActive = true;\n                    me.consume();\n                }\n            },\n            mouseMove: (sender, me) => {\n                if (this.isActive) {\n                    me.consume();\n                }\n            },\n            mouseUp: (sender, me) => {\n                if (this.isActive) {\n                    this.isActive = false;\n                    me.consume();\n                }\n            },\n        };\n        graph.addMouseListener(insertHandler);\n    }\n    /**\n     * Creates the layout instance used to layout the\n     * swimlanes in the diagram.\n     * @returns StackLayout instance\n     */\n    createDiagramLayout() {\n        const gs = this.graph.gridSize;\n        const layout = new StackLayout(this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * gs, 2 * gs);\n        // Overrides isIgnored to only take into account swimlanes\n        layout.isVertexIgnored = (cell) => {\n            return !layout.graph.isSwimlane(cell);\n        };\n        return layout;\n    }\n    /**\n     * Creates the layout instance used to layout the\n     * children of each swimlane.\n     * @returns CompactTreeLayout instance\n     */\n    createSwimlaneLayout() {\n        return new CompactTreeLayout(this.graph, this.horizontalFlow);\n    }\n    /**\n     * Creates the {@link toolbar} with no container.\n     * @returns EditorToolbar instance\n     */\n    createToolbar() {\n        return new EditorToolbar(null, this);\n    }\n    /**\n     * Initializes the toolbar for the given container.\n     * @param container\n     */\n    setToolbarContainer(container) {\n        this.toolbar.init(container);\n    }\n    /**\n     * Creates the {@link status} using the specified container.\n     * This implementation adds listeners in the editor to\n     * display the last saved time and the current filename\n     * in the status bar.\n     * @param container DOM node that will contain the statusbar.\n     */\n    setStatusContainer(container) {\n        if (this.status == null) {\n            this.status = container;\n            // Prints the last saved time in the status bar\n            // when files are saved\n            this.addListener(InternalEvent.SAVE, () => {\n                const tstamp = new Date().toLocaleString();\n                this.setStatus(`${Translations.get(this.lastSavedResource) || this.lastSavedResource}: ${tstamp}`);\n            });\n            // Updates the statusbar to display the filename\n            // when new files are opened\n            this.addListener(InternalEvent.OPEN, () => {\n                this.setStatus(`${Translations.get(this.currentFileResource) || this.currentFileResource}: ${this.filename}`);\n            });\n        }\n    }\n    /**\n     * Display the specified message in the status bar.\n     * @param message String the specified the message to be displayed.\n     */\n    setStatus(message) {\n        if (this.status != null && message != null) {\n            this.status.innerHTML = message;\n        }\n    }\n    /**\n     * Creates a listener to update the inner HTML of the\n     * specified DOM node with the value of {@link getTitle}.\n     * @param container DOM node that will contain the title.\n     */\n    setTitleContainer(container) {\n        this.addListener(InternalEvent.ROOT, (sender) => {\n            container.innerHTML = this.getTitle();\n        });\n    }\n    /**\n     * Executes a vertical or horizontal compact tree layout\n     * using the specified cell as an argument. The cell may\n     * either be a group or the root of a tree.\n     * @param cell {@link mxCell} to use in the compact tree layout.\n     * @param horizontal Optional boolean to specify the tree's\n     * orientation. Default is true.\n     */\n    treeLayout(cell, horizontal) {\n        if (cell != null) {\n            const layout = new CompactTreeLayout(this.graph, horizontal);\n            layout.execute(cell);\n        }\n    }\n    /**\n     * Returns the string value for the current root of the diagram.\n     */\n    getTitle() {\n        let title = '';\n        const { graph } = this;\n        let cell = graph.getCurrentRoot();\n        while (cell != null && cell.getParent().getParent() != null) {\n            // Append each label of a valid root\n            if (graph.isValidRoot(cell)) {\n                title = ` > ${graph.convertValueToString(cell)}${title}`;\n            }\n            cell = cell.getParent();\n        }\n        const prefix = this.getRootTitle();\n        return prefix + title;\n    }\n    /**\n     * Returns the string value of the root cell in {@link graph.model}.\n     */\n    getRootTitle() {\n        const root = this.graph.getDataModel().getRoot();\n        return this.graph.convertValueToString(root);\n    }\n    /**\n     * Undo the last change in {@link graph}.\n     */\n    undo() {\n        this.undoManager.undo();\n    }\n    /**\n     * Redo the last change in {@link graph}.\n     */\n    redo() {\n        this.undoManager.redo();\n    }\n    /**\n     * Invokes {@link createGroup} to create a new group cell and the invokes\n     * {@link graph.groupCells}, using the grid size of the graph as the spacing\n     * in the group's content area.\n     */\n    groupCells() {\n        const border = this.groupBorderSize != null ? this.groupBorderSize : this.graph.gridSize;\n        return this.graph.groupCells(this.createGroup(), border);\n    }\n    /**\n     * Creates and returns a clone of {@link defaultGroup} to be used\n     * as a new group cell in {@link group}.\n     * @returns Cell\n     */\n    createGroup() {\n        return cloneCell(this.defaultGroup);\n    }\n    /**\n     * Opens the specified file synchronously and parses it using\n     * {@link readGraphModel}. It updates {@link filename} and fires an <open>-event after\n     * the file has been opened. Exceptions should be handled as follows:\n     *\n     * @example\n     * ```javascript\n     * try\n     * {\n     *   editor.open(filename);\n     * }\n     * catch (e)\n     * {\n     *   mxUtils.error('Cannot open ' + filename +\n     *     ': ' + e.message, 280, true);\n     * }\n     * ```\n     *\n     * @param filename URL of the file to be opened.\n     */\n    open(filename) {\n        if (filename != null) {\n            const xml = load(filename).getXml();\n            this.readGraphModel(xml.documentElement);\n            this.filename = filename;\n            this.fireEvent(new EventObject(InternalEvent.OPEN, { filename }));\n        }\n    }\n    /**\n     * Reads the specified XML node into the existing graph model and resets the command history and modified state.\n     * @param node the XML node to be read into the graph model.\n     */\n    readGraphModel(node) {\n        new ModelXmlSerializer(this.graph.getDataModel()).import(node);\n        this.resetHistory();\n    }\n    /**\n     * Posts the string returned by {@link writeGraphModel} to the given URL or the\n     * URL returned by {@link getUrlPost}. The actual posting is carried out by\n     * {@link postDiagram}. If the URL is null then the resulting XML will be\n     * displayed using {@link popup}. Exceptions should be handled as\n     * follows:\n     *\n     * @example\n     * ```javascript\n     * try\n     * {\n     *   editor.save();\n     * }\n     * catch (e)\n     * {\n     *   mxUtils.error('Cannot save : ' + e.message, 280, true);\n     * }\n     * ```\n     *\n     * @param url\n     * @param linefeed\n     */\n    save(url = null, linefeed = this.linefeed) {\n        // Gets the URL to post the data to\n        url = url || this.getUrlPost();\n        // Posts the data if the URL is not empty\n        if (url != null && url.length > 0) {\n            const data = this.writeGraphModel(linefeed);\n            this.postDiagram(url, data);\n            // Resets the modified flag\n            this.setModified(false);\n        }\n        // Dispatches a save event\n        this.fireEvent(new EventObject(InternalEvent.SAVE, { url }));\n    }\n    /**\n     * Hook for subclassers to override the posting of a diagram\n     * represented by the given node to the given URL. This fires\n     * an asynchronous {@link post} event if the diagram has been posted.\n     *\n     * ### Example:\n     *\n     * To replace the diagram with the diagram in the response, use the\n     * following code.\n     *\n     * @example\n     * ```javascript\n     * editor.addListener(mxEvent.POST, function(sender, evt)\n     * {\n     *   // Process response (replace diagram)\n     *   var req = evt.getProperty('request');\n     *   var root = req.getDocumentElement();\n     *   editor.graph.readGraphModel(root)\n     * });\n     * ```\n     * @param url\n     * @param data\n     */\n    postDiagram(url, data) {\n        if (this.escapePostData) {\n            data = encodeURIComponent(data);\n        }\n        post(url, `${this.postParameterName}=${data}`, (req) => {\n            this.fireEvent(new EventObject(InternalEvent.POST, { request: req, url, data }));\n        });\n    }\n    /**\n     * Hook to create the string representation of the diagram.\n     *\n     * The default implementation uses {@link ModelXmlSerializer} to encode the graph model.\n     *\n     * @param linefeed Optional character to be used as the linefeed. Default is {@link linefeed}.\n     */\n    writeGraphModel(linefeed) {\n        return new ModelXmlSerializer(this.graph.getDataModel()).export({ pretty: false });\n    }\n    /**\n     * Returns the URL to post the diagram to. This is used\n     * in {@link save}. The default implementation returns {@link urlPost},\n     * adding <code>?draft=true</code>.\n     */\n    getUrlPost() {\n        return this.urlPost;\n    }\n    /**\n     * Returns the URL to create the image with. This is typically\n     * the URL of a backend which accepts an XML representation\n     * of a graph view to create an image. The function is used\n     * in the image action to create an image. This implementation\n     * returns {@link urlImage}.\n     */\n    getUrlImage() {\n        return this.urlImage;\n    }\n    /**\n     * Swaps the styles for the given names in the graph's\n     * stylesheet and refreshes the graph.\n     * @param first\n     * @param second\n     */\n    swapStyles(first, second) {\n        // @ts-ignore\n        const style = this.graph.getStylesheet().styles[second];\n        this.graph\n            .getView()\n            // @ts-ignore\n            .getStylesheet()\n            // @ts-ignore\n            .putCellStyle(second, this.graph.getStylesheet().styles[first]);\n        this.graph.getStylesheet().putCellStyle(first, style);\n        this.graph.refresh();\n    }\n    /**\n     * Creates and shows the properties dialog for the given\n     * cell. The content area of the dialog is created using\n     * {@link createProperties}.\n     * @param cell\n     */\n    showProperties(cell = null) {\n        cell = cell || this.graph.getSelectionCell();\n        // Uses the root node for the properties dialog\n        // if not cell was passed in and no cell is\n        // selected\n        if (cell == null) {\n            cell = this.graph.getCurrentRoot();\n            if (cell == null) {\n                cell = this.graph.getDataModel().getRoot();\n            }\n        }\n        if (cell != null) {\n            // Makes sure there is no in-place editor in the\n            // graph and computes the location of the dialog\n            this.graph.stopEditing(true);\n            const offset = getOffset(this.graph.container);\n            let x = offset.x + 10;\n            let { y } = offset;\n            // Avoids moving the dialog if it is alredy open\n            if (this.properties != null && !this.movePropertiesDialog) {\n                x = this.properties.getX();\n                y = this.properties.getY();\n            }\n            // Places the dialog near the cell for which it\n            // displays the properties\n            else {\n                const bounds = this.graph.getCellBounds(cell);\n                if (bounds != null) {\n                    x += bounds.x + Math.min(200, bounds.width);\n                    y += bounds.y;\n                }\n            }\n            // Hides the existing properties dialog and creates a new one with the\n            // contents created in the hook method\n            this.hideProperties();\n            const node = this.createProperties(cell);\n            if (node != null) {\n                // Displays the contents in a window and stores a reference to the\n                // window for later hiding of the window\n                this.properties = new MaxWindow(Translations.get(this.propertiesResource) || this.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);\n                this.properties.setVisible(true);\n            }\n        }\n    }\n    /**\n     * Returns true if the properties dialog is currently visible.\n     */\n    isPropertiesVisible() {\n        return this.properties != null;\n    }\n    /**\n     * Creates and returns the DOM node that represents the contents\n     * of the properties dialog for the given cell. This implementation\n     * works for user objects that are XML nodes and display all the\n     * node attributes in a form.\n     */\n    createProperties(cell) {\n        const model = this.graph.getDataModel();\n        const value = cell.getValue();\n        if (isNode(value)) {\n            // Creates a form for the user object inside\n            // the cell\n            const form = new MaxForm('properties');\n            // Adds a readonly field for the cell id\n            const id = form.addText('ID', cell.getId());\n            id.setAttribute('readonly', 'true');\n            let geo = null;\n            let yField = null;\n            let xField = null;\n            let widthField = null;\n            let heightField = null;\n            // Adds fields for the location and size\n            if (cell.isVertex()) {\n                geo = cell.getGeometry();\n                if (geo != null) {\n                    yField = form.addText('top', geo.y);\n                    xField = form.addText('left', geo.x);\n                    widthField = form.addText('width', geo.width);\n                    heightField = form.addText('height', geo.height);\n                }\n            }\n            // Adds a field for the cell style\n            const tmp = cell.getStyle();\n            const style = form.addText('Style', tmp || '');\n            // Creates textareas for each attribute of the\n            // user object within the cell\n            const attrs = value.attributes;\n            const texts = [];\n            for (let i = 0; i < attrs.length; i += 1) {\n                // Creates a textarea with more lines for\n                // the cell label\n                const val = attrs[i].value;\n                texts.push(form.addTextarea(attrs[i].nodeName, val, attrs[i].nodeName === 'label' ? 4 : 2));\n            }\n            // Adds an OK and Cancel button to the dialog\n            // contents and implements the respective\n            // actions below\n            // Defines the function to be executed when the\n            // OK button is pressed in the dialog\n            const okFunction = () => {\n                // Hides the dialog\n                this.hideProperties();\n                // Supports undo for the changes on the underlying\n                // XML structure / XML node attribute changes.\n                model.beginUpdate();\n                try {\n                    if (geo != null &&\n                        xField != null &&\n                        yField != null &&\n                        widthField != null &&\n                        heightField != null) {\n                        geo = geo.clone();\n                        geo.x = parseFloat(xField.value);\n                        geo.y = parseFloat(yField.value);\n                        geo.width = parseFloat(widthField.value);\n                        geo.height = parseFloat(heightField.value);\n                        model.setGeometry(cell, geo);\n                    }\n                    // Applies the style\n                    if (style.value.length > 0) {\n                        // @ts-expect-error TODO - style is no longer a string\n                        model.setStyle(cell, style.value);\n                    }\n                    else {\n                        model.setStyle(cell, {});\n                    }\n                    // Creates an undoable change for each\n                    // attribute and executes it using the\n                    // model, which will also make the change\n                    // part of the current transaction\n                    for (let i = 0; i < attrs.length; i += 1) {\n                        const edit = new CellAttributeChange(cell, attrs[i].nodeName, texts[i].value);\n                        model.execute(edit);\n                    }\n                    // Checks if the graph wants cells to\n                    // be automatically sized and updates\n                    // the size as an undoable step if\n                    // the feature is enabled\n                    if (this.graph.isAutoSizeCell(cell)) {\n                        this.graph.updateCellSize(cell);\n                    }\n                }\n                finally {\n                    model.endUpdate();\n                }\n            };\n            // Defines the function to be executed when the\n            // Cancel button is pressed in the dialog\n            const cancelFunction = () => {\n                // Hides the dialog\n                this.hideProperties();\n            };\n            form.addButtons(okFunction, cancelFunction);\n            return form.table;\n        }\n        return null;\n    }\n    /**\n     * Hides the properties dialog.\n     */\n    hideProperties() {\n        if (this.properties != null) {\n            this.properties.destroy();\n            this.properties = null;\n        }\n    }\n    /**\n     * Shows the tasks window. The tasks window is created using {@link createTasks}. The\n     * default width of the window is 200 pixels, the y-coordinate of the location\n     * can be specifies in {@link tasksTop} and the x-coordinate is right aligned with a\n     * 20 pixel offset from the right border. To change the location of the tasks\n     * window, the following code can be used:\n     *\n     * @example\n     * ```javascript\n     * var oldShowTasks = Editor.prototype.showTasks;\n     * Editor.prototype.showTasks = function()\n     * {\n     *   oldShowTasks.apply(this, arguments); // \"supercall\"\n     *\n     *   if (this.tasks != null)\n     *   {\n     *     this.tasks.setLocation(10, 10);\n     *   }\n     * };\n     * ```\n     */\n    showTasks() {\n        if (this.tasks == null) {\n            const div = document.createElement('div');\n            div.style.padding = '4px';\n            div.style.paddingLeft = '20px';\n            const w = document.body.clientWidth;\n            const wnd = new MaxWindow(Translations.get(this.tasksResource) || this.tasksResource, div, w - 220, this.tasksTop, 200);\n            wnd.setClosable(true);\n            wnd.destroyOnClose = false;\n            // Installs a function to update the contents\n            // of the tasks window on every change of the\n            // model, selection or root.\n            const funct = (sender) => {\n                InternalEvent.release(div);\n                div.innerHTML = '';\n                this.createTasks(div);\n            };\n            this.graph.getDataModel().addListener(InternalEvent.CHANGE, funct);\n            this.graph.getSelectionModel().addListener(InternalEvent.CHANGE, funct);\n            this.graph.addListener(InternalEvent.ROOT, funct);\n            // Assigns the icon to the tasks window\n            if (this.tasksWindowImage != null) {\n                wnd.setImage(this.tasksWindowImage);\n            }\n            this.tasks = wnd;\n            this.createTasks(div);\n        }\n        this.tasks.setVisible(true);\n    }\n    /**\n     * Updates the contents of the tasks window using {@link createTasks}.\n     * @param div\n     */\n    refreshTasks(div) {\n        if (this.tasks != null) {\n            const div = this.tasks.content;\n            InternalEvent.release(div);\n            div.innerHTML = '';\n            this.createTasks(div);\n        }\n    }\n    /**\n     * Updates the contents of the given DOM node to\n     * display the tasks associated with the current\n     * editor state. This is invoked whenever there\n     * is a possible change of state in the editor.\n     * Default implementation is empty.\n     * @param div\n     */\n    createTasks(div) {\n        // override\n    }\n    /**\n     * Shows the help window. If the help window does not exist\n     * then it is created using an iframe pointing to the resource\n     * for the <code>urlHelp</code> key or {@link urlHelp} if the resource\n     * is undefined.\n     * @param tasks\n     */\n    showHelp(tasks = null) {\n        if (this.help == null) {\n            const frame = document.createElement('iframe');\n            frame.setAttribute('src', (Translations.get('urlHelp') || this.urlHelp));\n            frame.setAttribute('height', '100%');\n            frame.setAttribute('width', '100%');\n            frame.setAttribute('frameBorder', '0');\n            frame.style.backgroundColor = 'white';\n            const w = document.body.clientWidth;\n            const h = document.body.clientHeight || document.documentElement.clientHeight;\n            const wnd = new MaxWindow(Translations.get(this.helpResource) || this.helpResource, frame, (w - this.helpWidth) / 2, (h - this.helpHeight) / 3, this.helpWidth, this.helpHeight);\n            wnd.setMaximizable(true);\n            wnd.setClosable(true);\n            wnd.destroyOnClose = false;\n            wnd.setResizable(true);\n            // Assigns the icon to the help window\n            if (this.helpWindowImage != null) {\n                wnd.setImage(this.helpWindowImage);\n            }\n            // Workaround for ignored iframe height 100% in FF\n            if (Client.IS_NS) {\n                const handler = (sender) => {\n                    const h = wnd.div.offsetHeight;\n                    frame.setAttribute('height', `${h - 26}px`);\n                };\n                wnd.addListener(InternalEvent.RESIZE_END, handler);\n                wnd.addListener(InternalEvent.MAXIMIZE, handler);\n                wnd.addListener(InternalEvent.NORMALIZE, handler);\n                wnd.addListener(InternalEvent.SHOW, handler);\n            }\n            this.help = wnd;\n        }\n        this.help.setVisible(true);\n    }\n    /**\n     * Shows the outline window. If the window does not exist, then it is\n     * created using an {@link outline}.\n     */\n    showOutline() {\n        const create = this.outline == null;\n        if (create) {\n            const div = document.createElement('div');\n            div.style.overflow = 'hidden';\n            div.style.position = 'relative';\n            div.style.width = '100%';\n            div.style.height = '100%';\n            div.style.background = 'white';\n            div.style.cursor = 'move';\n            const wnd = new MaxWindow(Translations.get(this.outlineResource) || this.outlineResource, div, 600, 480, 200, 200, false);\n            // Creates the outline in the specified div\n            // and links it to the existing graph\n            const outline = new Outline(this.graph, div);\n            wnd.setClosable(true);\n            wnd.setResizable(true);\n            wnd.destroyOnClose = false;\n            wnd.addListener(InternalEvent.RESIZE_END, () => {\n                outline.update();\n            });\n            this.outline = wnd;\n            this.outline.Outline = outline;\n        }\n        // Finally shows the outline\n        this.outline.setVisible(true);\n        this.outline.outline.update(true);\n    }\n    /**\n     * Puts the graph into the specified mode. The following mode names are supported:\n     * - select - Selects using the left mouse button, new connections are disabled.\n     * - connect - Selects using the left mouse button or creates new connections if mouse over cell hotspot. See {@link ConnectionHandler}.\n     * - pan - Pans using the left mouse button, new connections are disabled.\n     */\n    setMode(modename) {\n        const panningHandler = this.graph.getPlugin('PanningHandler');\n        if (modename === 'select') {\n            panningHandler && (panningHandler.useLeftButtonForPanning = false);\n            this.graph.setConnectable(false);\n        }\n        else if (modename === 'connect') {\n            panningHandler && (panningHandler.useLeftButtonForPanning = false);\n            this.graph.setConnectable(true);\n        }\n        else if (modename === 'pan') {\n            panningHandler && (panningHandler.useLeftButtonForPanning = true);\n            this.graph.setConnectable(false);\n        }\n    }\n    /**\n     * Uses {@link popupHandler} to create the menu in the graph's\n     * panning handler. The redirection is setup in {@link setToolbarContainer}.\n     * @param menu\n     * @param cell\n     * @param evt\n     */\n    createPopupMenu(menu, cell, evt) {\n        this.popupHandler.createMenu(this, menu, cell, evt);\n    }\n    /**\n     * Uses {@link defaultEdge} as the prototype for creating new edges\n     * in the connection handler of the graph. The style of the\n     * edge will be overridden with the value returned by {@link getEdgeStyle}.\n     * @param source\n     * @param target\n     */\n    createEdge(source, target) {\n        // Clones the default edge prototype\n        let e;\n        if (this.defaultEdge != null) {\n            e = cloneCell(this.defaultEdge);\n        }\n        else {\n            e = new Cell('');\n            e.setEdge(true);\n            const geo = new Geometry();\n            geo.relative = true;\n            e.setGeometry(geo);\n        }\n        // Overrides the edge style\n        const style = this.getEdgeStyle();\n        if (style != null) {\n            e.setStyle(style);\n        }\n        return e;\n    }\n    /**\n     * Returns a string identifying the style of new edges.\n     * The function is used in {@link createEdge} when new edges\n     * are created in the graph.\n     */\n    getEdgeStyle() {\n        return this.defaultEdgeStyle;\n    }\n    /**\n     * Returns the next attribute in {@link cycleAttributeValues}\n     * or null, if not attribute should be used in the specified cell.\n     * @param cell\n     */\n    consumeCycleAttribute(cell) {\n        return this.cycleAttributeValues != null &&\n            this.cycleAttributeValues.length > 0 &&\n            this.graph.isSwimlane(cell)\n            ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length]\n            : null;\n    }\n    /**\n     * Uses the returned value from {@link consumeCycleAttribute}\n     * as the value for the {@link cycleAttributeName} key in the given cell's style.\n     * @param cell\n     */\n    cycleAttribute(cell) {\n        if (this.cycleAttributeName != null) {\n            const value = this.consumeCycleAttribute(cell);\n            if (value != null) {\n                // @ts-expect-error TODO - style is no longer a string\n                cell.setStyle(`${cell.getStyle()};${this.cycleAttributeName}=${value}`);\n            }\n        }\n    }\n    /**\n     * Adds the given vertex as a child of parent at the specified\n     * x and y coordinate and fires an {@link addVertex} event.\n     * @param parent\n     * @param vertex\n     * @param x\n     * @param y\n     */\n    addVertex(parent, vertex, x, y) {\n        const model = this.graph.getDataModel();\n        while (parent != null && !this.graph.isValidDropTarget(parent)) {\n            parent = parent.getParent();\n        }\n        parent = parent != null ? parent : this.graph.getSwimlaneAt(x, y);\n        const { scale } = this.graph.getView();\n        let geo = vertex.getGeometry();\n        const pgeo = parent.getGeometry();\n        if (this.graph.isSwimlane(vertex) && !this.graph.swimlaneNesting) {\n            parent = null;\n        }\n        else if (parent == null && this.swimlaneRequired) {\n            return null;\n        }\n        else if (parent != null && pgeo != null) {\n            // Keeps vertex inside parent\n            const state = this.graph.getView().getState(parent);\n            if (state != null) {\n                x -= state.origin.x * scale;\n                y -= state.origin.y * scale;\n                if (this.graph.isConstrainedMoving) {\n                    const { width } = geo;\n                    const { height } = geo;\n                    let tmp = state.x + state.width;\n                    if (x + width > tmp) {\n                        x -= x + width - tmp;\n                    }\n                    tmp = state.y + state.height;\n                    if (y + height > tmp) {\n                        y -= y + height - tmp;\n                    }\n                }\n            }\n            else if (pgeo != null) {\n                x -= pgeo.x * scale;\n                y -= pgeo.y * scale;\n            }\n        }\n        geo = geo.clone();\n        geo.x = this.graph.snap(x / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);\n        geo.y = this.graph.snap(y / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);\n        vertex.setGeometry(geo);\n        if (parent == null) {\n            parent = this.graph.getDefaultParent();\n        }\n        this.cycleAttribute(vertex);\n        this.fireEvent(new EventObject(InternalEvent.BEFORE_ADD_VERTEX, { vertex: vertex, parent: parent }));\n        model.beginUpdate();\n        try {\n            vertex = this.graph.addCell(vertex, parent);\n            if (vertex != null) {\n                this.graph.constrainChild(vertex);\n                this.fireEvent(new EventObject(InternalEvent.ADD_VERTEX, { vertex: vertex }));\n            }\n        }\n        finally {\n            model.endUpdate();\n        }\n        if (vertex != null) {\n            this.graph.setSelectionCell(vertex);\n            this.graph.scrollCellToVisible(vertex);\n            this.fireEvent(new EventObject(InternalEvent.AFTER_ADD_VERTEX, { vertex: vertex }));\n        }\n        return vertex;\n    }\n    /**\n     * Removes the editor and all its associated resources. This does not\n     * normally need to be called, it is called automatically when the window\n     * unloads.\n     */\n    destroy() {\n        if (!this.destroyed) {\n            this.destroyed = true;\n            if (this.tasks != null) {\n                this.tasks.destroy();\n            }\n            if (this.outline != null) {\n                this.outline.destroy();\n            }\n            if (this.properties != null) {\n                this.properties.destroy();\n            }\n            if (this.keyHandler != null) {\n                this.keyHandler.destroy();\n            }\n            if (this.rubberband != null) {\n                this.rubberband.onDestroy();\n            }\n            if (this.toolbar != null) {\n                this.toolbar.destroy();\n            }\n            if (this.graph != null) {\n                this.graph.destroy();\n            }\n            this.status = null;\n            this.templates = null;\n        }\n    }\n}\nexport default Editor;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport CellMarker from './CellMarker';\n/**\n * Event handler that highlights cells\n *\n * ```javascript\n * new mxCellTracker(graph, '#00FF00');\n * ```\n *\n * For detecting dragEnter, dragOver and dragLeave on cells, the following code can be used:\n * ```javascript\n * graph.addMouseListener(\n * {\n *   cell: null,\n *   mouseDown: function(sender, me) { },\n *   mouseMove: function(sender, me)\n *   {\n *     var tmp = me.getCell();\n *\n *     if (tmp != this.cell)\n *     {\n *       if (this.cell != null)\n *       {\n *         this.dragLeave(me.getEvent(), this.cell);\n *       }\n *\n *       this.cell = tmp;\n *\n *       if (this.cell != null)\n *       {\n *         this.dragEnter(me.getEvent(), this.cell);\n *       }\n *     }\n *\n *     if (this.cell != null)\n *     {\n *       this.dragOver(me.getEvent(), this.cell);\n *     }\n *   },\n *   mouseUp: function(sender, me) { },\n *   dragEnter: function(evt, cell)\n *   {\n *     GlobalConfig.logger.debug('dragEnter', cell.value);\n *   },\n *   dragOver: function(evt, cell)\n *   {\n *     GlobalConfig.logger.debug('dragOver', cell.value);\n *   },\n *   dragLeave: function(evt, cell)\n *   {\n *     GlobalConfig.logger.debug('dragLeave', cell.value);\n *   }\n * });\n * ```\n */\nclass CellTracker extends CellMarker {\n    constructor(graph, color, funct = null) {\n        super(graph, color);\n        this.destroyed = false;\n        this.graph.addMouseListener(this);\n        if (funct) {\n            this.getCell = funct;\n        }\n    }\n    /**\n     * Ignores the event. The event is not consumed.\n     */\n    mouseDown(sender, me) {\n        return;\n    }\n    /**\n     * Handles the event by highlighting the cell under the mousepointer if it\n     * is over the hotspot region of the cell.\n     */\n    mouseMove(sender, me) {\n        if (this.isEnabled()) {\n            this.process(me);\n        }\n    }\n    /**\n     * Handles the event by resetting the highlight.\n     */\n    mouseUp(sender, me) {\n        return;\n    }\n    /**\n     * Destroys the object and all its resources and DOM nodes. This doesn't\n     * normally need to be called. It is called automatically when the window\n     * unloads.\n     */\n    destroy() {\n        if (!this.destroyed) {\n            this.destroyed = true;\n            this.graph.removeMouseListener(this);\n            super.destroy();\n        }\n    }\n}\nexport default CellTracker;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { getRotatedPoint, toRadians } from '../../util/mathUtils';\nimport Point from '../geometry/Point';\nimport ImageShape from '../geometry/node/ImageShape';\nimport Rectangle from '../geometry/Rectangle';\nimport RectangleShape from '../geometry/node/RectangleShape';\nimport { DIALECT, HANDLE_FILLCOLOR, HANDLE_SIZE, HANDLE_STROKECOLOR, } from '../../util/Constants';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Implements a single custom handle for vertices.\n *\n * @class VertexHandle\n */\nclass VertexHandle {\n    constructor(state, cursor = 'default', image = null, shape = null) {\n        this.dependencies = ['snap', 'cells'];\n        /**\n         * Specifies the cursor to be used for this handle. Default is 'default'.\n         */\n        this.cursor = 'default';\n        /**\n         * Specifies the {@link Image} to be used to render the handle. Default is null.\n         */\n        this.image = null;\n        /**\n         * Default is false.\n         */\n        this.ignoreGrid = false;\n        this.active = true;\n        this.graph = state.view.graph;\n        this.state = state;\n        this.cursor = cursor;\n        this.image = image;\n        this.shape = shape;\n        this.init();\n    }\n    /**\n     * Hook for subclassers to return the current position of the handle.\n     */\n    getPosition(bounds) {\n        return new Point();\n    }\n    /**\n     * Hooks for subclassers to update the style in the <state>.\n     */\n    setPosition(bounds, pt, me) {\n        return;\n    }\n    /**\n     * Hook for subclassers to execute the handle.\n     */\n    execute(me) {\n        return;\n    }\n    /**\n     * Sets the cell style with the given name to the corresponding value in <state>.\n     */\n    copyStyle(key) {\n        this.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);\n    }\n    /**\n     * Processes the given {@link MouseEvent} and invokes <setPosition>.\n     */\n    processEvent(me) {\n        const { scale } = this.graph.view;\n        const tr = this.graph.view.translate;\n        let pt = new Point(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);\n        // Center shape on mouse cursor\n        if (this.shape != null && this.shape.bounds != null) {\n            pt.x -= this.shape.bounds.width / scale / 4;\n            pt.y -= this.shape.bounds.height / scale / 4;\n        }\n        // Snaps to grid for the rotated position then applies the rotation for the direction after that\n        const alpha1 = -toRadians(this.getRotation());\n        const alpha2 = -toRadians(this.getTotalRotation()) - alpha1;\n        pt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1), this.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));\n        this.redraw();\n    }\n    /**\n     * Should be called after <setPosition> in <processEvent>.\n     * This repaints the state using {@link CellRenderer}.\n     */\n    positionChanged() {\n        if (this.state.text != null) {\n            this.state.text.apply(this.state);\n        }\n        if (this.state.shape != null) {\n            this.state.shape.apply(this.state);\n        }\n        this.graph.cellRenderer.redraw(this.state, true);\n    }\n    /**\n     * Returns the rotation defined in the style of the cell.\n     */\n    getRotation() {\n        if (this.state.shape != null) {\n            return this.state.shape.getRotation();\n        }\n        return 0;\n    }\n    /**\n     * Returns the rotation from the style and the rotation from the direction of\n     * the cell.\n     */\n    getTotalRotation() {\n        if (this.state.shape != null) {\n            return this.state.shape.getShapeRotation();\n        }\n        return 0;\n    }\n    /**\n     * Creates and initializes the shapes required for this handle.\n     */\n    init() {\n        const html = this.isHtmlRequired();\n        if (this.image) {\n            this.shape = new ImageShape(new Rectangle(0, 0, this.image.width, this.image.height), this.image.src);\n            this.shape.preserveImageAspect = false;\n        }\n        else if (!this.shape) {\n            this.shape = this.createShape(html);\n        }\n        this.initShape(html);\n    }\n    /**\n     * Creates and returns the shape for this handle.\n     */\n    createShape(html) {\n        const bounds = new Rectangle(0, 0, HANDLE_SIZE, HANDLE_SIZE);\n        return new RectangleShape(bounds, HANDLE_FILLCOLOR, HANDLE_STROKECOLOR);\n    }\n    /**\n     * Initializes <shape> and sets its cursor.\n     */\n    initShape(html) {\n        const shape = this.shape; // `this.shape` cannot be null.\n        if (html && shape.isHtmlAllowed()) {\n            shape.dialect = DIALECT.STRICTHTML;\n            shape.init(this.graph.container);\n        }\n        else {\n            shape.dialect =\n                this.graph.dialect !== DIALECT.SVG ? DIALECT.MIXEDHTML : DIALECT.SVG;\n            if (this.cursor) {\n                shape.init(this.graph.getView().getOverlayPane());\n            }\n        }\n        InternalEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n        shape.node.style.cursor = this.cursor;\n    }\n    /**\n     * Renders the shape for this handle.\n     */\n    redraw() {\n        if (this.shape && this.state.shape) {\n            let pt = this.getPosition(this.state.getPaintBounds());\n            if (pt) {\n                const alpha = toRadians(this.getTotalRotation());\n                pt = this.rotatePoint(this.flipPoint(pt), alpha);\n                const { scale } = this.graph.view;\n                const tr = this.graph.view.translate;\n                const shapeBounds = this.shape.bounds;\n                shapeBounds.x = Math.floor((pt.x + tr.x) * scale - shapeBounds.width / 2);\n                shapeBounds.y = Math.floor((pt.y + tr.y) * scale - shapeBounds.height / 2);\n                // Needed to force update of text bounds\n                this.shape.redraw();\n            }\n        }\n    }\n    /**\n     * Returns true if this handle should be rendered in HTML. This returns true if\n     * the text node is in the graph container.\n     */\n    isHtmlRequired() {\n        return !!this.state.text && this.state.text.node.parentNode === this.graph.container;\n    }\n    /**\n     * Rotates the point by the given angle.\n     */\n    rotatePoint(pt, alpha) {\n        const bounds = this.state.getCellBounds();\n        const cx = new Point(bounds.getCenterX(), bounds.getCenterY());\n        const cos = Math.cos(alpha);\n        const sin = Math.sin(alpha);\n        return getRotatedPoint(pt, cos, sin, cx);\n    }\n    /**\n     * Flips the given point vertically and/or horizontally.\n     */\n    flipPoint(pt) {\n        if (this.state.shape) {\n            const bounds = this.state.getCellBounds();\n            if (this.state.shape.flipH) {\n                pt.x = 2 * bounds.x + bounds.width - pt.x;\n            }\n            if (this.state.shape.flipV) {\n                pt.y = 2 * bounds.y + bounds.height - pt.y;\n            }\n        }\n        return pt;\n    }\n    /**\n     * Snaps the given point to the grid if ignore is false. This modifies\n     * the given point in-place and also returns it.\n     */\n    snapPoint(pt, ignore) {\n        if (!ignore) {\n            pt.x = this.graph.snap(pt.x);\n            pt.y = this.graph.snap(pt.y);\n        }\n        return pt;\n    }\n    /**\n     * Shows or hides this handle.\n     */\n    setVisible(visible) {\n        if (this.shape && this.shape.node) {\n            this.shape.node.style.display = visible ? '' : 'none';\n        }\n    }\n    /**\n     * Resets the state of this handle by setting its visibility to true.\n     */\n    reset() {\n        this.setVisible(true);\n        this.state.style = this.graph.getCellStyle(this.state.cell);\n        this.positionChanged();\n    }\n    /**\n     * Destroys this handle.\n     */\n    destroy() {\n        if (this.shape) {\n            this.shape.destroy();\n            this.shape = null;\n        }\n    }\n}\nexport default VertexHandle;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} to implement a circular layout for a given radius.\n * The vertices do not need to be connected for this layout to work and all\n * connections between vertices are not taken into account.\n *\n * Example:\n *\n * ```javascript\n * const layout = new CircleLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass CircleLayout extends GraphLayout {\n    /**\n     * Constructs a new circular layout for the specified radius.\n     *\n     * @param graph {@link Graph} that contains the cells.\n     * @param radius Optional radius as an int. Default is 100.\n     */\n    constructor(graph, radius = 100) {\n        super(graph);\n        /**\n         * Boolean specifying if the circle should be moved to the top,\n         * left corner specified by <x0> and <y0>. Default is false.\n         */\n        this.moveCircle = false;\n        /**\n         * Integer specifying the left coordinate of the circle.\n         * Default is 0.\n         */\n        this.x0 = 0;\n        /**\n         * Integer specifying the top coordinate of the circle.\n         * Default is 0.\n         */\n        this.y0 = 0;\n        /**\n         * Specifies if all edge points of traversed edges should be removed.\n         * Default is true.\n         */\n        this.resetEdges = true;\n        /**\n         * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n         * modified by the result. Default is true.\n         */\n        this.disableEdgeStyle = true;\n        this.radius = radius;\n    }\n    /**\n     * Implements {@link GraphLayout#execute}.\n     */\n    execute(parent) {\n        // Moves the vertices to build a circle. Makes sure the\n        // radius is large enough for the vertices to not\n        // overlap\n        this.graph.batchUpdate(() => {\n            // Gets all vertices inside the parent and finds\n            // the maximum dimension of the largest vertex\n            let max = 0;\n            let top = null;\n            let left = null;\n            const vertices = [];\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const cell = parent.getChildAt(i);\n                if (!this.isVertexIgnored(cell)) {\n                    vertices.push(cell);\n                    const bounds = this.getVertexBounds(cell);\n                    if (top == null) {\n                        top = bounds.y;\n                    }\n                    else {\n                        top = Math.min(top, bounds.y);\n                    }\n                    if (left == null) {\n                        left = bounds.x;\n                    }\n                    else {\n                        left = Math.min(left, bounds.x);\n                    }\n                    max = Math.max(max, Math.max(bounds.width, bounds.height));\n                }\n                else if (!this.isEdgeIgnored(cell)) {\n                    // Resets the points on the traversed edge\n                    if (this.resetEdges) {\n                        this.graph.resetEdge(cell);\n                    }\n                    if (this.disableEdgeStyle) {\n                        this.setEdgeStyleEnabled(cell, false);\n                    }\n                }\n            }\n            const r = this.getRadius(vertices.length, max);\n            if (this.moveCircle) {\n                // Moves the circle to the specified origin\n                left = this.x0;\n                top = this.y0;\n            }\n            this.circle(vertices, r, left, top);\n        });\n    }\n    /**\n     * Returns the radius to be used for the given vertex count. Max is the maximum\n     * width or height of all vertices in the layout.\n     */\n    getRadius(count, max) {\n        return Math.max((count * max) / Math.PI, this.radius);\n    }\n    /**\n     * Executes the circular layout for the specified array\n     * of vertices and the given radius. This is called from\n     * <execute>.\n     */\n    circle(vertices, r, left, top) {\n        const vertexCount = vertices.length;\n        const phi = (2 * Math.PI) / vertexCount;\n        vertices.forEach((vertex, i) => {\n            if (this.isVertexMovable(vertex)) {\n                this.setVertexLocation(vertex, Math.round(left + r + r * Math.sin(i * phi)), Math.round(top + r + r * Math.cos(i * phi)));\n            }\n        });\n    }\n}\nexport default CircleLayout;\n", "import GraphLayout from './GraphLayout';\n/**\n * Allows to compose multiple layouts into a single layout.\n *\n * The {@link master} layout is the layout that handles move operations if another layout than the first\n * element in {@link GraphLayout}s should be used. The {@link master} layout is not executed as\n * the code assumes that it is part of {@link layouts}.\n *\n * Example:\n * ```javascript\n * const first = new FastOrganicLayout(graph);\n * const second = new ParallelEdgeLayout(graph);\n * const layout = new CompositeLayout(graph, [first, second], first);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass CompositeLayout extends GraphLayout {\n    /**\n     * Constructs a new layout using the given layouts. The graph instance is\n     * required for creating the transaction that contains all layouts.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     * @param layouts Array of {@link GraphLayout}s.\n     * @param master Optional layout that handles moves. If no layout is given, then the first layout of the above array is used to handle moves.\n     */\n    constructor(graph, layouts, master) {\n        super(graph);\n        this.layouts = layouts;\n        this.master = master;\n    }\n    /**\n     * Calls `move` on {@link master} or the first layout in {@link layouts}.\n     */\n    moveCell(cell, x, y) {\n        if (this.master != null) {\n            this.master.moveCell.apply(this.master, [cell, x, y]);\n        }\n        else {\n            this.layouts[0].moveCell.apply(this.layouts[0], [cell, x, y]);\n        }\n    }\n    /**\n     * Implements {@link GraphLayout#execute} by executing all {@link layouts} in a single transaction.\n     */\n    execute(parent) {\n        this.graph.batchUpdate(() => {\n            for (let i = 0; i < this.layouts.length; i += 1) {\n                this.layouts[i].execute.apply(this.layouts[i], [parent]);\n            }\n        });\n    }\n}\nexport default CompositeLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport { intersects } from '../../util/mathUtils';\n/**\n * Extends {@link GraphLayout} to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n *\n * ```javascript\n * const layout = new EdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass EdgeLabelLayout extends GraphLayout {\n    constructor(graph, radius) {\n        super(graph);\n    }\n    /**\n     * Implements {@link GraphLayout.execute}\n     */\n    execute(parent) {\n        const { view } = this.graph;\n        const model = this.graph.getDataModel();\n        // Gets all vertices and edges inside the parent\n        const edges = [];\n        const vertices = [];\n        const childCount = parent.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const cell = parent.getChildAt(i);\n            const state = view.getState(cell);\n            if (state != null) {\n                if (!this.isVertexIgnored(cell)) {\n                    vertices.push(state);\n                }\n                else if (!this.isEdgeIgnored(cell)) {\n                    edges.push(state);\n                }\n            }\n        }\n        this.placeLabels(vertices, edges);\n    }\n    /**\n     * Places the labels of the given edges.\n     *\n     * @param v   vertexes\n     * @param e   edges\n     */\n    placeLabels(v, e) {\n        // Moves the vertices to build a circle. Makes sure the\n        // radius is large enough for the vertices to not\n        // overlap\n        this.graph.batchUpdate(() => {\n            for (let i = 0; i < e.length; i += 1) {\n                const edge = e[i];\n                if (edge != null && edge.text != null && edge.text.boundingBox != null) {\n                    for (let j = 0; j < v.length; j += 1) {\n                        const vertex = v[j];\n                        if (vertex != null) {\n                            this.avoid(edge, vertex);\n                        }\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Places the labels of the given edges.\n     */\n    avoid(edge, vertex) {\n        const model = this.graph.getDataModel();\n        const labRect = edge.text.boundingBox;\n        if (intersects(labRect, vertex)) {\n            const dy1 = -labRect.y - labRect.height + vertex.y;\n            const dy2 = -labRect.y + vertex.y + vertex.height;\n            let dy = Math.abs(dy1) < Math.abs(dy2) ? dy1 : dy2;\n            const dx1 = -labRect.x - labRect.width + vertex.x;\n            const dx2 = -labRect.x + vertex.x + vertex.width;\n            let dx = Math.abs(dx1) < Math.abs(dx2) ? dx1 : dx2;\n            if (Math.abs(dx) < Math.abs(dy)) {\n                dy = 0;\n            }\n            else {\n                dx = 0;\n            }\n            let g = edge.cell.getGeometry();\n            if (g != null) {\n                g = g.clone();\n                if (g.offset != null) {\n                    g.offset.x += dx;\n                    g.offset.y += dy;\n                }\n                else {\n                    g.offset = new Point(dx, dy);\n                }\n                model.setGeometry(edge.cell, g);\n            }\n        }\n    }\n}\nexport default EdgeLabelLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ObjectIdentity from '../../util/ObjectIdentity';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n *\n * Example:\n *\n * ```javascript\n * const layout = new FastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass MxFastOrganicLayout extends GraphLayout {\n    constructor(graph) {\n        super(graph);\n        /**\n         * Specifies if the top left corner of the input cells should be the origin of the layout result.  Default is true.\n         */\n        this.useInputOrigin = true;\n        /**\n         * Specifies if all edge points of traversed edges should be removed.  Default is true.\n         */\n        this.resetEdges = true;\n        /**\n         * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are modified by the result.  Default is true.\n         */\n        this.disableEdgeStyle = true;\n        /**\n         * The force constant by which the attractive forces are divided and the replusive forces are multiple by the square of.  The value equates to the average radius there is of free space around each node.  Default is 50.\n         */\n        this.forceConstant = 50;\n        /**\n         * Cache of <forceConstant>^2 for performance.\n         */\n        this.forceConstantSquared = 0;\n        /**\n         * Minimal distance limit.  Default is 2.  Prevents of dividing by zero.\n         */\n        this.minDistanceLimit = 2;\n        /**\n         * Maximal distance limit. Default is 500. Prevents of\n         * dividing by zero.\n         */\n        this.maxDistanceLimit = 500;\n        /**\n         * Cached version of minDistanceLimit squared.\n         */\n        this.minDistanceLimitSquared = 4;\n        /**\n         * Start value of temperature. Default is 200.\n         */\n        this.initialTemp = 200;\n        /**\n         * Temperature to limit displacement at later stages of layout.\n         */\n        this.temperature = 0;\n        /**\n         * Total number of iterations to run the layout though.\n         */\n        this.maxIterations = 0;\n        /**\n         * Current iteration count.\n         */\n        this.iteration = 0;\n        /**\n         * An array of all vertices to be laid out.\n         */\n        this.vertexArray = [];\n        /**\n         * An array of locally stored X co-ordinate displacements for the vertices.\n         */\n        this.dispX = [];\n        /**\n         * An array of locally stored Y co-ordinate displacements for the vertices.\n         */\n        this.dispY = [];\n        /**\n         * An array of locally stored co-ordinate positions for the vertices.\n         */\n        this.cellLocation = [];\n        /**\n         * The approximate radius of each cell, nodes only.\n         */\n        this.radius = [];\n        /**\n         * The approximate radius squared of each cell, nodes only.\n         */\n        this.radiusSquared = [];\n        /**\n         * Array of booleans representing the movable states of the vertices.\n         */\n        this.isMoveable = [];\n        /**\n         * Local copy of cell neighbours.\n         */\n        this.neighbours = {};\n        /**\n         * Hashtable from cells to local indices.\n         */\n        this.indices = {};\n        /**\n         * Boolean flag that specifies if the layout is allowed to run. If this is\n         * set to false, then the layout exits in the following iteration.\n         */\n        this.allowedToRun = true;\n    }\n    /**\n     * Returns a boolean indicating if the given <Cell> should be ignored as a\n     * vertex. This returns true if the cell has no connections.\n     *\n     * @param vertex <Cell> whose ignored state should be returned.\n     */\n    isVertexIgnored(vertex) {\n        return (super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0);\n    }\n    /**\n     * Implements {@link GraphLayout#execute}. This operates on all children of the\n     * given parent where <isVertexIgnored> returns false.\n     */\n    execute(parent) {\n        this.vertexArray = [];\n        let cells = this.graph.getChildVertices(parent);\n        for (let i = 0; i < cells.length; i += 1) {\n            if (!this.isVertexIgnored(cells[i])) {\n                this.vertexArray.push(cells[i]);\n            }\n        }\n        const initialBounds = this.useInputOrigin\n            ? this.graph.getBoundingBoxFromGeometry(this.vertexArray)\n            : null;\n        const n = this.vertexArray.length;\n        this.indices = {};\n        this.dispX = [];\n        this.dispY = [];\n        this.cellLocation = [];\n        this.isMoveable = [];\n        this.neighbours = {};\n        this.radius = [];\n        this.radiusSquared = [];\n        if (this.forceConstant < 0.001) {\n            this.forceConstant = 0.001;\n        }\n        this.forceConstantSquared = this.forceConstant * this.forceConstant;\n        // Create a map of vertices first. This is required for the array of\n        // arrays called neighbours which holds, for each vertex, a list of\n        // ints which represents the neighbours cells to that vertex as\n        // the indices into vertexArray\n        for (let i = 0; i < this.vertexArray.length; i += 1) {\n            const vertex = this.vertexArray[i];\n            this.cellLocation[i] = [];\n            // Set up the mapping from array indices to cells\n            const id = ObjectIdentity.get(vertex);\n            this.indices[id] = i;\n            const bounds = this.getVertexBounds(vertex);\n            // Set the X,Y value of the internal version of the cell to\n            // the center point of the vertex for better positioning\n            const { width } = bounds;\n            const { height } = bounds;\n            // Randomize (0, 0) locations\n            const { x } = bounds;\n            const { y } = bounds;\n            this.cellLocation[i][0] = x + width / 2.0;\n            this.cellLocation[i][1] = y + height / 2.0;\n            this.radius[i] = Math.min(width, height);\n            this.radiusSquared[i] = this.radius[i] * this.radius[i];\n        }\n        // Moves cell location back to top-left from center locations used in\n        // algorithm, resetting the edge points is part of the transaction\n        this.graph.batchUpdate(() => {\n            for (let i = 0; i < n; i += 1) {\n                this.dispX[i] = 0;\n                this.dispY[i] = 0;\n                this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n                // Get lists of neighbours to all vertices, translate the cells\n                // obtained in indices into vertexArray and store as an array\n                // against the orginial cell index\n                const edges = this.graph.getConnections(this.vertexArray[i], parent);\n                cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n                this.neighbours[i] = [];\n                for (let j = 0; j < cells.length; j += 1) {\n                    // Resets the points on the traversed edge\n                    if (this.resetEdges) {\n                        this.graph.resetEdge(edges[j]);\n                    }\n                    if (this.disableEdgeStyle) {\n                        this.setEdgeStyleEnabled(edges[j], false);\n                    }\n                    // Looks the cell up in the indices dictionary\n                    const id = ObjectIdentity.get(cells[j]);\n                    const index = this.indices[id];\n                    // Check the connected cell in part of the vertex list to be\n                    // acted on by this layout\n                    if (index != null) {\n                        this.neighbours[i][j] = index;\n                    }\n                    // Else if index of the other cell doesn't correspond to\n                    // any cell listed to be acted upon in this layout. Set\n                    // the index to the value of this vertex (a dummy self-loop)\n                    // so the attraction force of the edge is not calculated\n                    else {\n                        this.neighbours[i][j] = i;\n                    }\n                }\n            }\n            this.temperature = this.initialTemp;\n            // If max number of iterations has not been set, guess it\n            if (this.maxIterations === 0) {\n                this.maxIterations = 20 * Math.sqrt(n);\n            }\n            // Main iteration loop\n            for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration += 1) {\n                if (!this.allowedToRun) {\n                    return;\n                }\n                // Calculate repulsive forces on all vertices\n                this.calcRepulsion();\n                // Calculate attractive forces through edges\n                this.calcAttraction();\n                this.calcPositions();\n                this.reduceTemperature();\n            }\n            let minx = null;\n            let miny = null;\n            for (let i = 0; i < this.vertexArray.length; i += 1) {\n                const vertex = this.vertexArray[i];\n                if (this.isVertexMovable(vertex)) {\n                    const bounds = this.getVertexBounds(vertex);\n                    if (bounds != null) {\n                        this.cellLocation[i][0] -= bounds.width / 2.0;\n                        this.cellLocation[i][1] -= bounds.height / 2.0;\n                        const x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n                        const y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n                        this.setVertexLocation(vertex, x, y);\n                        if (minx == null) {\n                            minx = x;\n                        }\n                        else {\n                            minx = Math.min(minx, x);\n                        }\n                        if (miny == null) {\n                            miny = y;\n                        }\n                        else {\n                            miny = Math.min(miny, y);\n                        }\n                    }\n                }\n            }\n            // Modifies the cloned geometries in-place. Not needed\n            // to clone the geometries again as we're in the same\n            // undoable change.\n            let dx = -(minx || 0) + 1;\n            let dy = -(miny || 0) + 1;\n            if (initialBounds != null) {\n                dx += initialBounds.x;\n                dy += initialBounds.y;\n            }\n            this.graph.moveCells(this.vertexArray, dx, dy);\n        });\n    }\n    /**\n     * Takes the displacements calculated for each cell and applies them to the\n     * local cache of cell positions. Limits the displacement to the current\n     * temperature.\n     */\n    calcPositions() {\n        for (let index = 0; index < this.vertexArray.length; index += 1) {\n            if (this.isMoveable[index]) {\n                // Get the distance of displacement for this node for this\n                // iteration\n                let deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);\n                if (deltaLength < 0.001) {\n                    deltaLength = 0.001;\n                }\n                // Scale down by the current temperature if less than the\n                // displacement distance\n                const newXDisp = (this.dispX[index] / deltaLength) * Math.min(deltaLength, this.temperature);\n                const newYDisp = (this.dispY[index] / deltaLength) * Math.min(deltaLength, this.temperature);\n                // reset displacements\n                this.dispX[index] = 0;\n                this.dispY[index] = 0;\n                // Update the cached cell locations\n                this.cellLocation[index][0] += newXDisp;\n                this.cellLocation[index][1] += newYDisp;\n            }\n        }\n    }\n    /**\n     * Calculates the attractive forces between all laid out nodes linked by\n     * edges\n     */\n    calcAttraction() {\n        // Check the neighbours of each vertex and calculate the attractive\n        // force of the edge connecting them\n        for (let i = 0; i < this.vertexArray.length; i += 1) {\n            for (let k = 0; k < this.neighbours[i].length; k += 1) {\n                // Get the index of the othe cell in the vertex array\n                const j = this.neighbours[i][k];\n                // Do not proceed self-loops\n                if (i !== j && this.isMoveable[i] && this.isMoveable[j]) {\n                    const xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n                    const yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n                    // The distance between the nodes\n                    let deltaLengthSquared = xDelta * xDelta +\n                        yDelta * yDelta -\n                        this.radiusSquared[i] -\n                        this.radiusSquared[j];\n                    if (deltaLengthSquared < this.minDistanceLimitSquared) {\n                        deltaLengthSquared = this.minDistanceLimitSquared;\n                    }\n                    const deltaLength = Math.sqrt(deltaLengthSquared);\n                    const force = deltaLengthSquared / this.forceConstant;\n                    const displacementX = (xDelta / deltaLength) * force;\n                    const displacementY = (yDelta / deltaLength) * force;\n                    this.dispX[i] -= displacementX;\n                    this.dispY[i] -= displacementY;\n                    this.dispX[j] += displacementX;\n                    this.dispY[j] += displacementY;\n                }\n            }\n        }\n    }\n    /**\n     * Calculates the repulsive forces between all laid out nodes\n     */\n    calcRepulsion() {\n        const vertexCount = this.vertexArray.length;\n        for (let i = 0; i < vertexCount; i += 1) {\n            for (let j = i; j < vertexCount; j += 1) {\n                // Exits if the layout is no longer allowed to run\n                if (!this.allowedToRun) {\n                    return;\n                }\n                if (j !== i && this.isMoveable[i] && this.isMoveable[j]) {\n                    let xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n                    let yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n                    if (xDelta === 0) {\n                        xDelta = 0.01 + Math.random();\n                    }\n                    if (yDelta === 0) {\n                        yDelta = 0.01 + Math.random();\n                    }\n                    // Distance between nodes\n                    const deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n                    let deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];\n                    if (deltaLengthWithRadius > this.maxDistanceLimit) {\n                        // Ignore vertices too far apart\n                        continue;\n                    }\n                    if (deltaLengthWithRadius < this.minDistanceLimit) {\n                        deltaLengthWithRadius = this.minDistanceLimit;\n                    }\n                    const force = this.forceConstantSquared / deltaLengthWithRadius;\n                    const displacementX = (xDelta / deltaLength) * force;\n                    const displacementY = (yDelta / deltaLength) * force;\n                    this.dispX[i] += displacementX;\n                    this.dispY[i] += displacementY;\n                    this.dispX[j] -= displacementX;\n                    this.dispY[j] -= displacementY;\n                }\n            }\n        }\n    }\n    /**\n     * Reduces the temperature of the layout from an initial setting in a linear\n     * fashion to zero.\n     */\n    reduceTemperature() {\n        this.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n    }\n}\nexport default MxFastOrganicLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport GraphLayout from './GraphLayout';\nimport ObjectIdentity from '../../util/ObjectIdentity';\n/**\n * Extends {@link GraphLayout} for arranging parallel edges. This layout works\n * on edges for all pairs of vertices where there is more than one edge\n * connecting the latter.\n *\n * Example:\n *\n * ```javascript\n * const layout = new ParallelEdgeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * To run the layout for the parallel edges of a changed edge only, the\n * following code can be used.\n *\n * ```javascript\n * const layout = new ParallelEdgeLayout(graph);\n *\n * graph.addListener(mxEvent.CELL_CONNECTED, (sender, evt) =>\n * {\n *   const model = graph.getDataModel();\n *   const edge = evt.getProperty('edge');\n *   const src = model.getTerminal(edge, true);\n *   const trg = model.getTerminal(edge, false);\n *\n *   layout.isEdgeIgnored = (edge2) =>\n *   {\n *     const src2 = model.getTerminal(edge2, true);\n *     const trg2 = model.getTerminal(edge2, false);\n *\n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\n *   };\n *\n *   layout.execute(graph.getDefaultParent());\n * });\n * ```\n *\n * @category Layout\n */\nclass ParallelEdgeLayout extends GraphLayout {\n    constructor(graph) {\n        super(graph);\n        /**\n         * Defines the spacing between the parallels. Default is 20.\n         */\n        this.spacing = 20;\n        /**\n         * Specifies if only overlapping edges should be considered\n         * parallel. Default is false.\n         */\n        this.checkOverlap = false;\n    }\n    /**\n     * Implements {@link GraphLayout#execute}.\n     */\n    execute(parent, cells = null) {\n        const lookup = this.findParallels(parent, cells);\n        this.graph.batchUpdate(() => {\n            for (const i in lookup) {\n                const parallels = lookup[i];\n                if (parallels.length > 1) {\n                    this.layout(parallels);\n                }\n            }\n        });\n    }\n    /**\n     * Finds the parallel edges in the given parent.\n     */\n    findParallels(parent, cells = null) {\n        const lookup = [];\n        const addCell = (cell) => {\n            if (!this.isEdgeIgnored(cell)) {\n                const id = this.getEdgeId(cell);\n                if (id != null) {\n                    if (lookup[id] == null) {\n                        lookup[id] = [];\n                    }\n                    lookup[id].push(cell);\n                }\n            }\n        };\n        if (cells != null) {\n            for (let i = 0; i < cells.length; i += 1) {\n                addCell(cells[i]);\n            }\n        }\n        else {\n            const model = this.graph.getDataModel();\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                addCell(parent.getChildAt(i));\n            }\n        }\n        return lookup;\n    }\n    /**\n     * Returns a unique ID for the given edge. The id is independent of the\n     * edge direction and is built using the visible terminal of the given\n     * edge.\n     */\n    getEdgeId(edge) {\n        const view = this.graph.getView();\n        // Cannot used cached visible terminal because this could be triggered in BEFORE_UNDO\n        let src = view.getVisibleTerminal(edge, true);\n        let trg = view.getVisibleTerminal(edge, false);\n        let pts = '';\n        if (src != null && trg != null) {\n            src = ObjectIdentity.get(src);\n            trg = ObjectIdentity.get(trg);\n            if (this.checkOverlap) {\n                const state = this.graph.view.getState(edge);\n                if (state != null && state.absolutePoints != null) {\n                    const tmp = [];\n                    for (let i = 0; i < state.absolutePoints.length; i += 1) {\n                        const pt = state.absolutePoints[i];\n                        if (pt != null) {\n                            tmp.push(pt.x, pt.y);\n                        }\n                    }\n                    pts = tmp.join(',');\n                }\n            }\n            return (src > trg ? `${trg}-${src}` : `${src}-${trg}`) + pts;\n        }\n        return null;\n    }\n    /**\n     * Lays out the parallel edges in the given array.\n     */\n    layout(parallels) {\n        const edge = parallels[0];\n        const view = this.graph.getView();\n        const model = this.graph.getDataModel();\n        const src = view.getVisibleTerminal(edge, true).getGeometry();\n        const trg = view.getVisibleTerminal(edge, false).getGeometry();\n        let x0;\n        let y0;\n        // Routes multiple loops\n        if (src === trg) {\n            x0 = src.x + src.width + this.spacing;\n            y0 = src.y + src.height / 2;\n            for (let i = 0; i < parallels.length; i += 1) {\n                this.route(parallels[i], x0, y0);\n                x0 += this.spacing;\n            }\n        }\n        else if (src != null && trg != null) {\n            // Routes parallel edges\n            const scx = src.x + src.width / 2;\n            const scy = src.y + src.height / 2;\n            const tcx = trg.x + trg.width / 2;\n            const tcy = trg.y + trg.height / 2;\n            const dx = tcx - scx;\n            const dy = tcy - scy;\n            const len = Math.sqrt(dx * dx + dy * dy);\n            if (len > 0) {\n                x0 = scx + dx / 2;\n                y0 = scy + dy / 2;\n                const nx = (dy * this.spacing) / len;\n                const ny = (dx * this.spacing) / len;\n                x0 += (nx * (parallels.length - 1)) / 2;\n                y0 -= (ny * (parallels.length - 1)) / 2;\n                for (let i = 0; i < parallels.length; i += 1) {\n                    this.route(parallels[i], x0, y0);\n                    x0 -= nx;\n                    y0 += ny;\n                }\n            }\n        }\n    }\n    /**\n     * Routes the given edge via the given point.\n     */\n    route(edge, x, y) {\n        if (this.graph.isCellMovable(edge)) {\n            this.setEdgePoints(edge, [new Point(x, y)]);\n        }\n    }\n}\nexport default ParallelEdgeLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Rectangle from '../geometry/Rectangle';\nimport GraphLayout from './GraphLayout';\n/**\n * Extends {@link GraphLayout} for partitioning the parent cell vertically or\n * horizontally by filling the complete area with the child cells. A horizontal\n * layout partitions the height of the given parent whereas a non-horizontal\n * layout partitions the width. If the parent is a layer (that is, a child of\n * the root node), then the current graph size is partitioned. The children do\n * not need to be connected for this layout to work.\n *\n * Example:\n *\n * ```javascript\n * const layout = new PartitionLayout(graph, true, 10, 20);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass PartitionLayout extends GraphLayout {\n    constructor(graph, horizontal = true, spacing = 0, border = 0) {\n        super(graph);\n        /**\n         * Boolean that specifies if vertices should be resized. Default is true.\n         */\n        this.resizeVertices = true;\n        this.horizontal = horizontal != null ? horizontal : true;\n        this.spacing = spacing || 0;\n        this.border = border || 0;\n    }\n    /**\n     * Returns <horizontal>.\n     */\n    isHorizontal() {\n        return this.horizontal;\n    }\n    /**\n     * Implements {@link GraphLayout.moveCell}.\n     *\n     * @param {mxCell} cell\n     * @param {number} x\n     * @param {number} y\n     * @memberof mxPartitionLayout\n     */\n    moveCell(cell, x, y) {\n        const model = this.graph.getDataModel();\n        const parent = cell.getParent();\n        if (cell != null && parent != null) {\n            let i = 0;\n            let last = 0;\n            const childCount = parent.getChildCount();\n            // Finds index of the closest swimlane\n            // TODO: Take into account the orientation\n            for (i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                const bounds = this.getVertexBounds(child);\n                if (bounds != null) {\n                    const tmp = bounds.x + bounds.width / 2;\n                    if (last < x && tmp > x) {\n                        break;\n                    }\n                    last = tmp;\n                }\n            }\n            // Changes child order in parent\n            let idx = parent.getIndex(cell);\n            idx = Math.max(0, i - (i > idx ? 1 : 0));\n            model.add(parent, cell, idx);\n        }\n    }\n    /**\n     * Implements {@link GraphLayout#execute}. All children where <isVertexIgnored>\n     * returns false and <isVertexMovable> returns true are modified.\n     */\n    execute(parent) {\n        const horizontal = this.isHorizontal();\n        const model = this.graph.getDataModel();\n        let pgeo = parent.getGeometry();\n        // Handles special case where the parent is either a layer with no\n        // geometry or the current root of the view in which case the size\n        // of the graph's container will be used.\n        if (this.graph.container != null &&\n            ((pgeo == null && model.isLayer(parent)) ||\n                parent === this.graph.getView().currentRoot)) {\n            const width = this.graph.container.offsetWidth - 1;\n            const height = this.graph.container.offsetHeight - 1;\n            pgeo = new Rectangle(0, 0, width, height);\n        }\n        if (pgeo != null) {\n            const children = [];\n            const childCount = parent.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = parent.getChildAt(i);\n                if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n                    children.push(child);\n                }\n            }\n            const n = children.length;\n            if (n > 0) {\n                let x0 = this.border;\n                let y0 = this.border;\n                let other = horizontal ? pgeo.height : pgeo.width;\n                other -= 2 * this.border;\n                const size = this.graph.isSwimlane(parent)\n                    ? this.graph.getStartSize(parent)\n                    : new Rectangle();\n                other -= horizontal ? size.height : size.width;\n                x0 += size.width;\n                y0 += size.height;\n                const tmp = this.border + (n - 1) * this.spacing;\n                const value = horizontal\n                    ? (pgeo.width - x0 - tmp) / n\n                    : (pgeo.height - y0 - tmp) / n;\n                // Avoids negative values, that is values where the sum of the\n                // spacing plus the border is larger then the available space\n                if (value > 0) {\n                    model.beginUpdate();\n                    try {\n                        for (let i = 0; i < n; i += 1) {\n                            const child = children[i];\n                            let geo = child.getGeometry();\n                            if (geo != null) {\n                                geo = geo.clone();\n                                geo.x = x0;\n                                geo.y = y0;\n                                if (horizontal) {\n                                    if (this.resizeVertices) {\n                                        geo.width = value;\n                                        geo.height = other;\n                                    }\n                                    x0 += value + this.spacing;\n                                }\n                                else {\n                                    if (this.resizeVertices) {\n                                        geo.height = value;\n                                        geo.width = other;\n                                    }\n                                    y0 += value + this.spacing;\n                                }\n                                model.setGeometry(child, geo);\n                            }\n                        }\n                    }\n                    finally {\n                        model.endUpdate();\n                    }\n                }\n            }\n        }\n    }\n}\nexport default PartitionLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { CompactTreeLayout, } from './CompactTreeLayout';\n/**\n * Extends {@link CompactTreeLayout} to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * ```javascript\n * const layout = new RadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * ```\n *\n * @category Layout\n */\nclass RadialTreeLayout extends CompactTreeLayout {\n    constructor(graph) {\n        super(graph, false);\n        this.centerX = null;\n        this.centerY = null;\n        /**\n         * The initial offset to compute the angle position.\n         * @default 0.5\n         */\n        this.angleOffset = 0.5;\n        /**\n         * The X co-ordinate of the root cell\n         * @default 0\n         */\n        this.rootx = 0;\n        /**\n         * The Y co-ordinate of the root cell\n         * @default 0\n         */\n        this.rooty = 0;\n        /**\n         * Holds the levelDistance.\n         * @default 120\n         */\n        this.levelDistance = 120;\n        /**\n         * Holds the nodeDistance.\n         * @default 10\n         */\n        this.nodeDistance = 10;\n        /**\n         * Specifies if the radios should be computed automatically\n         * @default false\n         */\n        this.autoRadius = false;\n        /**\n         * Specifies if edges should be sorted according to the order of their\n         * opposite terminal cell in the model.\n         * @default false\n         */\n        this.sortEdges = false;\n        /**\n         * Array of leftmost x coordinate of each row\n         */\n        this.rowMinX = {};\n        /**\n         * Array of rightmost x coordinate of each row\n         */\n        this.rowMaxX = {};\n        /**\n         * Array of x coordinate of leftmost vertex of each row\n         */\n        this.rowMinCenX = {};\n        /**\n         * Array of x coordinate of rightmost vertex of each row\n         */\n        this.rowMaxCenX = {};\n        /**\n         * Array of y deltas of each row behind root vertex, also the radius in the tree\n         */\n        this.rowRadi = {};\n        /**\n         * Array of vertices on each row\n         */\n        this.row = [];\n    }\n    /**\n     * Returns a boolean indicating if the given {@link mxCell} should be ignored as a vertex.\n     *\n     * @param vertex {@link mxCell} whose ignored state should be returned.\n     * @return true if the cell has no connections.\n     */\n    isVertexIgnored(vertex) {\n        return (super.isVertexIgnored(vertex) || this.graph.getConnections(vertex).length === 0);\n    }\n    /**\n     * Implements {@link GraphLayout#execute}.\n     *\n     * If the parent has any connected edges, then it is used as the root of\n     * the tree. Else, {@link Graph#findTreeRoots} will be used to find a suitable\n     * root node within the set of children of the given parent.\n     *\n     * @param parent    {@link mxCell} whose children should be laid out.\n     * @param root      Optional {@link mxCell} that will be used as the root of the tree.\n     */\n    execute(parent, root = null) {\n        this.parent = parent;\n        this.useBoundingBox = false;\n        this.edgeRouting = false;\n        // this.horizontal = false;\n        super.execute(parent, root || undefined);\n        let bounds = null;\n        const rootBounds = this.getVertexBounds(this.root);\n        this.centerX = rootBounds.x + rootBounds.width / 2;\n        this.centerY = rootBounds.y + rootBounds.height / 2;\n        // Calculate the bounds of the involved vertices directly from the values set in the compact tree\n        for (const vertex in this.visited) {\n            const vertexBounds = this.getVertexBounds(this.visited[vertex]);\n            bounds = bounds != null ? bounds : vertexBounds.clone();\n            bounds.add(vertexBounds);\n        }\n        this.calcRowDims([this.node], 0);\n        let maxLeftGrad = 0;\n        let maxRightGrad = 0;\n        // Find the steepest left and right gradients\n        for (let i = 0; i < this.row.length; i += 1) {\n            const leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n            const rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n            maxLeftGrad = Math.max(maxLeftGrad, leftGrad);\n            maxRightGrad = Math.max(maxRightGrad, rightGrad);\n        }\n        // Extend out row so they meet the maximum gradient and convert to polar co-ords\n        for (let i = 0; i < this.row.length; i += 1) {\n            const xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n            const xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n            const fullWidth = xRightLimit - xLeftLimit;\n            for (let j = 0; j < this.row[i].length; j++) {\n                const row = this.row[i];\n                const node = row[j];\n                const vertexBounds = this.getVertexBounds(node.cell);\n                const xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;\n                const theta = 2 * Math.PI * xProportion;\n                node.theta = theta;\n            }\n        }\n        // Post-process from outside inwards to try to align parents with children\n        for (let i = this.row.length - 2; i >= 0; i--) {\n            const row = this.row[i];\n            for (let j = 0; j < row.length; j++) {\n                const node = row[j];\n                let { child } = node;\n                let counter = 0;\n                let totalTheta = 0;\n                while (child != null) {\n                    totalTheta += child.theta;\n                    counter++;\n                    child = child.next;\n                }\n                if (counter > 0) {\n                    const averTheta = totalTheta / counter;\n                    if (averTheta > node.theta && j < row.length - 1) {\n                        const nextTheta = row[j + 1].theta;\n                        node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);\n                    }\n                    else if (averTheta < node.theta && j > 0) {\n                        const lastTheta = row[j - 1].theta;\n                        node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);\n                    }\n                }\n            }\n        }\n        // Set locations\n        for (let i = 0; i < this.row.length; i += 1) {\n            for (let j = 0; j < this.row[i].length; j++) {\n                const row = this.row[i];\n                const node = row[j];\n                const vertexBounds = this.getVertexBounds(node.cell);\n                this.setVertexLocation(node.cell, this.centerX -\n                    vertexBounds.width / 2 +\n                    this.rowRadi[i] * Math.cos(node.theta), this.centerY -\n                    vertexBounds.height / 2 +\n                    this.rowRadi[i] * Math.sin(node.theta));\n            }\n        }\n    }\n    /**\n     * Recursive function to calculate the dimensions of each row\n     *\n     * @param row      Array of internal nodes, the children of which are to be processed.\n     * @param rowNum   Integer indicating which row is being processed.\n     */\n    calcRowDims(row, rowNum) {\n        if (row == null || row.length === 0) {\n            return;\n        }\n        // Place root's children proportionally around the first level\n        this.rowMinX[rowNum] = this.centerX;\n        this.rowMaxX[rowNum] = this.centerX;\n        this.rowMinCenX[rowNum] = this.centerX;\n        this.rowMaxCenX[rowNum] = this.centerX;\n        this.row[rowNum] = [];\n        let rowHasChildren = false;\n        for (let i = 0; i < row.length; i += 1) {\n            let child = row[i] != null ? row[i].child : null;\n            while (child != null) {\n                const { cell } = child;\n                const vertexBounds = this.getVertexBounds(cell);\n                this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n                this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n                this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n                this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n                this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n                if (child.child != null) {\n                    rowHasChildren = true;\n                }\n                this.row[rowNum].push(child);\n                child = child.next;\n            }\n        }\n        if (rowHasChildren) {\n            this.calcRowDims(this.row[rowNum], rowNum + 1);\n        }\n    }\n}\nexport default RadialTreeLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * @category Layout\n */\nconst HierarchicalEdgeStyle = {\n    ORTHOGONAL: 1,\n    POLYLINE: 2,\n    STRAIGHT: 3,\n    CURVE: 4,\n};\nexport default HierarchicalEdgeStyle;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Cell from '../../cell/Cell';\n/**\n * An abstraction of an internal hierarchy node or edge.\n *\n * @category Layout\n */\nclass GraphAbstractHierarchyCell extends Cell {\n    constructor() {\n        super();\n        this.swimlaneIndex = null;\n        /**\n         * The maximum rank this cell occupies. Default is -1.\n         */\n        this.maxRank = -1;\n        /**\n         * The minimum rank this cell occupies. Default is -1.\n         */\n        this.minRank = -1;\n        /**\n         * The width of this cell. Default is 0.\n         */\n        this.width = 0;\n        /**\n         * The height of this cell. Default is 0.\n         */\n        this.height = 0;\n        /**\n         * A cached version of the cells this cell connects to on the next layer up\n         */\n        this.nextLayerConnectedCells = null;\n        /**\n         * A cached version of the cells this cell connects to on the next layer down\n         */\n        this.previousLayerConnectedCells = null;\n        this.x = [];\n        this.y = [];\n        this.temp = [];\n    }\n    /**\n     * Returns whether or not this cell is an edge\n     */\n    isEdge() {\n        return false;\n    }\n    /**\n     * Returns whether or not this cell is a node\n     */\n    isVertex() {\n        return false;\n    }\n    /**\n     * Set the value of x for the specified layer\n     */\n    setX(layer, value) {\n        if (this.isVertex()) {\n            this.x[0] = value;\n        }\n        else if (this.isEdge()) {\n            this.x[layer - this.minRank - 1] = value;\n        }\n    }\n    /**\n     * Gets the value of x on the specified layer\n     */\n    getX(layer) {\n        if (this.isVertex()) {\n            return this.x[0];\n        }\n        if (this.isEdge()) {\n            return this.x[layer - this.minRank - 1];\n        }\n        return 0.0;\n    }\n    /**\n     * Set the value of y for the specified layer\n     */\n    setY(layer, value) {\n        if (this.isVertex()) {\n            this.y[0] = value;\n        }\n        else if (this.isEdge()) {\n            this.y[layer - this.minRank - 1] = value;\n        }\n    }\n}\nexport default GraphAbstractHierarchyCell;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphAbstractHierarchyCell from './GraphAbstractHierarchyCell';\nimport ObjectIdentity from '../../../util/ObjectIdentity';\n/**\n * An abstraction of a hierarchical edge for the hierarchy layout\n *\n * @category Layout\n */\nclass GraphHierarchyNode extends GraphAbstractHierarchyCell {\n    /**\n     * Constructs an internal node to represent the specified real graph cell\n     *\n     * @param cell the real graph cell this node represents\n     */\n    constructor(cell) {\n        super();\n        /**\n         * The object identities of the wrapped cells\n         */\n        this.ids = [];\n        /**\n         * Assigns a unique hashcode for each node. Used by the model dfs instead\n         * of copying HashSets\n         */\n        this.hashCode = false;\n        this.cell = cell;\n        this.id = ObjectIdentity.get(cell);\n        this.connectsAsTarget = [];\n        this.connectsAsSource = [];\n    }\n    /**\n     * Returns the integer value of the layer that this node resides in\n     */\n    getRankValue(layer) {\n        return this.maxRank;\n    }\n    /**\n     * Returns the cells this cell connects to on the next layer up\n     */\n    getNextLayerConnectedCells(layer) {\n        if (this.nextLayerConnectedCells == null) {\n            this.nextLayerConnectedCells = {};\n            this.nextLayerConnectedCells[0] = [];\n            for (let i = 0; i < this.connectsAsTarget.length; i += 1) {\n                const edge = this.connectsAsTarget[i];\n                if (edge.maxRank === -1 || edge.maxRank === layer + 1) {\n                    // Either edge is not in any rank or\n                    // no dummy nodes in edge, add node of other side of edge\n                    this.nextLayerConnectedCells[0].push(edge.source);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    this.nextLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return this.nextLayerConnectedCells[0];\n    }\n    /**\n     * Returns the cells this cell connects to on the next layer down\n     */\n    getPreviousLayerConnectedCells(layer) {\n        if (this.previousLayerConnectedCells == null) {\n            this.previousLayerConnectedCells = [];\n            this.previousLayerConnectedCells[0] = [];\n            for (let i = 0; i < this.connectsAsSource.length; i += 1) {\n                const edge = this.connectsAsSource[i];\n                if (edge.minRank === -1 || edge.minRank === layer - 1) {\n                    // No dummy nodes in edge, add node of other side of edge\n                    this.previousLayerConnectedCells[0].push(edge.target);\n                }\n                else {\n                    // Edge spans at least two layers, add edge\n                    this.previousLayerConnectedCells[0].push(edge);\n                }\n            }\n        }\n        return this.previousLayerConnectedCells[0];\n    }\n    /**\n     * Returns true.\n     */\n    isVertex() {\n        return true;\n    }\n    /**\n     * Gets the value of temp for the specified layer\n     */\n    getGeneralPurposeVariable(layer) {\n        return this.temp[0];\n    }\n    /**\n     * Set the value of temp for the specified layer\n     */\n    setGeneralPurposeVariable(layer, value) {\n        this.temp[0] = value;\n    }\n    isAncestor(otherNode) {\n        // Firstly, the hash code of this node needs to be shorter than the\n        // other node\n        if (otherNode != null &&\n            this.hashCode != null &&\n            otherNode.hashCode != null &&\n            this.hashCode.length < otherNode.hashCode.length) {\n            if (this.hashCode === otherNode.hashCode) {\n                return true;\n            }\n            if (this.hashCode == null || this.hashCode == null) {\n                return false;\n            }\n            // Secondly, this hash code must match the start of the other\n            // node's hash code. Arrays.equals cannot be used here since\n            // the arrays are different length, and we do not want to\n            // perform another array copy.\n            for (let i = 0; i < this.hashCode.length; i += 1) {\n                if (this.hashCode[i] !== otherNode.hashCode[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Gets the core vertex associated with this wrapper\n     */\n    getCoreCell() {\n        return this.cell;\n    }\n}\nexport default GraphHierarchyNode;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphAbstractHierarchyCell from './GraphAbstractHierarchyCell';\nimport ObjectIdentity from '../../../util/ObjectIdentity';\n/**\n * An abstraction of a hierarchical edge for the hierarchy layout\n *\n * @category Layout\n */\nclass GraphHierarchyEdge extends GraphAbstractHierarchyCell {\n    /**\n     * Constructs a hierarchy edge\n     *\n     * @param edges a list of real graph edges this abstraction represents\n     */\n    constructor(edges) {\n        super();\n        /**\n         * The node this edge is sourced at\n         */\n        this.source = null;\n        /**\n         * The node this edge targets\n         */\n        this.target = null;\n        /**\n         * Whether or not the direction of this edge has been reversed\n         * internally to create a DAG for the hierarchical layout\n         */\n        this.isReversed = false;\n        this.edges = edges;\n        this.ids = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            this.ids.push(ObjectIdentity.get(edges[i]));\n        }\n    }\n    /**\n     * Inverts the direction of this internal edge(s)\n     */\n    invert() {\n        const temp = this.source;\n        this.source = this.target;\n        this.target = temp;\n        this.isReversed = !this.isReversed;\n    }\n    /**\n     * Returns the cells this cell connects to on the next layer up\n     */\n    getNextLayerConnectedCells(layer) {\n        if (this.nextLayerConnectedCells == null) {\n            this.nextLayerConnectedCells = [];\n            for (let i = 0; i < this.temp.length; i += 1) {\n                this.nextLayerConnectedCells[i] = [];\n                if (i === this.temp.length - 1) {\n                    this.nextLayerConnectedCells[i].push(this.source);\n                }\n                else {\n                    this.nextLayerConnectedCells[i].push(this);\n                }\n            }\n        }\n        return this.nextLayerConnectedCells[layer - this.minRank - 1];\n    }\n    /**\n     * Returns the cells this cell connects to on the next layer down\n     */\n    getPreviousLayerConnectedCells(layer) {\n        if (this.previousLayerConnectedCells == null) {\n            this.previousLayerConnectedCells = [];\n            for (let i = 0; i < this.temp.length; i += 1) {\n                this.previousLayerConnectedCells[i] = [];\n                if (i === 0) {\n                    this.previousLayerConnectedCells[i].push(this.target);\n                }\n                else {\n                    this.previousLayerConnectedCells[i].push(this);\n                }\n            }\n        }\n        return this.previousLayerConnectedCells[layer - this.minRank - 1];\n    }\n    /**\n     * Returns true.\n     */\n    isEdge() {\n        return true;\n    }\n    /**\n     * Gets the value of temp for the specified layer\n     */\n    getGeneralPurposeVariable(layer) {\n        return this.temp[layer - this.minRank - 1];\n    }\n    /**\n     * Set the value of temp for the specified layer\n     */\n    setGeneralPurposeVariable(layer, value) {\n        this.temp[layer - this.minRank - 1] = value;\n    }\n    /**\n     * Gets the first core edge associated with this wrapper\n     */\n    getCoreCell() {\n        if (this.edges.length > 0) {\n            return this.edges[0];\n        }\n        return null;\n    }\n}\nexport default GraphHierarchyEdge;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Dictionary from '../../../util/Dictionary';\nimport GraphHierarchyNode from '../datatypes/GraphHierarchyNode';\nimport GraphHierarchyEdge from '../datatypes/GraphHierarchyEdge';\n/**\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * @category Layout\n */\nclass GraphHierarchyModel {\n    /**\n     *\n     * Creates an internal ordered graph model using the vertices passed in. If\n     * there are any, leftward edge need to be inverted in the internal model\n     *\n     * @param layout\n     * @param vertices the vertices for this hierarchy\n     * @param roots\n     * @param parent\n     * @param tightenToSource whether or not to tighten vertices towards the sources\n     */\n    constructor(layout, vertices, roots, parent, tightenToSource) {\n        /**\n         * Mapping from rank number to actual rank\n         */\n        this.ranks = null;\n        /**\n         * Store of roots of this hierarchy model, these are real graph cells, not\n         * internal cells\n         */\n        this.roots = null;\n        /**\n         * The parent cell whose children are being laid out\n         */\n        this.parent = null;\n        /**\n         * Count of the number of times the ancestor dfs has been used.\n         */\n        this.dfsCount = 0;\n        /**\n         * High value to start source layering scan rank value from.\n         */\n        this.SOURCESCANSTARTRANK = 100000000;\n        /**\n         * Whether or not to tighten the assigned ranks of vertices up towards\n         * the source cells.\n         */\n        this.tightenToSource = false;\n        const graph = layout.getGraph();\n        this.tightenToSource = tightenToSource;\n        this.roots = roots;\n        this.parent = parent;\n        // map of cells to internal cell needed for second run through\n        // to setup the sink of edges correctly\n        this.vertexMapper = new Dictionary();\n        this.edgeMapper = new Dictionary();\n        this.maxRank = 0;\n        const internalVertices = {};\n        if (vertices == null) {\n            vertices = graph.getChildVertices(parent);\n        }\n        this.maxRank = this.SOURCESCANSTARTRANK;\n        // map of cells to internal cell needed for second run through\n        // to setup the sink of edges correctly. Guess size by number\n        // of edges is roughly same as number of vertices.\n        this.createInternalCells(layout, vertices, internalVertices);\n        // Go through edges set their sink values. Also check the\n        // ordering if and invert edges if necessary\n        for (let i = 0; i < vertices.length; i += 1) {\n            const edges = internalVertices[i].connectsAsSource;\n            for (let j = 0; j < edges.length; j++) {\n                const internalEdge = edges[j];\n                const realEdges = internalEdge.edges;\n                // Only need to process the first real edge, since\n                // all the edges connect to the same other vertex\n                if (realEdges != null && realEdges.length > 0) {\n                    const realEdge = realEdges[0];\n                    let targetCell = layout.getVisibleTerminal(realEdge, false);\n                    let internalTargetCell = this.vertexMapper.get(targetCell);\n                    if (internalVertices[i] === internalTargetCell) {\n                        // If there are parallel edges going between two vertices and not all are in the same direction\n                        // you can have navigated across one direction when doing the cycle reversal that isn't the same\n                        // direction as the first real edge in the array above. When that happens the if above catches\n                        // that and we correct the target cell before continuing.\n                        // This branch only detects this single case\n                        targetCell = layout.getVisibleTerminal(realEdge, true);\n                        internalTargetCell = this.vertexMapper.get(targetCell);\n                    }\n                    if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {\n                        internalEdge.target = internalTargetCell;\n                        if (internalTargetCell.connectsAsTarget.length === 0) {\n                            internalTargetCell.connectsAsTarget = [];\n                        }\n                        if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {\n                            internalTargetCell.connectsAsTarget.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            // Use the temp variable in the internal nodes to mark this\n            // internal vertex as having been visited.\n            internalVertices[i].temp[0] = 1;\n        }\n    }\n    /**\n     * Creates all edges in the internal model\n     *\n     * @param layout Reference to the <HierarchicalLayout> algorithm.\n     * @param vertices Array of {@link Cells} that represent the vertices whom are to\n     * have an internal representation created.\n     * @param internalVertices The array of {@link GraphHierarchyNodes} to have their\n     * information filled in using the real vertices.\n     */\n    createInternalCells(layout, vertices, internalVertices) {\n        const graph = layout.getGraph();\n        // Create internal edges\n        for (let i = 0; i < vertices.length; i += 1) {\n            internalVertices[i] = new GraphHierarchyNode(vertices[i]);\n            this.vertexMapper.put(vertices[i], internalVertices[i]);\n            // If the layout is deterministic, order the cells\n            // List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n            const conns = layout.getEdges(vertices[i]);\n            internalVertices[i].connectsAsSource = [];\n            // Create internal edges, but don't do any rank assignment yet\n            // First use the information from the greedy cycle remover to\n            // invert the leftward edges internally\n            for (let j = 0; j < conns.length; j++) {\n                const cell = layout.getVisibleTerminal(conns[j], false);\n                // Looking for outgoing edges only\n                if (cell !== vertices[i] && cell.isVertex() && !layout.isVertexIgnored(cell)) {\n                    // We process all edge between this source and its targets\n                    // If there are edges going both ways, we need to collect\n                    // them all into one internal edges to avoid looping problems\n                    // later. We assume this direction (source -> target) is the\n                    // natural direction if at least half the edges are going in\n                    // that direction.\n                    // The check below for edges[0] being in the vertex mapper is\n                    // in case we've processed this the other way around\n                    // (target -> source) and the number of edges in each direction\n                    // are the same. All the graph edges will have been assigned to\n                    // an internal edge going the other way, so we don't want to\n                    // process them again\n                    const undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);\n                    const directedEdges = layout.getEdgesBetween(vertices[i], cell, true);\n                    if (undirectedEdges != null &&\n                        undirectedEdges.length > 0 &&\n                        this.edgeMapper.get(undirectedEdges[0]) == null &&\n                        directedEdges.length * 2 >= undirectedEdges.length) {\n                        const internalEdge = new GraphHierarchyEdge(undirectedEdges);\n                        for (let k = 0; k < undirectedEdges.length; k++) {\n                            const edge = undirectedEdges[k];\n                            this.edgeMapper.put(edge, internalEdge);\n                            // Resets all point on the edge and disables the edge style\n                            // without deleting it from the cell style\n                            graph.resetEdge(edge);\n                            if (layout.disableEdgeStyle) {\n                                layout.setEdgeStyleEnabled(edge, false);\n                                layout.setOrthogonalEdge(edge, true);\n                            }\n                        }\n                        internalEdge.source = internalVertices[i];\n                        if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {\n                            internalVertices[i].connectsAsSource.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            // Ensure temp variable is cleared from any previous use\n            internalVertices[i].temp[0] = 0;\n        }\n    }\n    /**\n     * Basic determination of minimum layer ranking by working from from sources\n     * or sinks and working through each node in the relevant edge direction.\n     * Starting at the sinks is basically a longest path layering algorithm.\n     */\n    initialRank() {\n        const startNodes = [];\n        if (this.roots != null) {\n            for (let i = 0; i < this.roots.length; i += 1) {\n                const internalNode = this.vertexMapper.get(this.roots[i]);\n                if (internalNode != null) {\n                    startNodes.push(internalNode);\n                }\n            }\n        }\n        const internalNodes = this.vertexMapper.getValues();\n        for (let i = 0; i < internalNodes.length; i += 1) {\n            // Mark the node as not having had a layer assigned\n            internalNodes[i].temp[0] = -1;\n        }\n        const startNodesCopy = startNodes.slice();\n        while (startNodes.length > 0) {\n            const internalNode = startNodes[0];\n            const layerDeterminingEdges = internalNode.connectsAsTarget;\n            const edgesToBeMarked = internalNode.connectsAsSource;\n            // flag to keep track of whether or not all layer determining\n            // edges have been scanned\n            let allEdgesScanned = true;\n            // Work out the layer of this node from the layer determining\n            // edges. The minimum layer number of any node connected by one of\n            // the layer determining edges variable\n            let minimumLayer = this.SOURCESCANSTARTRANK;\n            for (let i = 0; i < layerDeterminingEdges.length; i += 1) {\n                const internalEdge = layerDeterminingEdges[i];\n                if (internalEdge.temp[0] === 5270620) {\n                    // This edge has been scanned, get the layer of the\n                    // node on the other end\n                    const otherNode = internalEdge.source;\n                    minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n                }\n                else {\n                    allEdgesScanned = false;\n                    break;\n                }\n            }\n            // If all edge have been scanned, assign the layer, mark all\n            // edges in the other direction and remove from the nodes list\n            if (allEdgesScanned) {\n                internalNode.temp[0] = minimumLayer;\n                this.maxRank = Math.min(this.maxRank, minimumLayer);\n                if (edgesToBeMarked != null) {\n                    for (let i = 0; i < edgesToBeMarked.length; i += 1) {\n                        const internalEdge = edgesToBeMarked[i];\n                        // Assign unique stamp ( y/m/d/h )\n                        internalEdge.temp[0] = 5270620;\n                        // Add node on other end of edge to LinkedList of\n                        // nodes to be analysed\n                        const otherNode = internalEdge.target;\n                        // Only add node if it hasn't been assigned a layer\n                        if (otherNode.temp[0] === -1) {\n                            startNodes.push(otherNode);\n                            // Mark this other node as neither being\n                            // unassigned nor assigned so it isn't\n                            // added to this list again, but it's\n                            // layer isn't used in any calculation.\n                            otherNode.temp[0] = -2;\n                        }\n                    }\n                }\n                startNodes.shift();\n            }\n            else {\n                // Not all the edges have been scanned, get to the back of\n                // the class and put the dunces cap on\n                const removedCell = startNodes.shift();\n                startNodes.push(internalNode);\n                if (removedCell === internalNode && startNodes.length === 1) {\n                    // This is an error condition, we can't get out of\n                    // this loop. It could happen for more than one node\n                    // but that's a lot harder to detect. Log the error\n                    // TODO make log comment\n                    break;\n                }\n            }\n        }\n        // Normalize the ranks down from their large starting value to place\n        // at least 1 sink on layer 0\n        for (let i = 0; i < internalNodes.length; i += 1) {\n            // Mark the node as not having had a layer assigned\n            internalNodes[i].temp[0] -= this.maxRank;\n        }\n        // Tighten the rank 0 nodes as far as possible\n        for (let i = 0; i < startNodesCopy.length; i += 1) {\n            const internalNode = startNodesCopy[i];\n            let currentMaxLayer = 0;\n            const layerDeterminingEdges = internalNode.connectsAsSource;\n            for (let j = 0; j < layerDeterminingEdges.length; j++) {\n                const internalEdge = layerDeterminingEdges[j];\n                const otherNode = internalEdge.target;\n                internalNode.temp[0] = Math.max(currentMaxLayer, otherNode.temp[0] + 1);\n                currentMaxLayer = internalNode.temp[0];\n            }\n        }\n        // Reset the maxRank to that which would be expected for a from-sink\n        // scan\n        this.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;\n    }\n    /**\n     * Fixes the layer assignments to the values stored in the nodes. Also needs\n     * to create dummy nodes for edges that cross layers.\n     */\n    fixRanks() {\n        // TODO: Should this be a Cell[]?\n        const rankList = {};\n        this.ranks = [];\n        for (let i = 0; i < this.maxRank + 1; i += 1) {\n            rankList[i] = [];\n            this.ranks.push(rankList[i]);\n        }\n        // Perform a DFS to obtain an initial ordering for each rank.\n        // Without doing this you would end up having to process\n        // crossings for a standard tree.\n        let rootsArray = null;\n        if (this.roots != null) {\n            const oldRootsArray = this.roots;\n            rootsArray = [];\n            for (let i = 0; i < oldRootsArray.length; i += 1) {\n                const cell = oldRootsArray[i];\n                const internalNode = this.vertexMapper.get(cell);\n                rootsArray[i] = internalNode;\n            }\n        }\n        this.visit((parent, node, edge, layer, seen) => {\n            if (seen == 0 && node.maxRank < 0 && node.minRank < 0) {\n                rankList[node.temp[0]].push(node);\n                node.maxRank = node.temp[0];\n                node.minRank = node.temp[0];\n                // Set temp[0] to the nodes position in the rank\n                node.temp[0] = rankList[node.maxRank].length - 1;\n            }\n            if (parent != null && edge != null) {\n                const parentToCellRankDifference = parent.maxRank - node.maxRank;\n                if (parentToCellRankDifference > 1) {\n                    // There are ranks in between the parent and current cell\n                    edge.maxRank = parent.maxRank;\n                    edge.minRank = node.maxRank;\n                    edge.temp = [];\n                    edge.x = [];\n                    edge.y = [];\n                    for (let i = edge.minRank + 1; i < edge.maxRank; i += 1) {\n                        // The connecting edge must be added to the\n                        // appropriate ranks\n                        rankList[i].push(edge);\n                        edge.setGeneralPurposeVariable(i, rankList[i].length - 1);\n                    }\n                }\n            }\n        }, rootsArray, false, null);\n    }\n    /**\n     * A depth first search through the internal heirarchy model.\n     *\n     * @param visitor The visitor function pattern to be called for each node.\n     * @param trackAncestors Whether or not the search is to keep track all nodes\n     * directly above this one in the search path.\n     */\n    visit(visitor, dfsRoots, trackAncestors, seenNodes = null) {\n        // Run dfs through on all roots\n        if (dfsRoots != null) {\n            for (let i = 0; i < dfsRoots.length; i += 1) {\n                const internalNode = dfsRoots[i];\n                if (internalNode != null) {\n                    if (seenNodes == null) {\n                        seenNodes = {};\n                    }\n                    if (trackAncestors) {\n                        // Set up hash code for root\n                        internalNode.hashCode = [];\n                        internalNode.hashCode[0] = this.dfsCount;\n                        internalNode.hashCode[1] = i;\n                        this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);\n                    }\n                    else {\n                        this.dfs(null, internalNode, null, visitor, seenNodes, 0);\n                    }\n                }\n            }\n            this.dfsCount++;\n        }\n    }\n    /**\n     * Performs a depth first search on the internal hierarchy model\n     *\n     * @param parent the parent internal node of the current internal node\n     * @param root the current internal node\n     * @param connectingEdge the internal edge connecting the internal node and the parent\n     * internal node, if any\n     * @param visitor the visitor pattern to be called for each node\n     * @param seen a set of all nodes seen by this dfs a set of all of the\n     * ancestor node of the current node\n     * @param layer the layer on the dfs tree ( not the same as the model ranks )\n     */\n    dfs(parent, root, connectingEdge, visitor, seen, layer) {\n        if (root != null) {\n            const rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                visitor(parent, root, connectingEdge, layer, 0);\n                // Copy the connects as source list so that visitors\n                // can change the original for edge direction inversions\n                const outgoingEdges = root.connectsAsSource.slice();\n                for (let i = 0; i < outgoingEdges.length; i += 1) {\n                    const internalEdge = outgoingEdges[i];\n                    const targetNode = internalEdge.target;\n                    // Root check is O(|roots|)\n                    this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);\n                }\n            }\n            else {\n                // Use the int field to indicate this node has been seen\n                visitor(parent, root, connectingEdge, layer, 1);\n            }\n        }\n    }\n    /**\n     * Performs a depth first search on the internal hierarchy model. This dfs\n     * extends the default version by keeping track of cells ancestors, but it\n     * should be only used when necessary because of it can be computationally\n     * intensive for deep searches.\n     *\n     * @param parent the parent internal node of the current internal node\n     * @param root the current internal node\n     * @param connectingEdge the internal edge connecting the internal node and the parent\n     * internal node, if any\n     * @param visitor the visitor pattern to be called for each node\n     * @param seen a set of all nodes seen by this dfs\n     * @param ancestors the parent hash code\n     * @param childHash the new hash code for this node\n     * @param layer the layer on the dfs tree ( not the same as the model ranks )\n     */\n    extendedDfs(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {\n        // Explanation of custom hash set. Previously, the ancestors variable\n        // was passed through the dfs as a HashSet. The ancestors were copied\n        // into a new HashSet and when the new child was processed it was also\n        // added to the set. If the current node was in its ancestor list it\n        // meant there is a cycle in the graph and this information is passed\n        // to the visitor.visit() in the seen parameter. The HashSet clone was\n        // very expensive on CPU so a custom hash was developed using primitive\n        // types. temp[] couldn't be used so hashCode[] was added to each node.\n        // Each new child adds another int to the array, copying the prefix\n        // from its parent. Child of the same parent add different ints (the\n        // limit is therefore 2^32 children per parent...). If a node has a\n        // child with the hashCode already set then the child code is compared\n        // to the same portion of the current nodes array. If they match there\n        // is a loop.\n        // Note that the basic mechanism would only allow for 1 use of this\n        // functionality, so the root nodes have two ints. The second int is\n        // incremented through each node root and the first is incremented\n        // through each run of the dfs algorithm (therefore the dfs is not\n        // thread safe). The hash code of each node is set if not already set,\n        // or if the first int does not match that of the current run.\n        if (root != null) {\n            if (parent != null) {\n                // Form this nodes hash code if necessary, that is, if the\n                // hashCode variable has not been initialized or if the\n                // start of the parent hash code does not equal the start of\n                // this nodes hash code, indicating the code was set on a\n                // previous run of this dfs.\n                if (root.hashCode == null || root.hashCode[0] != parent.hashCode[0]) {\n                    const hashCodeLength = parent.hashCode.length + 1;\n                    root.hashCode = parent.hashCode.slice();\n                    root.hashCode[hashCodeLength - 1] = childHash;\n                }\n            }\n            const rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                visitor(parent, root, connectingEdge, layer, 0);\n                // Copy the connects as source list so that visitors\n                // can change the original for edge direction inversions\n                const outgoingEdges = root.connectsAsSource.slice();\n                for (let i = 0; i < outgoingEdges.length; i += 1) {\n                    const internalEdge = outgoingEdges[i];\n                    const targetNode = internalEdge.target;\n                    // Root check is O(|roots|)\n                    this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);\n                }\n            }\n            else {\n                // Use the int field to indicate this node has been seen\n                visitor(parent, root, connectingEdge, layer, 1);\n            }\n        }\n    }\n}\nexport default GraphHierarchyModel;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * The specific layout interface for hierarchical layouts. It adds a {@link execute}\n * method for the hierarchical layout model that is shared between the layout stages.\n *\n * @category Layout\n */\nclass HierarchicalLayoutStage {\n}\nexport default HierarchicalLayoutStage;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport { remove } from '../../../util/arrayUtils';\nimport { clone } from '../../../util/cloneUtils';\n/**\n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n *\n * @category Layout\n */\nclass MinimumCycleRemover extends HierarchicalLayoutStage {\n    /**\n     * Creates a cycle remover for the given internal model.\n     */\n    constructor(layout) {\n        super();\n        this.layout = layout;\n    }\n    /**\n     * Takes the graph detail and configuration information within the facade\n     * and creates the resulting laid out graph within that facade for further\n     * use.\n     */\n    execute(parent) {\n        const model = this.layout.getDataModel();\n        const seenNodes = {};\n        const unseenNodesArray = model.vertexMapper.getValues();\n        const unseenNodes = {};\n        for (let i = 0; i < unseenNodesArray.length; i += 1) {\n            unseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];\n        }\n        // Perform a dfs through the internal model. If a cycle is found,\n        // reverse it.\n        let rootsArray = null;\n        if (model.roots != null) {\n            const modelRoots = model.roots;\n            rootsArray = [];\n            for (let i = 0; i < modelRoots.length; i += 1) {\n                rootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n            }\n        }\n        model.visit((parent, node, connectingEdge, layer, seen) => {\n            // Check if the cell is in it's own ancestor list, if so\n            // invert the connecting edge and reverse the target/source\n            // relationship to that edge in the parent and the cell\n            if (node.isAncestor(parent)) {\n                connectingEdge.invert();\n                remove(connectingEdge, parent.connectsAsSource);\n                parent.connectsAsTarget.push(connectingEdge);\n                remove(connectingEdge, node.connectsAsTarget);\n                node.connectsAsSource.push(connectingEdge);\n            }\n            seenNodes[node.id] = node;\n            delete unseenNodes[node.id];\n        }, rootsArray, true, null);\n        // If there are any nodes that should be nodes that the dfs can miss\n        // these need to be processed with the dfs and the roots assigned\n        // correctly to form a correct internal model\n        const seenNodesCopy = clone(seenNodes, null, true);\n        // Pick a random cell and dfs from it\n        model.visit((parent, node, connectingEdge, layer, seen) => {\n            // Check if the cell is in it's own ancestor list, if so\n            // invert the connecting edge and reverse the target/source\n            // relationship to that edge in the parent and the cell\n            if (node.isAncestor(parent)) {\n                connectingEdge.invert();\n                remove(connectingEdge, parent.connectsAsSource);\n                node.connectsAsSource.push(connectingEdge);\n                parent.connectsAsTarget.push(connectingEdge);\n                remove(connectingEdge, node.connectsAsTarget);\n            }\n            seenNodes[node.id] = node;\n            delete unseenNodes[node.id];\n        }, Object.values(unseenNodes), true, seenNodesCopy);\n    }\n}\nexport default MinimumCycleRemover;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * A utility class used to track cells whilst sorting occurs on the median\n * values. Does not violate (x.compareTo(y)==0) == (x.equals(y))\n *\n * @category Layout\n */\nclass MedianCellSorter {\n    constructor() {\n        /**\n         * The weighted value of the cell stored.\n         */\n        this.medianValue = 0;\n        /**\n         * The cell whose median value is being calculated\n         */\n        this.cell = false;\n        // empty\n    }\n    /**\n     * Compares two MedianCellSorters.\n     */\n    compare(a, b) {\n        if (a != null && b != null) {\n            if (b.medianValue > a.medianValue) {\n                return -1;\n            }\n            if (b.medianValue < a.medianValue) {\n                return 1;\n            }\n            return 0;\n        }\n        return 0;\n    }\n}\nexport default MedianCellSorter;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport MedianCellSorter from '../util/MedianCellSorter';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weightings as well heuristic to straighten edges as\n * far as possible.\n *\n * @category Layout\n */\nclass MedianHybridCrossingReduction extends HierarchicalLayoutStage {\n    constructor(layout) {\n        super();\n        /**\n         * The maximum number of iterations to perform whilst reducing edge\n         * crossings. Default is 24.\n         */\n        this.maxIterations = 24;\n        /**\n         * Stores each rank as a collection of cells in the best order found for\n         * each layer so far\n         */\n        this.nestedBestRanks = null;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.currentBestCrossings = 0;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.iterationsWithoutImprovement = 0;\n        /**\n         * The total number of crossings found in the best configuration so far\n         */\n        this.maxNoImprovementIterations = 2;\n        this.layout = layout;\n    }\n    /**\n     * Performs a vertex ordering within ranks as described by Gansner et al\n     * 1993\n     */\n    execute(parent) {\n        const model = this.layout.getDataModel();\n        let ranks = model.ranks;\n        // Stores initial ordering as being the best one found so far\n        this.nestedBestRanks = [];\n        for (let i = 0; i < ranks.length; i += 1) {\n            this.nestedBestRanks[i] = ranks[i].slice();\n        }\n        let iterationsWithoutImprovement = 0;\n        let currentBestCrossings = this.calculateCrossings(model);\n        for (let i = 0; i < this.maxIterations &&\n            iterationsWithoutImprovement < this.maxNoImprovementIterations; i++) {\n            this.weightedMedian(i, model);\n            this.transpose(i, model);\n            const candidateCrossings = this.calculateCrossings(model);\n            if (candidateCrossings < currentBestCrossings) {\n                currentBestCrossings = candidateCrossings;\n                iterationsWithoutImprovement = 0;\n                // Store the current rankings as the best ones\n                for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n                    const rank = ranks[j];\n                    for (let k = 0; k < rank.length; k += 1) {\n                        const cell = rank[k];\n                        this.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;\n                    }\n                }\n            }\n            else {\n                // Increase count of iterations where we haven't improved the\n                // layout\n                iterationsWithoutImprovement += 1;\n                // Restore the best values to the cells\n                for (let j = 0; j < this.nestedBestRanks.length; j += 1) {\n                    const rank = ranks[j];\n                    for (let k = 0; k < rank.length; k += 1) {\n                        const cell = rank[k];\n                        cell.setGeneralPurposeVariable(j, k);\n                    }\n                }\n            }\n            if (currentBestCrossings === 0) {\n                // Do nothing further\n                break;\n            }\n        }\n        // Store the best rankings but in the model\n        ranks = [];\n        const rankList = [];\n        for (let i = 0; i < model.maxRank + 1; i += 1) {\n            rankList[i] = [];\n            ranks[i] = rankList[i];\n        }\n        for (let i = 0; i < this.nestedBestRanks.length; i += 1) {\n            for (let j = 0; j < this.nestedBestRanks[i].length; j += 1) {\n                rankList[i].push(this.nestedBestRanks[i][j]);\n            }\n        }\n        model.ranks = ranks;\n    }\n    /**\n     * Calculates the total number of edge crossing in the current graph.\n     * Returns the current number of edge crossings in the hierarchy graph\n     * model in the current candidate layout\n     *\n     * @param model the internal model describing the hierarchy\n     */\n    calculateCrossings(model) {\n        const ranks = model.ranks;\n        const numRanks = ranks.length;\n        let totalCrossings = 0;\n        for (let i = 1; i < numRanks; i += 1) {\n            totalCrossings += this.calculateRankCrossing(i, model);\n        }\n        return totalCrossings;\n    }\n    /**\n     * Calculates the number of edges crossings between the specified rank and\n     * the rank below it. Returns the number of edges crossings with the rank\n     * beneath\n     *\n     * @param i  the topmost rank of the pair ( higher rank value )\n     * @param model the internal model describing the hierarchy\n     */\n    calculateRankCrossing(i, model) {\n        let totalCrossings = 0;\n        const ranks = model.ranks;\n        const rank = ranks[i];\n        const previousRank = ranks[i - 1];\n        const tmpIndices = [];\n        // Iterate over the top rank and fill in the connection information\n        for (let j = 0; j < rank.length; j += 1) {\n            const node = rank[j];\n            const rankPosition = node.getGeneralPurposeVariable(i);\n            const connectedCells = (node.getPreviousLayerConnectedCells(i));\n            const nodeIndices = [];\n            for (let k = 0; k < connectedCells.length; k += 1) {\n                const connectedNode = connectedCells[k];\n                const otherCellRankPosition = (connectedNode.getGeneralPurposeVariable(i - 1));\n                nodeIndices.push(otherCellRankPosition);\n            }\n            nodeIndices.sort((x, y) => {\n                return x - y;\n            });\n            tmpIndices[rankPosition] = nodeIndices;\n        }\n        let indices = [];\n        for (let j = 0; j < tmpIndices.length; j++) {\n            indices = indices.concat(tmpIndices[j]);\n        }\n        let firstIndex = 1;\n        while (firstIndex < previousRank.length) {\n            firstIndex <<= 1;\n        }\n        const treeSize = 2 * firstIndex - 1;\n        firstIndex -= 1;\n        const tree = [];\n        for (let j = 0; j < treeSize; ++j) {\n            tree[j] = 0;\n        }\n        for (let j = 0; j < indices.length; j += 1) {\n            const index = indices[j];\n            let treeIndex = index + firstIndex;\n            ++tree[treeIndex];\n            while (treeIndex > 0) {\n                if (treeIndex % 2) {\n                    totalCrossings += tree[treeIndex + 1];\n                }\n                treeIndex = (treeIndex - 1) >> 1;\n                ++tree[treeIndex];\n            }\n        }\n        return totalCrossings;\n    }\n    /**\n     * Takes each possible adjacent cell pair on each rank and checks if\n     * swapping them around reduces the number of crossing\n     *\n     * @param mainLoopIteration the iteration number of the main loop\n     * @param model the internal model describing the hierarchy\n     */\n    transpose(mainLoopIteration, model) {\n        let improved = true;\n        // Track the number of iterations in case of looping\n        let count = 0;\n        const maxCount = 10;\n        while (improved && count++ < maxCount) {\n            // On certain iterations allow allow swapping of cell pairs with\n            // equal edge crossings switched or not switched. This help to\n            // nudge a stuck layout into a lower crossing total.\n            const nudge = mainLoopIteration % 2 === 1 && count % 2 === 1;\n            improved = false;\n            const ranks = model.ranks;\n            for (let i = 0; i < ranks.length; i += 1) {\n                const rank = ranks[i];\n                const orderedCells = [];\n                for (let j = 0; j < rank.length; j++) {\n                    const cell = rank[j];\n                    let tempRank = cell.getGeneralPurposeVariable(i);\n                    // FIXME: Workaround to avoid negative tempRanks\n                    if (tempRank < 0) {\n                        tempRank = j;\n                    }\n                    orderedCells[tempRank] = cell;\n                }\n                let leftCellAboveConnections = null;\n                let leftCellBelowConnections = null;\n                let rightCellAboveConnections = null;\n                let rightCellBelowConnections = null;\n                let leftAbovePositions = null;\n                let leftBelowPositions = null;\n                let rightAbovePositions = null;\n                let rightBelowPositions = null;\n                let leftCell = null;\n                let rightCell = null;\n                for (let j = 0; j < rank.length - 1; j++) {\n                    // For each intra-rank adjacent pair of cells\n                    // see if swapping them around would reduce the\n                    // number of edges crossing they cause in total\n                    // On every cell pair except the first on each rank, we\n                    // can save processing using the previous values for the\n                    // right cell on the new left cell\n                    if (j === 0) {\n                        leftCell = orderedCells[j];\n                        leftCellAboveConnections = (leftCell.getNextLayerConnectedCells(i));\n                        leftCellBelowConnections = (leftCell.getPreviousLayerConnectedCells(i));\n                        leftAbovePositions = [];\n                        leftBelowPositions = [];\n                        for (let k = 0; k < leftCellAboveConnections.length; k++) {\n                            leftAbovePositions[k] = (leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1));\n                        }\n                        for (let k = 0; k < leftCellBelowConnections.length; k++) {\n                            leftBelowPositions[k] = (leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1));\n                        }\n                    }\n                    else {\n                        leftCellAboveConnections = rightCellAboveConnections;\n                        leftCellBelowConnections = rightCellBelowConnections;\n                        leftAbovePositions = rightAbovePositions;\n                        leftBelowPositions = rightBelowPositions;\n                        leftCell = rightCell;\n                    }\n                    rightCell = orderedCells[j + 1];\n                    rightCellAboveConnections = (rightCell.getNextLayerConnectedCells(i));\n                    rightCellBelowConnections = (rightCell.getPreviousLayerConnectedCells(i));\n                    rightAbovePositions = [];\n                    rightBelowPositions = [];\n                    for (let k = 0; k < rightCellAboveConnections.length; k++) {\n                        rightAbovePositions[k] = (rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1));\n                    }\n                    for (let k = 0; k < rightCellBelowConnections.length; k++) {\n                        rightBelowPositions[k] = (rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1));\n                    }\n                    let totalCurrentCrossings = 0;\n                    let totalSwitchedCrossings = 0;\n                    for (let k = 0; k < leftAbovePositions.length; k += 1) {\n                        for (let ik = 0; ik < rightAbovePositions.length; ik += 1) {\n                            if (leftAbovePositions[k] > rightAbovePositions[ik]) {\n                                totalCurrentCrossings += 1;\n                            }\n                            if (leftAbovePositions[k] < rightAbovePositions[ik]) {\n                                totalSwitchedCrossings += 1;\n                            }\n                        }\n                    }\n                    for (let k = 0; k < leftBelowPositions.length; k += 1) {\n                        for (let ik = 0; ik < rightBelowPositions.length; ik += 1) {\n                            if (leftBelowPositions[k] > rightBelowPositions[ik]) {\n                                totalCurrentCrossings += 1;\n                            }\n                            if (leftBelowPositions[k] < rightBelowPositions[ik]) {\n                                totalSwitchedCrossings += 1;\n                            }\n                        }\n                    }\n                    if (totalSwitchedCrossings < totalCurrentCrossings ||\n                        (totalSwitchedCrossings === totalCurrentCrossings && nudge)) {\n                        const temp = (leftCell.getGeneralPurposeVariable(i));\n                        leftCell.setGeneralPurposeVariable(i, rightCell.getGeneralPurposeVariable(i));\n                        rightCell.setGeneralPurposeVariable(i, temp);\n                        // With this pair exchanged we have to switch all of\n                        // values for the left cell to the right cell so the\n                        // next iteration for this rank uses it as the left\n                        // cell again\n                        rightCellAboveConnections = leftCellAboveConnections;\n                        rightCellBelowConnections = leftCellBelowConnections;\n                        rightAbovePositions = leftAbovePositions;\n                        rightBelowPositions = leftBelowPositions;\n                        rightCell = leftCell;\n                        if (!nudge) {\n                            // Don't count nudges as improvement or we'll end\n                            // up stuck in two combinations and not finishing\n                            // as early as we should\n                            improved = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Sweeps up or down the layout attempting to minimise the median placement\n     * of connected cells on adjacent ranks\n     *\n     * @param iteration the iteration number of the main loop\n     * @param model the internal model describing the hierarchy\n     */\n    weightedMedian(iteration, model) {\n        // Reverse sweep direction each time through this method\n        const downwardSweep = iteration % 2 === 0;\n        if (downwardSweep) {\n            for (let j = model.maxRank - 1; j >= 0; j -= 1) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n        else {\n            for (let j = 1; j < model.maxRank; j += 1) {\n                this.medianRank(j, downwardSweep);\n            }\n        }\n    }\n    /**\n     * Attempts to minimise the median placement of connected cells on this rank\n     * and one of the adjacent ranks\n     *\n     * @param rankValue the layer number of this rank\n     * @param downwardSweep whether or not this is a downward sweep through the graph\n     */\n    medianRank(rankValue, downwardSweep) {\n        const nestedBestRanks = (this.nestedBestRanks);\n        const numCellsForRank = nestedBestRanks[rankValue].length;\n        const medianValues = [];\n        const reservedPositions = {};\n        for (let i = 0; i < numCellsForRank; i += 1) {\n            const cell = nestedBestRanks[rankValue][i];\n            const sorterEntry = new MedianCellSorter();\n            sorterEntry.cell = cell;\n            // Flip whether or not equal medians are flipped on up and down\n            // sweeps\n            // TODO re-implement some kind of nudge\n            // medianValues[i].nudge = !downwardSweep;\n            const nextLevelConnectedCells = downwardSweep\n                ? cell.getNextLayerConnectedCells(rankValue)\n                : cell.getPreviousLayerConnectedCells(rankValue);\n            const nextRankValue = downwardSweep ? rankValue + 1 : rankValue - 1;\n            if (nextLevelConnectedCells != null && nextLevelConnectedCells.length !== 0) {\n                sorterEntry.medianValue = this.medianValue(nextLevelConnectedCells, nextRankValue);\n                medianValues.push(sorterEntry);\n            }\n            else {\n                // Nodes with no adjacent vertices are flagged in the reserved array\n                // to indicate they should be left in their current position.\n                reservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;\n            }\n        }\n        medianValues.sort(new MedianCellSorter().compare);\n        // Set the new position of each node within the rank using\n        // its temp variable\n        for (let i = 0; i < numCellsForRank; i += 1) {\n            if (reservedPositions[i] == null) {\n                const cell = (medianValues.shift().cell);\n                cell.setGeneralPurposeVariable(rankValue, i);\n            }\n        }\n    }\n    /**\n     * Calculates the median rank order positioning for the specified cell using\n     * the connected cells on the specified rank. Returns the median rank\n     * ordering value of the connected cells\n     *\n     * @param connectedCells the cells on the specified rank connected to the\n     * specified cell\n     * @param rankValue the rank that the connected cell lie upon\n     */\n    medianValue(connectedCells, rankValue) {\n        const medianValues = [];\n        let arrayCount = 0;\n        for (let i = 0; i < connectedCells.length; i += 1) {\n            const cell = connectedCells[i];\n            medianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);\n        }\n        // Sort() sorts lexicographically by default (i.e. 11 before 9) so force\n        // numerical order sort\n        medianValues.sort((a, b) => {\n            return a - b;\n        });\n        if (arrayCount % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(arrayCount / 2)];\n        }\n        if (arrayCount === 2) {\n            return (medianValues[0] + medianValues[1]) / 2.0;\n        }\n        const medianPoint = arrayCount / 2;\n        const leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n        const rightMedian = medianValues[arrayCount - 1] - medianValues[medianPoint];\n        return ((medianValues[medianPoint - 1] * rightMedian +\n            medianValues[medianPoint] * leftMedian) /\n            (leftMedian + rightMedian));\n    }\n}\nexport default MedianHybridCrossingReduction;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport { DIRECTION } from '../../../util/Constants';\nimport { GlobalConfig } from '../../../util/config';\nimport WeightedCellSorter from '../util/WeightedCellSorter';\nimport Dictionary from '../../../util/Dictionary';\nimport Point from '../../geometry/Point';\nimport HierarchicalEdgeStyle from '../datatypes/HierarchicalEdgeStyle';\n/**\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weightings as well as heuristics to straighten edges as\n * far as possible.\n *\n * @category Layout\n */\nclass CoordinateAssignment extends HierarchicalLayoutStage {\n    /**\n     * Creates a coordinate assignment.\n     *\n     * @param layout\n     * @param intraCellSpacing the minimum buffer between cells on the same rank interRankCellSpacing\n     * @param interRankCellSpacing the minimum distance between cells on adjacent ranks\n     * @param orientation the position of the root node(s) relative to the graph\n     * @param initialX the leftmost coordinate node placement starts at\n     * @param parallelEdgeSpacing\n     */\n    constructor(layout, intraCellSpacing = 30, interRankCellSpacing = 100, orientation, initialX, parallelEdgeSpacing = 10) {\n        super();\n        /**\n         * The minimum buffer between cells on the same rank. Default is 30.\n         */\n        this.intraCellSpacing = 30;\n        /**\n         * The minimum distance between cells on adjacent ranks. Default is 100.\n         */\n        this.interRankCellSpacing = 100;\n        /**\n         * The distance between each parallel edge on each ranks for long edges.\n         * Default is 10.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The number of heuristic iterations to run. Default is 8.\n         */\n        this.maxIterations = 8;\n        /**\n         * The preferred horizontal distance between edges exiting a vertex Default is 5.\n         */\n        this.prefHozEdgeSep = 5;\n        /**\n         * The preferred vertical offset between edges exiting a vertex Default is 2.\n         */\n        this.prefVertEdgeOff = 2;\n        /**\n         * The minimum distance for an edge jetty from a vertex Default is 12.\n         */\n        this.minEdgeJetty = 12;\n        /**\n         * The size of the vertical buffer in the center of inter-rank channels\n         * where edge control points should not be placed Default is 4.\n         */\n        this.channelBuffer = 4;\n        /**\n         * Map of internal edges and (x,y) pair of positions of the start and end jetty\n         * for that edge where it connects to the source and target vertices.\n         * Note this should technically be a WeakHashMap, but since JS does not\n         * have an equivalent, housekeeping must be performed before using.\n         * i.e. check all edges are still in the model and clear the values.\n         * Note that the y co-ord is the offset of the jetty, not the\n         * absolute point\n         */\n        this.jettyPositions = null;\n        /**\n         * The position of the root ( start ) node(s) relative to the rest of the\n         * laid out graph. Default is <mxConstants.DIRECTION.NORTH>.\n         */\n        this.orientation = DIRECTION.NORTH;\n        /**\n         * The maximum x value this positioning lays up to\n         */\n        this.limitX = null;\n        /**\n         * The sum of x-displacements for the current iteration\n         */\n        this.currentXDelta = null;\n        /**\n         * The rank that has the widest x position\n         */\n        this.widestRank = null;\n        /**\n         * Internal cache of top-most values of Y for each rank\n         */\n        this.rankTopY = null;\n        /**\n         * Internal cache of bottom-most value of Y for each rank\n         */\n        this.rankBottomY = null;\n        /**\n         * The X-coordinate of the edge of the widest rank\n         */\n        this.widestRankValue = null;\n        /**\n         * The width of all the ranks\n         */\n        this.rankWidths = null;\n        /**\n         * The Y-coordinate of all the ranks\n         */\n        this.rankY = null;\n        /**\n         * Whether or not to perform local optimisations and iterate multiple times\n         * through the algorithm. Default is true.\n         */\n        this.fineTuning = true;\n        /**\n         * A store of connections to the layer above for speed\n         */\n        this.nextLayerConnectedCache = null;\n        /**\n         * A store of connections to the layer below for speed\n         */\n        this.previousLayerConnectedCache = null;\n        /**\n         * Padding added to resized parents Default is 10.\n         */\n        this.groupPadding = 10;\n        this.layout = layout;\n        this.intraCellSpacing = intraCellSpacing;\n        this.interRankCellSpacing = interRankCellSpacing;\n        this.orientation = orientation;\n        this.initialX = initialX;\n        this.parallelEdgeSpacing = parallelEdgeSpacing;\n    }\n    /**\n     * Utility method to display current positions\n     */\n    printStatus() {\n        const model = this.layout.getDataModel();\n        const ranks = model.ranks;\n        const logger = GlobalConfig.logger;\n        logger.show();\n        logger.info('======Coord assignment debug=======');\n        for (let j = 0; j < ranks.length; j++) {\n            const rank = ranks[j];\n            const cellsInfo = rank\n                .map((cell) => String(cell.getGeneralPurposeVariable(j)))\n                .join('  ');\n            logger.info(`Rank ${j} : ${cellsInfo}`);\n        }\n        logger.info('====================================');\n    }\n    /**\n     * A basic horizontal coordinate assignment algorithm\n     */\n    execute(parent) {\n        this.jettyPositions = Object();\n        const model = this.layout.getDataModel();\n        this.currentXDelta = 0.0;\n        this.initialCoords(this.layout.getGraph(), model);\n        //  this.printStatus();\n        if (this.fineTuning) {\n            this.minNode(model);\n        }\n        let bestXDelta = 100000000.0;\n        if (this.fineTuning) {\n            for (let i = 0; i < this.maxIterations; i += 1) {\n                //      this.printStatus();\n                // Median Heuristic\n                if (i !== 0) {\n                    this.medianPos(i, model);\n                    this.minNode(model);\n                }\n                // if the total offset is less for the current positioning,\n                // there are less heavily angled edges and so the current\n                // positioning is used\n                const ranks = model.ranks;\n                if (this.currentXDelta < bestXDelta) {\n                    for (let j = 0; j < ranks.length; j++) {\n                        const rank = ranks[j];\n                        for (let k = 0; k < rank.length; k++) {\n                            const cell = rank[k];\n                            cell.setX(j, cell.getGeneralPurposeVariable(j));\n                        }\n                    }\n                    bestXDelta = this.currentXDelta;\n                }\n                else {\n                    // Restore the best positions\n                    for (let j = 0; j < ranks.length; j++) {\n                        const rank = ranks[j];\n                        for (let k = 0; k < rank.length; k++) {\n                            const cell = rank[k];\n                            cell.setGeneralPurposeVariable(j, cell.getX(j));\n                        }\n                    }\n                }\n                this.minPath(this.layout.getGraph(), model);\n                this.currentXDelta = 0;\n            }\n        }\n        this.setCellLocations(this.layout.getGraph(), model);\n    }\n    /**\n     * Performs one median positioning sweep in both directions\n     */\n    minNode(model) {\n        // Queue all nodes\n        const nodeList = [];\n        // Need to be able to map from cell to cellWrapper\n        const map = new Dictionary();\n        const rank = [];\n        for (let i = 0; i <= model.maxRank; i += 1) {\n            rank[i] = model.ranks[i];\n            for (let j = 0; j < rank[i].length; j += 1) {\n                // Use the weight to store the rank and visited to store whether\n                // or not the cell is in the list\n                const node = rank[i][j];\n                const nodeWrapper = new WeightedCellSorter(node, i);\n                nodeWrapper.rankIndex = j;\n                nodeWrapper.visited = true;\n                nodeList.push(nodeWrapper);\n                map.put(node, nodeWrapper);\n            }\n        }\n        // Set a limit of the maximum number of times we will access the queue\n        // in case a loop appears\n        const maxTries = nodeList.length * 10;\n        let count = 0;\n        // Don't move cell within this value of their median\n        const tolerance = 1;\n        while (nodeList.length > 0 && count <= maxTries) {\n            const cellWrapper = nodeList.shift();\n            const cell = (cellWrapper.cell);\n            const rankValue = cellWrapper.weightedValue;\n            const rankIndex = parseInt(String(cellWrapper.rankIndex));\n            const nextLayerConnectedCells = (cell.getNextLayerConnectedCells(rankValue));\n            const previousLayerConnectedCells = (cell.getPreviousLayerConnectedCells(rankValue));\n            const numNextLayerConnected = nextLayerConnectedCells.length;\n            const numPreviousLayerConnected = previousLayerConnectedCells.length;\n            const medianNextLevel = this.medianXValue(nextLayerConnectedCells, rankValue + 1);\n            const medianPreviousLevel = this.medianXValue(previousLayerConnectedCells, rankValue - 1);\n            const numConnectedNeighbours = numNextLayerConnected + numPreviousLayerConnected;\n            const currentPosition = cell.getGeneralPurposeVariable(rankValue);\n            let cellMedian = currentPosition;\n            if (numConnectedNeighbours > 0) {\n                cellMedian =\n                    (medianNextLevel * numNextLayerConnected +\n                        medianPreviousLevel * numPreviousLayerConnected) /\n                        numConnectedNeighbours;\n            }\n            // Flag storing whether or not position has changed\n            let positionChanged = false;\n            if (cellMedian < currentPosition - tolerance) {\n                if (rankIndex === 0) {\n                    cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                    positionChanged = true;\n                }\n                else {\n                    const leftCell = rank[rankValue][rankIndex - 1];\n                    let leftLimit = leftCell.getGeneralPurposeVariable(rankValue);\n                    leftLimit =\n                        leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n                    if (leftLimit < cellMedian) {\n                        cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                        positionChanged = true;\n                    }\n                    else if (leftLimit <\n                        cell.getGeneralPurposeVariable(rankValue) - tolerance) {\n                        cell.setGeneralPurposeVariable(rankValue, leftLimit);\n                        positionChanged = true;\n                    }\n                }\n            }\n            else if (cellMedian > currentPosition + tolerance) {\n                const rankSize = rank[rankValue].length;\n                if (rankIndex === rankSize - 1) {\n                    cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                    positionChanged = true;\n                }\n                else {\n                    const rightCell = rank[rankValue][rankIndex + 1];\n                    let rightLimit = rightCell.getGeneralPurposeVariable(rankValue);\n                    rightLimit =\n                        rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n                    if (rightLimit > cellMedian) {\n                        cell.setGeneralPurposeVariable(rankValue, cellMedian);\n                        positionChanged = true;\n                    }\n                    else if (rightLimit >\n                        cell.getGeneralPurposeVariable(rankValue) + tolerance) {\n                        cell.setGeneralPurposeVariable(rankValue, rightLimit);\n                        positionChanged = true;\n                    }\n                }\n            }\n            if (positionChanged) {\n                // Add connected nodes to map and list\n                for (let i = 0; i < nextLayerConnectedCells.length; i += 1) {\n                    const connectedCell = nextLayerConnectedCells[i];\n                    const connectedCellWrapper = map.get(connectedCell);\n                    if (connectedCellWrapper != null) {\n                        if (connectedCellWrapper.visited == false) {\n                            connectedCellWrapper.visited = true;\n                            nodeList.push(connectedCellWrapper);\n                        }\n                    }\n                }\n                // Add connected nodes to map and list\n                for (let i = 0; i < previousLayerConnectedCells.length; i += 1) {\n                    const connectedCell = previousLayerConnectedCells[i];\n                    const connectedCellWrapper = map.get(connectedCell);\n                    if (connectedCellWrapper != null) {\n                        if (connectedCellWrapper.visited == false) {\n                            connectedCellWrapper.visited = true;\n                            nodeList.push(connectedCellWrapper);\n                        }\n                    }\n                }\n            }\n            cellWrapper.visited = false;\n            count += 1;\n        }\n    }\n    /**\n     * Performs one median positioning sweep in one direction\n     *\n     * @param i the iteration of the whole process\n     * @param model an internal model of the hierarchical layout\n     */\n    medianPos(i, model) {\n        // Reverse sweep direction each time through this method\n        const downwardSweep = i % 2 === 0;\n        if (downwardSweep) {\n            for (let j = model.maxRank; j > 0; j--) {\n                this.rankMedianPosition(j - 1, model, j);\n            }\n        }\n        else {\n            for (let j = 0; j < model.maxRank - 1; j++) {\n                this.rankMedianPosition(j + 1, model, j);\n            }\n        }\n    }\n    /**\n     * Performs median minimisation over one rank.\n     *\n     * @param rankValue the layer number of this rank\n     * @param model an internal model of the hierarchical layout\n     * @param nextRankValue the layer number whose connected cels are to be laid out\n     * relative to\n     */\n    rankMedianPosition(rankValue, model, nextRankValue) {\n        const ranks = model.ranks;\n        const rank = ranks[rankValue];\n        // Form an array of the order in which the cell are to be processed\n        // , the order is given by the weighted sum of the in or out edges,\n        // depending on whether we're traveling up or down the hierarchy.\n        const weightedValues = [];\n        const cellMap = {};\n        for (let i = 0; i < rank.length; i += 1) {\n            const currentCell = rank[i];\n            weightedValues[i] = new WeightedCellSorter(currentCell);\n            weightedValues[i].rankIndex = i;\n            cellMap[currentCell.id] = weightedValues[i];\n            let nextLayerConnectedCells = null;\n            if (nextRankValue < rankValue) {\n                nextLayerConnectedCells = currentCell.getPreviousLayerConnectedCells(rankValue);\n            }\n            else {\n                nextLayerConnectedCells = currentCell.getNextLayerConnectedCells(rankValue);\n            }\n            // Calculate the weighing based on this node type and those this\n            // node is connected to on the next layer\n            weightedValues[i].weightedValue = this.calculatedWeightedValue(currentCell, nextLayerConnectedCells);\n        }\n        weightedValues.sort(WeightedCellSorter.compare);\n        // Set the new position of each node within the rank using\n        // its temp variable\n        for (let i = 0; i < weightedValues.length; i += 1) {\n            let numConnectionsNextLevel = 0;\n            const cell = weightedValues[i].cell;\n            let nextLayerConnectedCells = null;\n            let medianNextLevel = 0;\n            if (nextRankValue < rankValue) {\n                nextLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue).slice();\n            }\n            else {\n                nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue).slice();\n            }\n            if (nextLayerConnectedCells != null) {\n                numConnectionsNextLevel = nextLayerConnectedCells.length;\n                if (numConnectionsNextLevel > 0) {\n                    medianNextLevel = this.medianXValue(nextLayerConnectedCells, nextRankValue);\n                }\n                else {\n                    // For case of no connections on the next level set the\n                    // median to be the current position and try to be\n                    // positioned there\n                    medianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n                }\n            }\n            let leftBuffer = 0.0;\n            let leftLimit = -100000000.0;\n            for (let j = weightedValues[i].rankIndex - 1; j >= 0;) {\n                const weightedValue = cellMap[rank[j].id];\n                if (weightedValue != null) {\n                    const leftCell = weightedValue.cell;\n                    if (weightedValue.visited) {\n                        // The left limit is the right hand limit of that\n                        // cell plus any allowance for unallocated cells\n                        // in-between\n                        leftLimit =\n                            leftCell.getGeneralPurposeVariable(rankValue) +\n                                leftCell.width / 2.0 +\n                                this.intraCellSpacing +\n                                leftBuffer +\n                                cell.width / 2.0;\n                        j = -1;\n                    }\n                    else {\n                        leftBuffer += leftCell.width + this.intraCellSpacing;\n                        j--;\n                    }\n                }\n            }\n            let rightBuffer = 0.0;\n            let rightLimit = 100000000.0;\n            for (let j = weightedValues[i].rankIndex + 1; j < weightedValues.length;) {\n                const weightedValue = cellMap[rank[j].id];\n                if (weightedValue != null) {\n                    const rightCell = weightedValue.cell;\n                    if (weightedValue.visited) {\n                        // The left limit is the right hand limit of that\n                        // cell plus any allowance for unallocated cells\n                        // in-between\n                        rightLimit =\n                            rightCell.getGeneralPurposeVariable(rankValue) -\n                                rightCell.width / 2.0 -\n                                this.intraCellSpacing -\n                                rightBuffer -\n                                cell.width / 2.0;\n                        j = weightedValues.length;\n                    }\n                    else {\n                        rightBuffer += rightCell.width + this.intraCellSpacing;\n                        j++;\n                    }\n                }\n            }\n            if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {\n                cell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n            }\n            else if (medianNextLevel < leftLimit) {\n                // Couldn't place at median value, place as close to that\n                // value as possible\n                cell.setGeneralPurposeVariable(rankValue, leftLimit);\n                this.currentXDelta = this.currentXDelta + leftLimit - medianNextLevel;\n            }\n            else if (medianNextLevel > rightLimit) {\n                // Couldn't place at median value, place as close to that\n                // value as possible\n                cell.setGeneralPurposeVariable(rankValue, rightLimit);\n                this.currentXDelta = this.currentXDelta + medianNextLevel - rightLimit;\n            }\n            weightedValues[i].visited = true;\n        }\n    }\n    /**\n     * Calculates the priority the specified cell has based on the type of its\n     * cell and the cells it is connected to on the next layer\n     *\n     * @param currentCell the cell whose weight is to be calculated\n     * @param collection the cells the specified cell is connected to\n     */\n    calculatedWeightedValue(currentCell, collection) {\n        let totalWeight = 0;\n        for (let i = 0; i < collection.length; i += 1) {\n            const cell = collection[i];\n            if (currentCell.isVertex() && cell.isVertex()) {\n                totalWeight += 1;\n            }\n            else if (currentCell.isEdge() && cell.isEdge()) {\n                totalWeight += 8;\n            }\n            else {\n                totalWeight += 2;\n            }\n        }\n        return totalWeight;\n    }\n    /**\n     * Calculates the median position of the connected cell on the specified\n     * rank\n     *\n     * @param connectedCells the cells the candidate connects to on this level\n     * @param rankValue the layer number of this rank\n     */\n    medianXValue(connectedCells, rankValue) {\n        if (connectedCells.length === 0) {\n            return 0;\n        }\n        const medianValues = [];\n        for (let i = 0; i < connectedCells.length; i += 1) {\n            medianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n        }\n        medianValues.sort((a, b) => a - b);\n        if (connectedCells.length % 2 === 1) {\n            // For odd numbers of adjacent vertices return the median\n            return medianValues[Math.floor(connectedCells.length / 2)];\n        }\n        const medianPoint = connectedCells.length / 2;\n        const leftMedian = medianValues[medianPoint - 1];\n        const rightMedian = medianValues[medianPoint];\n        return (leftMedian + rightMedian) / 2;\n    }\n    /**\n     * Sets up the layout in an initial positioning. The ranks are all centered\n     * as much as possible along the middle vertex in each rank. The other cells\n     * are then placed as close as possible on either side.\n     *\n     * @param facade the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    initialCoords(facade, model) {\n        this.calculateWidestRank(facade, model);\n        // Sweep up and down from the widest rank\n        for (let i = this.widestRank; i >= 0; i--) {\n            if (i < model.maxRank) {\n                this.rankCoordinates(i, facade, model);\n            }\n        }\n        for (let i = this.widestRank + 1; i <= model.maxRank; i += 1) {\n            if (i > 0) {\n                this.rankCoordinates(i, facade, model);\n            }\n        }\n    }\n    /**\n     * Sets up the layout in an initial positioning. All the first cells in each\n     * rank are moved to the left and the rest of the rank inserted as close\n     * together as their size and buffering permits. This method works on just\n     * the specified rank.\n     *\n     * @param rankValue the current rank being processed\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    rankCoordinates(rankValue, graph, model) {\n        const ranks = model.ranks;\n        const rank = ranks[rankValue];\n        let maxY = 0.0;\n        let localX = this.initialX +\n            (this.widestRankValue - this.rankWidths[rankValue]) / 2;\n        // Store whether or not any of the cells' bounds were unavailable so\n        // to only issue the warning once for all cells\n        let boundsWarning = false;\n        for (let i = 0; i < rank.length; i += 1) {\n            const node = rank[i];\n            if (node.isVertex()) {\n                const bounds = this.layout.getVertexBounds(node.cell);\n                if (bounds != null) {\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        node.width = bounds.width;\n                        node.height = bounds.height;\n                    }\n                    else {\n                        node.width = bounds.height;\n                        node.height = bounds.width;\n                    }\n                }\n                else {\n                    boundsWarning = true;\n                }\n                maxY = Math.max(maxY, node.height);\n            }\n            else if (node.isEdge()) {\n                // The width is the number of additional parallel edges\n                // time the parallel edge spacing\n                let numEdges = 1;\n                if (node.edges != null) {\n                    numEdges = node.edges.length;\n                }\n                else {\n                    GlobalConfig.logger.warn('edge.edges is null');\n                }\n                node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n            }\n            // Set the initial x-value as being the best result so far\n            localX += node.width / 2.0;\n            node.setX(rankValue, localX);\n            node.setGeneralPurposeVariable(rankValue, localX);\n            localX += node.width / 2.0;\n            localX += this.intraCellSpacing;\n        }\n        if (boundsWarning) {\n            GlobalConfig.logger.warn('At least one cell has no bounds');\n        }\n    }\n    /**\n     * Calculates the width rank in the hierarchy. Also set the y value of each\n     * rank whilst performing the calculation\n     *\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    calculateWidestRank(graph, model) {\n        // Starting y co-ordinate\n        let y = -this.interRankCellSpacing;\n        // Track the widest cell on the last rank since the y\n        // difference depends on it\n        let lastRankMaxCellHeight = 0.0;\n        this.rankWidths = [];\n        this.rankY = [];\n        for (let rankValue = model.maxRank; rankValue >= 0; rankValue -= 1) {\n            // Keep track of the widest cell on this rank\n            let maxCellHeight = 0.0;\n            const ranks = model.ranks;\n            const rank = ranks[rankValue];\n            let localX = this.initialX;\n            // Store whether or not any of the cells' bounds were unavailable so\n            // to only issue the warning once for all cells\n            let boundsWarning = false;\n            for (let i = 0; i < rank.length; i += 1) {\n                const node = rank[i];\n                if (node.isVertex()) {\n                    const bounds = this.layout.getVertexBounds(node.cell);\n                    if (bounds != null) {\n                        if (this.orientation === DIRECTION.NORTH ||\n                            this.orientation === DIRECTION.SOUTH) {\n                            node.width = bounds.width;\n                            node.height = bounds.height;\n                        }\n                        else {\n                            node.width = bounds.height;\n                            node.height = bounds.width;\n                        }\n                    }\n                    else {\n                        boundsWarning = true;\n                    }\n                    maxCellHeight = Math.max(maxCellHeight, node.height);\n                }\n                else if (node.isEdge()) {\n                    // The width is the number of additional parallel edges\n                    // time the parallel edge spacing\n                    let numEdges = 1;\n                    if (node.edges != null) {\n                        numEdges = node.edges.length;\n                    }\n                    else {\n                        GlobalConfig.logger.warn('edge.edges is null');\n                    }\n                    node.width = (numEdges - 1) * this.parallelEdgeSpacing;\n                }\n                // Set the initial x-value as being the best result so far\n                localX += node.width / 2.0;\n                node.setX(rankValue, localX);\n                node.setGeneralPurposeVariable(rankValue, localX);\n                localX += node.width / 2.0;\n                localX += this.intraCellSpacing;\n                if (localX > this.widestRankValue) {\n                    this.widestRankValue = localX;\n                    this.widestRank = rankValue;\n                }\n                this.rankWidths[rankValue] = localX;\n            }\n            if (boundsWarning) {\n                GlobalConfig.logger.warn('At least one cell has no bounds');\n            }\n            this.rankY[rankValue] = y;\n            const distanceToNextRank = maxCellHeight / 2.0 + lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n            lastRankMaxCellHeight = maxCellHeight;\n            if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.WEST) {\n                y += distanceToNextRank;\n            }\n            else {\n                y -= distanceToNextRank;\n            }\n            for (let i = 0; i < rank.length; i += 1) {\n                const cell = rank[i];\n                cell.setY(rankValue, y);\n            }\n        }\n    }\n    /**\n     * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n     * processing step has completed.\n     *\n     * @param graph the facade describing the input graph\n     * @param model an internal model of the hierarchical layout\n     */\n    minPath(graph, model) {\n        // Work down and up each edge with at least 2 control points\n        // trying to straighten each one out. If the same number of\n        // straight segments are formed in both directions, the\n        // preferred direction used is the one where the final\n        // control points have the least offset from the connectable\n        // region of the terminating vertices\n        const edges = model.edgeMapper.getValues();\n        for (let j = 0; j < edges.length; j++) {\n            const cell = edges[j];\n            if (cell.maxRank - cell.minRank - 1 < 1) {\n                continue;\n            }\n            // At least two virtual nodes in the edge\n            // Check first whether the edge is already straight\n            let referenceX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n            let edgeStraight = true;\n            let refSegCount = 0;\n            for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n                const x = cell.getGeneralPurposeVariable(i);\n                if (referenceX !== x) {\n                    edgeStraight = false;\n                    referenceX = x;\n                }\n                else {\n                    refSegCount += 1;\n                }\n            }\n            if (!edgeStraight) {\n                let upSegCount = 0;\n                let downSegCount = 0;\n                const upXPositions = [];\n                const downXPositions = [];\n                let i = 0;\n                let currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n                for (i = cell.minRank + 1; i < cell.maxRank - 1; i += 1) {\n                    // Attempt to straight out the control point on the\n                    // next segment up with the current control point.\n                    const nextX = cell.getX(i + 1);\n                    if (currentX === nextX) {\n                        upXPositions[i - cell.minRank - 1] = currentX;\n                        upSegCount += 1;\n                    }\n                    else if (this.repositionValid(model, cell, i + 1, currentX)) {\n                        upXPositions[i - cell.minRank - 1] = currentX;\n                        upSegCount += 1;\n                        // Leave currentX at same value\n                    }\n                    else {\n                        upXPositions[i - cell.minRank - 1] = nextX;\n                        currentX = nextX;\n                    }\n                }\n                currentX = cell.getX(i);\n                for (let i = cell.maxRank - 1; i > cell.minRank + 1; i--) {\n                    // Attempt to straight out the control point on the\n                    // next segment down with the current control point.\n                    const nextX = cell.getX(i - 1);\n                    if (currentX === nextX) {\n                        downXPositions[i - cell.minRank - 2] = currentX;\n                        downSegCount += 1;\n                    }\n                    else if (this.repositionValid(model, cell, i - 1, currentX)) {\n                        downXPositions[i - cell.minRank - 2] = currentX;\n                        downSegCount += 1;\n                        // Leave currentX at same value\n                    }\n                    else {\n                        downXPositions[i - cell.minRank - 2] = cell.getX(i - 1);\n                        currentX = nextX;\n                    }\n                }\n                if (downSegCount > refSegCount || upSegCount > refSegCount) {\n                    if (downSegCount >= upSegCount) {\n                        // Apply down calculation values\n                        for (let i = cell.maxRank - 2; i > cell.minRank; i--) {\n                            cell.setX(i, downXPositions[i - cell.minRank - 1]);\n                        }\n                    }\n                    else if (upSegCount > downSegCount) {\n                        // Apply up calculation values\n                        for (let i = cell.minRank + 2; i < cell.maxRank; i += 1) {\n                            cell.setX(i, upXPositions[i - cell.minRank - 2]);\n                        }\n                    }\n                    else {\n                        // Neither direction provided a favourable result\n                        // But both calculations are better than the\n                        // existing solution, so apply the one with minimal\n                        // offset to attached vertices at either end.\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Determines whether or not a node may be moved to the specified x\n     * position on the specified rank\n     *\n     * @param model the layout model\n     * @param cell the cell being analysed\n     * @param rank the layer of the cell\n     * @param position the x position being sought\n     */\n    repositionValid(model, cell, rank, position) {\n        const ranks = model.ranks;\n        const rankArray = ranks[rank];\n        let rankIndex = -1;\n        for (let i = 0; i < rankArray.length; i += 1) {\n            if (cell === rankArray[i]) {\n                rankIndex = i;\n                break;\n            }\n        }\n        if (rankIndex < 0) {\n            return false;\n        }\n        const currentX = cell.getGeneralPurposeVariable(rank);\n        if (position < currentX) {\n            // Trying to move node to the left.\n            if (rankIndex === 0) {\n                // Left-most node, can move anywhere\n                return true;\n            }\n            const leftCell = rankArray[rankIndex - 1];\n            let leftLimit = leftCell.getGeneralPurposeVariable(rank);\n            leftLimit = leftLimit + leftCell.width / 2 + this.intraCellSpacing + cell.width / 2;\n            return leftLimit <= position;\n        }\n        if (position > currentX) {\n            // Trying to move node to the right.\n            if (rankIndex === rankArray.length - 1) {\n                // Right-most node, can move anywhere\n                return true;\n            }\n            const rightCell = rankArray[rankIndex + 1];\n            let rightLimit = rightCell.getGeneralPurposeVariable(rank);\n            rightLimit =\n                rightLimit - rightCell.width / 2 - this.intraCellSpacing - cell.width / 2;\n            return rightLimit >= position;\n        }\n        return true;\n    }\n    /**\n     * Sets the cell locations in the facade to those stored after this layout\n     * processing step has completed.\n     *\n     * @param graph the input graph\n     * @param model the layout model\n     */\n    setCellLocations(graph, model) {\n        this.rankTopY = [];\n        this.rankBottomY = [];\n        const ranks = model.ranks;\n        for (let i = 0; i < ranks.length; i += 1) {\n            this.rankTopY[i] = Number.MAX_VALUE;\n            this.rankBottomY[i] = -Number.MAX_VALUE;\n        }\n        const vertices = model.vertexMapper.getValues();\n        // Process vertices all first, since they define the lower and\n        // limits of each rank. Between these limits lie the channels\n        // where the edges can be routed across the graph\n        for (let i = 0; i < vertices.length; i += 1) {\n            this.setVertexLocation(vertices[i]);\n        }\n        // Post process edge styles. Needs the vertex locations set for initial\n        // values of the top and bottoms of each rank\n        if (this.layout.edgeStyle === HierarchicalEdgeStyle.ORTHOGONAL ||\n            this.layout.edgeStyle === HierarchicalEdgeStyle.POLYLINE ||\n            this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n            this.localEdgeProcessing(model);\n        }\n        const edges = model.edgeMapper.getValues();\n        for (let i = 0; i < edges.length; i += 1) {\n            this.setEdgePosition(edges[i]);\n        }\n    }\n    /**\n     * Separates the x position of edges as they connect to vertices\n     *\n     * @param model the layout model\n     */\n    localEdgeProcessing(model) {\n        // Iterate through each vertex, look at the edges connected in\n        // both directions.\n        const ranks = model.ranks;\n        for (let rankIndex = 0; rankIndex < ranks.length; rankIndex += 1) {\n            const rank = ranks[rankIndex];\n            for (let cellIndex = 0; cellIndex < rank.length; cellIndex += 1) {\n                const cell = rank[cellIndex];\n                if (cell.isVertex()) {\n                    let currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n                    let currentRank = rankIndex - 1;\n                    // Two loops, last connected cells, and next\n                    for (let k = 0; k < 2; k += 1) {\n                        if (currentRank > -1 &&\n                            currentRank < ranks.length &&\n                            currentCells != null &&\n                            currentCells.length > 0) {\n                            const sortedCells = [];\n                            for (let j = 0; j < currentCells.length; j++) {\n                                const sorter = new WeightedCellSorter(currentCells[j], currentCells[j].getX(currentRank));\n                                sortedCells.push(sorter);\n                            }\n                            sortedCells.sort(WeightedCellSorter.compare);\n                            let leftLimit = cell.x[0] - cell.width / 2;\n                            let rightLimit = leftLimit + cell.width;\n                            // Connected edge count starts at 1 to allow for buffer\n                            // with edge of vertex\n                            let connectedEdgeCount = 0;\n                            let connectedEdgeGroupCount = 0;\n                            const connectedEdges = [];\n                            // Calculate width requirements for all connected edges\n                            for (let j = 0; j < sortedCells.length; j++) {\n                                const innerCell = sortedCells[j].cell;\n                                let connections;\n                                if (innerCell.isVertex()) {\n                                    // Get the connecting edge\n                                    if (k === 0) {\n                                        connections = cell.connectsAsSource;\n                                    }\n                                    else {\n                                        connections = cell.connectsAsTarget;\n                                    }\n                                    for (let connIndex = 0; connIndex < connections.length; connIndex += 1) {\n                                        if (connections[connIndex].source === innerCell ||\n                                            connections[connIndex].target === innerCell) {\n                                            connectedEdgeCount += connections[connIndex].edges.length;\n                                            connectedEdgeGroupCount += 1;\n                                            connectedEdges.push(connections[connIndex]);\n                                        }\n                                    }\n                                }\n                                else {\n                                    connectedEdgeCount += innerCell.edges.length;\n                                    connectedEdgeGroupCount += 1;\n                                    connectedEdges.push(innerCell);\n                                }\n                            }\n                            const requiredWidth = (connectedEdgeCount + 1) * this.prefHozEdgeSep;\n                            // Add a buffer on the edges of the vertex if the edge count allows\n                            if (cell.width > requiredWidth + 2 * this.prefHozEdgeSep) {\n                                leftLimit += this.prefHozEdgeSep;\n                                rightLimit -= this.prefHozEdgeSep;\n                            }\n                            const availableWidth = rightLimit - leftLimit;\n                            const edgeSpacing = availableWidth / connectedEdgeCount;\n                            let currentX = leftLimit + edgeSpacing / 2.0;\n                            let currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n                            let maxYOffset = 0;\n                            for (let j = 0; j < connectedEdges.length; j++) {\n                                const numActualEdges = connectedEdges[j].edges.length;\n                                const jettyPositions = this.jettyPositions;\n                                let pos = jettyPositions[connectedEdges[j].ids[0]];\n                                if (pos == null) {\n                                    pos = [];\n                                    jettyPositions[connectedEdges[j].ids[0]] = pos;\n                                }\n                                if (j < connectedEdgeCount / 2) {\n                                    currentYOffset += this.prefVertEdgeOff;\n                                }\n                                else if (j > connectedEdgeCount / 2) {\n                                    currentYOffset -= this.prefVertEdgeOff;\n                                }\n                                // Ignore the case if equals, this means the second of 2\n                                // jettys with the same y (even number of edges)\n                                for (let m = 0; m < numActualEdges; m += 1) {\n                                    pos[m * 4 + k * 2] = currentX;\n                                    currentX += edgeSpacing;\n                                    pos[m * 4 + k * 2 + 1] = currentYOffset;\n                                }\n                                maxYOffset = Math.max(maxYOffset, currentYOffset);\n                            }\n                        }\n                        currentCells = cell.getNextLayerConnectedCells(rankIndex);\n                        currentRank = rankIndex + 1;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Fixes the control points\n     */\n    setEdgePosition(cell) {\n        // For parallel edges we need to seperate out the points a\n        // little\n        let offsetX = 0;\n        // Only set the edge control points once\n        if (cell.temp[0] !== 101207) {\n            let { maxRank } = cell;\n            let { minRank } = cell;\n            if (maxRank === minRank) {\n                maxRank = cell.source.maxRank;\n                minRank = cell.target.minRank;\n            }\n            let parallelEdgeCount = 0;\n            const jettyPositions = this.jettyPositions;\n            const jettys = jettyPositions[cell.ids[0]];\n            const source = cell.isReversed\n                ? cell.target.cell\n                : cell.source.cell;\n            const { graph } = this.layout;\n            const layoutReversed = this.orientation === DIRECTION.EAST || this.orientation === DIRECTION.SOUTH;\n            for (let i = 0; i < cell.edges.length; i += 1) {\n                const realEdge = cell.edges[i];\n                const realSource = this.layout.getVisibleTerminal(realEdge, true);\n                // List oldPoints = graph.getPoints(realEdge);\n                const newPoints = [];\n                // Single length reversed edges end up with the jettys in the wrong\n                // places. Since single length edges only have jettys, not segment\n                // control points, we just say the edge isn't reversed in this section\n                let reversed = cell.isReversed;\n                if (realSource !== source) {\n                    // The real edges include all core model edges and these can go\n                    // in both directions. If the source of the hierarchical model edge\n                    // isn't the source of the specific real edge in this iteration\n                    // treat if as reversed\n                    reversed = !reversed;\n                }\n                // First jetty of edge\n                if (jettys != null) {\n                    const arrayOffset = reversed ? 2 : 0;\n                    const rankBottomY = this.rankBottomY;\n                    const rankTopY = this.rankTopY;\n                    let y = reversed\n                        ? layoutReversed\n                            ? rankBottomY[minRank]\n                            : rankTopY[minRank]\n                        : layoutReversed\n                            ? rankTopY[maxRank]\n                            : rankBottomY[maxRank];\n                    let jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    y += jetty;\n                    let x = jettys[parallelEdgeCount * 4 + arrayOffset];\n                    const modelSource = realEdge.getTerminal(true);\n                    if (this.layout.isPort(modelSource) && modelSource.getParent() === realSource) {\n                        const state = graph.view.getState(modelSource);\n                        if (state != null) {\n                            x = state.x;\n                        }\n                        else {\n                            x =\n                                realSource.geometry.x +\n                                    cell.source.width *\n                                        modelSource.geometry.x;\n                        }\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        newPoints.push(new Point(x, y));\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(x, y + jetty));\n                        }\n                    }\n                    else {\n                        newPoints.push(new Point(y, x));\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(y + jetty, x));\n                        }\n                    }\n                }\n                // Declare variables to define loop through edge points and\n                // change direction if edge is reversed\n                let loopStart = cell.x.length - 1;\n                let loopLimit = -1;\n                let loopDelta = -1;\n                let currentRank = cell.maxRank - 1;\n                if (reversed) {\n                    loopStart = 0;\n                    loopLimit = cell.x.length;\n                    loopDelta = 1;\n                    currentRank = cell.minRank + 1;\n                }\n                // Reversed edges need the points inserted in\n                // reverse order\n                for (let j = loopStart; cell.maxRank !== cell.minRank && j !== loopLimit; j += loopDelta) {\n                    // The horizontal position in a vertical layout\n                    const positionX = cell.x[j] + offsetX;\n                    // Work out the vertical positions in a vertical layout\n                    // in the edge buffer channels above and below this rank\n                    const rankTopY = this.rankTopY;\n                    const rankBottomY = this.rankBottomY;\n                    let topChannelY = (rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2.0;\n                    let bottomChannelY = (rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2.0;\n                    if (reversed) {\n                        const tmp = topChannelY;\n                        topChannelY = bottomChannelY;\n                        bottomChannelY = tmp;\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        newPoints.push(new Point(positionX, topChannelY));\n                        newPoints.push(new Point(positionX, bottomChannelY));\n                    }\n                    else {\n                        newPoints.push(new Point(topChannelY, positionX));\n                        newPoints.push(new Point(bottomChannelY, positionX));\n                    }\n                    this.limitX = Math.max(this.limitX, positionX);\n                    currentRank += loopDelta;\n                }\n                // Second jetty of edge\n                if (jettys != null) {\n                    const arrayOffset = reversed ? 2 : 0;\n                    const rankTopY = this.rankTopY;\n                    const rankBottomY = this.rankBottomY;\n                    const rankY = reversed\n                        ? layoutReversed\n                            ? rankTopY[maxRank]\n                            : rankBottomY[maxRank]\n                        : layoutReversed\n                            ? rankBottomY[minRank]\n                            : rankTopY[minRank];\n                    let jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n                    if (reversed !== layoutReversed) {\n                        jetty = -jetty;\n                    }\n                    const y = rankY - jetty;\n                    let x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n                    const modelTarget = realEdge.getTerminal(false);\n                    const realTarget = this.layout.getVisibleTerminal(realEdge, false);\n                    if (this.layout.isPort(modelTarget) && modelTarget.getParent() === realTarget) {\n                        const state = graph.view.getState(modelTarget);\n                        if (state != null) {\n                            x = state.x;\n                        }\n                        else {\n                            x =\n                                realTarget.geometry.x +\n                                    cell.target.width *\n                                        modelTarget.geometry.x;\n                        }\n                    }\n                    if (this.orientation === DIRECTION.NORTH ||\n                        this.orientation === DIRECTION.SOUTH) {\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(x, y - jetty));\n                        }\n                        newPoints.push(new Point(x, y));\n                    }\n                    else {\n                        if (this.layout.edgeStyle === HierarchicalEdgeStyle.CURVE) {\n                            newPoints.push(new Point(y - jetty, x));\n                        }\n                        newPoints.push(new Point(y, x));\n                    }\n                }\n                if (cell.isReversed) {\n                    this.processReversedEdge(cell, realEdge);\n                }\n                this.layout.setEdgePoints(realEdge, newPoints);\n                // Increase offset so next edge is drawn next to\n                // this one\n                if (offsetX === 0.0) {\n                    offsetX = this.parallelEdgeSpacing;\n                }\n                else if (offsetX > 0) {\n                    offsetX = -offsetX;\n                }\n                else {\n                    offsetX = -offsetX + this.parallelEdgeSpacing;\n                }\n                parallelEdgeCount++;\n            }\n            cell.temp[0] = 101207;\n        }\n    }\n    /**\n     * Fixes the position of the specified vertex.\n     *\n     * @param cell the vertex to position\n     */\n    setVertexLocation(cell) {\n        const realCell = cell.cell;\n        const positionX = cell.x[0] - cell.width / 2;\n        const positionY = cell.y[0] - cell.height / 2;\n        const rankTopY = this.rankTopY;\n        const rankBottomY = this.rankBottomY;\n        rankTopY[cell.minRank] = Math.min(rankTopY[cell.minRank], positionY);\n        rankBottomY[cell.minRank] = Math.max(rankBottomY[cell.minRank], positionY + cell.height);\n        if (this.orientation === DIRECTION.NORTH || this.orientation === DIRECTION.SOUTH) {\n            this.layout.setVertexLocation(realCell, positionX, positionY);\n        }\n        else {\n            this.layout.setVertexLocation(realCell, positionY, positionX);\n        }\n        this.limitX = Math.max(this.limitX, positionX + cell.width);\n    }\n    /**\n     * Hook to add additional processing\n     *\n     * @param edge the hierarchical model edge\n     * @param realEdge the real edge in the graph\n     */\n    processReversedEdge(edge, realEdge) {\n        // hook for subclassers\n    }\n}\nexport default CoordinateAssignment;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\nimport { DIRECTION } from '../../util/Constants';\nimport HierarchicalEdgeStyle from './datatypes/HierarchicalEdgeStyle';\nimport Dictionary from '../../util/Dictionary';\nimport GraphHierarchyModel from './hierarchical/GraphHierarchyModel';\nimport ObjectIdentity from '../../util/ObjectIdentity';\nimport MinimumCycleRemover from './hierarchical/MinimumCycleRemover';\nimport MedianHybridCrossingReduction from './hierarchical/MedianHybridCrossingReduction';\nimport CoordinateAssignment from './hierarchical/CoordinateAssignment';\n/**\n * A hierarchical layout algorithm.\n *\n * @category Layout\n */\nclass HierarchicalLayout extends GraphLayout {\n    /**\n     * Constructs a new hierarchical layout algorithm.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION.NORTH}.\n     * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.\n     */\n    constructor(graph, orientation = DIRECTION.NORTH, deterministic = true) {\n        super(graph);\n        this.parentX = null;\n        this.parentY = null;\n        /**\n         * Holds the array of <Cell> that this layout contains.\n         */\n        this.roots = null;\n        /**\n         * Specifies if the parent should be resized after the layout so that it\n         * contains all the child cells. Default is false. See also <parentBorder>.\n         */\n        this.resizeParent = false;\n        /**\n         * Specifies if the parent location should be maintained, so that the\n         * top, left corner stays the same before and after execution of\n         * the layout. Default is false for backwards compatibility.\n         */\n        this.maintainParentLocation = false;\n        /**\n         * Specifies if the parent should be moved if <resizeParent> is enabled.\n         * Default is false.\n         */\n        this.moveParent = false;\n        /**\n         * The border to be added around the children if the parent is to be\n         * resized using <resizeParent>. Default is 0.\n         */\n        this.parentBorder = 0;\n        /**\n         * The spacing buffer added between cells on the same layer. Default is 30.\n         */\n        this.intraCellSpacing = 30;\n        /**\n         * The spacing buffer added between cell on adjacent layers. Default is 100.\n         */\n        this.interRankCellSpacing = 100;\n        /**\n         * The spacing buffer between unconnected hierarchies. Default is 60.\n         */\n        this.interHierarchySpacing = 60;\n        /**\n         * The distance between each parallel edge on each ranks for long edges.\n         * Default is 10.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The position of the root node(s) relative to the laid out graph in.\n         * Default is <mxConstants.DIRECTION.NORTH>.\n         */\n        this.orientation = DIRECTION.NORTH;\n        /**\n         * Whether or not to perform local optimisations and iterate multiple times\n         * through the algorithm. Default is true.\n         */\n        this.fineTuning = true;\n        /**\n         * Whether or not to tighten the assigned ranks of vertices up towards\n         * the source cells. Default is true.\n         */\n        this.tightenToSource = true;\n        /**\n         * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n         * modified by the result. Default is true.\n         */\n        this.disableEdgeStyle = true;\n        /**\n         * Whether or not to drill into child cells and layout in reverse\n         * group order. This also cause the layout to navigate edges whose\n         * terminal vertices have different parents but are in the same\n         * ancestry chain. Default is true.\n         */\n        this.traverseAncestors = true;\n        /**\n         * The internal <GraphHierarchyModel> formed of the layout.\n         */\n        this.model = null;\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgesCache = new Dictionary();\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgeSourceTermCache = new Dictionary();\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgesTargetTermCache = new Dictionary();\n        /**\n         * The style to apply between cell layers to edge segments.\n         * Default is {@link HierarchicalEdgeStyle#POLYLINE}.\n         */\n        this.edgeStyle = HierarchicalEdgeStyle.POLYLINE;\n        this.orientation = orientation;\n        this.deterministic = deterministic;\n    }\n    /**\n     * Returns the internal <GraphHierarchyModel> for this layout algorithm.\n     */\n    getDataModel() {\n        return this.model;\n    }\n    /**\n     * Executes the layout for the children of the specified parent.\n     *\n     * @param parent Parent <Cell> that contains the children to be laid out.\n     * @param roots Optional starting roots of the layout.\n     */\n    execute(parent, roots = null) {\n        this.parent = parent;\n        this.edgesCache = new Dictionary();\n        this.edgeSourceTermCache = new Dictionary();\n        this.edgesTargetTermCache = new Dictionary();\n        if (roots != null && !(roots instanceof Array)) {\n            roots = [roots];\n        }\n        // If the roots are set and the parent is set, only\n        // use the roots that are some dependent of the that\n        // parent.\n        // If just the root are set, use them as-is\n        // If just the parent is set use it's immediate\n        // children as the initial set\n        if (roots == null && parent == null) {\n            // TODO indicate the problem\n            return;\n        }\n        //  Maintaining parent location\n        this.parentX = null;\n        this.parentY = null;\n        if (parent !== this.graph.getDataModel().root &&\n            parent.isVertex() != null &&\n            this.maintainParentLocation) {\n            const geo = parent.getGeometry();\n            if (geo != null) {\n                this.parentX = geo.x;\n                this.parentY = geo.y;\n            }\n        }\n        if (roots != null) {\n            const rootsCopy = [];\n            for (let i = 0; i < roots.length; i += 1) {\n                const ancestor = parent != null ? parent.isAncestor(roots[i]) : true;\n                if (ancestor && roots[i].isVertex()) {\n                    rootsCopy.push(roots[i]);\n                }\n            }\n            this.roots = rootsCopy;\n        }\n        const { model } = this.graph;\n        model.batchUpdate(() => {\n            this.run(parent);\n            if (this.resizeParent && !parent.isCollapsed()) {\n                this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n            }\n            // Maintaining parent location\n            if (this.parentX != null && this.parentY != null) {\n                let geo = parent.getGeometry();\n                if (geo != null) {\n                    geo = geo.clone();\n                    geo.x = this.parentX;\n                    geo.y = this.parentY;\n                    model.setGeometry(parent, geo);\n                }\n            }\n        });\n    }\n    /**\n     * Returns all visible children in the given parent which do not have\n     * incoming edges. If the result is empty then the children with the\n     * maximum difference between incoming and outgoing edges are returned.\n     * This takes into account edges that are being promoted to the given\n     * root due to invisible children or collapsed cells.\n     *\n     * @param parent <Cell> whose children should be checked.\n     * @param vertices array of vertices to limit search to\n     */\n    findRoots(parent, vertices) {\n        const roots = [];\n        if (parent != null && vertices != null) {\n            const { model } = this.graph;\n            let best = null;\n            let maxDiff = -100000;\n            for (const i in vertices) {\n                const cell = vertices[i];\n                if (cell.isVertex() && cell.isVisible()) {\n                    const conns = this.getEdges(cell);\n                    let fanOut = 0;\n                    let fanIn = 0;\n                    for (let k = 0; k < conns.length; k++) {\n                        const src = this.getVisibleTerminal(conns[k], true);\n                        if (src === cell) {\n                            fanOut++;\n                        }\n                        else {\n                            fanIn++;\n                        }\n                    }\n                    if (fanIn === 0 && fanOut > 0) {\n                        roots.push(cell);\n                    }\n                    const diff = fanOut - fanIn;\n                    if (diff > maxDiff) {\n                        maxDiff = diff;\n                        best = cell;\n                    }\n                }\n            }\n            if (roots.length === 0 && best != null) {\n                roots.push(best);\n            }\n        }\n        return roots;\n    }\n    /**\n     * Returns the connected edges for the given cell.\n     *\n     * @param cell <Cell> whose edges should be returned.\n     */\n    getEdges(cell) {\n        const cachedEdges = this.edgesCache.get(cell);\n        if (cachedEdges != null) {\n            return cachedEdges;\n        }\n        const { model } = this.graph;\n        let edges = [];\n        const isCollapsed = cell.isCollapsed();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            if (this.isPort(child)) {\n                edges = edges.concat(child.getEdges(true, true));\n            }\n            else if (isCollapsed || !child.isVisible()) {\n                edges = edges.concat(child.getEdges(true, true));\n            }\n        }\n        edges = edges.concat(cell.getEdges(true, true));\n        const result = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            const source = this.getVisibleTerminal(edges[i], true);\n            const target = this.getVisibleTerminal(edges[i], false);\n            if (source === target ||\n                (source !== target &&\n                    ((target === cell &&\n                        (this.parent == null ||\n                            this.isAncestor(this.parent, source, this.traverseAncestors))) ||\n                        (source === cell &&\n                            (this.parent == null ||\n                                this.isAncestor(this.parent, target, this.traverseAncestors)))))) {\n                result.push(edges[i]);\n            }\n        }\n        this.edgesCache.put(cell, result);\n        return result;\n    }\n    /**\n     * Helper function to return visible terminal for edge allowing for ports\n     *\n     * @param edge <Cell> whose edges should be returned.\n     * @param source Boolean that specifies whether the source or target terminal is to be returned\n     */\n    getVisibleTerminal(edge, source) {\n        let terminalCache;\n        if (source) {\n            terminalCache = this.edgeSourceTermCache;\n        }\n        else {\n            terminalCache = this.edgesTargetTermCache;\n        }\n        const term = terminalCache.get(edge);\n        if (term != null) {\n            return term;\n        }\n        const state = this.graph.view.getState(edge);\n        let terminal = state != null\n            ? state.getVisibleTerminal(source)\n            : this.graph.view.getVisibleTerminal(edge, source);\n        if (terminal == null) {\n            terminal =\n                state != null\n                    ? state.getVisibleTerminal(source)\n                    : this.graph.view.getVisibleTerminal(edge, source);\n        }\n        if (terminal != null) {\n            if (this.isPort(terminal)) {\n                terminal = terminal.getParent();\n            }\n            terminalCache.put(edge, terminal);\n        }\n        return terminal;\n    }\n    /**\n     * The API method used to exercise the layout upon the graph description\n     * and produce a separate description of the vertex position and edge\n     * routing changes made. It runs each stage of the layout that has been\n     * created.\n     */\n    run(parent) {\n        // Separate out unconnected hierarchies\n        const hierarchyVertices = [];\n        const allVertexSet = {};\n        if (this.roots == null && parent != null) {\n            const filledVertexSet = Object();\n            this.filterDescendants(parent, filledVertexSet);\n            this.roots = [];\n            let filledVertexSetEmpty = true;\n            // Poor man's isSetEmpty\n            for (const key in filledVertexSet) {\n                if (filledVertexSet[key] != null) {\n                    filledVertexSetEmpty = false;\n                    break;\n                }\n            }\n            while (!filledVertexSetEmpty) {\n                const candidateRoots = this.findRoots(parent, filledVertexSet);\n                // If the candidate root is an unconnected group cell, remove it from\n                // the layout. We may need a custom set that holds such groups and forces\n                // them to be processed for resizing and/or moving.\n                for (let i = 0; i < candidateRoots.length; i += 1) {\n                    const vertexSet = Object();\n                    hierarchyVertices.push(vertexSet);\n                    this.traverse({\n                        vertex: candidateRoots[i],\n                        directed: true,\n                        edge: null,\n                        allVertices: allVertexSet,\n                        currentComp: vertexSet,\n                        hierarchyVertices: hierarchyVertices,\n                        filledVertexSet: filledVertexSet,\n                        func: null,\n                        visited: null,\n                    });\n                }\n                for (let i = 0; i < candidateRoots.length; i += 1) {\n                    this.roots.push(candidateRoots[i]);\n                }\n                filledVertexSetEmpty = true;\n                // Poor man's isSetEmpty\n                for (const key in filledVertexSet) {\n                    if (filledVertexSet[key] != null) {\n                        filledVertexSetEmpty = false;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            // Find vertex set as directed traversal from roots\n            const roots = this.roots; // NEED CHECK - roots cannot be null\n            for (let i = 0; i < roots.length; i += 1) {\n                const vertexSet = Object();\n                hierarchyVertices.push(vertexSet);\n                this.traverse({\n                    vertex: roots[i],\n                    directed: true,\n                    edge: null,\n                    allVertices: allVertexSet,\n                    currentComp: vertexSet,\n                    hierarchyVertices: hierarchyVertices,\n                    filledVertexSet: null,\n                    func: null,\n                    visited: null,\n                });\n            }\n        }\n        // Iterate through the result removing parents who have children in this layout\n        // Perform a layout for each seperate hierarchy\n        // Track initial coordinate x-positioning\n        let initialX = 0;\n        for (let i = 0; i < hierarchyVertices.length; i += 1) {\n            const vertexSet = hierarchyVertices[i];\n            const tmp = [];\n            for (const key in vertexSet) {\n                tmp.push(vertexSet[key]);\n            }\n            this.model = new GraphHierarchyModel(this, tmp, this.roots, parent, this.tightenToSource);\n            this.cycleStage(parent);\n            this.layeringStage();\n            this.crossingStage(parent);\n            initialX = this.placementStage(initialX, parent);\n        }\n    }\n    /**\n     * Creates an array of descendant cells\n     */\n    filterDescendants(cell, result) {\n        const { model } = this.graph;\n        if (cell.isVertex() && cell !== this.parent && cell.isVisible()) {\n            result[ObjectIdentity.get(cell)] = cell;\n        }\n        if (this.traverseAncestors || (cell === this.parent && cell.isVisible())) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = cell.getChildAt(i);\n                // Ignore ports in the layout vertex list, they are dealt with\n                // in the traversal mechanisms\n                if (!this.isPort(child)) {\n                    this.filterDescendants(child, result);\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell is a \"port\", that is, when connecting to\n     * it, its parent is the connecting vertex in terms of graph traversal\n     *\n     * @param cell <Cell> that represents the port.\n     */\n    isPort(cell) {\n        if (cell != null && cell.geometry != null) {\n            return cell.geometry.relative;\n        }\n        return false;\n    }\n    /**\n     * Returns the edges between the given source and target. This takes into\n     * account collapsed and invisible cells and ports.\n     *\n     * source -\n     * target -\n     * directed -\n     */\n    getEdgesBetween(source, target, directed) {\n        directed = directed != null ? directed : false;\n        const edges = this.getEdges(source);\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edges.length; i += 1) {\n            const src = this.getVisibleTerminal(edges[i], true);\n            const trg = this.getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) ||\n                (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Traverses the (directed) graph invoking the given function for each\n     * visited vertex and edge. The function is invoked with the current vertex\n     * and the incoming edge as a parameter. This implementation makes sure\n     * each vertex is only visited once. The function may return false if the\n     * traversal should stop at the given vertex.\n     *\n     * @param vertex <Cell> that represents the vertex where the traversal starts.\n     * @param directed boolean indicating if edges should only be traversed\n     * from source to target. Default is true.\n     * @param edge Optional <Cell> that represents the incoming edge. This is\n     * null for the first step of the traversal.\n     * @param allVertices Array of cell paths for the visited cells.\n     */\n    traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet, }) {\n        if (vertex != null && allVertices != null) {\n            // Has this vertex been seen before in any traversal\n            // And if the filled vertex set is populated, only\n            // process vertices in that it contains\n            const vertexID = ObjectIdentity.get(vertex);\n            if (allVertices[vertexID] == null &&\n                (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {\n                if (currentComp[vertexID] == null) {\n                    currentComp[vertexID] = vertex;\n                }\n                if (allVertices[vertexID] == null) {\n                    allVertices[vertexID] = vertex;\n                }\n                if (filledVertexSet !== null) {\n                    delete filledVertexSet[vertexID];\n                }\n                const edges = this.getEdges(vertex);\n                const edgeIsSource = [];\n                for (let i = 0; i < edges.length; i += 1) {\n                    edgeIsSource[i] = this.getVisibleTerminal(edges[i], true) == vertex;\n                }\n                for (let i = 0; i < edges.length; i += 1) {\n                    if (!directed || edgeIsSource[i]) {\n                        const next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n                        // Check whether there are more edges incoming from the target vertex than outgoing\n                        // The hierarchical model treats bi-directional parallel edges as being sourced\n                        // from the more \"sourced\" terminal. If the directions are equal in number, the direction\n                        // is that of the natural direction from the roots of the layout.\n                        // The checks below are slightly more verbose than need be for performance reasons\n                        let netCount = 1;\n                        for (let j = 0; j < edges.length; j++) {\n                            if (j !== i) {\n                                const isSource2 = edgeIsSource[j];\n                                const otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n                                if (otherTerm === next) {\n                                    if (isSource2) {\n                                        netCount++;\n                                    }\n                                    else {\n                                        netCount--;\n                                    }\n                                }\n                            }\n                        }\n                        if (netCount >= 0) {\n                            currentComp = this.traverse({\n                                vertex: next,\n                                directed,\n                                edge: edges[i],\n                                allVertices,\n                                currentComp,\n                                hierarchyVertices,\n                                filledVertexSet,\n                                func: null,\n                                visited: null,\n                            });\n                        }\n                    }\n                }\n            }\n            else if (currentComp[vertexID] == null) {\n                // We've seen this vertex before, but not in the current component\n                // This component and the one it's in need to be merged\n                for (let i = 0; i < hierarchyVertices.length; i += 1) {\n                    const comp = hierarchyVertices[i];\n                    // @ts-expect-error\n                    if (comp[vertexID] != null) {\n                        for (const key in comp) {\n                            // @ts-expect-error\n                            currentComp[key] = comp[key];\n                        }\n                        // Remove the current component from the hierarchy set\n                        hierarchyVertices.splice(i, 1);\n                        return currentComp;\n                    }\n                }\n            }\n        }\n        return currentComp;\n    }\n    /**\n     * Executes the cycle stage using mxMinimumCycleRemover.\n     */\n    cycleStage(parent) {\n        const cycleStage = new MinimumCycleRemover(this);\n        cycleStage.execute(parent);\n    }\n    /**\n     * Implements first stage of a Sugiyama layout.\n     */\n    layeringStage() {\n        const model = this.model;\n        model.initialRank();\n        model.fixRanks();\n    }\n    /**\n     * Executes the crossing stage using mxMedianHybridCrossingReduction.\n     */\n    crossingStage(parent) {\n        const crossingStage = new MedianHybridCrossingReduction(this);\n        crossingStage.execute(parent);\n    }\n    /**\n     * Executes the placement stage using mxCoordinateAssignment.\n     */\n    placementStage(initialX, parent) {\n        const placementStage = new CoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);\n        placementStage.fineTuning = this.fineTuning;\n        placementStage.execute(parent);\n        return placementStage.limitX + this.interHierarchySpacing;\n    }\n}\nexport default HierarchicalLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2018, JGraph Ltd\nCopyright (c) 2006-2018, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphHierarchyNode from '../datatypes/GraphHierarchyNode';\nimport GraphHierarchyEdge from '../datatypes/GraphHierarchyEdge';\nimport CellPath from '../../cell/CellPath';\nimport Dictionary from '../../../util/Dictionary';\nimport { clone } from '../../../util/cloneUtils';\n/**\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * @category Layout\n */\nclass SwimlaneModel {\n    /**\n     * Creates an internal ordered graph model using the vertices passed in. If\n     * there are any, leftward edge need to be inverted in the internal model.\n     *\n     * @param layout\n     * @param vertices the vertices for this hierarchy\n     * @param roots\n     * @param parent\n     * @param tightenToSource whether or not to tighten vertices towards the sources\n     */\n    constructor(layout, vertices, roots, parent, tightenToSource) {\n        /**\n         * Mapping from rank number to actual rank\n         */\n        this.ranks = [];\n        /**\n         * Count of the number of times the ancestor dfs has been used.\n         */\n        this.dfsCount = 0;\n        /**\n         * High value to start source layering scan rank value from.\n         */\n        this.SOURCESCANSTARTRANK = 100000000;\n        /**\n         * Whether or not to tighten the assigned ranks of vertices up towards\n         * the source cells.\n         */\n        this.tightenToSource = false;\n        /**\n         * An array of the number of ranks within each swimlane\n         */\n        this.ranksPerGroup = null;\n        const graph = layout.getGraph();\n        this.tightenToSource = tightenToSource;\n        this.roots = roots;\n        this.parent = parent;\n        // map of cells to internal cell needed for second run through\n        // to setup the sink of edges correctly\n        this.vertexMapper = new Dictionary();\n        this.edgeMapper = new Dictionary();\n        this.maxRank = 0;\n        const internalVertices = [];\n        if (vertices == null) {\n            vertices = graph.getChildVertices(parent);\n        }\n        this.maxRank = this.SOURCESCANSTARTRANK;\n        // map of cells to internal cell needed for second run through\n        // to setup the sink of edges correctly. Guess size by number\n        // of edges is roughly same as number of vertices.\n        this.createInternalCells(layout, vertices, internalVertices);\n        // Go through edges set their sink values. Also check the\n        // ordering if and invert edges if necessary\n        for (let i = 0; i < vertices.length; i += 1) {\n            const edges = internalVertices[i].connectsAsSource;\n            for (let j = 0; j < edges.length; j++) {\n                const internalEdge = edges[j];\n                const realEdges = internalEdge.edges;\n                // Only need to process the first real edge, since\n                // all the edges connect to the same other vertex\n                if (realEdges != null && realEdges.length > 0) {\n                    const realEdge = realEdges[0];\n                    let targetCell = layout.getVisibleTerminal(realEdge, false);\n                    let internalTargetCell = this.vertexMapper.get(targetCell);\n                    if (internalVertices[i] == internalTargetCell) {\n                        // If there are parallel edges going between two vertices and not all are in the same direction\n                        // you can have navigated across one direction when doing the cycle reversal that isn't the same\n                        // direction as the first real edge in the array above. When that happens the if above catches\n                        // that and we correct the target cell before continuing.\n                        // This branch only detects this single case\n                        targetCell = layout.getVisibleTerminal(realEdge, true);\n                        internalTargetCell = this.vertexMapper.get(targetCell);\n                    }\n                    if (internalTargetCell != null && internalVertices[i] !== internalTargetCell) {\n                        internalEdge.target = internalTargetCell;\n                        if (internalTargetCell.connectsAsTarget.length == 0) {\n                            internalTargetCell.connectsAsTarget = [];\n                        }\n                        if (internalTargetCell.connectsAsTarget.indexOf(internalEdge) < 0) {\n                            internalTargetCell.connectsAsTarget.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            // Use the temp variable in the internal nodes to mark this\n            // internal vertex as having been visited.\n            internalVertices[i].temp[0] = 1;\n        }\n    }\n    /**\n     * Creates all edges in the internal model\n     *\n     * @param layout Reference to the <HierarchicalLayout> algorithm.\n     * @param vertices Array of {@link Cells} that represent the vertices whom are to\n     * have an internal representation created.\n     * @param internalVertices The array of {@link GraphHierarchyNodes} to have their\n     * information filled in using the real vertices.\n     */\n    createInternalCells(layout, vertices, internalVertices) {\n        const graph = layout.getGraph();\n        const swimlanes = layout.swimlanes;\n        // Create internal edges\n        for (let i = 0; i < vertices.length; i += 1) {\n            internalVertices[i] = new GraphHierarchyNode(vertices[i]);\n            this.vertexMapper.put(vertices[i], internalVertices[i]);\n            internalVertices[i].swimlaneIndex = -1;\n            for (let ii = 0; ii < swimlanes.length; ii += 1) {\n                if (vertices[i].getParent() === swimlanes[ii]) {\n                    internalVertices[i].swimlaneIndex = ii;\n                    break;\n                }\n            }\n            // If the layout is deterministic, order the cells\n            // List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n            const conns = layout.getEdges(vertices[i]);\n            internalVertices[i].connectsAsSource = [];\n            // Create internal edges, but don't do any rank assignment yet\n            // First use the information from the greedy cycle remover to\n            // invert the leftward edges internally\n            for (let j = 0; j < conns.length; j += 1) {\n                const cell = layout.getVisibleTerminal(conns[j], false);\n                // Looking for outgoing edges only\n                if (cell !== vertices[i] && cell.isVertex() && !layout.isVertexIgnored(cell)) {\n                    // We process all edge between this source and its targets\n                    // If there are edges going both ways, we need to collect\n                    // them all into one internal edges to avoid looping problems\n                    // later. We assume this direction (source -> target) is the\n                    // natural direction if at least half the edges are going in\n                    // that direction.\n                    // The check below for edges[0] being in the vertex mapper is\n                    // in case we've processed this the other way around\n                    // (target -> source) and the number of edges in each direction\n                    // are the same. All the graph edges will have been assigned to\n                    // an internal edge going the other way, so we don't want to\n                    // process them again\n                    const undirectedEdges = layout.getEdgesBetween(vertices[i], cell, false);\n                    const directedEdges = layout.getEdgesBetween(vertices[i], cell, true);\n                    if (undirectedEdges != null &&\n                        undirectedEdges.length > 0 &&\n                        this.edgeMapper.get(undirectedEdges[0]) == null &&\n                        directedEdges.length * 2 >= undirectedEdges.length) {\n                        const internalEdge = new GraphHierarchyEdge(undirectedEdges);\n                        for (let k = 0; k < undirectedEdges.length; k += 1) {\n                            const edge = undirectedEdges[k];\n                            this.edgeMapper.put(edge, internalEdge);\n                            // Resets all point on the edge and disables the edge style\n                            // without deleting it from the cell style\n                            graph.resetEdge(edge);\n                            if (layout.disableEdgeStyle) {\n                                layout.setEdgeStyleEnabled(edge, false);\n                                layout.setOrthogonalEdge(edge, true);\n                            }\n                        }\n                        internalEdge.source = internalVertices[i];\n                        if (internalVertices[i].connectsAsSource.indexOf(internalEdge) < 0) {\n                            internalVertices[i].connectsAsSource.push(internalEdge);\n                        }\n                    }\n                }\n            }\n            // Ensure temp variable is cleared from any previous use\n            internalVertices[i].temp[0] = 0;\n        }\n    }\n    /**\n     * Basic determination of minimum layer ranking by working from from sources\n     * or sinks and working through each node in the relevant edge direction.\n     * Starting at the sinks is basically a longest path layering algorithm.\n     */\n    initialRank() {\n        this.ranksPerGroup = [];\n        const startNodes = [];\n        const seen = {};\n        if (this.roots != null) {\n            for (let i = 0; i < this.roots.length; i += 1) {\n                const internalNode = this.vertexMapper.get(this.roots[i]);\n                this.maxChainDfs(null, internalNode, null, seen, 0);\n                if (internalNode != null) {\n                    startNodes.push(internalNode);\n                }\n            }\n        }\n        // Calculate the lower and upper rank bounds of each swimlane\n        const lowerRank = {};\n        const upperRank = {};\n        for (let i = this.ranksPerGroup.length - 1; i >= 0; i--) {\n            if (i === this.ranksPerGroup.length - 1) {\n                lowerRank[i] = 0;\n            }\n            else {\n                lowerRank[i] = upperRank[i + 1] + 1;\n            }\n            upperRank[i] = lowerRank[i] + this.ranksPerGroup[i];\n        }\n        this.maxRank = upperRank[0];\n        const internalNodes = this.vertexMapper.getValues();\n        for (let i = 0; i < internalNodes.length; i += 1) {\n            // Mark the node as not having had a layer assigned\n            internalNodes[i].temp[0] = -1;\n        }\n        const startNodesCopy = startNodes.slice();\n        while (startNodes.length > 0) {\n            const internalNode = startNodes[0];\n            const layerDeterminingEdges = internalNode.connectsAsTarget;\n            const edgesToBeMarked = internalNode.connectsAsSource;\n            // flag to keep track of whether or not all layer determining\n            // edges have been scanned\n            let allEdgesScanned = true;\n            // Work out the layer of this node from the layer determining\n            // edges. The minimum layer number of any node connected by one of\n            // the layer determining edges variable\n            let minimumLayer = upperRank[0];\n            for (let i = 0; i < layerDeterminingEdges.length; i += 1) {\n                const internalEdge = layerDeterminingEdges[i];\n                if (internalEdge.temp[0] === 5270620) {\n                    // This edge has been scanned, get the layer of the\n                    // node on the other end\n                    const otherNode = internalEdge.source;\n                    minimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n                }\n                else {\n                    allEdgesScanned = false;\n                    break;\n                }\n            }\n            // If all edge have been scanned, assign the layer, mark all\n            // edges in the other direction and remove from the nodes list\n            if (allEdgesScanned) {\n                if (minimumLayer > upperRank[internalNode.swimlaneIndex]) {\n                    minimumLayer = upperRank[internalNode.swimlaneIndex];\n                }\n                internalNode.temp[0] = minimumLayer;\n                if (edgesToBeMarked != null) {\n                    for (let i = 0; i < edgesToBeMarked.length; i += 1) {\n                        const internalEdge = edgesToBeMarked[i];\n                        // Assign unique stamp ( y/m/d/h )\n                        internalEdge.temp[0] = 5270620;\n                        // Add node on other end of edge to LinkedList of\n                        // nodes to be analysed\n                        const otherNode = internalEdge.target;\n                        // Only add node if it hasn't been assigned a layer\n                        if (otherNode.temp[0] === -1) {\n                            startNodes.push(otherNode);\n                            // Mark this other node as neither being\n                            // unassigned nor assigned so it isn't\n                            // added to this list again, but it's\n                            // layer isn't used in any calculation.\n                            otherNode.temp[0] = -2;\n                        }\n                    }\n                }\n                startNodes.shift();\n            }\n            else {\n                // Not all the edges have been scanned, get to the back of\n                // the class and put the dunces cap on\n                const removedCell = startNodes.shift();\n                startNodes.push(internalNode);\n                if (removedCell === internalNode && startNodes.length === 1) {\n                    // This is an error condition, we can't get out of\n                    // this loop. It could happen for more than one node\n                    // but that's a lot harder to detect. Log the error\n                    // TODO make log comment\n                    break;\n                }\n            }\n        }\n        // Normalize the ranks down from their large starting value to place\n        // at least 1 sink on layer 0\n        //  for (var key in this.vertexMapper)\n        //  {\n        //    let internalNode = this.vertexMapper[key];\n        //    // Mark the node as not having had a layer assigned\n        //    internalNode.temp[0] -= this.maxRank;\n        //  }\n        // Tighten the rank 0 nodes as far as possible\n        //  for ( let i = 0; i < startNodesCopy.length; i += 1)\n        //  {\n        //    let internalNode = startNodesCopy[i];\n        //    let currentMaxLayer = 0;\n        //    let layerDeterminingEdges = internalNode.connectsAsSource;\n        //\n        //    for ( let j = 0; j < layerDeterminingEdges.length; j++)\n        //    {\n        //      let internalEdge = layerDeterminingEdges[j];\n        //      let otherNode = internalEdge.target;\n        //      internalNode.temp[0] = Math.max(currentMaxLayer,\n        //          otherNode.temp[0] + 1);\n        //      currentMaxLayer = internalNode.temp[0];\n        //    }\n        //  }\n    }\n    /**\n     * Performs a depth first search on the internal hierarchy model. This dfs\n     * extends the default version by keeping track of chains within groups.\n     * Any cycles should be removed prior to running, but previously seen cells\n     * are ignored.\n     *\n     * @param parent the parent internal node of the current internal node\n     * @param root the current internal node\n     * @param connectingEdge the internal edge connecting the internal node and the parent\n     * internal node, if any\n     * @param seen a set of all nodes seen by this dfs\n     * @param chainCount the number of edges in the chain of vertices going through\n     * the current swimlane\n     */\n    maxChainDfs(parent, root, connectingEdge, seen, chainCount) {\n        if (root != null) {\n            const rootId = CellPath.create(root.cell);\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                const slIndex = root.swimlaneIndex;\n                const ranksPerGroup = this.ranksPerGroup;\n                if (ranksPerGroup[slIndex] == null || ranksPerGroup[slIndex] < chainCount) {\n                    ranksPerGroup[slIndex] = chainCount;\n                }\n                // Copy the connects as source list so that visitors\n                // can change the original for edge direction inversions\n                const outgoingEdges = root.connectsAsSource.slice();\n                for (let i = 0; i < outgoingEdges.length; i += 1) {\n                    const internalEdge = outgoingEdges[i];\n                    const targetNode = internalEdge.target;\n                    // Only navigate in source->target direction within the same\n                    // swimlane, or from a lower index swimlane to a higher one\n                    if (root.swimlaneIndex < targetNode.swimlaneIndex) {\n                        this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), 0);\n                    }\n                    else if (root.swimlaneIndex === targetNode.swimlaneIndex) {\n                        this.maxChainDfs(root, targetNode, internalEdge, clone(seen, null, true), chainCount + 1);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Fixes the layer assignments to the values stored in the nodes. Also needs\n     * to create dummy nodes for edges that cross layers.\n     */\n    fixRanks() {\n        const rankList = [];\n        this.ranks = [];\n        for (let i = 0; i < this.maxRank + 1; i += 1) {\n            rankList[i] = [];\n            this.ranks[i] = rankList[i];\n        }\n        // Perform a DFS to obtain an initial ordering for each rank.\n        // Without doing this you would end up having to process\n        // crossings for a standard tree.\n        let rootsArray = null;\n        if (this.roots != null) {\n            const oldRootsArray = this.roots;\n            rootsArray = [];\n            for (let i = 0; i < oldRootsArray.length; i += 1) {\n                const cell = oldRootsArray[i];\n                const internalNode = this.vertexMapper.get(cell);\n                rootsArray[i] = internalNode;\n            }\n        }\n        this.visit((parent, node, edge, layer, seen) => {\n            if (seen === 0 && node.maxRank < 0 && node.minRank < 0) {\n                rankList[node.temp[0]].push(node);\n                node.maxRank = node.temp[0];\n                node.minRank = node.temp[0];\n                // Set temp[0] to the nodes position in the rank\n                node.temp[0] = rankList[node.maxRank].length - 1;\n            }\n            if (parent != null && edge != null) {\n                const parentToCellRankDifference = parent.maxRank - node.maxRank;\n                if (parentToCellRankDifference > 1) {\n                    // There are ranks in between the parent and current cell\n                    edge.maxRank = parent.maxRank;\n                    edge.minRank = node.maxRank;\n                    edge.temp = [];\n                    edge.x = [];\n                    edge.y = [];\n                    for (let i = edge.minRank + 1; i < edge.maxRank; i += 1) {\n                        // The connecting edge must be added to the\n                        // appropriate ranks\n                        rankList[i].push(edge);\n                        edge.setGeneralPurposeVariable(i, rankList[i].length - 1);\n                    }\n                }\n            }\n        }, rootsArray, false, null);\n    }\n    /**\n     * A depth first search through the internal heirarchy model.\n     *\n     * @param visitor The visitor function pattern to be called for each node.\n     * @param trackAncestors Whether or not the search is to keep track all nodes\n     * directly above this one in the search path.\n     */\n    visit(visitor, dfsRoots, trackAncestors, seenNodes) {\n        // Run dfs through on all roots\n        if (dfsRoots != null) {\n            for (let i = 0; i < dfsRoots.length; i += 1) {\n                const internalNode = dfsRoots[i];\n                if (internalNode != null) {\n                    if (seenNodes == null) {\n                        seenNodes = {};\n                    }\n                    if (trackAncestors) {\n                        // Set up hash code for root\n                        internalNode.hashCode = [];\n                        internalNode.hashCode[0] = this.dfsCount;\n                        internalNode.hashCode[1] = i;\n                        this.extendedDfs(null, internalNode, null, visitor, seenNodes, internalNode.hashCode, i, 0);\n                    }\n                    else {\n                        this.dfs(null, internalNode, null, visitor, seenNodes, 0);\n                    }\n                }\n            }\n            this.dfsCount += 1;\n        }\n    }\n    /**\n     * Performs a depth first search on the internal hierarchy model\n     *\n     * @param parent the parent internal node of the current internal node\n     * @param root the current internal node\n     * @param connectingEdge the internal edge connecting the internal node and the parent\n     * internal node, if any\n     * @param visitor the visitor pattern to be called for each node\n     * @param seen a set of all nodes seen by this dfs a set of all of the\n     * ancestor node of the current node\n     * @param layer the layer on the dfs tree ( not the same as the model ranks )\n     */\n    dfs(parent, root, connectingEdge, visitor, seen, layer) {\n        if (root != null) {\n            const rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                visitor(parent, root, connectingEdge, layer, 0);\n                // Copy the connects as source list so that visitors\n                // can change the original for edge direction inversions\n                const outgoingEdges = root.connectsAsSource.slice();\n                for (let i = 0; i < outgoingEdges.length; i += 1) {\n                    const internalEdge = outgoingEdges[i];\n                    const targetNode = internalEdge.target;\n                    // Root check is O(|roots|)\n                    this.dfs(root, targetNode, internalEdge, visitor, seen, layer + 1);\n                }\n            }\n            else {\n                // Use the int field to indicate this node has been seen\n                visitor(parent, root, connectingEdge, layer, 1);\n            }\n        }\n    }\n    /**\n     * Performs a depth first search on the internal hierarchy model. This dfs\n     * extends the default version by keeping track of cells ancestors, but it\n     * should be only used when necessary because of it can be computationally\n     * intensive for deep searches.\n     *\n     * @param parent the parent internal node of the current internal node\n     * @param root the current internal node\n     * @param connectingEdge the internal edge connecting the internal node and the parent\n     * internal node, if any\n     * @param visitor the visitor pattern to be called for each node\n     * @param seen a set of all nodes seen by this dfs\n     * @param ancestors the parent hash code\n     * @param childHash the new hash code for this node\n     * @param layer the layer on the dfs tree ( not the same as the model ranks )\n     */\n    extendedDfs(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer) {\n        // Explanation of custom hash set. Previously, the ancestors variable\n        // was passed through the dfs as a HashSet. The ancestors were copied\n        // into a new HashSet and when the new child was processed it was also\n        // added to the set. If the current node was in its ancestor list it\n        // meant there is a cycle in the graph and this information is passed\n        // to the visitor.visit() in the seen parameter. The HashSet clone was\n        // very expensive on CPU so a custom hash was developed using primitive\n        // types. temp[] couldn't be used so hashCode[] was added to each node.\n        // Each new child adds another int to the array, copying the prefix\n        // from its parent. Child of the same parent add different ints (the\n        // limit is therefore 2^32 children per parent...). If a node has a\n        // child with the hashCode already set then the child code is compared\n        // to the same portion of the current nodes array. If they match there\n        // is a loop.\n        // Note that the basic mechanism would only allow for 1 use of this\n        // functionality, so the root nodes have two ints. The second int is\n        // incremented through each node root and the first is incremented\n        // through each run of the dfs algorithm (therefore the dfs is not\n        // thread safe). The hash code of each node is set if not already set,\n        // or if the first int does not match that of the current run.\n        if (root != null) {\n            if (parent != null) {\n                // Form this nodes hash code if necessary, that is, if the\n                // hashCode variable has not been initialized or if the\n                // start of the parent hash code does not equal the start of\n                // this nodes hash code, indicating the code was set on a\n                // previous run of this dfs.\n                if (root.hashCode == null || root.hashCode[0] !== parent.hashCode[0]) {\n                    const hashCodeLength = parent.hashCode.length + 1;\n                    root.hashCode = parent.hashCode.slice();\n                    root.hashCode[hashCodeLength - 1] = childHash;\n                }\n            }\n            const rootId = root.id;\n            if (seen[rootId] == null) {\n                seen[rootId] = root;\n                visitor(parent, root, connectingEdge, layer, 0);\n                // Copy the connects as source list so that visitors\n                // can change the original for edge direction inversions\n                const outgoingEdges = root.connectsAsSource.slice();\n                const incomingEdges = root.connectsAsTarget.slice();\n                for (let i = 0; i < outgoingEdges.length; i += 1) {\n                    const internalEdge = outgoingEdges[i];\n                    const targetNode = internalEdge.target;\n                    // Only navigate in source->target direction within the same\n                    // swimlane, or from a lower index swimlane to a higher one\n                    if (root.swimlaneIndex <= targetNode.swimlaneIndex) {\n                        this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);\n                    }\n                }\n                for (let i = 0; i < incomingEdges.length; i += 1) {\n                    const internalEdge = incomingEdges[i];\n                    const targetNode = internalEdge.source;\n                    // Only navigate in target->source direction from a lower index\n                    // swimlane to a higher one\n                    if (root.swimlaneIndex < targetNode.swimlaneIndex) {\n                        this.extendedDfs(root, targetNode, internalEdge, visitor, seen, root.hashCode, i, layer + 1);\n                    }\n                }\n            }\n            else {\n                // Use the int field to indicate this node has been seen\n                visitor(parent, root, connectingEdge, layer, 1);\n            }\n        }\n    }\n}\nexport default SwimlaneModel;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport HierarchicalLayoutStage from './HierarchicalLayoutStage';\nimport { remove } from '../../../util/arrayUtils';\nimport CellPath from '../../cell/CellPath';\nimport { clone } from '../../../util/cloneUtils';\n/**\n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n *\n * @category Layout\n */\nclass SwimlaneOrdering extends HierarchicalLayoutStage {\n    /**\n     * Creates a cycle remover for the given internal model.\n     */\n    constructor(layout) {\n        super();\n        this.layout = layout;\n    }\n    /**\n     * Takes the graph detail and configuration information within the facade\n     * and creates the resulting laid out graph within that facade for further\n     * use.\n     */\n    execute(parent) {\n        const model = this.layout.getDataModel();\n        const seenNodes = {};\n        const unseenNodes = clone(model.vertexMapper, null, true);\n        // Perform a dfs through the internal model. If a cycle is found,\n        // reverse it.\n        let rootsArray = null;\n        if (model.roots != null) {\n            const modelRoots = model.roots;\n            rootsArray = [];\n            for (let i = 0; i < modelRoots.length; i += 1) {\n                rootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n            }\n        }\n        model.visit((parent, node, connectingEdge, layer, seen) => {\n            // Check if the cell is in it's own ancestor list, if so\n            // invert the connecting edge and reverse the target/source\n            // relationship to that edge in the parent and the cell\n            // Ancestor hashes only line up within a swimlane\n            const isAncestor = parent != null &&\n                parent.swimlaneIndex === node.swimlaneIndex &&\n                node.isAncestor(parent);\n            // If the source->target swimlane indices go from higher to\n            // lower, the edge is reverse\n            const reversedOverSwimlane = parent != null &&\n                connectingEdge != null &&\n                parent.swimlaneIndex < node.swimlaneIndex &&\n                connectingEdge.source === node;\n            if (isAncestor) {\n                connectingEdge.invert();\n                remove(connectingEdge, parent.connectsAsSource);\n                node.connectsAsSource.push(connectingEdge);\n                parent.connectsAsTarget.push(connectingEdge);\n                remove(connectingEdge, node.connectsAsTarget);\n            }\n            else if (reversedOverSwimlane) {\n                connectingEdge.invert();\n                remove(connectingEdge, parent.connectsAsTarget);\n                node.connectsAsTarget.push(connectingEdge);\n                parent.connectsAsSource.push(connectingEdge);\n                remove(connectingEdge, node.connectsAsSource);\n            }\n            const cellId = CellPath.create(node.cell);\n            seenNodes[cellId] = node;\n            delete unseenNodes[cellId];\n        }, rootsArray, true, null);\n    }\n}\nexport default SwimlaneOrdering;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport GraphLayout from './GraphLayout';\nimport { DIRECTION } from '../../util/Constants';\nimport HierarchicalEdgeStyle from './datatypes/HierarchicalEdgeStyle';\nimport Dictionary from '../../util/Dictionary';\nimport Rectangle from '../geometry/Rectangle';\nimport SwimlaneModel from './hierarchical/SwimlaneModel';\nimport ObjectIdentity from '../../util/ObjectIdentity';\nimport SwimlaneOrdering from './hierarchical/SwimlaneOrdering';\nimport MedianHybridCrossingReduction from './hierarchical/MedianHybridCrossingReduction';\nimport CoordinateAssignment from './hierarchical/CoordinateAssignment';\n/**\n * A hierarchical layout algorithm.\n *\n * @category Layout\n */\nclass SwimlaneLayout extends GraphLayout {\n    /**\n     * Constructs a new hierarchical layout algorithm.\n     *\n     * @param graph Reference to the enclosing {@link Graph}.\n     * @param orientation Optional constant that defines the orientation of this layout. Default is {@link DIRECTION_NORTH}.\n     * @param deterministic Optional boolean that specifies if this layout should be deterministic. Default is true.\n     */\n    constructor(graph, orientation, deterministic = true) {\n        super(graph);\n        this.parentX = null;\n        this.parentY = null;\n        /**\n         * Holds the array of <Cell> that this layout contains.\n         */\n        this.roots = null;\n        /**\n         * Holds the array of <Cell> of the ordered swimlanes to lay out\n         */\n        this.swimlanes = null;\n        /**\n         * The cell width of any dummy vertices inserted\n         */\n        this.dummyVertexWidth = 50;\n        /**\n         * Specifies if the parent should be resized after the layout so that it\n         * contains all the child cells. Default is false. See also <parentBorder>.\n         */\n        this.resizeParent = false;\n        /**\n         * Specifies if the parent location should be maintained, so that the\n         * top, left corner stays the same before and after execution of\n         * the layout. Default is false for backwards compatibility.\n         */\n        this.maintainParentLocation = false;\n        /**\n         * Specifies if the parent should be moved if <resizeParent> is enabled.\n         * Default is false.\n         */\n        this.moveParent = false;\n        /**\n         * The border to be added around the children if the parent is to be\n         * resized using <resizeParent>. Default is 30.\n         */\n        this.parentBorder = 30;\n        /**\n         * The spacing buffer added between cells on the same layer. Default is 30.\n         */\n        this.intraCellSpacing = 30;\n        /**\n         * The spacing buffer added between cell on adjacent layers. Default is 100.\n         */\n        this.interRankCellSpacing = 100;\n        /**\n         * The spacing buffer between unconnected hierarchies. Default is 60.\n         */\n        this.interHierarchySpacing = 60;\n        /**\n         * The distance between each parallel edge on each ranks for long edges.\n         * Default is 10.\n         */\n        this.parallelEdgeSpacing = 10;\n        /**\n         * The position of the root node(s) relative to the laid out graph in.\n         * Default is {@link Constants#DIRECTION_NORTH}.\n         */\n        this.orientation = DIRECTION.NORTH;\n        /**\n         * Whether or not to perform local optimisations and iterate multiple times\n         * through the algorithm. Default is true.\n         */\n        this.fineTuning = true;\n        /**\n         * Whether or not to tighten the assigned ranks of vertices up towards\n         * the source cells. Default is true.\n         */\n        this.tightenToSource = true;\n        /**\n         * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n         * modified by the result. Default is true.\n         */\n        this.disableEdgeStyle = true;\n        /**\n         * Whether or not to drill into child cells and layout in reverse\n         * group order. This also cause the layout to navigate edges whose\n         * terminal vertices have different parents but are in the same\n         * ancestry chain. Default is true.\n         */\n        this.traverseAncestors = true;\n        /**\n         * The internal {@link SwimlaneModel} formed of the layout.\n         */\n        this.model = null;\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgesCache = new Dictionary();\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgeSourceTermCache = new Dictionary();\n        /**\n         * A cache of edges whose source terminal is the key\n         */\n        this.edgesTargetTermCache = new Dictionary();\n        /**\n         * The style to apply between cell layers to edge segments.\n         * Default is {@link HierarchicalEdgeStyle#POLYLINE}.\n         */\n        this.edgeStyle = HierarchicalEdgeStyle.POLYLINE;\n        this.orientation = orientation != null ? orientation : DIRECTION.NORTH;\n        this.deterministic = deterministic != null ? deterministic : true;\n    }\n    /**\n     * Returns the internal {@link SwimlaneModel} for this layout algorithm.\n     */\n    getDataModel() {\n        return this.model;\n    }\n    /**\n     * Executes the layout for the children of the specified parent.\n     *\n     * @param parent Parent <Cell> that contains the children to be laid out.\n     * @param swimlanes Ordered array of swimlanes to be laid out\n     */\n    execute(parent, swimlanes = null) {\n        this.parent = parent;\n        const { model } = this.graph;\n        this.edgesCache = new Dictionary();\n        this.edgeSourceTermCache = new Dictionary();\n        this.edgesTargetTermCache = new Dictionary();\n        // If the roots are set and the parent is set, only\n        // use the roots that are some dependent of the that\n        // parent.\n        // If just the root are set, use them as-is\n        // If just the parent is set use it's immediate\n        // children as the initial set\n        if (swimlanes == null || swimlanes.length < 1) {\n            // TODO indicate the problem\n            return;\n        }\n        if (parent == null) {\n            parent = swimlanes[0].getParent();\n        }\n        //  Maintaining parent location\n        this.parentX = null;\n        this.parentY = null;\n        if (parent !== this.graph.getDataModel().root &&\n            parent.isVertex() != null &&\n            this.maintainParentLocation) {\n            const geo = parent.getGeometry();\n            if (geo != null) {\n                this.parentX = geo.x;\n                this.parentY = geo.y;\n            }\n        }\n        this.swimlanes = swimlanes;\n        const dummyVertices = [];\n        // Check the swimlanes all have vertices\n        // in them\n        for (let i = 0; i < swimlanes.length; i += 1) {\n            const children = this.graph.getChildCells(swimlanes[i]);\n            if (children == null || children.length === 0) {\n                const vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);\n                dummyVertices.push(vertex);\n            }\n        }\n        model.beginUpdate();\n        try {\n            this.run(parent);\n            if (this.resizeParent && !parent.isCollapsed()) {\n                this.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n            }\n            // Maintaining parent location\n            if (this.parentX != null && this.parentY != null) {\n                let geo = parent.getGeometry();\n                if (geo != null) {\n                    geo = geo.clone();\n                    geo.x = this.parentX;\n                    geo.y = this.parentY;\n                    model.setGeometry(parent, geo);\n                }\n            }\n            this.graph.removeCells(dummyVertices);\n        }\n        finally {\n            model.endUpdate();\n        }\n    }\n    /**\n     * Updates the bounds of the given array of groups so that it includes\n     * all child vertices.\n     *\n     */\n    updateGroupBounds() {\n        // Get all vertices and edge in the layout\n        const cells = [];\n        const model = this.model;\n        for (const key in model.edgeMapper) {\n            // @ts-expect-error\n            const edge = model.edgeMapper[key];\n            for (let i = 0; i < edge.edges.length; i += 1) {\n                cells.push(edge.edges[i]);\n            }\n        }\n        let layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);\n        const childBounds = [];\n        const swimlanes = this.swimlanes;\n        for (let i = 0; i < swimlanes.length; i += 1) {\n            const lane = swimlanes[i];\n            const geo = lane.getGeometry();\n            if (geo != null) {\n                const children = this.graph.getChildCells(lane);\n                const size = this.graph.isSwimlane(lane)\n                    ? this.graph.getStartSize(lane)\n                    : new Rectangle();\n                const bounds = this.graph.getBoundingBoxFromGeometry(children);\n                childBounds[i] = bounds;\n                const childrenY = bounds.y + geo.y - size.height - this.parentBorder;\n                const maxChildrenY = bounds.y + geo.y + bounds.height;\n                if (layoutBounds == null) {\n                    layoutBounds = new Rectangle(0, childrenY, 0, maxChildrenY - childrenY);\n                }\n                else {\n                    layoutBounds.y = Math.min(layoutBounds.y, childrenY);\n                    const maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);\n                    layoutBounds.height = maxY - layoutBounds.y;\n                }\n            }\n        }\n        for (let i = 0; i < swimlanes.length; i += 1) {\n            const lane = swimlanes[i];\n            const geo = lane.getGeometry();\n            if (geo != null) {\n                const children = this.graph.getChildCells(lane);\n                const size = this.graph.isSwimlane(lane)\n                    ? this.graph.getStartSize(lane)\n                    : new Rectangle();\n                const newGeo = geo.clone();\n                const leftGroupBorder = i === 0 ? this.parentBorder : this.interRankCellSpacing / 2;\n                const w = size.width + leftGroupBorder;\n                const x = childBounds[i].x - w;\n                const y = layoutBounds.y - this.parentBorder;\n                newGeo.x += x;\n                newGeo.y = y;\n                newGeo.width = childBounds[i].width + w + this.interRankCellSpacing / 2;\n                newGeo.height =\n                    layoutBounds.height + size.height + 2 * this.parentBorder;\n                this.graph.model.setGeometry(lane, newGeo);\n                this.graph.moveCells(children, -x, geo.y - y);\n            }\n        }\n    }\n    /**\n     * Returns all visible children in the given parent which do not have\n     * incoming edges. If the result is empty then the children with the\n     * maximum difference between incoming and outgoing edges are returned.\n     * This takes into account edges that are being promoted to the given\n     * root due to invisible children or collapsed cells.\n     *\n     * @param parent <Cell> whose children should be checked.\n     * @param vertices array of vertices to limit search to\n     */\n    findRoots(parent, vertices) {\n        const roots = [];\n        if (parent != null && vertices != null) {\n            const { model } = this.graph;\n            let best = null;\n            let maxDiff = -100000;\n            for (const i in vertices) {\n                const cell = vertices[i];\n                if (cell != null &&\n                    cell.isVertex() &&\n                    cell.isVisible() &&\n                    parent.isAncestor(cell)) {\n                    const conns = this.getEdges(cell);\n                    let fanOut = 0;\n                    let fanIn = 0;\n                    for (let k = 0; k < conns.length; k++) {\n                        const src = this.getVisibleTerminal(conns[k], true);\n                        if (src === cell) {\n                            // Only count connection within this swimlane\n                            const other = this.getVisibleTerminal(conns[k], false);\n                            if (parent.isAncestor(other)) {\n                                fanOut += 1;\n                            }\n                        }\n                        else if (parent.isAncestor(src)) {\n                            fanIn += 1;\n                        }\n                    }\n                    if (fanIn === 0 && fanOut > 0) {\n                        roots.push(cell);\n                    }\n                    const diff = fanOut - fanIn;\n                    if (diff > maxDiff) {\n                        maxDiff = diff;\n                        best = cell;\n                    }\n                }\n            }\n            if (roots.length === 0 && best != null) {\n                roots.push(best);\n            }\n        }\n        return roots;\n    }\n    /**\n     * Returns the connected edges for the given cell.\n     *\n     * @param cell <Cell> whose edges should be returned.\n     */\n    getEdges(cell) {\n        const cachedEdges = this.edgesCache.get(cell);\n        if (cachedEdges != null) {\n            return cachedEdges;\n        }\n        let edges = [];\n        const isCollapsed = cell.isCollapsed();\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            if (this.isPort(child)) {\n                edges = edges.concat(child.getEdges(true, true));\n            }\n            else if (isCollapsed || !child.isVisible()) {\n                edges = edges.concat(child.getEdges(true, true));\n            }\n        }\n        edges = edges.concat(cell.getEdges(true, true));\n        const result = [];\n        for (let i = 0; i < edges.length; i += 1) {\n            const source = this.getVisibleTerminal(edges[i], true);\n            const target = this.getVisibleTerminal(edges[i], false);\n            if (source === target ||\n                (source !== target &&\n                    ((target === cell &&\n                        (this.parent == null ||\n                            this.graph.isValidAncestor(source, this.parent, this.traverseAncestors))) ||\n                        (source === cell &&\n                            (this.parent == null ||\n                                this.graph.isValidAncestor(target, this.parent, this.traverseAncestors)))))) {\n                result.push(edges[i]);\n            }\n        }\n        this.edgesCache.put(cell, result);\n        return result;\n    }\n    /**\n     * Helper function to return visible terminal for edge allowing for ports\n     *\n     * @param edge <Cell> whose edges should be returned.\n     * @param source Boolean that specifies whether the source or target terminal is to be returned\n     */\n    getVisibleTerminal(edge, source) {\n        let terminalCache = this.edgesTargetTermCache;\n        if (source) {\n            terminalCache = this.edgeSourceTermCache;\n        }\n        const term = terminalCache.get(edge);\n        if (term != null) {\n            return term;\n        }\n        const state = this.graph.view.getState(edge);\n        let terminal = state != null\n            ? state.getVisibleTerminal(source)\n            : this.graph.view.getVisibleTerminal(edge, source);\n        if (terminal == null) {\n            terminal =\n                state != null\n                    ? state.getVisibleTerminal(source)\n                    : this.graph.view.getVisibleTerminal(edge, source);\n        }\n        if (terminal != null) {\n            if (this.isPort(terminal)) {\n                terminal = terminal.getParent();\n            }\n            terminalCache.put(edge, terminal);\n        }\n        return terminal;\n    }\n    /**\n     * The API method used to exercise the layout upon the graph description\n     * and produce a separate description of the vertex position and edge\n     * routing changes made. It runs each stage of the layout that has been\n     * created.\n     */\n    run(parent) {\n        // Separate out unconnected hierarchies\n        const hierarchyVertices = [];\n        const allVertexSet = {};\n        if (this.swimlanes != null && this.swimlanes.length > 0 && parent != null) {\n            const filledVertexSet = {};\n            for (let i = 0; i < this.swimlanes.length; i += 1) {\n                this.filterDescendants(this.swimlanes[i], filledVertexSet);\n            }\n            this.roots = [];\n            let filledVertexSetEmpty = true;\n            // Poor man's isSetEmpty\n            for (const key in filledVertexSet) {\n                if (filledVertexSet[key] != null) {\n                    filledVertexSetEmpty = false;\n                    break;\n                }\n            }\n            // Only test for candidates in each swimlane in order\n            let laneCounter = 0;\n            while (!filledVertexSetEmpty && laneCounter < this.swimlanes.length) {\n                const candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);\n                if (candidateRoots.length === 0) {\n                    laneCounter++;\n                    continue;\n                }\n                // If the candidate root is an unconnected group cell, remove it from\n                // the layout. We may need a custom set that holds such groups and forces\n                // them to be processed for resizing and/or moving.\n                for (let i = 0; i < candidateRoots.length; i += 1) {\n                    const vertexSet = Object();\n                    hierarchyVertices.push(vertexSet);\n                    this.traverse({\n                        vertex: candidateRoots[i],\n                        directed: true,\n                        edge: null,\n                        allVertices: allVertexSet,\n                        currentComp: vertexSet,\n                        hierarchyVertices,\n                        filledVertexSet,\n                        swimlaneIndex: laneCounter,\n                        func: null,\n                        visited: null,\n                    });\n                }\n                for (let i = 0; i < candidateRoots.length; i += 1) {\n                    this.roots.push(candidateRoots[i]);\n                }\n                filledVertexSetEmpty = true;\n                // Poor man's isSetEmpty\n                for (const key in filledVertexSet) {\n                    if (filledVertexSet[key] != null) {\n                        filledVertexSetEmpty = false;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            // Find vertex set as directed traversal from roots\n            const roots = this.roots;\n            for (let i = 0; i < roots.length; i += 1) {\n                const vertexSet = Object();\n                hierarchyVertices.push(vertexSet);\n                this.traverse({\n                    vertex: roots[i],\n                    directed: true,\n                    edge: null,\n                    allVertices: allVertexSet,\n                    currentComp: vertexSet,\n                    hierarchyVertices,\n                    filledVertexSet: null,\n                    swimlaneIndex: i,\n                    func: null,\n                    visited: null,\n                }); // CHECK THIS PARAM!! ====================\n            }\n        }\n        const tmp = [];\n        for (const key in allVertexSet) {\n            tmp.push(allVertexSet[key]);\n        }\n        this.model = new SwimlaneModel(this, tmp, this.roots, parent, this.tightenToSource);\n        this.cycleStage(parent);\n        this.layeringStage();\n        this.crossingStage(parent);\n        this.placementStage(0, parent);\n    }\n    /**\n     * Creates an array of descendant cells\n     */\n    filterDescendants(cell, result) {\n        const { model } = this.graph;\n        if (cell.isVertex() &&\n            cell !== this.parent &&\n            cell.getParent() !== this.parent &&\n            cell.isVisible()) {\n            result[ObjectIdentity.get(cell)] = cell;\n        }\n        if (this.traverseAncestors || (cell === this.parent && cell.isVisible())) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const child = cell.getChildAt(i);\n                // Ignore ports in the layout vertex list, they are dealt with\n                // in the traversal mechanisms\n                if (!this.isPort(child)) {\n                    this.filterDescendants(child, result);\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given cell is a \"port\", that is, when connecting to\n     * it, its parent is the connecting vertex in terms of graph traversal\n     *\n     * @param cell <Cell> that represents the port.\n     */\n    isPort(cell) {\n        if (cell.geometry.relative) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the edges between the given source and target. This takes into\n     * account collapsed and invisible cells and ports.\n     *\n     * source -\n     * target -\n     * directed -\n     */\n    getEdgesBetween(source, target, directed = false) {\n        const edges = this.getEdges(source);\n        const result = [];\n        // Checks if the edge is connected to the correct\n        // cell and returns the first match\n        for (let i = 0; i < edges.length; i += 1) {\n            const src = this.getVisibleTerminal(edges[i], true);\n            const trg = this.getVisibleTerminal(edges[i], false);\n            if ((src === source && trg === target) ||\n                (!directed && src === target && trg === source)) {\n                result.push(edges[i]);\n            }\n        }\n        return result;\n    }\n    /**\n     * Traverses the (directed) graph invoking the given function for each\n     * visited vertex and edge. The function is invoked with the current vertex\n     * and the incoming edge as a parameter. This implementation makes sure\n     * each vertex is only visited once. The function may return false if the\n     * traversal should stop at the given vertex.\n     *\n     * @param vertex <Cell> that represents the vertex where the traversal starts.\n     * @param directed boolean indicating if edges should only be traversed\n     * from source to target. Default is true.\n     * @param edge Optional <Cell> that represents the incoming edge. This is\n     * null for the first step of the traversal.\n     * @param allVertices Array of cell paths for the visited cells.\n     * @param swimlaneIndex the laid out order index of the swimlane vertex is contained in\n     */\n    traverse({ vertex, directed, allVertices, currentComp, hierarchyVertices, filledVertexSet, swimlaneIndex, }) {\n        if (vertex != null && allVertices != null) {\n            // Has this vertex been seen before in any traversal\n            // And if the filled vertex set is populated, only\n            // process vertices in that it contains\n            const vertexID = ObjectIdentity.get(vertex);\n            if (allVertices[vertexID] == null &&\n                (filledVertexSet == null ? true : filledVertexSet[vertexID] != null)) {\n                if (currentComp[vertexID] == null) {\n                    currentComp[vertexID] = vertex;\n                }\n                if (allVertices[vertexID] == null) {\n                    allVertices[vertexID] = vertex;\n                }\n                if (filledVertexSet !== null) {\n                    delete filledVertexSet[vertexID];\n                }\n                const edges = this.getEdges(vertex);\n                for (let i = 0; i < edges.length; i += 1) {\n                    let otherVertex = this.getVisibleTerminal(edges[i], true);\n                    const isSource = otherVertex === vertex;\n                    if (isSource) {\n                        otherVertex = this.getVisibleTerminal(edges[i], false);\n                    }\n                    let otherIndex = 0;\n                    // Get the swimlane index of the other terminal\n                    for (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++) {\n                        if (this.swimlanes[otherIndex].isAncestor(otherVertex)) {\n                            break;\n                        }\n                    }\n                    if (otherIndex >= this.swimlanes.length) {\n                        continue;\n                    }\n                    // Traverse if the other vertex is within the same swimlane as\n                    // as the current vertex, or if the swimlane index of the other\n                    // vertex is greater than that of this vertex\n                    if (otherIndex > swimlaneIndex ||\n                        ((!directed || isSource) && otherIndex === swimlaneIndex)) {\n                        currentComp = this.traverse({\n                            vertex: otherVertex,\n                            directed,\n                            edge: edges[i],\n                            allVertices,\n                            currentComp,\n                            hierarchyVertices,\n                            filledVertexSet,\n                            swimlaneIndex: otherIndex,\n                            func: null,\n                            visited: null,\n                        });\n                    }\n                }\n            }\n            else if (currentComp[vertexID] == null) {\n                // We've seen this vertex before, but not in the current component\n                // This component and the one it's in need to be merged\n                for (let i = 0; i < hierarchyVertices.length; i += 1) {\n                    const comp = hierarchyVertices[i];\n                    // @ts-expect-error\n                    if (comp[vertexID] != null) {\n                        for (const key in comp) {\n                            // @ts-expect-error\n                            currentComp[key] = comp[key];\n                        }\n                        // Remove the current component from the hierarchy set\n                        hierarchyVertices.splice(i, 1);\n                        return currentComp;\n                    }\n                }\n            }\n        }\n        return currentComp;\n    }\n    /**\n     * Executes the cycle stage using mxMinimumCycleRemover.\n     */\n    cycleStage(parent) {\n        const cycleStage = new SwimlaneOrdering(this);\n        cycleStage.execute(parent);\n    }\n    /**\n     * Implements first stage of a Sugiyama layout.\n     */\n    layeringStage() {\n        const model = this.model;\n        model.initialRank();\n        model.fixRanks();\n    }\n    /**\n     * Executes the crossing stage using mxMedianHybridCrossingReduction.\n     */\n    crossingStage(parent) {\n        const crossingStage = new MedianHybridCrossingReduction(this);\n        crossingStage.execute(parent);\n    }\n    /**\n     * Executes the placement stage using mxCoordinateAssignment.\n     */\n    placementStage(initialX, parent) {\n        const placementStage = new CoordinateAssignment(this, this.intraCellSpacing, this.interRankCellSpacing, this.orientation, initialX, this.parallelEdgeSpacing);\n        placementStage.fineTuning = this.fineTuning;\n        placementStage.execute(parent);\n        return placementStage.limitX + this.interHierarchySpacing;\n    }\n}\nexport default SwimlaneLayout;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport ConnectionConstraint from '../../other/ConnectionConstraint';\nimport Rectangle from '../Rectangle';\nimport Shape from '../Shape';\nimport Translations from '../../../util/Translations';\nimport { getValue, isNotNullish } from '../../../util/Utils';\nimport { ALIGN, DIRECTION, NODETYPE, NONE, RECTANGLE_ROUNDING_FACTOR, TEXT_DIRECTION, } from '../../../util/Constants';\nimport StencilShapeRegistry from './StencilShapeRegistry';\nimport { getChildNodes, getTextContent } from '../../../util/domUtils';\nimport Point from '../Point';\nimport { getNumber } from '../../../util/StringUtils';\n/**\n * Configure global settings for stencil shapes.\n * @experimental subject to change or removal. maxGraph's global configuration may be modified in the future without prior notice.\n * @since 0.11.0\n * @category Configuration\n */\nexport const StencilShapeConfig = {\n    /**\n     * Specifies if the use of eval is allowed for evaluating text content and images.\n     * Set this to `true` if stencils can not contain user input.\n     * @default false\n     */\n    allowEval: false,\n    /**\n     * Specifies the default value for the localized attribute of the text element.\n     * @default false\n     */\n    defaultLocalized: false,\n};\n/**\n * Implements a generic shape which is based on an XML node as a description.\n */\nclass StencilShape extends Shape {\n    constructor(desc) {\n        super();\n        /**\n         * Holds an array of {@link ConnectionConstraint}s as defined in the shape.\n         */\n        this.constraints = [];\n        /**\n         * Holds the aspect of the shape. Default is 'auto'.\n         */\n        this.aspect = 'auto';\n        /**\n         * Holds the width of the shape. Default is 100.\n         */\n        this.w0 = 100;\n        /**\n         * Holds the height of the shape. Default is 100.\n         */\n        this.h0 = 100;\n        /**\n         * Holds the XML node with the stencil description.\n         */\n        // bgNode: Element;\n        this.bgNode = null;\n        /**\n         * Holds the XML node with the stencil description.\n         */\n        this.fgNode = null;\n        /**\n         * Holds the strokewidth direction from the description.\n         */\n        this.strokeWidthValue = null;\n        this.desc = desc;\n        this.parseDescription();\n        this.parseConstraints();\n    }\n    /**\n     * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\n     */\n    parseDescription() {\n        // LATER: Preprocess nodes for faster painting\n        this.fgNode = this.desc.getElementsByTagName('foreground')[0];\n        this.bgNode = this.desc.getElementsByTagName('background')[0];\n        this.w0 = Number(this.desc.getAttribute('w') || 100);\n        this.h0 = Number(this.desc.getAttribute('h') || 100);\n        // Possible values for aspect are: variable and fixed where\n        // variable means fill the available space and fixed means\n        // use w0 and h0 to compute the aspect.\n        const aspect = this.desc.getAttribute('aspect');\n        this.aspect = aspect ?? 'variable';\n        // Possible values for strokewidth are all numbers and \"inherit\"\n        // where the inherit means take the value from the style (ie. the\n        // user-defined stroke-width). Note that the strokewidth is scaled\n        // by the minimum scaling that is used to draw the shape (sx, sy).\n        const sw = this.desc.getAttribute('strokewidth');\n        this.strokeWidthValue = isNotNullish(sw) ? sw : '1';\n    }\n    /**\n     * Reads the constraints from {@link desc} into {@link constraints} using {@link parseConstraint}.\n     */\n    parseConstraints() {\n        const conns = this.desc.getElementsByTagName('connections')[0];\n        if (conns) {\n            const tmp = getChildNodes(conns);\n            if (tmp.length > 0) {\n                this.constraints = [];\n                for (let i = 0; i < tmp.length; i += 1) {\n                    this.constraints.push(this.parseConstraint(tmp[i]));\n                }\n            }\n        }\n    }\n    /**\n     * Parses the given XML node and returns its {@link ConnectionConstraint}.\n     */\n    parseConstraint(node) {\n        const x = Number(node.getAttribute('x'));\n        const y = Number(node.getAttribute('y'));\n        const perimeter = node.getAttribute('perimeter') === '1';\n        const name = node.getAttribute('name');\n        return new ConnectionConstraint(new Point(x, y), perimeter, name);\n    }\n    /**\n     * Gets the given attribute as a text. The return value from <evaluateAttribute>\n     * is used as a key to {@link Resources#get} if the localized attribute in the text\n     * node is 1 or if <defaultLocalized> is true.\n     */\n    evaluateTextAttribute(node, attribute, shape) {\n        let result = this.evaluateAttribute(node, attribute, shape);\n        const loc = node.getAttribute('localized');\n        if ((StencilShapeConfig.defaultLocalized && !loc) || loc === '1') {\n            result = Translations.get(result);\n        }\n        return result;\n    }\n    /**\n     * Gets the attribute for the given name from the given node. If the attribute\n     * does not exist then the text content of the node is evaluated and if it is\n     * a function it is invoked with <shape> as the only argument and the return\n     * value is used as the attribute value to be returned.\n     */\n    evaluateAttribute(node, attribute, shape) {\n        let result = node.getAttribute(attribute);\n        if (!result) {\n            const text = getTextContent(node);\n            if (text && StencilShapeConfig.allowEval) {\n                const funct = eval(text);\n                if (typeof funct === 'function') {\n                    result = funct(shape);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawShape(canvas, shape, x, y, w, h) {\n        const stack = canvas.states.slice();\n        // TODO: Internal structure (array of special structs?), relative and absolute\n        // coordinates (eg. note shape, process vs star, actor etc.), text rendering\n        // and non-proportional scaling, how to implement pluggable edge shapes\n        // (start, segment, end blocks), pluggable markers, how to implement\n        // swimlanes (title area) with this API, add icon, horizontal/vertical\n        // label, indicator for all shapes, rotation\n        const direction = getValue(shape.style, 'direction', null);\n        const aspect = this.computeAspect(shape, x, y, w, h, direction);\n        const minScale = Math.min(aspect.width, aspect.height);\n        const sw = this.strokeWidthValue === 'inherit'\n            ? Number(getNumber(shape.style, 'strokeWidth', 1))\n            : Number(this.strokeWidthValue) * minScale;\n        canvas.setStrokeWidth(sw);\n        // Draws a transparent rectangle for catching events\n        if (shape.style?.pointerEvents ?? false) {\n            canvas.setStrokeColor(NONE);\n            canvas.rect(x, y, w, h);\n            canvas.stroke();\n            canvas.setStrokeColor(shape.stroke);\n        }\n        this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);\n        this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true, !shape.outline || shape.style == null || !(shape.style.backgroundOutline ?? false));\n        // Restores stack for unequal count of save/restore calls\n        if (canvas.states.length != stack.length) {\n            canvas.states = stack;\n        }\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawChildren(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint) {\n        if (node && w > 0 && h > 0) {\n            let tmp = node.firstChild;\n            while (tmp) {\n                if (tmp.nodeType === NODETYPE.ELEMENT) {\n                    this.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);\n                }\n                tmp = tmp.nextSibling;\n            }\n        }\n    }\n    /**\n     * Returns a rectangle that contains the offset in x and y and the horizontal\n     * and vertical scale in width and height used to draw this shape inside the\n     * given {@link Rectangle}.\n     *\n     * @param shape {@link Shape} to be drawn.\n     * @param bounds {@link Rectangle} that should contain the stencil.\n     * @param direction Optional direction of the shape to be darwn.\n     */\n    computeAspect(shape = null, x, y, w, h, direction) {\n        let x0 = x;\n        let y0 = y;\n        let sx = w / this.w0;\n        let sy = h / this.h0;\n        const inverse = direction === DIRECTION.NORTH || direction === DIRECTION.SOUTH;\n        if (inverse) {\n            sy = w / this.h0;\n            sx = h / this.w0;\n            const delta = (w - h) / 2;\n            x0 += delta;\n            y0 -= delta;\n        }\n        if (this.aspect === 'fixed') {\n            sy = Math.min(sx, sy);\n            sx = sy;\n            // Centers the shape inside the available space\n            if (inverse) {\n                x0 += (h - this.w0 * sx) / 2;\n                y0 += (w - this.h0 * sy) / 2;\n            }\n            else {\n                x0 += (w - this.w0 * sx) / 2;\n                y0 += (h - this.h0 * sy) / 2;\n            }\n        }\n        return new Rectangle(x0, y0, sx, sy);\n    }\n    /**\n     * Draws this stencil inside the given bounds.\n     */\n    drawNode(canvas, shape, node, aspect, disableShadow, paint) {\n        const name = node.nodeName;\n        const x0 = aspect.x;\n        const y0 = aspect.y;\n        const sx = aspect.width;\n        const sy = aspect.height;\n        const minScale = Math.min(sx, sy);\n        if (name === 'save') {\n            canvas.save();\n        }\n        else if (name === 'restore') {\n            canvas.restore();\n        }\n        else if (paint) {\n            if (name === 'path') {\n                canvas.begin();\n                let parseRegularly = true;\n                if (node.getAttribute('rounded') == '1') {\n                    parseRegularly = false;\n                    const arcSize = Number(node.getAttribute('arcSize'));\n                    let pointCount = 0;\n                    const segs = [];\n                    // Renders the elements inside the given path\n                    let childNode = node.firstChild;\n                    while (childNode != null) {\n                        if (childNode.nodeType === NODETYPE.ELEMENT) {\n                            const childName = childNode.nodeName;\n                            if (childName === 'move' || childName === 'line') {\n                                if (childName === 'move' || segs.length === 0) {\n                                    segs.push([]);\n                                }\n                                segs[segs.length - 1].push(new Point(x0 + Number(childNode.getAttribute('x')) * sx, y0 + Number(childNode.getAttribute('y')) * sy));\n                                pointCount++;\n                            }\n                            else {\n                                // We only support move and line for rounded corners\n                                parseRegularly = true;\n                                break;\n                            }\n                        }\n                        childNode = childNode.nextSibling;\n                    }\n                    if (!parseRegularly && pointCount > 0) {\n                        for (let i = 0; i < segs.length; i += 1) {\n                            let close = false;\n                            const ps = segs[i][0];\n                            const pe = segs[i][segs[i].length - 1];\n                            if (ps.x === pe.x && ps.y === pe.y) {\n                                segs[i].pop();\n                                close = true;\n                            }\n                            this.addPoints(canvas, segs[i], true, arcSize, close);\n                        }\n                    }\n                    else {\n                        parseRegularly = true;\n                    }\n                }\n                if (parseRegularly) {\n                    // Renders the elements inside the given path\n                    let childNode = node.firstChild;\n                    while (childNode) {\n                        if (childNode.nodeType === NODETYPE.ELEMENT) {\n                            this.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);\n                        }\n                        childNode = childNode.nextSibling;\n                    }\n                }\n            }\n            else if (name === 'close') {\n                canvas.close();\n            }\n            else if (name === 'move') {\n                canvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'line') {\n                canvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'quad') {\n                canvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy);\n            }\n            else if (name === 'curve') {\n                canvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy, x0 + Number(node.getAttribute('x3')) * sx, y0 + Number(node.getAttribute('y3')) * sy);\n            }\n            else if (name === 'arc') {\n                canvas.arcTo(Number(node.getAttribute('rx')) * sx, Number(node.getAttribute('ry')) * sy, Number(node.getAttribute('x-axis-rotation')), Boolean(node.getAttribute('large-arc-flag')), Boolean(node.getAttribute('sweep-flag')), x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n            }\n            else if (name === 'rect') {\n                canvas.rect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n            }\n            else if (name === 'roundrect') {\n                let arcsize = Number(node.getAttribute('arcsize'));\n                if (arcsize === 0) {\n                    arcsize = RECTANGLE_ROUNDING_FACTOR * 100;\n                }\n                const w = Number(node.getAttribute('w')) * sx;\n                const h = Number(node.getAttribute('h')) * sy;\n                const factor = Number(arcsize) / 100;\n                const r = Math.min(w * factor, h * factor);\n                canvas.roundrect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, w, h, r, r);\n            }\n            else if (name === 'ellipse') {\n                canvas.ellipse(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n            }\n            else if (name === 'image') {\n                if (!shape.outline) {\n                    const src = this.evaluateAttribute(node, 'src', shape);\n                    canvas.image(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy, src, false, node.getAttribute('flipH') === '1', node.getAttribute('flipV') === '1');\n                }\n            }\n            else if (name === 'text') {\n                if (!shape.outline) {\n                    const str = this.evaluateTextAttribute(node, 'str', shape);\n                    let rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n                    if (node.getAttribute('align-shape') === '0') {\n                        const dr = shape.rotation;\n                        // Depends on flipping\n                        const flipH = getValue(shape.style, 'flipH', 0) == 1;\n                        const flipV = getValue(shape.style, 'flipV', 0) == 1;\n                        if (flipH && flipV) {\n                            rotation -= dr;\n                        }\n                        else if (flipH || flipV) {\n                            rotation += dr;\n                        }\n                        else {\n                            rotation -= dr;\n                        }\n                    }\n                    rotation -= Number(node.getAttribute('rotation'));\n                    canvas.text(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, 0, 0, str, node.getAttribute('align') || ALIGN.LEFT, node.getAttribute('valign') || ALIGN.TOP, false, '', 'auto', false, rotation, TEXT_DIRECTION.AUTO);\n                }\n            }\n            else if (name === 'include-shape') {\n                const stencil = StencilShapeRegistry.getStencil(node.getAttribute('name'));\n                if (stencil) {\n                    const x = x0 + Number(node.getAttribute('x')) * sx;\n                    const y = y0 + Number(node.getAttribute('y')) * sy;\n                    const w = Number(node.getAttribute('w')) * sx;\n                    const h = Number(node.getAttribute('h')) * sy;\n                    stencil.drawShape(canvas, shape, x, y, w, h);\n                }\n            }\n            else if (name === 'fillstroke') {\n                canvas.fillAndStroke();\n            }\n            else if (name === 'fill') {\n                canvas.fill();\n            }\n            else if (name === 'stroke') {\n                canvas.stroke();\n            }\n            else if (name === 'strokewidth') {\n                const s = node.getAttribute('fixed') === '1' ? 1 : minScale;\n                canvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n            }\n            else if (name === 'dashed') {\n                canvas.setDashed(node.getAttribute('dashed') === '1');\n            }\n            else if (name === 'dashpattern') {\n                let value = node.getAttribute('pattern');\n                if (value != null) {\n                    const tmp = value.split(' ');\n                    const pat = [];\n                    for (let i = 0; i < tmp.length; i += 1) {\n                        if (tmp[i].length > 0) {\n                            pat.push(Number(tmp[i]) * minScale);\n                        }\n                    }\n                    value = pat.join(' ');\n                    canvas.setDashPattern(value);\n                }\n            }\n            else if (name === 'strokecolor') {\n                canvas.setStrokeColor(node.getAttribute('color'));\n            }\n            else if (name === 'linecap') {\n                canvas.setLineCap(node.getAttribute('cap'));\n            }\n            else if (name === 'linejoin') {\n                canvas.setLineJoin(node.getAttribute('join'));\n            }\n            else if (name === 'miterlimit') {\n                canvas.setMiterLimit(Number(node.getAttribute('limit')));\n            }\n            else if (name === 'fillcolor') {\n                canvas.setFillColor(node.getAttribute('color'));\n            }\n            else if (name === 'alpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'fillalpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'strokealpha') {\n                canvas.setAlpha(Number(node.getAttribute('alpha')));\n            }\n            else if (name === 'fontcolor') {\n                canvas.setFontColor(node.getAttribute('color'));\n            }\n            else if (name === 'fontstyle') {\n                canvas.setFontStyle(Number(node.getAttribute('style')));\n            }\n            else if (name === 'fontfamily') {\n                canvas.setFontFamily(node.getAttribute('family'));\n            }\n            else if (name === 'fontsize') {\n                canvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n            }\n            if (disableShadow &&\n                (name === 'fillstroke' || name === 'fill' || name === 'stroke')) {\n                disableShadow = false;\n                canvas.setShadow(false);\n            }\n        }\n    }\n}\nexport default StencilShape;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport EventObject from '../event/EventObject';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Implements a basic animation in JavaScript.\n *\n * @class Animation\n * @extends {EventSource}\n */\nclass Animation extends EventSource {\n    constructor(delay = 20) {\n        super();\n        /**\n         * Reference to the thread while the animation is running.\n         */\n        this.thread = null;\n        this.delay = delay;\n    }\n    /**\n     * Returns true if the animation is running.\n     */\n    isRunning() {\n        return this.thread != null;\n    }\n    /**\n     * Starts the animation by repeatedly invoking updateAnimation.\n     */\n    startAnimation() {\n        if (this.thread == null) {\n            this.thread = window.setInterval(this.updateAnimation.bind(this), this.delay);\n        }\n    }\n    /**\n     * Hook for subclassers to implement the animation. Invoke stopAnimation\n     * when finished, startAnimation to resume. This is called whenever the\n     * timer fires and fires an mxEvent.EXECUTE event with no properties.\n     */\n    updateAnimation() {\n        this.fireEvent(new EventObject(InternalEvent.EXECUTE));\n    }\n    /**\n     * Stops the animation by deleting the timer and fires an {@link Event#DONE}.\n     */\n    stopAnimation() {\n        if (this.thread != null) {\n            window.clearInterval(this.thread);\n            this.thread = null;\n            this.fireEvent(new EventObject(InternalEvent.DONE));\n        }\n    }\n}\nexport default Animation;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { setOpacity } from '../../util/styleUtils';\nimport GeometryChange from '../undoable_changes/GeometryChange';\nimport TerminalChange from '../undoable_changes/TerminalChange';\nimport ValueChange from '../undoable_changes/ValueChange';\nimport ChildChange from '../undoable_changes/ChildChange';\nimport StyleChange from '../undoable_changes/StyleChange';\n/**\n * Provides animation effects.\n *\n * @class Effects\n */\nclass Effects {\n    /**\n     * Asynchronous animated move operation. See also: <Morphing>.\n     *\n     * @example\n     * ```javascript\n     * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n     * {\n     *   var changes = evt.getProperty('edit').changes;\n     *\n     *   if (changes.length < 10)\n     *   {\n     *     Effects.animateChanges(graph, changes);\n     *   }\n     * });\n     * ```\n     *\n     * @param graph - {@link Graph} that received the changes.\n     * @param changes - Array of changes to be animated.\n     * @param done - Optional function argument that is invoked after the\n     * last step of the animation.\n     */\n    static animateChanges(graph, changes, done) {\n        const maxStep = 10;\n        let step = 0;\n        const animate = () => {\n            let isRequired = false;\n            for (let i = 0; i < changes.length; i += 1) {\n                const change = changes[i];\n                if (change instanceof GeometryChange ||\n                    change instanceof TerminalChange ||\n                    change instanceof ValueChange ||\n                    change instanceof ChildChange ||\n                    change instanceof StyleChange) {\n                    // @ts-ignore\n                    const state = graph.getView().getState(change.cell || change.child, false);\n                    if (state != null) {\n                        isRequired = true;\n                        if (change.constructor !== GeometryChange || change.cell.isEdge()) {\n                            setOpacity(state.shape.node, (100 * step) / maxStep);\n                        }\n                        else {\n                            const { scale } = graph.getView();\n                            const geometry = change.geometry;\n                            const previous = change.previous;\n                            const dx = (geometry.x - previous.x) * scale;\n                            const dy = (geometry.y - previous.y) * scale;\n                            const sx = (geometry.width - previous.width) * scale;\n                            const sy = (geometry.height - previous.height) * scale;\n                            if (step === 0) {\n                                state.x -= dx;\n                                state.y -= dy;\n                                state.width -= sx;\n                                state.height -= sy;\n                            }\n                            else {\n                                state.x += dx / maxStep;\n                                state.y += dy / maxStep;\n                                state.width += sx / maxStep;\n                                state.height += sy / maxStep;\n                            }\n                            graph.cellRenderer.redraw(state);\n                            // Fades all connected edges and children\n                            Effects.cascadeOpacity(graph, change.cell, (100 * step) / maxStep);\n                        }\n                    }\n                }\n            }\n            if (step < maxStep && isRequired) {\n                step++;\n                window.setTimeout(animate, delay);\n            }\n            else if (done != null) {\n                done();\n            }\n        };\n        const delay = 30;\n        animate();\n    }\n    /**\n     * Sets the opacity on the given cell and its descendants.\n     *\n     * @param graph - {@link Graph} that contains the cells.\n     * @param cell - <Cell> to set the opacity for.\n     * @param opacity - New value for the opacity in %.\n     */\n    static cascadeOpacity(graph, cell, opacity) {\n        // Fades all children\n        const childCount = cell.getChildCount();\n        for (let i = 0; i < childCount; i += 1) {\n            const child = cell.getChildAt(i);\n            const childState = graph.getView().getState(child);\n            if (childState != null) {\n                setOpacity(childState.shape.node, opacity);\n                Effects.cascadeOpacity(graph, child, opacity);\n            }\n        }\n        // Fades all connected edges\n        const edges = cell.getEdges();\n        if (edges != null) {\n            for (let i = 0; i < edges.length; i += 1) {\n                const edgeState = graph.getView().getState(edges[i]);\n                if (edgeState != null) {\n                    setOpacity(edgeState.shape.node, opacity);\n                }\n            }\n        }\n    }\n    /**\n     * Asynchronous fade-out operation.\n     */\n    static fadeOut(node, from, remove, step, delay, isEnabled) {\n        step = step || 40;\n        delay = delay || 30;\n        let opacity = from || 100;\n        setOpacity(node, opacity);\n        if (isEnabled || isEnabled == null) {\n            const f = () => {\n                opacity = Math.max(opacity - step, 0);\n                setOpacity(node, opacity);\n                if (opacity > 0) {\n                    window.setTimeout(f, delay);\n                }\n                else {\n                    node.style.visibility = 'hidden';\n                    if (remove && node.parentNode) {\n                        node.parentNode.removeChild(node);\n                    }\n                }\n            };\n            window.setTimeout(f, delay);\n        }\n        else {\n            node.style.visibility = 'hidden';\n            if (remove && node.parentNode) {\n                node.parentNode.removeChild(node);\n            }\n        }\n    }\n}\nexport default Effects;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport Dictionary from '../../util/Dictionary';\n/**\n * @class CellStatePreview\n *\n * Implements a live preview for moving cells.\n */\nclass CellStatePreview {\n    constructor(graph) {\n        /**\n         * Contains the number of entries in the map.\n         */\n        this.count = 0;\n        this.deltas = new Dictionary();\n        this.graph = graph;\n    }\n    /**\n     * Returns true if this contains no entries.\n     */\n    isEmpty() {\n        return this.count === 0;\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @param {boolean} add\n     * @param {boolean} includeEdges\n     * @return {*}  {mxPoint}\n     * @memberof mxCellStatePreview\n     */\n    moveState(state, dx, dy, add = true, includeEdges = true) {\n        let delta = this.deltas.get(state.cell);\n        if (delta == null) {\n            // Note: Deltas stores the point and the state since the key is a string.\n            delta = { point: new Point(dx, dy), state };\n            this.deltas.put(state.cell, delta);\n            this.count++;\n        }\n        else if (add) {\n            delta.point.x += dx;\n            delta.point.y += dy;\n        }\n        else {\n            delta.point.x = dx;\n            delta.point.y = dy;\n        }\n        if (includeEdges) {\n            this.addEdges(state);\n        }\n        return delta.point;\n    }\n    /**\n     *\n     * @param {Function} visitor\n     * @memberof mxCellStatePreview\n     */\n    show(visitor = null) {\n        this.deltas.visit((key, delta) => {\n            this.translateState(delta.state, delta.point.x, delta.point.y);\n        });\n        this.deltas.visit((key, delta) => {\n            this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n        });\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @memberof mxCellStatePreview\n     */\n    translateState(state, dx, dy) {\n        if (state != null) {\n            if (state.cell.isVertex()) {\n                state.view.updateCellState(state);\n                const geo = state.cell.getGeometry();\n                // Moves selection cells and non-relative vertices in\n                // the first phase so that edge terminal points will\n                // be updated in the second phase\n                if ((dx !== 0 || dy !== 0) &&\n                    geo != null &&\n                    (!geo.relative || this.deltas.get(state.cell) != null)) {\n                    state.x += dx;\n                    state.y += dy;\n                }\n            }\n            for (const child of state.cell.getChildren()) {\n                this.translateState(state.view.getState(child), dx, dy);\n            }\n        }\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Function} visitor\n     * @memberof mxCellStatePreview\n     */\n    revalidateState(state, dx, dy, visitor = null) {\n        // Updates the edge terminal points and restores the\n        // (relative) positions of any (relative) children\n        if (state.cell.isEdge()) {\n            state.view.updateCellState(state);\n        }\n        const geo = state.cell.getGeometry();\n        const pState = state.view.getState(state.cell.getParent());\n        // Moves selection vertices which are relative\n        if ((dx !== 0 || dy !== 0) &&\n            geo != null &&\n            geo.relative &&\n            state.cell.isVertex() &&\n            (pState == null || pState.cell.isVertex() || this.deltas.get(state.cell) != null)) {\n            state.x += dx;\n            state.y += dy;\n        }\n        this.graph.cellRenderer.redraw(state);\n        // Invokes the visitor on the given state\n        if (visitor != null) {\n            visitor(state);\n        }\n        for (const child of state.cell.getChildren()) {\n            this.revalidateState(this.graph.view.getState(child), dx, dy, visitor);\n        }\n    }\n    /**\n     *\n     * @param {CellState} state\n     * @memberof mxCellStatePreview\n     */\n    addEdges(state) {\n        const edgeCount = state.cell.getEdgeCount();\n        for (let i = 0; i < edgeCount; i += 1) {\n            const s = state.view.getState(state.cell.getEdgeAt(i));\n            if (s != null) {\n                this.moveState(s, 0, 0);\n            }\n        }\n    }\n}\nexport default CellStatePreview;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Point from '../geometry/Point';\nimport CellStatePreview from '../cell/CellStatePreview';\nimport Animation from './Animation';\n/**\n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n *\n * ```javascript\n * graph.getDataModel().beginUpdate();\n * try\n * {\n *   let circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   let morph = new Morphing(graph);\n *   morph.addListener(mxEvent.DONE, ()=>\n *   {\n *     graph.getDataModel().endUpdate();\n *   });\n *\n *   morph.startAnimation();\n * }\n * ```\n *\n * Constructor: Morphing\n *\n * Constructs an animation.\n *\n * @param graph Reference to the enclosing {@link Graph}.\n * @param steps Optional number of steps in the morphing animation. Default is 6.\n * @param ease Optional easing constant for the animation. Default is 1.5.\n * @param delay Optional delay between the animation steps. Passed to <Animation>.\n */\nclass Morphing extends Animation {\n    constructor(graph, steps = 6, ease = 1.5, delay) {\n        super(delay);\n        /**\n         * Contains the current step.\n         */\n        this.step = 0;\n        /**\n         * Optional array of cells to be animated. If this is not specified\n         * then all cells are checked and animated if they have been moved\n         * in the current transaction.\n         */\n        this.cells = null;\n        this.graph = graph;\n        this.steps = steps;\n        this.ease = ease;\n    }\n    /**\n     * Animation step.\n     */\n    updateAnimation() {\n        super.updateAnimation();\n        const move = new CellStatePreview(this.graph);\n        if (this.cells != null) {\n            // Animates the given cells individually without recursion\n            for (const cell of this.cells) {\n                this.animateCell(cell, move, false);\n            }\n        }\n        else {\n            // Animates all changed cells by using recursion to find\n            // the changed cells but not for the animation itself\n            this.animateCell(this.graph.getDataModel().getRoot(), move, true);\n        }\n        this.show(move);\n        if (move.isEmpty() || this.step++ >= this.steps) {\n            this.stopAnimation();\n        }\n    }\n    /**\n     * Shows the changes in the given <CellStatePreview>.\n     */\n    show(move) {\n        move.show();\n    }\n    /**\n     * Animates the given cell state using <CellStatePreview.moveState>.\n     */\n    animateCell(cell, move, recurse = false) {\n        const state = this.graph.getView().getState(cell);\n        let delta = null;\n        if (state != null) {\n            // Moves the animated state from where it will be after the model\n            // change by subtracting the given delta vector from that location\n            delta = this.getDelta(state);\n            if (cell.isVertex() && (delta.x != 0 || delta.y != 0)) {\n                const translate = this.graph.view.getTranslate();\n                const scale = this.graph.view.getScale();\n                delta.x += translate.x * scale;\n                delta.y += translate.y * scale;\n                move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n            }\n        }\n        if (recurse && !this.stopRecursion(state, delta)) {\n            const childCount = cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                this.animateCell(cell.getChildAt(i), move, recurse);\n            }\n        }\n    }\n    /**\n     * Returns true if the animation should not recursively find more\n     * deltas for children if the given parent state has been animated.\n     */\n    stopRecursion(state = null, delta = null) {\n        return delta != null && (delta.x != 0 || delta.y != 0);\n    }\n    /**\n     * Returns the vector between the current rendered state and the future\n     * location of the state after the display will be updated.\n     */\n    getDelta(state) {\n        const origin = this.getOriginForCell(state.cell);\n        const translate = this.graph.getView().getTranslate();\n        const scale = this.graph.getView().getScale();\n        const x = state.x / scale - translate.x;\n        const y = state.y / scale - translate.y;\n        return new Point((origin.x - x) * scale, (origin.y - y) * scale);\n    }\n    /**\n     * Returns the top, left corner of the given cell. TODO: Improve performance\n     * by using caching inside this method as the result per cell never changes\n     * during the lifecycle of this object.\n     */\n    getOriginForCell(cell = null) {\n        let result = null;\n        if (cell != null) {\n            const parent = cell.getParent();\n            const geo = cell.getGeometry();\n            result = this.getOriginForCell(parent);\n            // TODO: Handle offsets\n            if (geo != null && parent != null) {\n                if (geo.relative) {\n                    const pgeo = parent.getGeometry();\n                    if (pgeo != null) {\n                        result.x += geo.x * pgeo.width;\n                        result.y += geo.y * pgeo.height;\n                    }\n                }\n                else {\n                    result.x += geo.x;\n                    result.y += geo.y;\n                }\n            }\n        }\n        if (result == null) {\n            const t = this.graph.view.getTranslate();\n            result = new Point(-t.x, -t.y);\n        }\n        return result;\n    }\n}\nexport default Morphing;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport AbstractCanvas2D from './AbstractCanvas2D';\nimport { DEFAULT_FONTFAMILY, DEFAULT_FONTSIZE, NONE, SHADOWCOLOR, SHADOW_OFFSET_X, SHADOW_OFFSET_Y, SHADOW_OPACITY, } from '../../util/Constants';\nimport { getOuterHtml, isNode } from '../../util/domUtils';\n/**\n * Base class for all canvases. The following methods make up the public\n * interface of the canvas 2D for all painting in mxGraph:\n *\n * - <save>, <restore>\n * - <scale>, <translate>, <rotate>\n * - <setAlpha>, <setFillAlpha>, <setStrokeAlpha>, <setFillColor>, <setGradient>,\n *   <setStrokeColor>, <setStrokeWidth>, <setDashed>, <setDashPattern>, <setLineCap>,\n *   <setLineJoin>, <setMiterLimit>\n * - <setFontColor>, <setFontBackgroundColor>, <setFontBorderColor>, <setFontSize>,\n *   <setFontFamily>, <setFontStyle>\n * - <setShadow>, <setShadowColor>, <setShadowAlpha>, <setShadowOffset>\n * - <rect>, <roundrect>, <ellipse>, <image>, <text>\n * - <begin>, {@link moveTo}, <lineTo>, <quadTo>, <curveTo>\n * - <stroke>, <fill>, <fillAndStroke>\n *\n * <AbstractCanvas2D.arcTo> is an additional method for drawing paths. This is\n * a synthetic method, meaning that it is turned into a sequence of curves by\n * default. Subclassers may add native support for arcs.\n *\n * Constructor: D\n *\n * Constructs a new abstract canvas.\n */\nclass XmlCanvas2D extends AbstractCanvas2D {\n    constructor(root) {\n        super();\n        /**\n         * Specifies if text output should be enabled.\n         * @default true\n         */\n        this.textEnabled = true;\n        /**\n         * Specifies if the output should be compressed by removing redundant calls.\n         * @default true\n         */\n        this.compressed = true;\n        this.root = root;\n        // Writes default settings;\n        this.writeDefaults();\n    }\n    /**\n     * Writes the rendering defaults to {@link root}:\n     */\n    writeDefaults() {\n        let elem;\n        // Writes font defaults\n        elem = this.createElement('fontfamily');\n        elem.setAttribute('family', DEFAULT_FONTFAMILY);\n        this.root.appendChild(elem);\n        elem = this.createElement('fontsize');\n        elem.setAttribute('size', String(DEFAULT_FONTSIZE));\n        this.root.appendChild(elem);\n        // Writes shadow defaults\n        elem = this.createElement('shadowcolor');\n        elem.setAttribute('color', SHADOWCOLOR);\n        this.root.appendChild(elem);\n        elem = this.createElement('shadowalpha');\n        elem.setAttribute('alpha', String(SHADOW_OPACITY));\n        this.root.appendChild(elem);\n        elem = this.createElement('shadowoffset');\n        elem.setAttribute('dx', String(SHADOW_OFFSET_X));\n        elem.setAttribute('dy', String(SHADOW_OFFSET_Y));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Returns a formatted number with 2 decimal places.\n     */\n    format(value) {\n        if (typeof value === 'string') {\n            return parseFloat(parseFloat(value).toFixed(2));\n        }\n        else {\n            return parseFloat(value.toFixed(2));\n        }\n    }\n    /**\n     * Creates the given element using the owner document of {@link root}.\n     */\n    createElement(name) {\n        return this.root.ownerDocument.createElement(name);\n    }\n    /**\n     * Saves the drawing state.\n     */\n    save() {\n        if (this.compressed) {\n            super.save();\n        }\n        this.root.appendChild(this.createElement('save'));\n    }\n    /**\n     * Restores the drawing state.\n     */\n    restore() {\n        if (this.compressed) {\n            super.restore();\n        }\n        this.root.appendChild(this.createElement('restore'));\n    }\n    /**\n     * Scales the output.\n     *\n     * @param scale Number that represents the scale where 1 is equal to 100%.\n     */\n    scale(value) {\n        const elem = this.createElement('scale');\n        elem.setAttribute('scale', String(value));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Translates the output.\n     *\n     * @param dx Number that specifies the horizontal translation.\n     * @param dy Number that specifies the vertical translation.\n     */\n    translate(dx, dy) {\n        const elem = this.createElement('translate');\n        elem.setAttribute('dx', String(this.format(dx)));\n        elem.setAttribute('dy', String(this.format(dy)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Rotates and/or flips the output around a given center. (Note: Due to\n     * limitations in VML, the rotation cannot be concatenated.)\n     *\n     * @param theta Number that represents the angle of the rotation (in degrees).\n     * @param flipH Boolean indicating if the output should be flipped horizontally.\n     * @param flipV Boolean indicating if the output should be flipped vertically.\n     * @param cx Number that represents the x-coordinate of the rotation center.\n     * @param cy Number that represents the y-coordinate of the rotation center.\n     */\n    rotate(theta, flipH, flipV, cx, cy) {\n        const elem = this.createElement('rotate');\n        if (theta !== 0 || flipH || flipV) {\n            elem.setAttribute('theta', String(this.format(theta)));\n            elem.setAttribute('flipH', flipH ? '1' : '0');\n            elem.setAttribute('flipV', flipV ? '1' : '0');\n            elem.setAttribute('cx', String(this.format(cx)));\n            elem.setAttribute('cy', String(this.format(cy)));\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current alpha.\n     *\n     * @param value Number that represents the new alpha. Possible values are between\n     * 1 (opaque) and 0 (transparent).\n     */\n    setAlpha(value) {\n        if (this.compressed) {\n            if (this.state.alpha === value) {\n                return;\n            }\n            super.setAlpha(value);\n        }\n        const elem = this.createElement('alpha');\n        elem.setAttribute('alpha', String(this.format(value)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current fill alpha.\n     *\n     * @param value Number that represents the new fill alpha. Possible values are between\n     * 1 (opaque) and 0 (transparent).\n     */\n    setFillAlpha(value) {\n        if (this.compressed) {\n            if (this.state.fillAlpha === value) {\n                return;\n            }\n            super.setFillAlpha(value);\n        }\n        const elem = this.createElement('fillalpha');\n        elem.setAttribute('alpha', String(this.format(value)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current stroke alpha.\n     *\n     * @param value Number that represents the new stroke alpha. Possible values are between\n     * 1 (opaque) and 0 (transparent).\n     */\n    setStrokeAlpha(value) {\n        if (this.compressed) {\n            if (this.state.strokeAlpha === value) {\n                return;\n            }\n            super.setStrokeAlpha(value);\n        }\n        const elem = this.createElement('strokealpha');\n        elem.setAttribute('alpha', String(this.format(value)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current fill color.\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setFillColor(value = null) {\n        if (value === NONE) {\n            value = null;\n        }\n        if (this.compressed) {\n            if (this.state.fillColor === value) {\n                return;\n            }\n            super.setFillColor(value);\n        }\n        const elem = this.createElement('fillcolor');\n        elem.setAttribute('color', value != null ? value : NONE);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the gradient. Note that the coordinates may be ignored by some implementations.\n     *\n     * @param color1 Hexadecimal representation of the start color.\n     * @param color2 Hexadecimal representation of the end color.\n     * @param x X-coordinate of the gradient region.\n     * @param y y-coordinate of the gradient region.\n     * @param w Width of the gradient region.\n     * @param h Height of the gradient region.\n     * @param direction One of {@link Constants#DIRECTION_NORTH}, {@link Constants#DIRECTION_EAST},\n     * {@link Constants#DIRECTION_SOUTH} or {@link Constants#DIRECTION_WEST}.\n     * @param alpha1 Optional alpha of the start color. Default is 1. Possible values\n     * are between 1 (opaque) and 0 (transparent).\n     * @param alpha2 Optional alpha of the end color. Default is 1. Possible values\n     * are between 1 (opaque) and 0 (transparent).\n     */\n    setGradient(color1, color2, x, y, w, h, direction, alpha1 = 1.0, alpha2 = 1.0) {\n        if (color1 != null && color2 != null) {\n            super.setGradient(color1, color2, x, y, w, h, direction, alpha1, alpha2);\n            const elem = this.createElement('gradient');\n            elem.setAttribute('c1', color1);\n            elem.setAttribute('c2', color2);\n            elem.setAttribute('x', String(this.format(x)));\n            elem.setAttribute('y', String(this.format(y)));\n            elem.setAttribute('w', String(this.format(w)));\n            elem.setAttribute('h', String(this.format(h)));\n            // Default direction is south\n            if (direction != null) {\n                elem.setAttribute('direction', direction);\n            }\n            if (alpha1 != null) {\n                elem.setAttribute('alpha1', String(alpha1));\n            }\n            if (alpha2 != null) {\n                elem.setAttribute('alpha2', String(alpha2));\n            }\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current stroke color.\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setStrokeColor(value = null) {\n        if (value === NONE) {\n            value = null;\n        }\n        if (this.compressed) {\n            if (this.state.strokeColor === value) {\n                return;\n            }\n            super.setStrokeColor(value);\n        }\n        const elem = this.createElement('strokecolor');\n        elem.setAttribute('color', value != null ? value : NONE);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current stroke width.\n     *\n     * @param value Numeric representation of the stroke width.\n     */\n    setStrokeWidth(value) {\n        if (this.compressed) {\n            if (this.state.strokeWidth === value) {\n                return;\n            }\n            super.setStrokeWidth(value);\n        }\n        const elem = this.createElement('strokewidth');\n        elem.setAttribute('width', String(this.format(value)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Enables or disables dashed lines.\n     *\n     * @param value Boolean that specifies if dashed lines should be enabled.\n     * @param value Boolean that specifies if the stroke width should be ignored\n     * for the dash pattern.\n     * @default false\n     */\n    setDashed(value, fixDash) {\n        if (this.compressed) {\n            if (this.state.dashed === value) {\n                return;\n            }\n            super.setDashed(value, fixDash);\n        }\n        const elem = this.createElement('dashed');\n        elem.setAttribute('dashed', value ? '1' : '0');\n        if (fixDash != null) {\n            elem.setAttribute('fixDash', fixDash ? '1' : '0');\n        }\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current dash pattern.\n     * @default '3 3'\n     *\n     * @param value String that represents the dash pattern, which is a sequence of\n     * numbers defining the length of the dashes and the length of the spaces\n     * between the dashes. The lengths are relative to the line width - a length\n     * of 1 is equals to the line width.\n     */\n    setDashPattern(value) {\n        if (this.compressed) {\n            if (this.state.dashPattern === value) {\n                return;\n            }\n            super.setDashPattern(value);\n        }\n        const elem = this.createElement('dashpattern');\n        elem.setAttribute('pattern', value);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the line cap.\n     * @default 'flat' which corresponds to 'butt' in SVG\n     *\n     * @param value String that represents the line cap. Possible values are flat, round\n     * and square.\n     */\n    setLineCap(value) {\n        if (this.compressed) {\n            if (this.state.lineCap === value) {\n                return;\n            }\n            super.setLineCap(value);\n        }\n        const elem = this.createElement('linecap');\n        elem.setAttribute('cap', value);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the line join.\n     * @default 'miter'\n     *\n     * @param value String that represents the line join. Possible values are miter,\n     * round and bevel.\n     */\n    setLineJoin(value) {\n        if (this.compressed) {\n            if (this.state.lineJoin === value) {\n                return;\n            }\n            super.setLineJoin(value);\n        }\n        const elem = this.createElement('linejoin');\n        elem.setAttribute('join', value);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the miter limit.\n     * @default 10\n     *\n     * @param value Number that represents the miter limit.\n     */\n    setMiterLimit(value) {\n        if (this.compressed) {\n            if (this.state.miterLimit === value) {\n                return;\n            }\n            super.setMiterLimit(value);\n        }\n        const elem = this.createElement('miterlimit');\n        elem.setAttribute('limit', String(value));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current font color.\n     * @default '#000000'\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setFontColor(value = null) {\n        if (this.textEnabled) {\n            if (value === NONE) {\n                value = null;\n            }\n            if (this.compressed) {\n                if (this.state.fontColor === value) {\n                    return;\n                }\n                super.setFontColor(value);\n            }\n            const elem = this.createElement('fontcolor');\n            elem.setAttribute('color', value != null ? value : NONE);\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current font background color.\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setFontBackgroundColor(value = null) {\n        if (this.textEnabled) {\n            if (value === NONE) {\n                value = null;\n            }\n            if (this.compressed) {\n                if (this.state.fontBackgroundColor === value) {\n                    return;\n                }\n                super.setFontBackgroundColor(value);\n            }\n            const elem = this.createElement('fontbackgroundcolor');\n            elem.setAttribute('color', value != null ? value : NONE);\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current font border color.\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setFontBorderColor(value = null) {\n        if (this.textEnabled) {\n            if (value === NONE) {\n                value = null;\n            }\n            if (this.compressed) {\n                if (this.state.fontBorderColor === value) {\n                    return;\n                }\n                super.setFontBorderColor(value);\n            }\n            const elem = this.createElement('fontbordercolor');\n            elem.setAttribute('color', value != null ? value : NONE);\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current font size.\n     * @default {@link mxConstants.DEFAULT_FONTSIZE}\n     *\n     * @param value Numeric representation of the font size.\n     */\n    setFontSize(value) {\n        if (this.textEnabled) {\n            if (this.compressed) {\n                if (this.state.fontSize === value) {\n                    return;\n                }\n                super.setFontSize(value);\n            }\n            const elem = this.createElement('fontsize');\n            elem.setAttribute('size', String(value));\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current font family.\n     * @default {@link mxConstants.DEFAULT_FONTFAMILY}\n     *\n     * @param value String representation of the font family. This handles the same\n     * values as the CSS font-family property.\n     */\n    setFontFamily(value) {\n        if (this.textEnabled) {\n            if (this.compressed) {\n                if (this.state.fontFamily === value) {\n                    return;\n                }\n                super.setFontFamily(value);\n            }\n            const elem = this.createElement('fontfamily');\n            elem.setAttribute('family', value);\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Sets the current font style.\n     *\n     * @param value Numeric representation of the font family. This is the sum of the\n     * font styles from {@link mxConstants}.\n     */\n    setFontStyle(value = 0) {\n        if (this.textEnabled) {\n            if (value == null) {\n                value = 0;\n            }\n            if (this.compressed) {\n                if (this.state.fontStyle === value) {\n                    return;\n                }\n                super.setFontStyle(value);\n            }\n            const elem = this.createElement('fontstyle');\n            elem.setAttribute('style', String(value));\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Enables or disables shadows.\n     *\n     * @param value Boolean that specifies if shadows should be enabled.\n     */\n    setShadow(value) {\n        if (this.compressed) {\n            if (this.state.shadow === value) {\n                return;\n            }\n            super.setShadow(value);\n        }\n        const elem = this.createElement('shadow');\n        elem.setAttribute('enabled', value ? '1' : '0');\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current shadow color. Default {@link mxConstants.SHADOWCOLOR}\n     *\n     *\n     * @param value Hexadecimal representation of the color or 'none'.\n     */\n    setShadowColor(value = null) {\n        if (this.compressed) {\n            if (value === NONE) {\n                value = null;\n            }\n            if (this.state.shadowColor === value) {\n                return;\n            }\n            super.setShadowColor(value);\n        }\n        const elem = this.createElement('shadowcolor');\n        elem.setAttribute('color', value != null ? value : NONE);\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current shadows alpha. Default is {@link mxConstants.SHADOW_OPACITY}\n     *\n     * @param value Number that represents the new alpha. Possible values are between 1 (opaque) and 0 (transparent).\n     */\n    setShadowAlpha(value) {\n        if (this.compressed) {\n            if (this.state.shadowAlpha === value) {\n                return;\n            }\n            super.setShadowAlpha(value);\n        }\n        const elem = this.createElement('shadowalpha');\n        elem.setAttribute('alpha', String(value));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Sets the current shadow offset.\n     *\n     * @param dx Number that represents the horizontal offset of the shadow.\n     * @param dy Number that represents the vertical offset of the shadow.\n     */\n    setShadowOffset(dx, dy) {\n        if (this.compressed) {\n            if (this.state.shadowDx === dx && this.state.shadowDy === dy) {\n                return;\n            }\n            super.setShadowOffset(dx, dy);\n        }\n        const elem = this.createElement('shadowoffset');\n        elem.setAttribute('dx', String(dx));\n        elem.setAttribute('dy', String(dy));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Puts a rectangle into the drawing buffer.\n     *\n     * @param x Number that represents the x-coordinate of the rectangle.\n     * @param y Number that represents the y-coordinate of the rectangle.\n     * @param w Number that represents the width of the rectangle.\n     * @param h Number that represents the height of the rectangle.\n     */\n    rect(x, y, w, h) {\n        const elem = this.createElement('rect');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        elem.setAttribute('w', String(this.format(w)));\n        elem.setAttribute('h', String(this.format(h)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Puts a rounded rectangle into the drawing buffer.\n     *\n     * @param x Number that represents the x-coordinate of the rectangle.\n     * @param y Number that represents the y-coordinate of the rectangle.\n     * @param w Number that represents the width of the rectangle.\n     * @param h Number that represents the height of the rectangle.\n     * @param dx Number that represents the horizontal rounding.\n     * @param dy Number that represents the vertical rounding.\n     */\n    roundrect(x, y, w, h, dx, dy) {\n        const elem = this.createElement('roundrect');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        elem.setAttribute('w', String(this.format(w)));\n        elem.setAttribute('h', String(this.format(h)));\n        elem.setAttribute('dx', String(this.format(dx)));\n        elem.setAttribute('dy', String(this.format(dy)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Puts an ellipse into the drawing buffer.\n     *\n     * @param x Number that represents the x-coordinate of the ellipse.\n     * @param y Number that represents the y-coordinate of the ellipse.\n     * @param w Number that represents the width of the ellipse.\n     * @param h Number that represents the height of the ellipse.\n     */\n    ellipse(x, y, w, h) {\n        const elem = this.createElement('ellipse');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        elem.setAttribute('w', String(this.format(w)));\n        elem.setAttribute('h', String(this.format(h)));\n        this.root.appendChild(elem);\n    }\n    /**\n     * Paints an image.\n     *\n     * @param x Number that represents the x-coordinate of the image.\n     * @param y Number that represents the y-coordinate of the image.\n     * @param w Number that represents the width of the image.\n     * @param h Number that represents the height of the image.\n     * @param src String that specifies the URL of the image.\n     * @param aspect Boolean indicating if the aspect of the image should be preserved.\n     * @param flipH Boolean indicating if the image should be flipped horizontally.\n     * @param flipV Boolean indicating if the image should be flipped vertically.\n     */\n    image(x, y, w, h, src, aspect = true, flipH = false, flipV = false) {\n        src = this.converter.convert(src);\n        // LATER: Add option for embedding images as base64.\n        const elem = this.createElement('image');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        elem.setAttribute('w', String(this.format(w)));\n        elem.setAttribute('h', String(this.format(h)));\n        elem.setAttribute('src', src);\n        elem.setAttribute('aspect', aspect ? '1' : '0');\n        elem.setAttribute('flipH', flipH ? '1' : '0');\n        elem.setAttribute('flipV', flipV ? '1' : '0');\n        this.root.appendChild(elem);\n    }\n    updateText() {\n        return;\n    }\n    /**\n     * Starts a new path and puts it into the drawing buffer.\n     */\n    begin() {\n        this.root.appendChild(this.createElement('begin'));\n        this.lastX = 0;\n        this.lastY = 0;\n    }\n    end() {\n        return;\n    }\n    /**\n     * Moves the current path the given point.\n     *\n     * @param x Number that represents the x-coordinate of the point.\n     * @param y Number that represents the y-coordinate of the point.\n     */\n    moveTo(x, y) {\n        const elem = this.createElement('move');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        this.root.appendChild(elem);\n        this.lastX = x;\n        this.lastY = y;\n    }\n    /**\n     * Draws a line to the given coordinates.\n     *\n     * @param x Number that represents the x-coordinate of the endpoint.\n     * @param y Number that represents the y-coordinate of the endpoint.\n     */\n    lineTo(x, y) {\n        const elem = this.createElement('line');\n        elem.setAttribute('x', String(this.format(x)));\n        elem.setAttribute('y', String(this.format(y)));\n        this.root.appendChild(elem);\n        this.lastX = x;\n        this.lastY = y;\n    }\n    /**\n     * Adds a quadratic curve to the current path.\n     *\n     * @param x1 Number that represents the x-coordinate of the control point.\n     * @param y1 Number that represents the y-coordinate of the control point.\n     * @param x2 Number that represents the x-coordinate of the endpoint.\n     * @param y2 Number that represents the y-coordinate of the endpoint.\n     */\n    quadTo(x1, y1, x2, y2) {\n        const elem = this.createElement('quad');\n        elem.setAttribute('x1', String(this.format(x1)));\n        elem.setAttribute('y1', String(this.format(y1)));\n        elem.setAttribute('x2', String(this.format(x2)));\n        elem.setAttribute('y2', String(this.format(y2)));\n        this.root.appendChild(elem);\n        this.lastX = x2;\n        this.lastY = y2;\n    }\n    /**\n     * Adds a bezier curve to the current path.\n     *\n     * @param x1 Number that represents the x-coordinate of the first control point.\n     * @param y1 Number that represents the y-coordinate of the first control point.\n     * @param x2 Number that represents the x-coordinate of the second control point.\n     * @param y2 Number that represents the y-coordinate of the second control point.\n     * @param x3 Number that represents the x-coordinate of the endpoint.\n     * @param y3 Number that represents the y-coordinate of the endpoint.\n     */\n    curveTo(x1, y1, x2, y2, x3, y3) {\n        const elem = this.createElement('curve');\n        elem.setAttribute('x1', String(this.format(x1)));\n        elem.setAttribute('y1', String(this.format(y1)));\n        elem.setAttribute('x2', String(this.format(x2)));\n        elem.setAttribute('y2', String(this.format(y2)));\n        elem.setAttribute('x3', String(this.format(x3)));\n        elem.setAttribute('y3', String(this.format(y3)));\n        this.root.appendChild(elem);\n        this.lastX = x3;\n        this.lastY = y3;\n    }\n    /**\n     * Closes the current path.\n     */\n    close() {\n        this.root.appendChild(this.createElement('close'));\n    }\n    /**\n     * Paints the given text. Possible values for format are empty string for\n     * plain text and html for HTML markup. Background and border color as well\n     * as clipping is not available in plain text labels for VML. HTML labels\n     * are not available as part of shapes with no foreignObject support in SVG\n     * (eg. IE9, IE10).\n     *\n     * @param x Number that represents the x-coordinate of the text.\n     * @param y Number that represents the y-coordinate of the text.\n     * @param w Number that represents the available width for the text or 0 for automatic width.\n     * @param h Number that represents the available height for the text or 0 for automatic height.\n     * @param str String that specifies the text to be painted.\n     * @param align String that represents the horizontal alignment.\n     * @param valign String that represents the vertical alignment.\n     * @param wrap Boolean that specifies if word-wrapping is enabled. Requires w > 0.\n     * @param format Empty string for plain text or 'html' for HTML markup.\n     * @param overflow Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.\n     * @param clip Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.\n     * @param rotation Number that specifies the angle of the rotation around the anchor point of the text.\n     * @param dir Optional string that specifies the text direction. Possible values are rtl and ltr.\n     */\n    text(x, y, w, h, str, align = null, valign = null, wrap = null, format = null, overflow = null, clip = null, rotation = null, dir = null) {\n        if (this.textEnabled && str != null) {\n            if (isNode(str)) {\n                str = getOuterHtml(str);\n            }\n            const elem = this.createElement('text');\n            elem.setAttribute('x', String(this.format(x)));\n            elem.setAttribute('y', String(this.format(y)));\n            elem.setAttribute('w', String(this.format(w)));\n            elem.setAttribute('h', String(this.format(h)));\n            elem.setAttribute('str', str);\n            if (align != null) {\n                elem.setAttribute('align', align);\n            }\n            if (valign != null) {\n                elem.setAttribute('valign', valign);\n            }\n            elem.setAttribute('wrap', wrap ? '1' : '0');\n            if (format == null) {\n                format = '';\n            }\n            elem.setAttribute('format', format);\n            if (overflow != null) {\n                elem.setAttribute('overflow', overflow);\n            }\n            if (clip != null) {\n                elem.setAttribute('clip', clip ? '1' : '0');\n            }\n            if (rotation != null) {\n                elem.setAttribute('rotation', String(rotation));\n            }\n            if (dir != null) {\n                elem.setAttribute('dir', dir);\n            }\n            this.root.appendChild(elem);\n        }\n    }\n    /**\n     * Paints the outline of the current drawing buffer.\n     */\n    stroke() {\n        this.root.appendChild(this.createElement('stroke'));\n    }\n    /**\n     * Fills the current drawing buffer.\n     */\n    fill() {\n        this.root.appendChild(this.createElement('fill'));\n    }\n    /**\n     * Fills the current drawing buffer and its outline.\n     */\n    fillAndStroke() {\n        this.root.appendChild(this.createElement('fillstroke'));\n    }\n}\nexport default XmlCanvas2D;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport InternalEvent from '../view/event/InternalEvent';\nimport { write } from './domUtils';\n/**\n * Adds a hyperlink to the specified parent that invokes action on the\n * specified editor.\n *\n * @param parent DOM node to contain the new link.\n * @param text String that is used as the link label.\n * @param editor <Editor> that will execute the action.\n * @param action String that defines the name of the action to be executed.\n * @param pad Optional left-padding for the link. Default is 0.\n */\nexport const linkAction = (parent, text, editor, action, pad = 0) => {\n    return link(parent, text, () => {\n        editor.execute(action);\n    }, pad);\n};\n/**\n * Adds a hyperlink to the specified parent that invokes the specified\n * function on the editor passing along the specified argument. The\n * function name is the name of a function of the editor instance,\n * not an action name.\n *\n * @param parent DOM node to contain the new link.\n * @param text String that is used as the link label.\n * @param editor <Editor> instance to execute the function on.\n * @param functName String that represents the name of the function.\n * @param arg Object that represents the argument to the function.\n * @param pad Optional left-padding for the link. Default is 0.\n */\nexport const linkInvoke = (parent, text, editor, functName, arg, pad = 0) => {\n    return link(parent, text, () => {\n        // @ts-ignore\n        editor[functName](arg);\n    }, pad);\n};\n/**\n * Adds a hyperlink to the specified parent and invokes the given function\n * when the link is clicked.\n *\n * @param parent DOM node to contain the new link.\n * @param text String that is used as the link label.\n * @param funct Function to execute when the link is clicked.\n * @param pad Optional left-padding for the link. Default is 0.\n */\nexport const link = (parent, text, funct, pad = 0) => {\n    const a = document.createElement('span');\n    a.style.color = 'blue';\n    a.style.textDecoration = 'underline';\n    a.style.cursor = 'pointer';\n    a.style.paddingLeft = `${pad}px`;\n    InternalEvent.addListener(a, 'click', funct);\n    write(a, text);\n    if (parent != null) {\n        parent.appendChild(a);\n    }\n    return a;\n};\n/**\n * Returns a new button with the given level and function as an onclick\n * event handler.\n *\n * ```javascript\n * document.body.appendChild(mxUtils.button('Test', (evt)=>\n * {\n *   alert('Hello, World!');\n * }));\n * ```\n *\n * @param label String that represents the label of the button.\n * @param funct Function to be called if the button is pressed.\n * @param doc Optional document to be used for creating the button. Default is the\n * current document.\n */\nexport const button = (label, funct, doc = null) => {\n    doc = doc != null ? doc : document;\n    const button = doc.createElement('button');\n    write(button, label);\n    InternalEvent.addListener(button, 'click', (evt) => {\n        funct(evt);\n    });\n    return button;\n};\n", "/*\nCopyright 2024-present The maxGraph project Contributors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport MaxLog from './MaxLog';\n/**\n * A {@link Logger} that uses {@link MaxLog} to log messages.\n *\n * Notice that the log level for this logger are configured in {@link MaxLog}.\n *\n * @experimental subject to change or removal. The logging system may be modified in the future without prior notice.\n * @since 0.11.0\n * @category Logging\n */\nexport class MaxLogAsLogger {\n    enter(message) {\n        return MaxLog.enter(message);\n    }\n    leave(message, baseTimestamp) {\n        MaxLog.leave(message, baseTimestamp);\n    }\n    show() {\n        MaxLog.show();\n    }\n    info(message) {\n        MaxLog.writeln(message);\n    }\n    debug(message) {\n        MaxLog.debug(message);\n    }\n    error(message, ...optionalParams) {\n        const args = optionalParams?.map((param) => String(param));\n        MaxLog.writeln(`[ERROR] ${message}`, ...args);\n    }\n    trace(message) {\n        MaxLog.trace(message);\n    }\n    warn(message) {\n        MaxLog.warn(message);\n    }\n}\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Maps from keys to base64 encoded images or file locations. All values must\n * be URLs or use the format data:image/format followed by a comma and the base64\n * encoded image data, eg. \"data:image/gif,XYZ\", where XYZ is the base64 encoded\n * image data.\n *\n * To add a new image bundle to an existing graph, the following code is used:\n *\n * ```javascript\n * let bundle = new mxImageBundle(alt);\n * bundle.putImage('myImage', 'data:image/gif,R0lGODlhEAAQAMIGAAAAAICAAICAgP' +\n *   '//AOzp2O3r2////////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAh+QQBCgAHACwAAAAA' +\n *   'EAAQAAADTXi63AowynnAMDfjPUDlnAAJhmeBFxAEloliKltWmiYCQvfVr6lBPB1ggxN1hi' +\n *   'laSSASFQpIV5HJBDyHpqK2ejVRm2AAgZCdmCGO9CIBADs=', fallback);\n * bundle.putImage('mySvgImage', 'data:image/svg+xml,' + encodeURIComponent(\n *   '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">' +\n *   '<linearGradient id=\"gradient\"><stop offset=\"10%\" stop-color=\"#F00\"/>' +\n *   '<stop offset=\"90%\" stop-color=\"#fcc\"/></linearGradient>' +\n *   '<rect fill=\"url(#gradient)\" width=\"100%\" height=\"100%\"/></svg>'), fallback);\n * graph.addImageBundle(bundle);\n * ```;\n *\n * Alt is an optional boolean (default is false) that specifies if the value\n * or the fallback should be returned in <getImage>.\n *\n * The image can then be referenced in any cell style using image=myImage.\n * If you are using mxOutline, you should use the same image bundles in the\n * graph that renders the outline.\n *\n * The keys for images are resolved in {@link Graph#postProcessCellStyle} and\n * turned into a data URI if the returned value has a short data URI format\n * as specified above.\n *\n * A typical value for the fallback is a MTHML link as defined in RFC 2557.\n * Note that this format requires a file to be dynamically created on the\n * server-side, or the page that contains the graph to be modified to contain\n * the resources, this can be done by adding a comment that contains the\n * resource in the HEAD section of the page after the title tag.\n *\n * This type of fallback mechanism should be used in IE6 and IE7. IE8 does\n * support data URIs, but the maximum size is limited to 32 KB, which means\n * all data URIs should be limited to 32 KB.\n */\nclass ImageBundle {\n    constructor(alt = false) {\n        this.images = {};\n        this.alt = alt;\n    }\n    /**\n     * Adds the specified entry to the map. The entry is an object with a value and\n     * fallback property as specified in the arguments.\n     */\n    putImage(key, value, fallback) {\n        this.images[key] = { value, fallback };\n    }\n    /**\n     * Returns the value for the given key. This returns the value\n     * or fallback, depending on <alt>. The fallback is returned if\n     * <alt> is true, the value is returned otherwise.\n     */\n    getImage(key) {\n        let result = null;\n        if (key) {\n            const img = this.images[key];\n            if (img) {\n                result = this.alt ? img.fallback : img.value;\n            }\n        }\n        return result;\n    }\n}\nexport default ImageBundle;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Shape from '../geometry/Shape';\n/**\n * Creates a new image export instance to be used with an export canvas.\n *\n * Here is an example that uses this class to create an image via a backend using {@link XmlCanvas2D}.\n *\n * ```javascript\n * const xmlDoc = xmlUtils.createXmlDocument();\n * const root = xmlDoc.createElement('output');\n * xmlDoc.appendChild(root);\n *\n * const xmlCanvas = new XmlCanvas2D(root);\n * const imageExport = new ImageExport();\n *\n * imageExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n * const xml = xmlUtils.getXml(root);\n *\n * const bounds = graph.getGraphBounds();\n * const w = Math.ceil(bounds.x + bounds.width);\n * const h = Math.ceil(bounds.y + bounds.height);\n *\n * new MaxXmlRequest('export', 'format=png&w=' + w +\n * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\n * \t\t.simulate(document, '_blank');\n * ```\n */\nclass ImageExport {\n    constructor() {\n        /**\n         * Specifies if overlays should be included in the export.\n         * @default false\n         */\n        this.includeOverlays = false;\n    }\n    /**\n     * Draws the given state and all its descendants to the given canvas.\n     */\n    drawState(state, canvas) {\n        if (state) {\n            this.visitStatesRecursive(state, canvas, this.drawCellState.bind(this));\n            // Paints the overlays\n            if (this.includeOverlays) {\n                this.visitStatesRecursive(state, canvas, this.drawOverlays.bind(this));\n            }\n        }\n    }\n    /**\n     * Visits the given state and all its descendants to the given canvas recursively.\n     */\n    visitStatesRecursive(state, canvas, visitor) {\n        if (state) {\n            visitor(state, canvas);\n            const graph = state.view.graph;\n            const childCount = state.cell.getChildCount();\n            for (let i = 0; i < childCount; i += 1) {\n                const childState = graph.view.getState(state.cell.getChildAt(i));\n                if (childState)\n                    this.visitStatesRecursive(childState, canvas, visitor);\n            }\n        }\n    }\n    /**\n     * Returns the link for the given cell state and canvas. This returns null.\n     */\n    getLinkForCellState(_state, _canvas) {\n        return null;\n    }\n    /**\n     * Draws the given state to the given canvas.\n     */\n    drawCellState(state, canvas) {\n        // Experimental feature\n        const link = this.getLinkForCellState(state, canvas);\n        if (link) {\n            canvas.setLink(link);\n        }\n        // Paints the shape and text\n        this.drawShape(state, canvas);\n        this.drawText(state, canvas);\n        if (link) {\n            canvas.setLink(null);\n        }\n    }\n    /**\n     * Draws the shape of the given state.\n     */\n    drawShape(state, canvas) {\n        if (state.shape instanceof Shape && state.shape.checkBounds()) {\n            canvas.save();\n            state.shape.beforePaint(canvas);\n            state.shape.paint(canvas);\n            state.shape.afterPaint(canvas);\n            canvas.restore();\n        }\n    }\n    /**\n     * Draws the text of the given state.\n     */\n    drawText(state, canvas) {\n        if (state.text && state.text.checkBounds()) {\n            canvas.save();\n            state.text.beforePaint(canvas);\n            state.text.paint(canvas);\n            state.text.afterPaint(canvas);\n            canvas.restore();\n        }\n    }\n    /**\n     * Draws the overlays for the given state. This is called if <includeOverlays>\n     * is true.\n     */\n    drawOverlays(state, canvas) {\n        if (state.overlays != null) {\n            state.overlays.visit((_id, shape) => {\n                if (shape instanceof Shape) {\n                    shape.paint(canvas);\n                }\n            });\n        }\n    }\n}\nexport default ImageExport;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport EventSource from '../event/EventSource';\nimport InternalEvent from '../event/InternalEvent';\n/**\n * Manager for automatically saving diagrams. The <save> hook must be\n * implemented.\n *\n * ```javascript\n * const mgr = new AutoSaveManager(editor.graph);\n * mgr.save() {\n *   GlobalConfig.logger.show();\n *   GlobalConfig.logger.debug('save');\n * };\n * ```\n */\nclass AutoSaveManager extends EventSource {\n    constructor(graph) {\n        super();\n        /**\n         * Reference to the enclosing {@link Graph}.\n         */\n        this.graph = null;\n        /**\n         * Minimum amount of seconds between two consecutive autosaves. Eg. a\n         * value of 1 (s) means the graph is not stored more than once per second.\n         * Default is 10.\n         */\n        this.autoSaveDelay = 10;\n        /**\n         * Minimum amount of seconds between two consecutive autosaves triggered by\n         * more than <autoSaveThreshhold> changes within a timespan of less than\n         * <autoSaveDelay> seconds. Eg. a value of 1 (s) means the graph is not\n         * stored more than once per second even if there are more than\n         * <autoSaveThreshold> changes within that timespan. Default is 2.\n         */\n        this.autoSaveThrottle = 2;\n        /**\n         * Minimum amount of ignored changes before an autosave. Eg. a value of 2\n         * means after 2 change of the graph model the autosave will trigger if the\n         * condition below is true. Default is 5.\n         */\n        this.autoSaveThreshold = 5;\n        /**\n         * Counter for ignored changes in autosave.\n         */\n        this.ignoredChanges = 0;\n        /**\n         * Used for autosaving. See <autosave>.\n         */\n        this.lastSnapshot = 0;\n        /**\n         * Specifies if event handling is enabled. Default is true.\n         */\n        this.enabled = true;\n        // Notifies the manager of a change\n        this.changeHandler = (sender, evt) => {\n            if (this.isEnabled()) {\n                this.graphModelChanged(evt.getProperty('edit').changes);\n            }\n        };\n        this.setGraph(graph);\n    }\n    /**\n     * Returns true if events are handled. This implementation\n     * returns <enabled>.\n     */\n    isEnabled() {\n        return this.enabled;\n    }\n    /**\n     * Enables or disables event handling. This implementation\n     * updates <enabled>.\n     *\n     * @param enabled - Boolean that specifies the new enabled state.\n     */\n    setEnabled(value) {\n        this.enabled = value;\n    }\n    /**\n     * Sets the graph that the layouts operate on.\n     */\n    setGraph(graph) {\n        if (this.graph != null) {\n            this.graph.getDataModel().removeListener(this.changeHandler);\n        }\n        this.graph = graph;\n        if (this.graph != null) {\n            this.graph.getDataModel().addListener(InternalEvent.CHANGE, this.changeHandler);\n        }\n    }\n    /**\n     * Empty hook that is called if the graph should be saved.\n     */\n    save() {\n        // empty\n    }\n    /**\n     * Invoked when the graph model has changed.\n     */\n    graphModelChanged(changes) {\n        const now = new Date().getTime();\n        const dt = (now - this.lastSnapshot) / 1000;\n        if (dt > this.autoSaveDelay ||\n            (this.ignoredChanges >= this.autoSaveThreshold && dt > this.autoSaveThrottle)) {\n            this.save();\n            this.reset();\n        }\n        else {\n            // Increments the number of ignored changes\n            this.ignoredChanges++;\n        }\n    }\n    /**\n     * Resets all counters.\n     */\n    reset() {\n        this.lastSnapshot = new Date().getTime();\n        this.ignoredChanges = 0;\n    }\n    /**\n     * Removes all handlers from the <graph> and deletes the reference to it.\n     */\n    destroy() {\n        this.setGraph(null);\n    }\n}\nexport default AutoSaveManager;\n", "/*\nCopyright 2021-present The maxGraph project Contributors\nCopyright (c) 2006-2015, JGraph Ltd\nCopyright (c) 2006-2015, Gaudenz Alder\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport Translations from '../../util/Translations';\nimport { isNode } from '../../util/domUtils';\n/**\n * @class Multiplicity\n *\n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to {@link graph.multiplicities}.\n *\n * ### Example\n *\n * ```javascript\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * ```\n *\n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n */\nclass Multiplicity {\n    constructor(source, type, attr, value, min, max, validNeighbors, countError, typeError, validNeighborsAllowed = true) {\n        /**\n         * Boolean indicating if the list of validNeighbors are those that are allowed\n         * for this rule or those that are not allowed for this rule.\n         */\n        this.validNeighborsAllowed = true;\n        this.source = source;\n        this.type = type;\n        this.attr = attr;\n        this.value = value;\n        this.min = min ?? 0;\n        this.max = max ?? Number.MAX_VALUE;\n        this.validNeighbors = validNeighbors;\n        this.countError = Translations.get(countError) || countError;\n        this.typeError = Translations.get(typeError) || typeError;\n        this.validNeighborsAllowed = validNeighborsAllowed;\n    }\n    /**\n     * Checks the multiplicity for the given arguments and returns the error\n     * for the given connection or null if the multiplicity does not apply.\n     *\n     * @param graph Reference to the enclosing {@link graph} instance.\n     * @param edge {@link mxCell} that represents the edge to validate.\n     * @param source {@link mxCell} that represents the source terminal.\n     * @param target {@link mxCell} that represents the target terminal.\n     * @param sourceOut Number of outgoing edges from the source terminal.\n     * @param targetIn Number of incoming edges for the target terminal.\n     */\n    check(graph, edge, source, target, sourceOut, targetIn) {\n        let error = '';\n        if ((this.source && this.checkTerminal(graph, source, edge)) ||\n            (!this.source && this.checkTerminal(graph, target, edge))) {\n            if (this.countError != null &&\n                ((this.source && (this.max === 0 || sourceOut >= this.max)) ||\n                    (!this.source && (this.max === 0 || targetIn >= this.max)))) {\n                error += `${this.countError}\\n`;\n            }\n            if (this.validNeighbors != null &&\n                this.typeError != null &&\n                this.validNeighbors.length > 0) {\n                const isValid = this.checkNeighbors(graph, edge, source, target);\n                if (!isValid) {\n                    error += `${this.typeError}\\n`;\n                }\n            }\n        }\n        return error.length > 0 ? error : null;\n    }\n    /**\n     * Checks if there are any valid neighbours in {@link validNeighbors}. This is only\n     * called if {@link validNeighbors} is a non-empty array.\n     */\n    checkNeighbors(graph, edge, source, target) {\n        const sourceValue = source.getValue();\n        const targetValue = target.getValue();\n        let isValid = !this.validNeighborsAllowed;\n        const valid = this.validNeighbors;\n        for (let j = 0; j < valid.length; j++) {\n            if (this.source && this.checkType(graph, targetValue, valid[j])) {\n                isValid = this.validNeighborsAllowed;\n                break;\n            }\n            else if (!this.source && this.checkType(graph, sourceValue, valid[j])) {\n                isValid = this.validNeighborsAllowed;\n                break;\n            }\n        }\n        return isValid;\n    }\n    /**\n     * Checks the given terminal cell and returns true if this rule applies. The\n     * given cell is the source or target of the given edge, depending on\n     * {@link source}. This implementation uses {@link checkType} on the terminal's value.\n     */\n    checkTerminal(graph, edge, terminal) {\n        const value = terminal?.getValue() ?? null;\n        return this.checkType(graph, value, this.type, this.attr, this.value);\n    }\n    /**\n     * Checks the type of the given value.\n     */\n    checkType(graph, value, type, attr, attrValue) {\n        if (value != null) {\n            if (typeof value !== 'string' &&\n                'nodeType' in value &&\n                !Number.isNaN(value.nodeType)) {\n                // Checks if value is a DOM node\n                return isNode(value, type, attr, attrValue);\n            }\n            return value === type;\n        }\n        return false;\n    }\n}\nexport default Multiplicity;\n"],
  "mappings": "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",
  "names": ["name", "key", "value", "i", "value", "name", "funct", "i", "evt", "value", "evt", "RENDERING_HINT", "DIALECT", "NODETYPE", "CURSOR", "FONT", "ARROW", "ALIGN", "DIRECTION", "TEXT_DIRECTION", "ELBOW", "EDGESTYLE", "PERIMETER", "SHAPE", "i", "node", "text", "parent", "br", "value", "child", "tmp", "id", "link", "evt", "state", "shape", "funct", "entry", "i", "node", "state", "evt", "tmp", "childCount", "target", "tmp", "node", "_a", "tmp", "text", "key", "value", "obj", "i", "obj", "key", "id", "value", "result", "key", "value", "text", "intersects", "result", "edge", "source", "value", "state", "i", "style", "tmp", "intersects", "cx", "cell", "result", "parent", "i", "childCount", "i", "value", "style", "name", "node", "result", "model", "key", "cell", "text", "tmp", "value", "obj", "clone", "i", "i", "value", "state", "link", "enabled", "createXmlDocument", "state", "shape", "link", "cell", "obj", "result", "key", "i", "i", "_a", "value", "target", "i", "name", "key", "result", "template", "i", "name", "fieldname", "obj", "value", "write", "node", "tmp", "child", "dec", "into", "id", "_node", "name", "tmp", "value", "style", "id", "edge", "parent", "source", "child", "name", "_a", "cell", "tmp", "childCount", "result", "i", "target", "document", "id", "obj", "node", "into", "dec", "cell", "childCount", "i", "child", "parent", "source", "target", "attribute", "value", "createXmlDocument", "model", "result", "node", "tmp", "value", "i", "node", "tmp", "value", "style", "_a", "text", "id", "i", "link", "item", "cy", "w", "h", "_a", "tmp", "value", "key", "i", "state", "node", "_a", "cell", "style", "_a", "source", "state", "clone", "i", "source", "i", "state", "_a", "tmp", "name", "name", "obj", "value", "key", "value", "result", "i", "state", "cell", "childCount", "model", "child", "evt", "parent", "source", "target", "node", "edge", "points", "edgeStyle", "tmp", "key", "id", "perimeter", "style", "points", "_a", "i", "p0", "p1", "funct", "shape", "source", "points", "_a", "source", "result", "value", "state", "tmp", "result", "_a", "node", "flex", "item", "block", "elt", "style", "name", "key", "shape", "state", "name", "value", "evt", "result", "source", "i", "tmp", "id", "node", "cell", "_a", "model", "parent", "child", "tmp", "tmp2", "cell", "source", "target", "childCount", "i", "model", "cell", "model", "cell", "model", "model", "cell", "style", "model", "cell", "source", "model", "cell", "value", "model", "cell", "result", "i", "edge", "source", "target", "tmp", "cell", "parent", "clone", "childCount", "value", "cell", "id", "parent", "child", "childCount", "i", "edge", "source", "target", "result", "style", "tmp", "key", "clone", "style", "name", "key", "points", "result", "i", "state", "state", "source", "target", "points", "result", "state", "source", "target", "points", "result", "state", "source", "target", "points", "result", "state", "source", "target", "result", "state", "source", "points", "result", "i", "state", "result", "source", "target", "pt", "i", "tmp", "state", "value", "result", "source", "target", "dx", "dy", "i", "points", "_a", "key", "parent", "tmp", "_a", "node", "shape", "state", "elt", "enabled", "state", "cell", "evt", "perimeter", "name", "enabled", "i", "state", "source", "cell", "parent", "intersects", "tmp", "_a", "icon", "state", "evt", "parent", "cell", "shape", "points", "source", "target", "i", "edgeStyle", "result", "intersects", "tmp", "_a", "clone", "edge", "model", "b", "state", "i", "shape", "intersects", "model", "parent", "tmp", "style", "cell", "childCount", "child", "result", "text", "i", "key", "value", "result", "state", "evt", "node", "intersects", "state", "result", "i", "source", "target", "edge", "model", "node", "cell", "tmp", "i", "remove", "_a", "_a", "_a", "points", "points", "state", "_a", "i", "tmp", "_a", "_a", "tmp", "_a", "node", "_a", "result", "result", "result", "cell", "child", "state", "style", "key", "value", "tmp", "i", "clone", "parent", "points", "source", "target", "extend", "edge", "show", "evt", "childCount", "intersection", "model", "intersects", "tmp", "source", "_a", "edge", "perimeter", "id", "key", "i", "cell", "state", "parent", "value", "target", "value", "target", "evt", "value", "edge", "style", "parent", "source", "state", "id", "target", "i", "cell", "childCount", "child", "result", "evt", "cell", "value", "style", "evt", "cell", "tmp", "state", "i", "result", "source", "name", "value", "cell", "style", "state", "tmp", "i", "parent", "result", "i", "child", "state", "tmp", "cell", "tmp", "i", "key", "cell", "result", "style", "value", "i", "parent", "state", "cell", "state", "i", "childCount", "child", "evt", "i", "child", "cell", "state", "enabled", "cell", "value", "cell", "evt", "parent", "childCount", "child", "tmp", "i", "value", "cell", "parent", "childCount", "i", "child", "result", "state", "style", "evt", "clone", "tmp", "value", "cell", "source", "i", "state", "target", "state", "node", "id", "shape", "cell", "enabled", "edge", "source", "target", "error", "tmp", "err", "cell", "childCount", "i", "value", "value", "_a", "parent", "id", "style", "state", "state", "value", "result", "evt", "elt", "tmp", "cell", "evt", "source", "enabled", "value", "state", "node", "evt", "value", "cell", "key", "tmp", "i", "state", "enabled", "funct", "parent", "iconCls", "_a", "evt", "item", "row", "cell", "evt", "cell", "enabled", "edge", "source", "target", "evt", "value", "shape", "cell", "state", "icon", "i", "tmp", "tmp2", "result", "_a", "model", "parent", "style", "id", "clone", "evt", "state", "clone", "i", "evt", "clone", "value", "cell", "parent", "state", "result", "i", "shape", "childCount", "target", "error", "key", "points", "source", "evt", "value", "tmp", "state", "model", "id", "evt", "extend", "enabled", "result", "source", "target", "edgeStyle", "cell", "edge", "tmp", "value", "parent", "evt", "enabled", "value", "model", "cell", "i", "result", "child", "source", "evt", "outline", "value", "sizer", "state", "div", "clone", "i", "row", "cell", "intersects", "tmp", "name", "evt", "value", "cell", "style", "parent", "childCount", "i", "child", "tmp", "model", "cell", "attribute", "value", "tmp", "target", "evt", "enabled", "funct", "_a", "source", "editor", "evt", "action", "editor", "menu", "cell", "evt", "conditions", "item", "icon", "funct", "action", "parent", "iconCls", "enabled", "icon", "funct", "pressedIcon", "style", "evt", "value", "tmp", "toggle", "evt", "value", "elt", "state", "funct", "evt", "elt", "editor", "evt", "funct", "icon", "action", "value", "mode", "toggle", "cell", "target", "model", "source", "edge", "parent", "i", "cell", "parent", "key", "edge", "source", "result", "i", "child", "value", "model", "points", "state", "tmp", "cell", "parent", "cell", "parent", "model", "i", "node", "child", "source", "cell", "id", "edge", "state", "target", "tmp", "childCount", "cell", "model", "parent", "i", "childCount", "value", "child", "tmp", "mod", "style", "style", "evt", "child", "elt", "funct", "icon", "tmp", "button", "dec", "node", "obj", "child", "editor", "tmp", "as", "elt", "style", "name", "obj", "dec", "_node", "into", "editor", "node", "as", "action", "dec", "node", "into", "i", "child", "template", "clone", "style", "evt", "tmp", "id", "dec", "obj", "value", "node", "tmp", "id", "i", "obj", "value", "write", "node", "dec", "_node", "tmp", "tmp2", "id", "obj", "dec", "_node", "cell", "node", "model", "state", "parent", "childCount", "name", "i", "value", "obj", "node", "dec", "child", "model", "tmp", "cell", "obj", "node", "dec", "tmp", "tmp2", "_node", "obj", "node", "i", "style", "value", "entry", "key", "_node", "obj", "style", "key", "value", "dec", "obj", "dec", "node", "obj", "points", "template", "name", "button", "name", "value", "result", "parent", "evt", "elt", "funct", "button", "i", "evt", "enabled", "result", "i", "node", "clone", "value", "editor", "node", "cell", "dec", "funct", "evt", "action", "name", "template", "menu", "source", "target", "model", "i", "style", "id", "tmp", "div", "h", "parent", "state", "funct", "state", "shape", "key", "parent", "childCount", "i", "cell", "cell", "parent", "i", "parent", "model", "childCount", "i", "cell", "state", "edge", "intersects", "parent", "i", "id", "parent", "i", "cell", "id", "model", "childCount", "edge", "state", "tmp", "cell", "model", "parent", "i", "childCount", "child", "tmp", "value", "parent", "i", "row", "node", "child", "cell", "value", "cell", "i", "edge", "value", "i", "value", "parent", "i", "cell", "edge", "node", "parent", "model", "i", "node", "parent", "model", "i", "cell", "node", "model", "cell", "parent", "i", "node", "source", "state", "tmp", "edge", "parent", "i", "model", "cell", "childCount", "child", "result", "source", "target", "edge", "state", "key", "tmp", "parent", "i", "cell", "edge", "node", "parent", "model", "i", "node", "parent", "model", "i", "key", "edge", "cell", "childCount", "child", "result", "source", "target", "state", "tmp", "tmp", "i", "node", "perimeter", "name", "attribute", "shape", "result", "_a", "value", "i", "state", "cell", "childCount", "child", "node", "remove", "state", "key", "child", "i", "cell", "state", "childCount", "i", "result", "parent", "value", "name", "parent", "text", "editor", "action", "funct", "button", "evt", "key", "value", "result", "state", "childCount", "i", "link", "shape", "evt", "value", "source", "value", "edge", "target", "error"]
}
